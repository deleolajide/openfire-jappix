/*

Jappix - An open social platform
These are the origin JS script for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Author: Val√©rian Saliou

*/

// Bundle
var Origin = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Checks if the URL passed has the same origin than Jappix itself
     * @public
     * @param {string} url
     * @return {undefined}
     */
    self.isSame = function(url) {

        /* Source: http://stackoverflow.com/questions/9404793/check-if-same-origin-policy-applies */

        try {
            var loc = window.location,
            a = document.createElement('a');

            a.href = url;

            return (!a.hostname || (a.hostname == loc.hostname))    &&
                   (!a.port     || (a.port == loc.port))            &&
                   (!a.protocol || (a.protocol == loc.protocol));
        } catch(e) {
            Console.error('Origin.isSame', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixOrigin = Origin;
// jXHR.js (JSON-P XHR)
// v0.1 (c) Kyle Simpson
// License: MIT
// modified by gueron Jonathan to work with strophe lib
// for http://www.iadvize.com

(function(global){
    var SETTIMEOUT = global.setTimeout, // for better compression
        doc = global.document,
        callback_counter = 0;
        
    global.jXHR = function() {
        var script_url,
            script_loaded,
            jsonp_callback,
            scriptElem,
            publicAPI = null;
            
        function removeScript() { try { scriptElem.parentNode.removeChild(scriptElem); } catch (err) { } }
            
        function reset() {
            script_loaded = false;
            script_url = "";
            removeScript();
            scriptElem = null;
            fireReadyStateChange(0);
        }
        
        function ThrowError(msg) {
            try { 
                publicAPI.onerror.call(publicAPI,msg,script_url); 
            } catch (err) { 
                //throw new Error(msg); 
            }
        }

        function handleScriptLoad() {
            if ((this.readyState && this.readyState!=="complete" && this.readyState!=="loaded") || script_loaded) { return; }
            this.onload = this.onreadystatechange = null; // prevent memory leak
            script_loaded = true;
            if (publicAPI.readyState !== 4) ThrowError("handleScriptLoad: Script failed to load ["+script_url+"].");
            removeScript();
        }
        
        function parseXMLString(xmlStr) {
            var xmlDoc = null;
            if(window.DOMParser) {
                var parser = new DOMParser();
                xmlDoc = parser.parseFromString(xmlStr,"text/xml");
            }
            else {
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM"); 
                xmlDoc.async="false";
                xmlDoc.loadXML(xmlStr);
            }
            return xmlDoc;
        }
        
        function fireReadyStateChange(rs,args) {
        
            args = args || [];
            publicAPI.readyState = rs;
            if (rs == 4) {
                publicAPI.responseText = args[0].reply;
                publicAPI.responseXML = parseXMLString(args[0].reply);
            }
            if (typeof publicAPI.onreadystatechange === "function") publicAPI.onreadystatechange.apply(publicAPI,args);
        }
                
        publicAPI = {
            onerror:null,
            onreadystatechange:null,
            readyState:0,
            status:200,
            responseBody: null,
            responseText: null,
            responseXML: null,
            open:function(method,url){
                reset();
                var internal_callback = "cb"+(callback_counter++);
                (function(icb){
                    global.jXHR[icb] = function() {
                        try { fireReadyStateChange.call(publicAPI,4,arguments); } 
                        catch(err) { 
                            publicAPI.readyState = -1;
                            ThrowError("Script failed to run ["+script_url+"]."); 
                        }
                        global.jXHR[icb] = null;
                    };
                })(internal_callback);
                script_url = url + '?callback=?jXHR&data=';
                script_url = script_url.replace(/=\?jXHR/,"=jXHR."+internal_callback);
                fireReadyStateChange(1);
            },
            send:function(data){
                script_url = script_url + encodeURIComponent(data);
                SETTIMEOUT(function(){
                    scriptElem = doc.createElement("script");
                    scriptElem.setAttribute("type","text/javascript");
                    scriptElem.onload = scriptElem.onreadystatechange = function(){handleScriptLoad.call(scriptElem);};
                    scriptElem.setAttribute("src",script_url);
                    doc.getElementsByTagName("head")[0].appendChild(scriptElem);
                },0);
                fireReadyStateChange(2);
            },
            abort:function(){},
            setRequestHeader:function(){}, // noop
            getResponseHeader:function(){return "";}, // basically noop
            getAllResponseHeaders:function(){return [];} // ditto
        };

        reset();
        
        return publicAPI;
    };
})(window);

/**
 * Version: 1.0 Alpha-1 
 * Build Date: 13-Nov-2007
 * Copyright (c) 2006-2007, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * License: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * Website: http://www.datejs.com/ or http://www.coolite.com/datejs/
 */
Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|after|from)/i,subtract:/^(\-|before|ago)/i,yesterday:/^yesterday/i,today:/^t(oday)?/i,tomorrow:/^tomorrow/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^min(ute)?s?/i,hour:/^h(ou)?rs?/i,week:/^w(ee)?k/i,month:/^m(o(nth)?s?)?/i,day:/^d(ays?)?/i,year:/^y((ea)?rs?)?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a|p)/i},abbreviatedTimeZoneStandard:{GMT:"-000",EST:"-0400",CST:"-0500",MST:"-0600",PST:"-0700"},abbreviatedTimeZoneDST:{GMT:"-000",EDT:"-0500",CDT:"-0600",MDT:"-0700",PDT:"-0800"}};
Date.getMonthNumberFromName=function(name){var n=Date.CultureInfo.monthNames,m=Date.CultureInfo.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.getDayNumberFromName=function(name){var n=Date.CultureInfo.dayNames,m=Date.CultureInfo.abbreviatedDayNames,o=Date.CultureInfo.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};Date.isLeapYear=function(year){return(((year%4===0)&&(year%100!==0))||(year%400===0));};Date.getDaysInMonth=function(year,month){return[31,(Date.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};Date.getTimezoneOffset=function(s,dst){return(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()]:Date.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];};Date.getTimezoneAbbreviation=function(offset,dst){var n=(dst||false)?Date.CultureInfo.abbreviatedTimeZoneDST:Date.CultureInfo.abbreviatedTimeZoneStandard,p;for(p in n){if(n[p]===offset){return p;}}
return null;};Date.prototype.clone=function(){return new Date(this.getTime());};Date.prototype.compareTo=function(date){if(isNaN(this)){throw new Error(this);}
if(date instanceof Date&&!isNaN(date)){return(this>date)?1:(this<date)?-1:0;}else{throw new TypeError(date);}};Date.prototype.equals=function(date){return(this.compareTo(date)===0);};Date.prototype.between=function(start,end){var t=this.getTime();return t>=start.getTime()&&t<=end.getTime();};Date.prototype.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};Date.prototype.addSeconds=function(value){return this.addMilliseconds(value*1000);};Date.prototype.addMinutes=function(value){return this.addMilliseconds(value*60000);};Date.prototype.addHours=function(value){return this.addMilliseconds(value*3600000);};Date.prototype.addDays=function(value){return this.addMilliseconds(value*86400000);};Date.prototype.addWeeks=function(value){return this.addMilliseconds(value*604800000);};Date.prototype.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,this.getDaysInMonth()));return this;};Date.prototype.addYears=function(value){return this.addMonths(value*12);};Date.prototype.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.millisecond||x.milliseconds){this.addMilliseconds(x.millisecond||x.milliseconds);}
if(x.second||x.seconds){this.addSeconds(x.second||x.seconds);}
if(x.minute||x.minutes){this.addMinutes(x.minute||x.minutes);}
if(x.hour||x.hours){this.addHours(x.hour||x.hours);}
if(x.month||x.months){this.addMonths(x.month||x.months);}
if(x.year||x.years){this.addYears(x.year||x.years);}
if(x.day||x.days){this.addDays(x.day||x.days);}
return this;};Date._validate=function(value,min,max,name){if(typeof value!="number"){throw new TypeError(value+" is not a Number.");}else if(value<min||value>max){throw new RangeError(value+" is not a valid value for "+name+".");}
return true;};Date.validateMillisecond=function(n){return Date._validate(n,0,999,"milliseconds");};Date.validateSecond=function(n){return Date._validate(n,0,59,"seconds");};Date.validateMinute=function(n){return Date._validate(n,0,59,"minutes");};Date.validateHour=function(n){return Date._validate(n,0,23,"hours");};Date.validateDay=function(n,year,month){return Date._validate(n,1,Date.getDaysInMonth(year,month),"days");};Date.validateMonth=function(n){return Date._validate(n,0,11,"months");};Date.validateYear=function(n){return Date._validate(n,1,9999,"seconds");};Date.prototype.set=function(config){var x=config;if(!x.millisecond&&x.millisecond!==0){x.millisecond=-1;}
if(!x.second&&x.second!==0){x.second=-1;}
if(!x.minute&&x.minute!==0){x.minute=-1;}
if(!x.hour&&x.hour!==0){x.hour=-1;}
if(!x.day&&x.day!==0){x.day=-1;}
if(!x.month&&x.month!==0){x.month=-1;}
if(!x.year&&x.year!==0){x.year=-1;}
if(x.millisecond!=-1&&Date.validateMillisecond(x.millisecond)){this.addMilliseconds(x.millisecond-this.getMilliseconds());}
if(x.second!=-1&&Date.validateSecond(x.second)){this.addSeconds(x.second-this.getSeconds());}
if(x.minute!=-1&&Date.validateMinute(x.minute)){this.addMinutes(x.minute-this.getMinutes());}
if(x.hour!=-1&&Date.validateHour(x.hour)){this.addHours(x.hour-this.getHours());}
if(x.month!==-1&&Date.validateMonth(x.month)){this.addMonths(x.month-this.getMonth());}
if(x.year!=-1&&Date.validateYear(x.year)){this.addYears(x.year-this.getFullYear());}
if(x.day!=-1&&Date.validateDay(x.day,this.getFullYear(),this.getMonth())){this.addDays(x.day-this.getDate());}
if(x.timezone){this.setTimezone(x.timezone);}
if(x.timezoneOffset){this.setTimezoneOffset(x.timezoneOffset);}
return this;};Date.prototype.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};Date.prototype.isLeapYear=function(){var y=this.getFullYear();return(((y%4===0)&&(y%100!==0))||(y%400===0));};Date.prototype.isWeekday=function(){return!(this.is().sat()||this.is().sun());};Date.prototype.getDaysInMonth=function(){return Date.getDaysInMonth(this.getFullYear(),this.getMonth());};Date.prototype.moveToFirstDayOfMonth=function(){return this.set({day:1});};Date.prototype.moveToLastDayOfMonth=function(){return this.set({day:this.getDaysInMonth()});};Date.prototype.moveToDayOfWeek=function(day,orient){var diff=(day-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};Date.prototype.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};Date.prototype.getDayOfYear=function(){return Math.floor((this-new Date(this.getFullYear(),0,1))/86400000);};Date.prototype.getWeekOfYear=function(firstDayOfWeek){var y=this.getFullYear(),m=this.getMonth(),d=this.getDate();var dow=firstDayOfWeek||Date.CultureInfo.firstDayOfWeek;var offset=7+1-new Date(y,0,1).getDay();if(offset==8){offset=1;}
var daynum=((Date.UTC(y,m,d,0,0,0)-Date.UTC(y,0,1,0,0,0))/86400000)+1;var w=Math.floor((daynum-offset+7)/7);if(w===dow){y--;var prevOffset=7+1-new Date(y,0,1).getDay();if(prevOffset==2||prevOffset==8){w=53;}else{w=52;}}
return w;};Date.prototype.isDST=function(){console.log('isDST');return this.toString().match(/(E|C|M|P)(S|D)T/)[2]=="D";};Date.prototype.getTimezone=function(){return Date.getTimezoneAbbreviation(this.getUTCOffset,this.isDST());};Date.prototype.setTimezoneOffset=function(s){var here=this.getTimezoneOffset(),there=Number(s)*-6/10;this.addMinutes(there-here);return this;};Date.prototype.setTimezone=function(s){return this.setTimezoneOffset(Date.getTimezoneOffset(s));};Date.prototype.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r[0]+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};Date.prototype.getDayName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedDayNames[this.getDay()]:Date.CultureInfo.dayNames[this.getDay()];};Date.prototype.getMonthName=function(abbrev){return abbrev?Date.CultureInfo.abbreviatedMonthNames[this.getMonth()]:Date.CultureInfo.monthNames[this.getMonth()];};Date.prototype._toString=Date.prototype.toString;Date.prototype.toString=function(format){var self=this;var p=function p(s){return(s.toString().length==1)?"0"+s:s;};return format?format.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g,function(format){switch(format){case"hh":return p(self.getHours()<13?self.getHours():(self.getHours()-12));case"h":return self.getHours()<13?self.getHours():(self.getHours()-12);case"HH":return p(self.getHours());case"H":return self.getHours();case"mm":return p(self.getMinutes());case"m":return self.getMinutes();case"ss":return p(self.getSeconds());case"s":return self.getSeconds();case"yyyy":return self.getFullYear();case"yy":return self.getFullYear().toString().substring(2,4);case"dddd":return self.getDayName();case"ddd":return self.getDayName(true);case"dd":return p(self.getDate());case"d":return self.getDate().toString();case"MMMM":return self.getMonthName();case"MMM":return self.getMonthName(true);case"MM":return p((self.getMonth()+1));case"M":return self.getMonth()+1;case"t":return self.getHours()<12?Date.CultureInfo.amDesignator.substring(0,1):Date.CultureInfo.pmDesignator.substring(0,1);case"tt":return self.getHours()<12?Date.CultureInfo.amDesignator:Date.CultureInfo.pmDesignator;case"zzz":case"zz":case"z":return"";}}):this._toString();};
Date.now=function(){return new Date();};Date.today=function(){return Date.now().clearTime();};Date.prototype._orient=+1;Date.prototype.next=function(){this._orient=+1;return this;};Date.prototype.last=Date.prototype.prev=Date.prototype.previous=function(){this._orient=-1;return this;};Date.prototype._is=false;Date.prototype.is=function(){this._is=true;return this;};Number.prototype._dateElement="day";Number.prototype.fromNow=function(){var c={};c[this._dateElement]=this;return Date.now().add(c);};Number.prototype.ago=function(){var c={};c[this._dateElement]=this*-1;return Date.now().add(c);};(function(){var $D=Date.prototype,$N=Number.prototype;var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),de;var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
return this.moveToDayOfWeek(n,this._orient);};};for(var i=0;i<dx.length;i++){$D[dx[i]]=$D[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};for(var j=0;j<mx.length;j++){$D[mx[j]]=$D[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$D[de]=$D[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}}());Date.prototype.toJSONString=function(){return this.toString("yyyy-MM-ddThh:mm:ssZ");};Date.prototype.toShortDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortDatePattern);};Date.prototype.toLongDateString=function(){return this.toString(Date.CultureInfo.formatPatterns.longDatePattern);};Date.prototype.toShortTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.shortTimePattern);};Date.prototype.toLongTimeString=function(){return this.toString(Date.CultureInfo.formatPatterns.longTimePattern);};Date.prototype.getOrdinal=function(){switch(this.getDate()){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};Date.Grammar={};Date.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=((s.length==3)?Date.getMonthNumberFromName(s):(Number(s)-1));};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<Date.CultureInfo.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];var now=new Date();this.year=now.getFullYear();this.month=now.getMonth();this.day=1;this.hour=0;this.minute=0;this.second=0;for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
this.hour=(this.meridian=="p"&&this.hour<13)?this.hour+12:this.hour;if(this.day>Date.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
if(this.now){return new Date();}
var today=Date.today();var method=null;var expression=!!(this.days!=null||this.orient||this.operator);if(expression){var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(this.weekday){this.unit="day";gap=(Date.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
if(this.unit=="week"){this.unit="day";this.value=this.value*7;}
this[this.unit+"s"]=this.value*orient;}
return today.add(this);}else{if(this.meridian&&this.hour){this.hour=(this.hour<13&&this.meridian=="p")?this.hour+12:this.hour;}
if(this.weekday&&!this.day){this.day=(today.addDays((Date.getDayNumberFromName(this.weekday)-today.getDay()))).getDate();}
if(this.month&&!this.day){this.day=1;}
return today.set(this);}}};var _=Date.Parsing.Operators,g=Date.Grammar,t=Date.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=Date.CultureInfo.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken(Date.CultureInfo.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.mm,g.ss],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^(\+|\-)?\s*\d\d\d\d?/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^(\+|\-)\s*\d\d\d\d/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[Date.CultureInfo.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw Date.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["yyyy-MM-ddTHH:mm:ss","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};}());Date._parse=Date.parse;Date.parse=function(s){var r=null;if(!s){return null;}
try{r=Date.Grammar.start.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};Date.getParseFunction=function(fx){var fn=Date.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};Date.parseExact=function(s,fx){return Date.getParseFunction(fx)(s);};

/*!
 * jQuery JavaScript Library v1.11.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-23T21:02Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
    version = "1.11.0",

    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init( selector, context );
    },

    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function( all, letter ) {
        return letter.toUpperCase();
    };

jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // Start with an empty selector
    selector: "",

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function() {
        return slice.call( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
        return num != null ?

            // Return a 'clean' array
            ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

            // Return just the object
            slice.call( this );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems ) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;
        ret.context = this.context;

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    },

    map: function( callback ) {
        return this.pushStack( jQuery.map(this, function( elem, i ) {
            return callback.call( elem, i, elem );
        }));
    },

    slice: function() {
        return this.pushStack( slice.apply( this, arguments ) );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    eq: function( i ) {
        var len = this.length,
            j = +i + ( i < 0 ? len : 0 );
        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
    },

    end: function() {
        return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: deletedIds.sort,
    splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
    var src, copyIsArray, copy, name, options, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;

        // skip the boolean and the target
        target = arguments[ i ] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function( msg ) {
        throw new Error( msg );
    },

    noop: function() {},

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function( obj ) {
        return jQuery.type(obj) === "function";
    },

    isArray: Array.isArray || function( obj ) {
        return jQuery.type(obj) === "array";
    },

    isWindow: function( obj ) {
        /* jshint eqeqeq: false */
        return obj != null && obj == obj.window;
    },

    isNumeric: function( obj ) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        return obj - parseFloat( obj ) >= 0;
    },

    isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
            return false;
        }
        return true;
    },

    isPlainObject: function( obj ) {
        var key;

        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if ( obj.constructor &&
                !hasOwn.call(obj, "constructor") &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Support: IE<9
        // Handle iteration over inherited properties before own properties.
        if ( support.ownLast ) {
            for ( key in obj ) {
                return hasOwn.call( obj, key );
            }
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        for ( key in obj ) {}

        return key === undefined || hasOwn.call( obj, key );
    },

    type: function( obj ) {
        if ( obj == null ) {
            return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[ toString.call(obj) ] || "object" :
            typeof obj;
    },

    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function( data ) {
        if ( data && jQuery.trim( data ) ) {
            // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            ( window.execScript || function( data ) {
                window[ "eval" ].call( window, data );
            } )( data );
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

        if ( args ) {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Use native String.trim function wherever possible
    trim: trim && !trim.call("\uFEFF\xA0") ?
        function( text ) {
            return text == null ?
                "" :
                trim.call( text );
        } :

        // Otherwise use our own trimming functionality
        function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var ret = results || [];

        if ( arr != null ) {
            if ( isArraylike( Object(arr) ) ) {
                jQuery.merge( ret,
                    typeof arr === "string" ?
                    [ arr ] : arr
                );
            } else {
                push.call( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( indexOf ) {
                return indexOf.call( arr, elem, i );
            }

            len = arr.length;
            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i < len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr && arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        while ( j < len ) {
            first[ i++ ] = second[ j++ ];
        }

        // Support: IE<9
        // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
        if ( len !== len ) {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, invert ) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i < length; i++ ) {
            callbackInverse = !callback( elems[ i ], i );
            if ( callbackInverse !== callbackExpect ) {
                matches.push( elems[ i ] );
            }
        }

        return matches;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        // Go through the array, translating each of the items to their new values
        if ( isArray ) {
            for ( ; i < length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }

        // Go through every key on the object,
        } else {
            for ( i in elems ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }
        }

        // Flatten any nested arrays
        return concat.apply( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
        var args, proxy, tmp;

        if ( typeof context === "string" ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    },

    now: function() {
        return +( new Date() );
    },

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );

    if ( type === "function" || jQuery.isWindow( obj ) ) {
        return false;
    }

    if ( obj.nodeType === 1 && length ) {
        return true;
    }

    return type === "array" || length === 0 ||
        typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.16
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-13
 */
(function( window ) {

var i,
    support,
    Expr,
    getText,
    isXML,
    compile,
    outermostContext,
    sortInput,
    hasDuplicate,

    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,

    // Instance-specific data
    expando = "sizzle" + -(new Date()),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    sortOrder = function( a, b ) {
        if ( a === b ) {
            hasDuplicate = true;
        }
        return 0;
    },

    // General-purpose constants
    strundefined = typeof undefined,
    MAX_NEGATIVE = 1 << 31,

    // Instance methods
    hasOwn = ({}).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    // Use a stripped-down indexOf if we can't use a native one
    indexOf = arr.indexOf || function( elem ) {
        var i = 0,
            len = this.length;
        for ( ; i < len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

    // Regular expressions

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace( "w", "w#" ),

    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
        "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

    // Prefer arguments quoted,
    //   then not containing pseudos/brackets,
    //   then attribute selectors/non-parenthetical expressions,
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

    rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

    rpseudo = new RegExp( pseudos ),
    ridentifier = new RegExp( "^" + identifier + "$" ),

    matchExpr = {
        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
        "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
        "ATTR": new RegExp( "^" + attributes ),
        "PSEUDO": new RegExp( "^" + pseudos ),
        "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
        "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    },

    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,

    rnative = /^[^{]+\{\s*\[native \w/,

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

    rsibling = /[+~]/,
    rescape = /'|\\/g,

    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
    funescape = function( _, escaped, escapedWhitespace ) {
        var high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
                // BMP codepoint
                String.fromCharCode( high + 0x10000 ) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    };

// Optimize for push.apply( _, NodeList )
try {
    push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
    );
    // Support: Android<4.0
    // Detect silently failing push.apply
    arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
    push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
            push_native.apply( target, slice.call(els) );
        } :

        // Support: IE<9
        // Otherwise append directly
        function( target, els ) {
            var j = target.length,
                i = 0;
            // Can't trust NodeList.length
            while ( (target[j++] = els[i++]) ) {}
            target.length = j - 1;
        }
    };
}

function Sizzle( selector, context, results, seed ) {
    var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
    }

    context = context || document;
    results = results || [];

    if ( !selector || typeof selector !== "string" ) {
        return results;
    }

    if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
        return [];
    }

    if ( documentIsHTML && !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
            // Speed-up: Sizzle("#ID")
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context.getElementById( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document (jQuery #6963)
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                        contains( context, elem ) && elem.id === m ) {
                        results.push( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle("TAG")
            } else if ( match[2] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

            // Speed-up: Sizzle(".CLASS")
            } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                push.apply( results, context.getElementsByClassName( m ) );
                return results;
            }
        }

        // QSA path
        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 && selector;

            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements
            if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                groups = tokenize( selector );

                if ( (old = context.getAttribute("id")) ) {
                    nid = old.replace( rescape, "\\$&" );
                } else {
                    context.setAttribute( "id", nid );
                }
                nid = "[id='" + nid + "'] ";

                i = groups.length;
                while ( i-- ) {
                    groups[i] = nid + toSelector( groups[i] );
                }
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                newSelector = groups.join(",");
            }

            if ( newSelector ) {
                try {
                    push.apply( results,
                        newContext.querySelectorAll( newSelector )
                    );
                    return results;
                } catch(qsaError) {
                } finally {
                    if ( !old ) {
                        context.removeAttribute("id");
                    }
                }
            }
        }
    }

    // All others
    return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
    var keys = [];

    function cache( key, value ) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key + " " ) > Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
        }
        return (cache[ key + " " ] = value);
    }
    return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
    fn[ expando ] = true;
    return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
    var div = document.createElement("div");

    try {
        return !!fn( div );
    } catch (e) {
        return false;
    } finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
            div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
    }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
    var arr = attrs.split("|"),
        i = attrs.length;

    while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
    }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
    var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
            ( ~b.sourceIndex || MAX_NEGATIVE ) -
            ( ~a.sourceIndex || MAX_NEGATIVE );

    // Use IE sourceIndex if available on both nodes
    if ( diff ) {
        return diff;
    }

    // Check if b follows a
    if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
            if ( cur === b ) {
                return -1;
            }
        }
    }

    return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
    return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
    var hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

    // If no document and documentElement is available, return
    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
    }

    // Set our document
    document = doc;
    docElem = doc.documentElement;

    // Support tests
    documentIsHTML = !isXML( doc );

    // Support: IE>8
    // If iframe document is assigned to "document" variable and if iframe has been reloaded,
    // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
    // IE6-8 do not support the defaultView property so parent will be undefined
    if ( parent && parent !== parent.top ) {
        // IE11 does not have attachEvent, so all must suffer
        if ( parent.addEventListener ) {
            parent.addEventListener( "unload", function() {
                setDocument();
            }, false );
        } else if ( parent.attachEvent ) {
            parent.attachEvent( "onunload", function() {
                setDocument();
            });
        }
    }

    /* Attributes
    ---------------------------------------------------------------------- */

    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
    support.attributes = assert(function( div ) {
        div.className = "i";
        return !div.getAttribute("className");
    });

    /* getElement(s)By*
    ---------------------------------------------------------------------- */

    // Check if getElementsByTagName("*") returns only elements
    support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment("") );
        return !div.getElementsByTagName("*").length;
    });

    // Check if getElementsByClassName can be trusted
    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
        div.innerHTML = "<div class='a'></div><div class='a i'></div>";

        // Support: Safari<4
        // Catch class over-caching
        div.firstChild.className = "i";
        // Support: Opera<10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName("i").length === 2;
    });

    // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
    });

    // ID find and filter
    if ( support.getById ) {
        Expr.find["ID"] = function( id, context ) {
            if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                var m = context.getElementById( id );
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                return m && m.parentNode ? [m] : [];
            }
        };
        Expr.filter["ID"] = function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                return elem.getAttribute("id") === attrId;
            };
        };
    } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find["ID"];

        Expr.filter["ID"] =  function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                return node && node.value === attrId;
            };
        };
    }

    // Tag
    Expr.find["TAG"] = support.getElementsByTagName ?
        function( tag, context ) {
            if ( typeof context.getElementsByTagName !== strundefined ) {
                return context.getElementsByTagName( tag );
            }
        } :
        function( tag, context ) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName( tag );

            // Filter out possible comments
            if ( tag === "*" ) {
                while ( (elem = results[i++]) ) {
                    if ( elem.nodeType === 1 ) {
                        tmp.push( elem );
                    }
                }

                return tmp;
            }
            return results;
        };

    // Class
    Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
            return context.getElementsByClassName( className );
        }
    };

    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */

    // QSA and matchesSelector support

    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];

    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See http://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];

    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div.innerHTML = "<select t=''><option selected=''></option></select>";

            // Support: IE8, Opera 10-12
            // Nothing should be selected when empty strings follow ^= or $= or *=
            if ( div.querySelectorAll("[t^='']").length ) {
                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if ( !div.querySelectorAll("[selected]").length ) {
                rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":checked").length ) {
                rbuggyQSA.push(":checked");
            }
        });

        assert(function( div ) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = doc.createElement("input");
            input.setAttribute( "type", "hidden" );
            div.appendChild( input ).setAttribute( "name", "D" );

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if ( div.querySelectorAll("[name=d]").length ) {
                rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":enabled").length ) {
                rbuggyQSA.push( ":enabled", ":disabled" );
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
        });
    }

    if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call( div, "div" );

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call( div, "[s!='']:x" );
            rbuggyMatches.push( "!=", pseudos );
        });
    }

    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

    /* Contains
    ---------------------------------------------------------------------- */
    hasCompare = rnative.test( docElem.compareDocumentPosition );

    // Element contains another
    // Purposefully does not implement inclusive descendent
    // As in, an element does not contain itself
    contains = hasCompare || rnative.test( docElem.contains ) ?
        function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
                adown.contains ?
                    adown.contains( bup ) :
                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
            ));
        } :
        function( a, b ) {
            if ( b ) {
                while ( (b = b.parentNode) ) {
                    if ( b === a ) {
                        return true;
                    }
                }
            }
            return false;
        };

    /* Sorting
    ---------------------------------------------------------------------- */

    // Document order sorting
    sortOrder = hasCompare ?
    function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if ( compare ) {
            return compare;
        }

        // Calculate position if both inputs belong to the same document
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
            a.compareDocumentPosition( b ) :

            // Otherwise we know they are disconnected
            1;

        // Disconnected nodes
        if ( compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

            // Choose the first element that is related to our preferred document
            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                return -1;
            }
            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                return 1;
            }

            // Maintain original order
            return sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;
        }

        return compare & 4 ? -1 : 1;
    } :
    function( a, b ) {
        // Exit early if the nodes are identical
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

        // Parentless nodes are either documents or disconnected
        if ( !aup || !bup ) {
            return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
            return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
            ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
            bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
            i++;
        }

        return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck( ap[i], bp[i] ) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
    };

    return doc;
};

Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    // Make sure that attribute selectors are quoted
    expr = expr.replace( rattributeQuotes, "='$1']" );

    if ( support.matchesSelector && documentIsHTML &&
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
            var ret = matches.call( elem, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11 ) {
                return ret;
            }
        } catch(e) {}
    }

    return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
    // Set document vars if needed
    if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
    }
    return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

    return val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) && val.specified ?
                val.value :
                null;
};

Sizzle.error = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
    var elem,
        duplicates = [],
        j = 0,
        i = 0;

    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice( 0 );
    results.sort( sortOrder );

    if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
            if ( elem === results[ i ] ) {
                j = duplicates.push( i );
            }
        }
        while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
        }
    }

    // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225
    sortInput = null;

    return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

    if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        while ( (node = elem[i++]) ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if ( typeof elem.textContent === "string" ) {
            return elem.textContent;
        } else {
            // Traverse its children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                ret += getText( elem );
            }
        }
    } else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes

    return ret;
};

Expr = Sizzle.selectors = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: {},

    find: {},

    relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
    },

    preFilter: {
        "ATTR": function( match ) {
            match[1] = match[1].replace( runescape, funescape );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

            if ( match[2] === "~=" ) {
                match[3] = " " + match[3] + " ";
            }

            return match.slice( 0, 4 );
        },

        "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
                1 type (only|nth|...)
                2 what (child|of-type)
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                4 xn-component of xn+y argument ([+-]?\d*n|)
                5 sign of xn-component
                6 x of xn-component
                7 sign of y-component
                8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1].slice( 0, 3 ) === "nth" ) {
                // nth-* requires argument
                if ( !match[3] ) {
                    Sizzle.error( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

            // other types prohibit arguments
            } else if ( match[3] ) {
                Sizzle.error( match[0] );
            }

            return match;
        },

        "PSEUDO": function( match ) {
            var excess,
                unquoted = !match[5] && match[2];

            if ( matchExpr["CHILD"].test( match[0] ) ) {
                return null;
            }

            // Accept quoted arguments as-is
            if ( match[3] && match[4] !== undefined ) {
                match[2] = match[4];

            // Strip excess characters from unquoted arguments
            } else if ( unquoted && rpseudo.test( unquoted ) &&
                // Get excess from tokenize (recursively)
                (excess = tokenize( unquoted, true )) &&
                // advance to the next closing parenthesis
                (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                // excess is a negative index
                match[0] = match[0].slice( 0, excess );
                match[2] = unquoted.slice( 0, excess );
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
        }
    },

    filter: {

        "TAG": function( nodeNameSelector ) {
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            return nodeNameSelector === "*" ?
                function() { return true; } :
                function( elem ) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                };
        },

        "CLASS": function( className ) {
            var pattern = classCache[ className + " " ];

            return pattern ||
                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                classCache( className, function( elem ) {
                    return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                });
        },

        "ATTR": function( name, operator, check ) {
            return function( elem ) {
                var result = Sizzle.attr( elem, name );

                if ( result == null ) {
                    return operator === "!=";
                }
                if ( !operator ) {
                    return true;
                }

                result += "";

                return operator === "=" ? result === check :
                    operator === "!=" ? result !== check :
                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                    operator === "$=" ? check && result.slice( -check.length ) === check :
                    operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                    false;
            };
        },

        "CHILD": function( type, what, argument, first, last ) {
            var simple = type.slice( 0, 3 ) !== "nth",
                forward = type.slice( -4 ) !== "last",
                ofType = what === "of-type";

            return first === 1 && last === 0 ?

                // Shortcut for :nth-*(n)
                function( elem ) {
                    return !!elem.parentNode;
                } :

                function( elem, context, xml ) {
                    var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                        parent = elem.parentNode,
                        name = ofType && elem.nodeName.toLowerCase(),
                        useCache = !xml && !ofType;

                    if ( parent ) {

                        // :(first|last|only)-(child|of-type)
                        if ( simple ) {
                            while ( dir ) {
                                node = elem;
                                while ( (node = node[ dir ]) ) {
                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                        return false;
                                    }
                                }
                                // Reverse direction for :only-* (if we haven't yet done so)
                                start = dir = type === "only" && !start && "nextSibling";
                            }
                            return true;
                        }

                        start = [ forward ? parent.firstChild : parent.lastChild ];

                        // non-xml :nth-child(...) stores cache data on `parent`
                        if ( forward && useCache ) {
                            // Seek `elem` from a previously-cached index
                            outerCache = parent[ expando ] || (parent[ expando ] = {});
                            cache = outerCache[ type ] || [];
                            nodeIndex = cache[0] === dirruns && cache[1];
                            diff = cache[0] === dirruns && cache[2];
                            node = nodeIndex && parent.childNodes[ nodeIndex ];

                            while ( (node = ++nodeIndex && node && node[ dir ] ||

                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                // When found, cache indexes on `parent` and break
                                if ( node.nodeType === 1 && ++diff && node === elem ) {
                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            }

                        // Use previously-cached element index if available
                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                            diff = cache[1];

                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                        } else {
                            // Use the same loop as above to seek `elem` from the start
                            while ( (node = ++nodeIndex && node && node[ dir ] ||
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                    // Cache the index of each encountered element
                                    if ( useCache ) {
                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                    }

                                    if ( node === elem ) {
                                        break;
                                    }
                                }
                            }
                        }

                        // Incorporate the offset, then check against cycle size
                        diff -= last;
                        return diff === first || ( diff % first === 0 && diff / first >= 0 );
                    }
                };
        },

        "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length > 1 ) {
                args = [ pseudo, pseudo, "", argument ];
                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        while ( i-- ) {
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, "$1" ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    return !results.pop();
                };
        }),

        "has": markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem ).length > 0;
            };
        }),

        "contains": markFunction(function( text ) {
            return function( elem ) {
                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
            };
        }),

        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction( function( lang ) {
            // lang value must be a valid identifier
            if ( !ridentifier.test(lang || "") ) {
                Sizzle.error( "unsupported lang: " + lang );
            }
            lang = lang.replace( runescape, funescape ).toLowerCase();
            return function( elem ) {
                var elemLang;
                do {
                    if ( (elemLang = documentIsHTML ?
                        elem.lang :
                        elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                    }
                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                return false;
            };
        }),

        // Miscellaneous
        "target": function( elem ) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice( 1 ) === elem.id;
        },

        "root": function( elem ) {
            return elem === docElem;
        },

        "focus": function( elem ) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        "enabled": function( elem ) {
            return elem.disabled === false;
        },

        "disabled": function( elem ) {
            return elem.disabled === true;
        },

        "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },

        "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
                elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
        },

        // Contents
        "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                if ( elem.nodeType < 6 ) {
                    return false;
                }
            }
            return true;
        },

        "parent": function( elem ) {
            return !Expr.pseudos["empty"]( elem );
        },

        // Element/input types
        "header": function( elem ) {
            return rheader.test( elem.nodeName );
        },

        "input": function( elem ) {
            return rinputs.test( elem.nodeName );
        },

        "button": function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        "text": function( elem ) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
                elem.type === "text" &&

                // Support: IE<8
                // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
        },

        // Position-in-collection
        "first": createPositionalPseudo(function() {
            return [ 0 ];
        }),

        "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
        }),

        "even": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 0;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "odd": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 1;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; --i >= 0; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; ++i < length; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        })
    }
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
    Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + " " ];

    if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice( match[0].length ) || soFar;
            }
            groups.push( (tokens = []) );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
            matched = match.shift();
            tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace( rtrim, " " )
            });
            soFar = soFar.slice( matched.length );
        }

        // Filters
        for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                });
                soFar = soFar.slice( matched.length );
            }
        }

        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens
            tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
    var i = 0,
        len = tokens.length,
        selector = "";
    for ( ; i < len; i++ ) {
        selector += tokens[i].value;
    }
    return selector;
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
        checkNonElements = base && dir === "parentNode",
        doneName = done++;

    return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            var oldCache, outerCache,
                newCache = [ dirruns, doneName ];

            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if ( xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        if ( matcher( elem, context, xml ) ) {
                            return true;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                        if ( (oldCache = outerCache[ dir ]) &&
                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                            // Assign to newCache so results back-propagate to previous elements
                            return (newCache[ 2 ] = oldCache[ 2 ]);
                        } else {
                            // Reuse newcache so results back-propagate to previous elements
                            outerCache[ dir ] = newCache;

                            // A match means we're done; a fail means we have to keep checking
                            if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                return true;
                            }
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers.length > 1 ?
        function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return false;
                }
            }
            return true;
        } :
        matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for ( ; i < len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched.push( elem );
                if ( mapped ) {
                    map.push( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( null, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut.length;
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( null, results, matcherOut, xml );
            } else {
                push.apply( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf.call( checkContext, elem ) > -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i < len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j < len; j++ ) {
                    if ( Expr.relative[ tokens[j].type ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                    ).replace( rtrim, "$1" ),
                    matcher,
                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j < len && toSelector( tokens )
                );
            }
            matchers.push( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function( seed, context, xml, results, outermost ) {
            var elem, j, matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;

            if ( outermost ) {
                outermostContext = context !== document && context;
            }

            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                if ( byElement && elem ) {
                    j = 0;
                    while ( (matcher = elementMatchers[j++]) ) {
                        if ( matcher( elem, context, xml ) ) {
                            results.push( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher && elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched.push( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet && i !== matchedCount ) {
                j = 0;
                while ( (matcher = setMatchers[j++]) ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount > 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop.call( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push.apply( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost && !seed && setMatched.length > 0 &&
                    ( matchedCount + setMatchers.length ) > 1 ) {

                    Sizzle.uniqueSort( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + " " ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !group ) {
            group = tokenize( selector );
        }
        i = group.length;
        while ( i-- ) {
            cached = matcherFromTokens( group[i] );
            if ( cached[ expando ] ) {
                setMatchers.push( cached );
            } else {
                elementMatchers.push( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    }
    return cached;
};

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts.length;
    for ( ; i < len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

function select( selector, context, results, seed ) {
    var i, tokens, token, type, find,
        match = tokenize( selector );

    if ( !seed ) {
        // Try to minimize operations if there is only one group
        if ( match.length === 1 ) {

            // Take a shortcut and set the context if the root selector is an ID
            tokens = match[0] = match[0].slice( 0 );
            if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                    support.getById && context.nodeType === 9 && documentIsHTML &&
                    Expr.relative[ tokens[1].type ] ) {

                context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                if ( !context ) {
                    return results;
                }
                selector = selector.slice( tokens.shift().value.length );
            }

            // Fetch a seed set for right-to-left matching
            i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
            while ( i-- ) {
                token = tokens[i];

                // Abort if we hit a combinator
                if ( Expr.relative[ (type = token.type) ] ) {
                    break;
                }
                if ( (find = Expr.find[ type ]) ) {
                    // Search, expanding context for leading sibling combinators
                    if ( (seed = find(
                        token.matches[0].replace( runescape, funescape ),
                        rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                    )) ) {

                        // If seed is empty or no tokens remain, we can return early
                        tokens.splice( i, 1 );
                        selector = seed.length && toSelector( tokens );
                        if ( !selector ) {
                            push.apply( results, seed );
                            return results;
                        }

                        break;
                    }
                }
            }
        }
    }

    // Compile and execute a filtering function
    // Provide `match` to avoid retokenization if we modified the selector above
    compile( selector, match )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector ) && testContext( context.parentNode ) || context
    );
    return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
    // Should return 1, but returns 4 (following)
    return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
    div.innerHTML = "<a href='#'></a>";
    return div.firstChild.getAttribute("href") === "#" ;
}) ) {
    addHandle( "type|href|height|width", function( elem, name, isXML ) {
        if ( !isXML ) {
            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
        }
    });
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
    div.innerHTML = "<input/>";
    div.firstChild.setAttribute( "value", "" );
    return div.firstChild.getAttribute( "value" ) === "";
}) ) {
    addHandle( "value", function( elem, name, isXML ) {
        if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
            return elem.defaultValue;
        }
    });
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
    return div.getAttribute("disabled") == null;
}) ) {
    addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
            return elem[ name ] === true ? name.toLowerCase() :
                    (val = elem.getAttributeNode( name )) && val.specified ?
                    val.value :
                null;
        }
    });
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
    if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep( elements, function( elem, i ) {
            /* jshint -W018 */
            return !!qualifier.call( elem, i, elem ) !== not;
        });

    }

    if ( qualifier.nodeType ) {
        return jQuery.grep( elements, function( elem ) {
            return ( elem === qualifier ) !== not;
        });

    }

    if ( typeof qualifier === "string" ) {
        if ( risSimple.test( qualifier ) ) {
            return jQuery.filter( qualifier, elements, not );
        }

        qualifier = jQuery.filter( qualifier, elements );
    }

    return jQuery.grep( elements, function( elem ) {
        return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
    });
}

jQuery.filter = function( expr, elems, not ) {
    var elem = elems[ 0 ];

    if ( not ) {
        expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1 ?
        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
            return elem.nodeType === 1;
        }));
};

jQuery.fn.extend({
    find: function( selector ) {
        var i,
            ret = [],
            self = this,
            len = self.length;

        if ( typeof selector !== "string" ) {
            return this.pushStack( jQuery( selector ).filter(function() {
                for ( i = 0; i < len; i++ ) {
                    if ( jQuery.contains( self[ i ], this ) ) {
                        return true;
                    }
                }
            }) );
        }

        for ( i = 0; i < len; i++ ) {
            jQuery.find( selector, self[ i ], ret );
        }

        // Needed because $( selector, context ) becomes $( context ).find( selector )
        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + " " + selector : selector;
        return ret;
    },
    filter: function( selector ) {
        return this.pushStack( winnow(this, selector || [], false) );
    },
    not: function( selector ) {
        return this.pushStack( winnow(this, selector || [], true) );
    },
    is: function( selector ) {
        return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test( selector ) ?
                jQuery( selector ) :
                selector || [],
            false
        ).length;
    }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

    init = jQuery.fn.init = function( selector, context ) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if ( !selector ) {
            return this;
        }

        // Handle HTML strings
        if ( typeof selector === "string" ) {
            if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];

            } else {
                match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && (match[1] || !context) ) {

                // HANDLE: $(html) -> $(array)
                if ( match[1] ) {
                    context = context instanceof jQuery ? context[0] : context;

                    // scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge( this, jQuery.parseHTML(
                        match[1],
                        context && context.nodeType ? context.ownerDocument || context : document,
                        true
                    ) );

                    // HANDLE: $(html, props)
                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                        for ( match in context ) {
                            // Properties of context are called as methods if possible
                            if ( jQuery.isFunction( this[ match ] ) ) {
                                this[ match ]( context[ match ] );

                            // ...and otherwise set as attributes
                            } else {
                                this.attr( match, context[ match ] );
                            }
                        }
                    }

                    return this;

                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if ( elem.id !== match[2] ) {
                            return rootjQuery.find( selector );
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {
                return ( context || rootjQuery ).find( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor( context ).find( selector );
            }

        // HANDLE: $(DOMElement)
        } else if ( selector.nodeType ) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery.isFunction( selector ) ) {
            return typeof rootjQuery.ready !== "undefined" ?
                rootjQuery.ready( selector ) :
                // Execute immediately if ready is not present
                selector( jQuery );
        }

        if ( selector.selector !== undefined ) {
            this.selector = selector.selector;
            this.context = selector.context;
        }

        return jQuery.makeArray( selector, this );
    };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

jQuery.extend({
    dir: function( elem, dir, until ) {
        var matched = [],
            cur = elem[ dir ];

        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur.nodeType === 1 ) {
                matched.push( cur );
            }
            cur = cur[dir];
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                r.push( n );
            }
        }

        return r;
    }
});

jQuery.fn.extend({
    has: function( target ) {
        var i,
            targets = jQuery( target, this ),
            len = targets.length;

        return this.filter(function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( this, targets[i] ) ) {
                    return true;
                }
            }
        });
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                jQuery( selectors, context || this.context ) :
                0;

        for ( ; i < l; i++ ) {
            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                // Always skip document fragments
                if ( cur.nodeType < 11 && (pos ?
                    pos.index(cur) > -1 :

                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 &&
                        jQuery.find.matchesSelector(cur, selectors)) ) {

                    matched.push( cur );
                    break;
                }
            }
        }

        return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === "string" ) {
            return jQuery.inArray( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem, this );
    },

    add: function( selector, context ) {
        return this.pushStack(
            jQuery.unique(
                jQuery.merge( this.get(), jQuery( selector, context ) )
            )
        );
    },

    addBack: function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    }
});

function sibling( cur, dir ) {
    do {
        cur = cur[ dir ];
    } while ( cur && cur.nodeType !== 1 );

    return cur;
}

jQuery.each({
    parent: function( elem ) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
        return jQuery.dir( elem, "parentNode" );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "parentNode", until );
    },
    next: function( elem ) {
        return sibling( elem, "nextSibling" );
    },
    prev: function( elem ) {
        return sibling( elem, "previousSibling" );
    },
    nextAll: function( elem ) {
        return jQuery.dir( elem, "nextSibling" );
    },
    prevAll: function( elem ) {
        return jQuery.dir( elem, "previousSibling" );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "nextSibling", until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "previousSibling", until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
    },
    contents: function( elem ) {
        return jQuery.nodeName( elem, "iframe" ) ?
            elem.contentDocument || elem.contentWindow.document :
            jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
        var ret = jQuery.map( this, fn, until );

        if ( name.slice( -5 ) !== "Until" ) {
            selector = until;
        }

        if ( selector && typeof selector === "string" ) {
            ret = jQuery.filter( selector, ret );
        }

        if ( this.length > 1 ) {
            // Remove duplicates
            if ( !guaranteedUnique[ name ] ) {
                ret = jQuery.unique( ret );
            }

            // Reverse order for parents* and prev-derivatives
            if ( rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }
        }

        return this.pushStack( ret );
    };
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
        object[ flag ] = true;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *          the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:           will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:         will keep track of previous values and will call any callback added
 *                  after the list has been fired right away with the latest "memorized"
 *                  values (like a Deferred)
 *
 *  unique:         will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:    interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Flag to know if list is currently firing
        firing,
        // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once && [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === "function" ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg && arg.length && type !== "string" ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we're not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if ( list ) {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );
                            // Handle firing indexes
                            if ( firing ) {
                                if ( index <= firingLength ) {
                                    firingLength--;
                                }
                                if ( index <= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function( fn ) {
                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if ( !memory ) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                if ( list && ( !fired || stack ) ) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

    return self;
};


jQuery.extend({

    Deferred: function( func ) {
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                [ "notify", "progress", jQuery.Callbacks("memory") ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return jQuery.Deferred(function( newDefer ) {
                        jQuery.each( tuples, function( i, tuple ) {
                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ](function() {
                                var returned = fn && fn.apply( this, arguments );
                                if ( returned && jQuery.isFunction( returned.promise ) ) {
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject )
                                        .progress( newDefer.notify );
                                } else {
                                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add
            promise[ tuple[1] ] = list.add;

            // Handle state
            if ( stateString ) {
                list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock
                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            }

            // deferred[ resolve | reject | notify ]
            deferred[ tuple[0] ] = function() {
                deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                return this;
            };
            deferred[ tuple[0] + "With" ] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = slice.call( arguments ),
            length = resolveValues.length,

            // the count of uncompleted subordinates
            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                    if ( values === progressValues ) {
                        deferred.notifyWith( contexts, values );

                    } else if ( !(--remaining) ) {
                        deferred.resolveWith( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length > 1 ) {
            progressValues = new Array( length );
            progressContexts = new Array( length );
            resolveContexts = new Array( length );
            for ( ; i < length; i++ ) {
                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                    resolveValues[ i ].promise()
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    --remaining;
                }
            }
        }

        // if we're not waiting on anything, resolve the master
        if ( !remaining ) {
            deferred.resolveWith( resolveContexts, resolveValues );
        }

        return deferred.promise();
    }
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
    // Add the callback
    jQuery.ready.promise().done( fn );

    return this;
};

jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function( hold ) {
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            jQuery.ready( true );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {

        // Abort if there are pending holds or we're already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document.body ) {
            return setTimeout( jQuery.ready );
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true && --jQuery.readyWait > 0 ) {
            return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.trigger ) {
            jQuery( document ).trigger("ready").off("ready");
        }
    }
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
    if ( document.addEventListener ) {
        document.removeEventListener( "DOMContentLoaded", completed, false );
        window.removeEventListener( "load", completed, false );

    } else {
        document.detachEvent( "onreadystatechange", completed );
        window.detachEvent( "onload", completed );
    }
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
    // readyState === "complete" is good enough for us to call the dom ready in oldIE
    if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
        detach();
        jQuery.ready();
    }
}

jQuery.ready.promise = function( obj ) {
    if ( !readyList ) {

        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === "complete" ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            setTimeout( jQuery.ready );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document.addEventListener ) {
            // Use the handy event callback
            document.addEventListener( "DOMContentLoaded", completed, false );

            // A fallback to window.onload, that will always work
            window.addEventListener( "load", completed, false );

        // If IE event model is used
        } else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document.attachEvent( "onreadystatechange", completed );

            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", completed );

            // If IE and not a frame
            // continually check to see if the document is ready
            var top = false;

            try {
                top = window.frameElement == null && document.documentElement;
            } catch(e) {}

            if ( top && top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery.isReady ) {

                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll("left");
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        // detach all dom ready events
                        detach();

                        // and execute any waiting functions
                        jQuery.ready();
                    }
                })();
            }
        }
    }
    return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
    break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

jQuery(function() {
    // We need to execute this one support test ASAP because we need to know
    // if body.style.zoom needs to be set.

    var container, div,
        body = document.getElementsByTagName("body")[0];

    if ( !body ) {
        // Return for frameset docs that don't have a body
        return;
    }

    // Setup
    container = document.createElement( "div" );
    container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

    div = document.createElement( "div" );
    body.appendChild( container ).appendChild( div );

    if ( typeof div.style.zoom !== strundefined ) {
        // Support: IE<8
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to 'inline' and giving
        // them layout
        div.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1";

        if ( (support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 )) ) {
            // Prevent IE 6 from affecting layout for positioned elements #11048
            // Prevent IE from shrinking the body in IE 7 mode #12869
            // Support: IE<8
            body.style.zoom = 1;
        }
    }

    body.removeChild( container );

    // Null elements to avoid leaks in IE
    container = div = null;
});




(function() {
    var div = document.createElement( "div" );

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
    var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
        nodeType = +elem.nodeType || 1;

    // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
    return nodeType !== 1 && nodeType !== 9 ?
        false :

        // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem.nodeType === 1 ) {

        var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            try {
                data = data === "true" ? true :
                    data === "false" ? false :
                    data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data :
                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn't changed later
            jQuery.data( elem, key, data );

        } else {
            data = undefined;
        }
    }

    return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
    var name;
    for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
            continue;
        }
        if ( name !== "toJSON" ) {
            return false;
        }
    }

    return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var ret, thisCache,
        internalKey = jQuery.expando,

        // We have to handle DOM nodes and JS objects differently because IE6-7
        // can't GC object references properly across the DOM-JS boundary
        isNode = elem.nodeType,

        // Only DOM nodes need the global jQuery cache; JS object data is
        // attached directly to the object so GC can occur automatically
        cache = isNode ? jQuery.cache : elem,

        // Only defining an ID for JS objects if its cache already exists allows
        // the code to shortcut on the same path as a DOM node with no cache
        id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
        return;
    }

    if ( !id ) {
        // Only DOM nodes need a new unique ID for each element since their data
        // ends up in the global cache
        if ( isNode ) {
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
            id = internalKey;
        }
    }

    if ( !cache[ id ] ) {
        // Avoid exposing jQuery metadata on plain JS objects when the object
        // is serialized using JSON.stringify
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
        if ( pvt ) {
            cache[ id ] = jQuery.extend( cache[ id ], name );
        } else {
            cache[ id ].data = jQuery.extend( cache[ id ].data, name );
        }
    }

    thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
        if ( !thisCache.data ) {
            thisCache.data = {};
        }

        thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
        thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( typeof name === "string" ) {

        // First Try to find as-is property data
        ret = thisCache[ name ];

        // Test for null|undefined property data
        if ( ret == null ) {

            // Try to find the camelCased property
            ret = thisCache[ jQuery.camelCase( name ) ];
        }
    } else {
        ret = thisCache;
    }

    return ret;
}

function internalRemoveData( elem, name, pvt ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var thisCache, i,
        isNode = elem.nodeType,

        // See jQuery.data for more information
        cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
        return;
    }

    if ( name ) {

        thisCache = pvt ? cache[ id ] : cache[ id ].data;

        if ( thisCache ) {

            // Support array or space separated string names for data keys
            if ( !jQuery.isArray( name ) ) {

                // try the string as a key before any manipulation
                if ( name in thisCache ) {
                    name = [ name ];
                } else {

                    // split the camel cased version by spaces unless a key with the spaces exists
                    name = jQuery.camelCase( name );
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {
                        name = name.split(" ");
                    }
                }
            } else {
                // If "name" is an array of keys...
                // When data is initially created, via ("key", "val") signature,
                // keys will be converted to camelCase.
                // Since there is no way to tell _how_ a key was added, remove
                // both plain key and camelCase key. #12786
                // This will only penalize the array argument path.
                name = name.concat( jQuery.map( name, jQuery.camelCase ) );
            }

            i = name.length;
            while ( i-- ) {
                delete thisCache[ name[i] ];
            }

            // If there is no data left in the cache, we want to continue
            // and let the cache object itself get destroyed
            if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                return;
            }
        }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
        delete cache[ id ].data;

        // Don't destroy the parent cache unless the internal data object
        // had been the only thing left in it
        if ( !isEmptyDataObject( cache[ id ] ) ) {
            return;
        }
    }

    // Destroy the cache
    if ( isNode ) {
        jQuery.cleanData( [ elem ], true );

    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
    /* jshint eqeqeq: false */
    } else if ( support.deleteExpando || cache != cache.window ) {
        /* jshint eqeqeq: true */
        delete cache[ id ];

    // When all else fails, null
    } else {
        cache[ id ] = null;
    }
}

jQuery.extend({
    cache: {},

    // The following elements (space-suffixed to avoid Object.prototype collisions)
    // throw uncatchable exceptions if you attempt to set expando properties
    noData: {
        "applet ": true,
        "embed ": true,
        // ...but Flash objects (which have this classid) *can* handle expandos
        "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },

    hasData: function( elem ) {
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        return !!elem && !isEmptyDataObject( elem );
    },

    data: function( elem, name, data ) {
        return internalData( elem, name, data );
    },

    removeData: function( elem, name ) {
        return internalRemoveData( elem, name );
    },

    // For internal use only.
    _data: function( elem, name, data ) {
        return internalData( elem, name, data, true );
    },

    _removeData: function( elem, name ) {
        return internalRemoveData( elem, name, true );
    }
});

jQuery.fn.extend({
    data: function( key, value ) {
        var i, name, data,
            elem = this[0],
            attrs = elem && elem.attributes;

        // Special expections of .data basically thwart jQuery.access,
        // so implement the relevant behavior ourselves

        // Gets all values
        if ( key === undefined ) {
            if ( this.length ) {
                data = jQuery.data( elem );

                if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                    i = attrs.length;
                    while ( i-- ) {
                        name = attrs[i].name;

                        if ( name.indexOf("data-") === 0 ) {
                            name = jQuery.camelCase( name.slice(5) );

                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                    jQuery._data( elem, "parsedAttrs", true );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === "object" ) {
            return this.each(function() {
                jQuery.data( this, key );
            });
        }

        return arguments.length > 1 ?

            // Sets one value
            this.each(function() {
                jQuery.data( this, key, value );
            }) :

            // Gets one value
            // Try to fetch any internally stored data first
            elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
    },

    removeData: function( key ) {
        return this.each(function() {
            jQuery.removeData( this, key );
        });
    }
});


jQuery.extend({
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            type = ( type || "fx" ) + "queue";
            queue = jQuery._data( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                if ( !queue || jQuery.isArray(data) ) {
                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                } else {
                    queue.push( data );
                }
            }
            return queue || [];
        }
    },

    dequeue: function( elem, type ) {
        type = type || "fx";

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
                jQuery.dequeue( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === "inprogress" ) {
            fn = queue.shift();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === "fx" ) {
                queue.unshift( "inprogress" );
            }

            // clear up the last queue stop function
            delete hooks.stop;
            fn.call( elem, next, hooks );
        }

        if ( !startLength && hooks ) {
            hooks.empty.fire();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
        var key = type + "queueHooks";
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
                jQuery._removeData( elem, type + "queue" );
                jQuery._removeData( elem, key );
            })
        });
    }
});

jQuery.fn.extend({
    queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== "string" ) {
            data = type;
            type = "fx";
            setter--;
        }

        if ( arguments.length < setter ) {
            return jQuery.queue( this[0], type );
        }

        return data === undefined ?
            this :
            this.each(function() {
                var queue = jQuery.queue( this, type, data );

                // ensure a hooks for this queue
                jQuery._queueHooks( this, type );

                if ( type === "fx" && queue[0] !== "inprogress" ) {
                    jQuery.dequeue( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this.each(function() {
            jQuery.dequeue( this, type );
        });
    },
    clearQueue: function( type ) {
        return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            };

        if ( typeof type !== "string" ) {
            obj = type;
            type = undefined;
        }
        type = type || "fx";

        while ( i-- ) {
            tmp = jQuery._data( elements[ i ], type + "queueHooks" );
            if ( tmp && tmp.empty ) {
                count++;
                tmp.empty.add( resolve );
            }
        }
        resolve();
        return defer.promise( obj );
    }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
    };



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    var i = 0,
        length = elems.length,
        bulk = key == null;

    // Sets many values
    if ( jQuery.type( key ) === "object" ) {
        chainable = true;
        for ( i in key ) {
            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
        }

    // Sets one value
    } else if ( value !== undefined ) {
        chainable = true;

        if ( !jQuery.isFunction( value ) ) {
            raw = true;
        }

        if ( bulk ) {
            // Bulk operations run against the entire set
            if ( raw ) {
                fn.call( elems, value );
                fn = null;

            // ...except when executing function values
            } else {
                bulk = fn;
                fn = function( elem, key, value ) {
                    return bulk.call( jQuery( elem ), value );
                };
            }
        }

        if ( fn ) {
            for ( ; i < length; i++ ) {
                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
            }
        }
    }

    return chainable ?
        elems :

        // Gets
        bulk ?
            fn.call( elems ) :
            length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
    var fragment = document.createDocumentFragment(),
        div = document.createElement("div"),
        input = document.createElement("input");

    // Setup
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a>";

    // IE strips leading whitespace when .innerHTML is used
    support.leadingWhitespace = div.firstChild.nodeType === 3;

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    support.tbody = !div.getElementsByTagName( "tbody" ).length;

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    support.html5Clone =
        document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    input.type = "checkbox";
    input.checked = true;
    fragment.appendChild( input );
    support.appendChecked = input.checked;

    // Make sure textarea (and checkbox) defaultValue is properly cloned
    // Support: IE6-IE11+
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

    // #11217 - WebKit loses check when the name is after the checked attribute
    fragment.appendChild( div );
    div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // old WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

    // Support: IE<9
    // Opera does not clone events (and typeof div.attachEvent === undefined).
    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
    support.noCloneEvent = true;
    if ( div.attachEvent ) {
        div.attachEvent( "onclick", function() {
            support.noCloneEvent = false;
        });

        div.cloneNode( true ).click();
    }

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }

    // Null elements to avoid leaks in IE.
    fragment = div = input = null;
})();


(function() {
    var i, eventName,
        div = document.createElement( "div" );

    // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
    for ( i in { submit: true, change: true, focusin: true }) {
        eventName = "on" + i;

        if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
            // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
            div.setAttribute( eventName, "t" );
            support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
    return true;
}

function returnFalse() {
    return false;
}

function safeActiveElement() {
    try {
        return document.activeElement;
    } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

    global: {},

    add: function( elem, types, handler, data, selector ) {
        var tmp, events, t, handleObjIn,
            special, eventHandle, handleObj,
            handlers, type, namespaces, origType,
            elemData = jQuery._data( elem );

        // Don't attach events to noData or text/comment nodes (but allow plain objects)
        if ( !elemData ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
        }

        // Init the element's event structure and main handler, if this is the first
        if ( !(events = elemData.events) ) {
            events = elemData.events = {};
        }
        if ( !(eventHandle = elemData.handle) ) {
            eventHandle = elemData.handle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // There *must* be a type, no attaching namespace-only handlers
            if ( !type ) {
                continue;
            }

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                namespace: namespaces.join(".")
            }, handleObjIn );

            // Init the event handler queue if we're the first
            if ( !(handlers = events[ type ]) ) {
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                // Only use addEventListener/attachEvent if the special events handler returns false
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    // Bind the global event handler to the element
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );

                    } else if ( elem.attachEvent ) {
                        elem.attachEvent( "on" + type, eventHandle );
                    }
                }
            }

            if ( special.add ) {
                special.add.call( elem, handleObj );

                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
                handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
    },

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {
        var j, handleObj, tmp,
            origCount, t, events,
            special, handlers, type,
            namespaces, origType,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem );

        if ( !elemData || !(events = elemData.events) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                }
                continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

            // Remove matching events
            origCount = j = handlers.length;
            while ( j-- ) {
                handleObj = handlers[ j ];

                if ( ( mappedTypes || origType === handleObj.origType ) &&
                    ( !handler || handler.guid === handleObj.guid ) &&
                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                    ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                    handlers.splice( j, 1 );

                    if ( handleObj.selector ) {
                        handlers.delegateCount--;
                    }
                    if ( special.remove ) {
                        special.remove.call( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( origCount && !handlers.length ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            delete elemData.handle;

            // removeData also checks for emptiness and clears the expando if empty
            // so use it instead of delete
            jQuery._removeData( elem, "events" );
        }
    },

    trigger: function( event, data, elem, onlyHandlers ) {
        var handle, ontype, cur,
            bubbleType, special, tmp, i,
            eventPath = [ elem || document ],
            type = hasOwn.call( event, "type" ) ? event.type : event,
            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

        cur = tmp = elem = elem || document;

        // Don't do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
        }

        if ( type.indexOf(".") >= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[ jQuery.expando ] ?
            event :
            new jQuery.Event( type, typeof event === "object" && event );

        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.namespace_re = event.namespace ?
            new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
            null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
            event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            if ( !rfocusMorph.test( bubbleType + type ) ) {
                cur = cur.parentNode;
            }
            for ( ; cur; cur = cur.parentNode ) {
                eventPath.push( cur );
                tmp = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( tmp === (elem.ownerDocument || document) ) {
                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            }
        }

        // Fire handlers on the event path
        i = 0;
        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

            event.type = i > 1 ?
                bubbleType :
                special.bindType || type;

            // jQuery handler
            handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
            if ( handle ) {
                handle.apply( cur, data );
            }

            // Native handler
            handle = ontype && cur[ ontype ];
            if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                event.result = handle.apply( cur, data );
                if ( event.result === false ) {
                    event.preventDefault();
                }
            }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers && !event.isDefaultPrevented() ) {

            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                jQuery.acceptData( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Can't use an .isFunction() check here because IE6/7 fails that test.
                // Don't do default actions on window, that's where global variables be (#6170)
                if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ ontype ];

                    if ( tmp ) {
                        elem[ ontype ] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    try {
                        elem[ type ]();
                    } catch ( e ) {
                        // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                    }
                    jQuery.event.triggered = undefined;

                    if ( tmp ) {
                        elem[ ontype ] = tmp;
                    }
                }
            }
        }

        return event.result;
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event );

        var i, ret, handleObj, matched, j,
            handlerQueue = [],
            args = slice.call( arguments ),
            handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
            return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
            event.currentTarget = matched.elem;

            j = 0;
            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                // Triggered event must either 1) have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                    event.handleObj = handleObj;
                    event.data = handleObj.data;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                    if ( ret !== undefined ) {
                        if ( (event.result = ret) === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
        }

        return event.result;
    },

    handlers: function( event, handlers ) {
        var sel, handleObj, matches, i,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;

        // Find delegate handlers
        // Black-hole SVG <use> instance trees (#13180)
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

            /* jshint eqeqeq: false */
            for ( ; cur != this; cur = cur.parentNode || this ) {
                /* jshint eqeqeq: true */

                // Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                    matches = [];
                    for ( i = 0; i < delegateCount; i++ ) {
                        handleObj = handlers[ i ];

                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";

                        if ( matches[ sel ] === undefined ) {
                            matches[ sel ] = handleObj.needsContext ?
                                jQuery( sel, this ).index( cur ) >= 0 :
                                jQuery.find( sel, this, null, [ cur ] ).length;
                        }
                        if ( matches[ sel ] ) {
                            matches.push( handleObj );
                        }
                    }
                    if ( matches.length ) {
                        handlerQueue.push({ elem: cur, handlers: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( delegateCount < handlers.length ) {
            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
        }

        return handlerQueue;
    },

    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop, copy,
            type = event.type,
            originalEvent = event,
            fixHook = this.fixHooks[ type ];

        if ( !fixHook ) {
            this.fixHooks[ type ] = fixHook =
                rmouseEvent.test( type ) ? this.mouseHooks :
                rkeyEvent.test( type ) ? this.keyHooks :
                {};
        }
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        event = new jQuery.Event( originalEvent );

        i = copy.length;
        while ( i-- ) {
            prop = copy[ i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Support: IE<9
        // Fix target property (#1925)
        if ( !event.target ) {
            event.target = originalEvent.srcElement || document;
        }

        // Support: Chrome 23+, Safari?
        // Target should not be a text node (#504, #13143)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        // Support: IE<9
        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
        event.metaKey = !!event.metaKey;

        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

    fixHooks: {},

    keyHooks: {
        props: "char charCode key keyCode".split(" "),
        filter: function( event, original ) {

            // Add which for key events
            if ( event.which == null ) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
        filter: function( event, original ) {
            var body, eventDoc, doc,
                button = original.button,
                fromElement = original.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null && original.clientX != null ) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
            }

            // Add relatedTarget, if necessary
            if ( !event.relatedTarget && fromElement ) {
                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event.which && button !== undefined ) {
                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
        },
        focus: {
            // Fire native event if possible so blur/focus sequence is correct
            trigger: function() {
                if ( this !== safeActiveElement() && this.focus ) {
                    try {
                        this.focus();
                        return false;
                    } catch ( e ) {
                        // Support: IE<9
                        // If we error on focus to hidden element (#1486, #12518),
                        // let .trigger() run the handlers
                    }
                }
            },
            delegateType: "focusin"
        },
        blur: {
            trigger: function() {
                if ( this === safeActiveElement() && this.blur ) {
                    this.blur();
                    return false;
                }
            },
            delegateType: "focusout"
        },
        click: {
            // For checkbox, fire native event so checked state will be right
            trigger: function() {
                if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                    this.click();
                    return false;
                }
            },

            // For cross-browser consistency, don't fire native .click() on links
            _default: function( event ) {
                return jQuery.nodeName( event.target, "a" );
            }
        },

        beforeunload: {
            postDispatch: function( event ) {

                // Even when returnValue equals to undefined Firefox will still show alert
                if ( event.result !== undefined ) {
                    event.originalEvent.returnValue = event.result;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
            new jQuery.Event(),
            event,
            {
                type: type,
                isSimulated: true,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery.event.trigger( e, null, elem );
        } else {
            jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
            event.preventDefault();
        }
    }
};

jQuery.removeEvent = document.removeEventListener ?
    function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle, false );
        }
    } :
    function( elem, type, handle ) {
        var name = "on" + type;

        if ( elem.detachEvent ) {

            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if ( typeof elem[ name ] === strundefined ) {
                elem[ name ] = null;
            }

            elem.detachEvent( name, handle );
        }
    };

jQuery.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined && (
                // Support: IE < 9
                src.returnValue === false ||
                // Support: Android < 4.0
                src.getPreventDefault && src.getPreventDefault() ) ?
            returnTrue :
            returnFalse;

    // Event type
    } else {
        this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery.extend( this, props );
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function() {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;
        if ( !e ) {
            return;
        }

        // If preventDefault exists, run it on the original event
        if ( e.preventDefault ) {
            e.preventDefault();

        // Support: IE
        // Otherwise set the returnValue property of the original event to false
        } else {
            e.returnValue = false;
        }
    },
    stopPropagation: function() {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;
        if ( !e ) {
            return;
        }
        // If stopPropagation exists, run it on the original event
        if ( e.stopPropagation ) {
            e.stopPropagation();
        }

        // Support: IE
        // Set the cancelBubble property of the original event to true
        e.cancelBubble = true;
    },
    stopImmediatePropagation: function() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
    }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( this, arguments );
                event.type = fix;
            }
            return ret;
        }
    };
});

// IE submit delegation
if ( !support.submitBubbles ) {

    jQuery.event.special.submit = {
        setup: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Lazy-add a submit handler when a descendant form may potentially be submitted
            jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e.target,
                    form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                    jQuery.event.add( form, "submit._submit", function( event ) {
                        event._submit_bubble = true;
                    });
                    jQuery._data( form, "submitBubbles", true );
                }
            });
            // return undefined since we don't need an event listener
        },

        postDispatch: function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( event._submit_bubble ) {
                delete event._submit_bubble;
                if ( this.parentNode && !event.isTrigger ) {
                    jQuery.event.simulate( "submit", this.parentNode, event, true );
                }
            }
        },

        teardown: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            jQuery.event.remove( this, "._submit" );
        }
    };
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

    jQuery.event.special.change = {

        setup: function() {

            if ( rformElems.test( this.nodeName ) ) {
                // IE doesn't fire change on a check/radio until blur; trigger it on click
                // after a propertychange. Eat the blur-change in special.change.handle.
                // This still fires onchange a second time for check/radio after blur.
                if ( this.type === "checkbox" || this.type === "radio" ) {
                    jQuery.event.add( this, "propertychange._change", function( event ) {
                        if ( event.originalEvent.propertyName === "checked" ) {
                            this._just_changed = true;
                        }
                    });
                    jQuery.event.add( this, "click._change", function( event ) {
                        if ( this._just_changed && !event.isTrigger ) {
                            this._just_changed = false;
                        }
                        // Allow triggered, simulated change events (#11500)
                        jQuery.event.simulate( "change", this, event, true );
                    });
                }
                return false;
            }
            // Delegated event; lazy-add a change handler on descendant inputs
            jQuery.event.add( this, "beforeactivate._change", function( e ) {
                var elem = e.target;

                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                    jQuery.event.add( elem, "change._change", function( event ) {
                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                            jQuery.event.simulate( "change", this.parentNode, event, true );
                        }
                    });
                    jQuery._data( elem, "changeBubbles", true );
                }
            });
        },

        handle: function( event ) {
            var elem = event.target;

            // Swallow native change events from checkbox/radio, we already triggered them above
            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                return event.handleObj.handler.apply( this, arguments );
            }
        },

        teardown: function() {
            jQuery.event.remove( this, "._change" );

            return !rformElems.test( this.nodeName );
        }
    };
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

        jQuery.event.special[ fix ] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix );

                if ( !attaches ) {
                    doc.addEventListener( orig, handler, true );
                }
                jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix ) - 1;

                if ( !attaches ) {
                    doc.removeEventListener( orig, handler, true );
                    jQuery._removeData( doc, fix );
                } else {
                    jQuery._data( doc, fix, attaches );
                }
            }
        };
    });
}

jQuery.fn.extend({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var type, origFn;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this.on( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == null && fn == null ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types && types.preventDefault && types.handleObj ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            return this;
        }
        if ( typeof types === "object" ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this.off( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === false || typeof selector === "function" ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === false ) {
            fn = returnFalse;
        }
        return this.each(function() {
            jQuery.event.remove( this, types, fn, selector );
        });
    },

    trigger: function( type, data ) {
        return this.each(function() {
            jQuery.event.trigger( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        var elem = this[0];
        if ( elem ) {
            return jQuery.event.trigger( type, data, elem, true );
        }
    }
});


function createSafeFragment( document ) {
    var list = nodeNames.split( "|" ),
        safeFrag = document.createDocumentFragment();

    if ( safeFrag.createElement ) {
        while ( list.length ) {
            safeFrag.createElement(
                list.pop()
            );
        }
    }
    return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rleadingWhitespace = /^\s+/,
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rtbody = /<tbody/i,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

    // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
    },
    safeFragment = createSafeFragment( document ),
    fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
    var elems, elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
            typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
            undefined;

    if ( !found ) {
        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
            if ( !tag || jQuery.nodeName( elem, tag ) ) {
                found.push( elem );
            } else {
                jQuery.merge( found, getAll( elem, tag ) );
            }
        }
    }

    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], found ) :
        found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
    }
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
    return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

        elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
        elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
    elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
    return elem;
}
function restoreScript( elem ) {
    var match = rscriptTypeMasked.exec( elem.type );
    if ( match ) {
        elem.type = match[1];
    } else {
        elem.removeAttribute("type");
    }
    return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
    var elem,
        i = 0;
    for ( ; (elem = elems[i]) != null; i++ ) {
        jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
    }
}

function cloneCopyEvent( src, dest ) {

    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
        return;
    }

    var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData.events;

    if ( events ) {
        delete curData.handle;
        curData.events = {};

        for ( type in events ) {
            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
            }
        }
    }

    // make the cloned public data object a copy from the original
    if ( curData.data ) {
        curData.data = jQuery.extend( {}, curData.data );
    }
}

function fixCloneNodeIssues( src, dest ) {
    var nodeName, e, data;

    // We do not need to do anything for non-Elements
    if ( dest.nodeType !== 1 ) {
        return;
    }

    nodeName = dest.nodeName.toLowerCase();

    // IE6-8 copies events bound via attachEvent when using cloneNode.
    if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
        data = jQuery._data( dest );

        for ( e in data.events ) {
            jQuery.removeEvent( dest, e, data.handle );
        }

        // Event data gets referenced instead of copied if the expando gets copied too
        dest.removeAttribute( jQuery.expando );
    }

    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
    if ( nodeName === "script" && dest.text !== src.text ) {
        disableScript( dest ).text = src.text;
        restoreScript( dest );

    // IE6-10 improperly clones children of object elements using classid.
    // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if ( nodeName === "object" ) {
        if ( dest.parentNode ) {
            dest.outerHTML = src.outerHTML;
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
            dest.innerHTML = src.innerHTML;
        }

    } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn't also set

        dest.defaultChecked = dest.checked = src.checked;

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of "on"
        if ( dest.value !== src.value ) {
            dest.value = src.value;
        }

    // IE6-8 fails to return the selected option to the default selected
    // state when cloning options
    } else if ( nodeName === "option" ) {
        dest.defaultSelected = dest.selected = src.defaultSelected;

    // IE6-8 fails to set the defaultValue to the correct value when
    // cloning other types of input fields
    } else if ( nodeName === "input" || nodeName === "textarea" ) {
        dest.defaultValue = src.defaultValue;
    }
}

jQuery.extend({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var destElements, node, clone, i, srcElements,
            inPage = jQuery.contains( elem.ownerDocument, elem );

        if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
            clone = elem.cloneNode( true );

        // IE<=8 does not properly clone detached, unknown element nodes
        } else {
            fragmentDiv.innerHTML = elem.outerHTML;
            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
        }

        if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
            destElements = getAll( clone );
            srcElements = getAll( elem );

            // Fix all IE cloning issues
            for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                // Ensure that the destination node is not null; Fixes #9587
                if ( destElements[i] ) {
                    fixCloneNodeIssues( node, destElements[i] );
                }
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            if ( deepDataAndEvents ) {
                srcElements = srcElements || getAll( elem );
                destElements = destElements || getAll( clone );

                for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                    cloneCopyEvent( node, destElements[i] );
                }
            } else {
                cloneCopyEvent( elem, clone );
            }
        }

        // Preserve script evaluation history
        destElements = getAll( clone, "script" );
        if ( destElements.length > 0 ) {
            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
        }

        destElements = srcElements = node = null;

        // Return the cloned set
        return clone;
    },

    buildFragment: function( elems, context, scripts, selection ) {
        var j, elem, contains,
            tmp, tag, tbody, wrap,
            l = elems.length,

            // Ensure a safe fragment
            safe = createSafeFragment( context ),

            nodes = [],
            i = 0;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                // Convert html into DOM nodes
                } else {
                    tmp = tmp || safe.appendChild( context.createElement("div") );

                    // Deserialize a standard representation
                    tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;

                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Manually add leading whitespace removed by IE
                    if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !support.tbody ) {

                        // String was a <table>, *may* have spurious <tbody>
                        elem = tag === "table" && !rtbody.test( elem ) ?
                            tmp.firstChild :

                            // String was a bare <thead> or <tfoot>
                            wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                tmp :
                                0;

                        j = elem && elem.childNodes.length;
                        while ( j-- ) {
                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                elem.removeChild( tbody );
                            }
                        }
                    }

                    jQuery.merge( nodes, tmp.childNodes );

                    // Fix #12392 for WebKit and IE > 9
                    tmp.textContent = "";

                    // Fix #12392 for oldIE
                    while ( tmp.firstChild ) {
                        tmp.removeChild( tmp.firstChild );
                    }

                    // Remember the top-level container for proper cleanup
                    tmp = safe.lastChild;
                }
            }
        }

        // Fix #11356: Clear elements from fragment
        if ( tmp ) {
            safe.removeChild( tmp );
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !support.appendChecked ) {
            jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
        }

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

            // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( safe.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( (elem = tmp[ j++ ]) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        tmp = null;

        return safe;
    },

    cleanData: function( elems, /* internal */ acceptData ) {
        var elem, type, id, data,
            i = 0,
            internalKey = jQuery.expando,
            cache = jQuery.cache,
            deleteExpando = support.deleteExpando,
            special = jQuery.event.special;

        for ( ; (elem = elems[i]) != null; i++ ) {
            if ( acceptData || jQuery.acceptData( elem ) ) {

                id = elem[ internalKey ];
                data = id && cache[ id ];

                if ( data ) {
                    if ( data.events ) {
                        for ( type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
                    }

                    // Remove cache only if it was not already removed by jQuery.event.remove
                    if ( cache[ id ] ) {

                        delete cache[ id ];

                        // IE does not allow us to delete expando properties from nodes,
                        // nor does it have a removeAttribute function on Document nodes;
                        // we must handle all of these cases
                        if ( deleteExpando ) {
                            delete elem[ internalKey ];

                        } else if ( typeof elem.removeAttribute !== strundefined ) {
                            elem.removeAttribute( internalKey );

                        } else {
                            elem[ internalKey ] = null;
                        }

                        deletedIds.push( id );
                    }
                }
            }
        }
    }
});

jQuery.fn.extend({
    text: function( value ) {
        return access( this, function( value ) {
            return value === undefined ?
                jQuery.text( this ) :
                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
    },

    append: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.appendChild( elem );
            }
        });
    },

    prepend: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.insertBefore( elem, target.firstChild );
            }
        });
    },

    before: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this );
            }
        });
    },

    after: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this.nextSibling );
            }
        });
    },

    remove: function( selector, keepData /* Internal Use Only */ ) {
        var elem,
            elems = selector ? jQuery.filter( selector, this ) : this,
            i = 0;

        for ( ; (elem = elems[i]) != null; i++ ) {

            if ( !keepData && elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem ) );
            }

            if ( elem.parentNode ) {
                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                    setGlobalEval( getAll( elem, "script" ) );
                }
                elem.parentNode.removeChild( elem );
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem, false ) );
            }

            // Remove any remaining nodes
            while ( elem.firstChild ) {
                elem.removeChild( elem.firstChild );
            }

            // If this is a select, ensure that it displays empty (#12336)
            // Support: IE<9
            if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                elem.options.length = 0;
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map(function() {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return access( this, function( value ) {
            var elem = this[ 0 ] || {},
                i = 0,
                l = this.length;

            if ( value === undefined ) {
                return elem.nodeType === 1 ?
                    elem.innerHTML.replace( rinlinejQuery, "" ) :
                    undefined;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                value = value.replace( rxhtmlTag, "<$1></$2>" );

                try {
                    for (; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        elem = this[i] || {};
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                            elem.innerHTML = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {}
            }

            if ( elem ) {
                this.empty().append( value );
            }
        }, null, value, arguments.length );
    },

    replaceWith: function() {
        var arg = arguments[ 0 ];

        // Make the changes, replacing each context element with the new content
        this.domManip( arguments, function( elem ) {
            arg = this.parentNode;

            jQuery.cleanData( getAll( this ) );

            if ( arg ) {
                arg.replaceChild( elem, this );
            }
        });

        // Force removal if there was no new content (e.g., from empty arguments)
        return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },

    detach: function( selector ) {
        return this.remove( selector, true );
    },

    domManip: function( args, callback ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var first, node, hasScripts,
            scripts, doc, fragment,
            i = 0,
            l = this.length,
            set = this,
            iNoClone = l - 1,
            value = args[0],
            isFunction = jQuery.isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
            return this.each(function( index ) {
                var self = set.eq( index );
                if ( isFunction ) {
                    args[0] = value.call( this, index, self.html() );
                }
                self.domManip( args, callback );
            });
        }

        if ( l ) {
            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            if ( first ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }

                    callback.call( this[i], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
                            !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                            if ( node.src ) {
                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl ) {
                                    jQuery._evalUrl( node.src );
                                }
                            } else {
                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                            }
                        }
                    }
                }

                // Fix #11809: Avoid leaking memory
                fragment = first = null;
            }
        }

        return this;
    }
});

jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
}, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
        var elems,
            i = 0,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1;

        for ( ; i <= last; i++ ) {
            elems = i === last ? this : this.clone(true);
            jQuery( insert[i] )[ original ]( elems );

            // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
            push.apply( ret, elems.get() );
        }

        return this.pushStack( ret );
    };
});


var iframe,
    elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
    var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

        // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle ?

            // Use of this method is a temporary fix (more like optmization) until something better comes along,
            // since it was removed from specification and supported only in FF
            window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();

    return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
    var doc = document,
        display = elemdisplay[ nodeName ];

    if ( !display ) {
        display = actualDisplay( nodeName, doc );

        // If the simple way fails, read from inside an iframe
        if ( display === "none" || !display ) {

            // Use the already-created iframe if possible
            iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
            doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

            // Support: IE
            doc.write();
            doc.close();

            display = actualDisplay( nodeName, doc );
            iframe.detach();
        }

        // Store the correct default display
        elemdisplay[ nodeName ] = display;
    }

    return display;
}


(function() {
    var a, shrinkWrapBlocksVal,
        div = document.createElement( "div" ),
        divReset =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
            "display:block;padding:0;margin:0;border:0";

    // Setup
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];

    a.style.cssText = "float:left;opacity:.5";

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    support.opacity = /^0.5/.test( a.style.opacity );

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!a.style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Null elements to avoid leaks in IE.
    a = div = null;

    support.shrinkWrapBlocks = function() {
        var body, container, div, containerStyles;

        if ( shrinkWrapBlocksVal == null ) {
            body = document.getElementsByTagName( "body" )[ 0 ];
            if ( !body ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
            container = document.createElement( "div" );
            div = document.createElement( "div" );

            body.appendChild( container ).appendChild( div );

            // Will be changed later if needed.
            shrinkWrapBlocksVal = false;

            if ( typeof div.style.zoom !== strundefined ) {
                // Support: IE6
                // Check if elements with layout shrink-wrap their children
                div.style.cssText = divReset + ";width:1px;padding:1px;zoom:1";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
            }

            body.removeChild( container );

            // Null elements to avoid leaks in IE.
            body = container = div = null;
        }

        return shrinkWrapBlocksVal;
    };

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
    rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
    getStyles = function( elem ) {
        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    };

    curCSS = function( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

        if ( computed ) {

            if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "";
    };
} else if ( document.documentElement.currentStyle ) {
    getStyles = function( elem ) {
        return elem.currentStyle;
    };

    curCSS = function( elem, name, computed ) {
        var left, rs, rsLeft, ret,
            style = elem.style;

        computed = computed || getStyles( elem );
        ret = computed ? computed[ name ] : undefined;

        // Avoid setting ret to empty string here
        // so we don't default to auto
        if ( ret == null && style && style[ name ] ) {
            ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

            // Remember the original values
            left = style.left;
            rs = elem.runtimeStyle;
            rsLeft = rs && rs.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                rs.left = elem.currentStyle.left;
            }
            style.left = name === "fontSize" ? "1em" : ret;
            ret = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                rs.left = rsLeft;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "" || "auto";
    };
}




function addGetHookIf( conditionFn, hookFn ) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
        get: function() {
            var condition = conditionFn();

            if ( condition == null ) {
                // The test was not ready at this point; screw the hook this time
                // but check again when needed next time.
                return;
            }

            if ( condition ) {
                // Hook not needed (or it's not possible to use it due to missing dependency),
                // remove it.
                // Since there are no other hooks for marginRight, remove the whole object.
                delete this.get;
                return;
            }

            // Hook needed; redefine it so that the support test is not executed again.

            return (this.get = hookFn).apply( this, arguments );
        }
    };
}


(function() {
    var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal,
        pixelPositionVal, reliableMarginRightVal,
        div = document.createElement( "div" ),
        containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
        divReset =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
            "display:block;padding:0;margin:0;border:0";

    // Setup
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];

    a.style.cssText = "float:left;opacity:.5";

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    support.opacity = /^0.5/.test( a.style.opacity );

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!a.style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Null elements to avoid leaks in IE.
    a = div = null;

    jQuery.extend(support, {
        reliableHiddenOffsets: function() {
            if ( reliableHiddenOffsetsVal != null ) {
                return reliableHiddenOffsetsVal;
            }

            var container, tds, isSupported,
                div = document.createElement( "div" ),
                body = document.getElementsByTagName( "body" )[ 0 ];

            if ( !body ) {
                // Return for frameset docs that don't have a body
                return;
            }

            // Setup
            div.setAttribute( "className", "t" );
            div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

            container = document.createElement( "div" );
            container.style.cssText = containerStyles;

            body.appendChild( container ).appendChild( div );

            // Support: IE8
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName( "td" );
            tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = ( tds[ 0 ].offsetHeight === 0 );

            tds[ 0 ].style.display = "";
            tds[ 1 ].style.display = "none";

            // Support: IE8
            // Check if empty table cells still have offsetWidth/Height
            reliableHiddenOffsetsVal = isSupported && ( tds[ 0 ].offsetHeight === 0 );

            body.removeChild( container );

            // Null elements to avoid leaks in IE.
            div = body = null;

            return reliableHiddenOffsetsVal;
        },

        boxSizing: function() {
            if ( boxSizingVal == null ) {
                computeStyleTests();
            }
            return boxSizingVal;
        },

        boxSizingReliable: function() {
            if ( boxSizingReliableVal == null ) {
                computeStyleTests();
            }
            return boxSizingReliableVal;
        },

        pixelPosition: function() {
            if ( pixelPositionVal == null ) {
                computeStyleTests();
            }
            return pixelPositionVal;
        },

        reliableMarginRight: function() {
            var body, container, div, marginDiv;

            // Use window.getComputedStyle because jsdom on node.js will break without it.
            if ( reliableMarginRightVal == null && window.getComputedStyle ) {
                body = document.getElementsByTagName( "body" )[ 0 ];
                if ( !body ) {
                    // Test fired too early or in an unsupported environment, exit.
                    return;
                }

                container = document.createElement( "div" );
                div = document.createElement( "div" );
                container.style.cssText = containerStyles;

                body.appendChild( container ).appendChild( div );

                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. (#3333)
                // Fails in WebKit before Feb 2011 nightlies
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                marginDiv = div.appendChild( document.createElement( "div" ) );
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";

                reliableMarginRightVal =
                    !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );

                body.removeChild( container );
            }

            return reliableMarginRightVal;
        }
    });

    function computeStyleTests() {
        var container, div,
            body = document.getElementsByTagName( "body" )[ 0 ];

        if ( !body ) {
            // Test fired too early or in an unsupported environment, exit.
            return;
        }

        container = document.createElement( "div" );
        div = document.createElement( "div" );
        container.style.cssText = containerStyles;

        body.appendChild( container ).appendChild( div );

        div.style.cssText =
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                "position:absolute;display:block;padding:1px;border:1px;width:4px;" +
                "margin-top:1%;top:1%";

        // Workaround failing boxSizing test due to offsetWidth returning wrong value
        // with some non-1 values of body zoom, ticket #13543
        jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
            boxSizingVal = div.offsetWidth === 4;
        });

        // Will be changed later if needed.
        boxSizingReliableVal = true;
        pixelPositionVal = false;
        reliableMarginRightVal = true;

        // Use window.getComputedStyle because jsdom on node.js will break without it.
        if ( window.getComputedStyle ) {
            pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
            boxSizingReliableVal =
                ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
        }

        body.removeChild( container );

        // Null elements to avoid leaks in IE.
        div = body = null;
    }

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
    var ret, name,
        old = {};

    // Remember the old values, and insert the new ones
    for ( name in options ) {
        old[ name ] = elem.style[ name ];
        elem.style[ name ] = options[ name ];
    }

    ret = callback.apply( elem, args || [] );

    // Revert the old values
    for ( name in options ) {
        elem.style[ name ] = old[ name ];
    }

    return ret;
};


var
        ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity\s*=\s*([^)]*)/,

    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
    rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    },

    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function showHide( elements, show ) {
    var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

    for ( ; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }

        values[ index ] = jQuery._data( elem, "olddisplay" );
        display = elem.style.display;
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] && display === "none" ) {
                elem.style.display = "";
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem.style.display === "" && isHidden( elem ) ) {
                values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
            }
        } else {

            if ( !values[ index ] ) {
                hidden = isHidden( elem );

                if ( display && display !== "none" || !hidden ) {
                    jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                }
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
            elem.style.display = show ? values[ index ] || "" : "none";
        }
    }

    return elements;
}

function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
        value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    var i = extra === ( isBorderBox ? "border" : "content" ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0,

        val = 0;

    for ( ; i < 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === "margin" ) {
            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === "content" ) {
                val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
            }

            // at this point, extra isn't border nor margin, so remove border
            if ( extra !== "margin" ) {
                val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        } else {
            // at this point, extra isn't content, so add padding
            val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

            // at this point, extra isn't content nor padding, so add border
            if ( extra !== "padding" ) {
                val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val <= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, styles );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? "border" : "content" ),
            valueIsBorderBox,
            styles
        )
    ) + "px";
}

jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, "opacity" );
                    return ret === "" ? "1" : ret;
                }
            }
        }
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
        "columnCount": true,
        "fillOpacity": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        "float": support.cssFloat ? "cssFloat" : "styleFloat"
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don't set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we're setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                // Fixes bug #9237
                type = "number";
            }

            // Make sure that null and NaN values aren't set. See: #7116
            if ( value == null || value !== value ) {
                return;
            }

            // If a number was passed in, add 'px' to the (except for certain CSS properties)
            if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                value += "px";
            }

            // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
            // but it would mean to define eight (for every problematic property) identical functions
            if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                style[ name ] = "inherit";
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                // Support: IE
                // Swallow errors from 'invalid' CSS values (#5509)
                try {
                    // Support: Chrome, Safari
                    // Setting style to blank string required to delete "style: x !important;"
                    style[ name ] = "";
                    style[ name ] = value;
                } catch(e) {}
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, extra, styles ) {
        var num, val, hooks,
            origName = jQuery.camelCase( name );

        // Make sure that we're working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks && "get" in hooks ) {
            val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name, styles );
        }

        //convert "normal" to computed value
        if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( extra === "" || extra ) {
            num = parseFloat( val );
            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
    }
});

jQuery.each([ "height", "width" ], function( i, name ) {
    jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
                    jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    }) :
                    getWidthOrHeight( elem, name, extra );
            }
        },

        set: function( elem, value, extra ) {
            var styles = extra && getStyles( elem );
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                    styles
                ) : 0
            );
        }
    };
});

if ( !support.opacity ) {
    jQuery.cssHooks.opacity = {
        get: function( elem, computed ) {
            // IE uses filters for opacity
            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                computed ? "1" : "";
        },

        set: function( elem, value ) {
            var style = elem.style,
                currentStyle = elem.currentStyle,
                opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                filter = currentStyle && currentStyle.filter || style.filter || "";

            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style.zoom = 1;

            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            // if value === "", then remove inline opacity #12685
            if ( ( value >= 1 || value === "" ) &&
                    jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                    style.removeAttribute ) {

                // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                // if "filter:" is present at all, clearType is disabled, we want to avoid this
                // style.removeAttribute is IE Only, but so apparently is this code path...
                style.removeAttribute( "filter" );

                // if there is no filter style applied in a css rule or unset inline opacity, we are done
                if ( value === "" || currentStyle && !currentStyle.filter ) {
                    return;
                }
            }

            // otherwise, set new filter values
            style.filter = ralpha.test( filter ) ?
                filter.replace( ralpha, opacity ) :
                filter + " " + opacity;
        }
    };
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
    function( elem, computed ) {
        if ( computed ) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap( elem, { "display": "inline-block" },
                curCSS, [ elem, "marginRight" ] );
        }
    }
);

// These hooks are used by animate to expand properties
jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
}, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
            var i = 0,
                expanded = {},

                // assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ];

            for ( ; i < 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
});

jQuery.fn.extend({
    css: function( name, value ) {
        return access( this, function( elem, name, value ) {
            var styles, len,
                map = {},
                i = 0;

            if ( jQuery.isArray( name ) ) {
                styles = getStyles( elem );
                len = name.length;

                for ( ; i < len; i++ ) {
                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                }

                return map;
            }

            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    },
    show: function() {
        return showHide( this, true );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state ) {
        if ( typeof state === "boolean" ) {
            return state ? this.show() : this.hide();
        }

        return this.each(function() {
            if ( isHidden( this ) ) {
                jQuery( this ).show();
            } else {
                jQuery( this ).hide();
            }
        });
    }
});


function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || "swing";
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    },
    cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks && hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        } else {
            this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks && hooks.set ) {
            hooks.set( this );
        } else {
            Tween.propHooks._default.set( this );
        }
        return this;
    }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween.elem[ tween.prop ] != null &&
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                return tween.elem[ tween.prop ];
            }

            // passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as "10px" are parsed to Float.
            // complex values such as "rotate(1rad)" are returned as is.
            result = jQuery.css( tween.elem, tween.prop, "" );
            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === "auto" ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery.fx.step[ tween.prop ] ) {
                jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    }
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
        if ( tween.elem.nodeType && tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
};

jQuery.easing = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p * Math.PI ) / 2;
    }
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        "*": [ function( prop, value ) {
            var tween = this.createTween( prop, value ),
                target = tween.cur(),
                parts = rfxnum.exec( value ),
                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                // Starting value computation is required for potential unit mismatches
                start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                scale = 1,
                maxIterations = 20;

            if ( start && start[ 3 ] !== unit ) {
                // Trust units reported by jQuery.css
                unit = unit || start[ 3 ];

                // Make sure we update the tween properties later on
                parts = parts || [];

                // Iteratively approximate from a nonzero starting point
                start = +target || 1;

                do {
                    // If previous iteration zeroed out, double until we get *something*
                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                    scale = scale || ".5";

                    // Adjust and apply
                    start = start / scale;
                    jQuery.style( tween.elem, prop, start + unit );

                // Update scale, tolerating zero or NaN from tween.cur()
                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
            }

            // Update tween properties
            if ( parts ) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[ 1 ] ?
                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                    +parts[ 2 ];
            }

            return tween;
        } ]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    });
    return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for ( ; i < 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    }

    if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
    }

    return attrs;
}

function createTween( value, prop, animation ) {
    var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
        index = 0,
        length = collection.length;
    for ( ; index < length; index++ ) {
        if ( (tween = collection[ index ].call( animation, prop, value )) ) {

            // we're done with this property
            return tween;
        }
    }
}

function defaultPrefilter( elem, props, opts ) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, display, dDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden( elem ),
        dataShow = jQuery._data( elem, "fxshow" );

    // handle queue: false promises
    if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, "fx" );
        if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
                if ( !hooks.unqueued ) {
                    oldfire();
                }
            };
        }
        hooks.unqueued++;

        anim.always(function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim.always(function() {
                hooks.unqueued--;
                if ( !jQuery.queue( elem, "fx" ).length ) {
                    hooks.empty.fire();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        display = jQuery.css( elem, "display" );
        dDisplay = defaultDisplay( elem.nodeName );
        if ( display === "none" ) {
            display = dDisplay;
        }
        if ( display === "inline" &&
                jQuery.css( elem, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !support.inlineBlockNeedsLayout || dDisplay === "inline" ) {
                style.display = "inline-block";
            } else {
                style.zoom = 1;
            }
        }
    }

    if ( opts.overflow ) {
        style.overflow = "hidden";
        if ( !support.shrinkWrapBlocks() ) {
            anim.always(function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            });
        }
    }

    // show/hide pass
    for ( prop in props ) {
        value = props[ prop ];
        if ( rfxtypes.exec( value ) ) {
            delete props[ prop ];
            toggle = toggle || value === "toggle";
            if ( value === ( hidden ? "hide" : "show" ) ) {

                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                    hidden = true;
                } else {
                    continue;
                }
            }
            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
        }
    }

    if ( !jQuery.isEmptyObject( orig ) ) {
        if ( dataShow ) {
            if ( "hidden" in dataShow ) {
                hidden = dataShow.hidden;
            }
        } else {
            dataShow = jQuery._data( elem, "fxshow", {} );
        }

        // store state if its toggle - enables .stop().toggle() to "reverse"
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }
        if ( hidden ) {
            jQuery( elem ).show();
        } else {
            anim.done(function() {
                jQuery( elem ).hide();
            });
        }
        anim.done(function() {
            var prop;
            jQuery._removeData( elem, "fxshow" );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        });
        for ( prop in orig ) {
            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween.start;
                if ( hidden ) {
                    tween.end = tween.start;
                    tween.start = prop === "width" || prop === "height" ? 1 : 0;
                }
            }
        }
    }
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

function Animation( elem, properties, options ) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }),
        tick = function() {
            if ( stopped ) {
                return false;
            }
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for ( ; index < length ; index++ ) {
                animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            if ( percent < 1 && length ) {
                return remaining;
            } else {
                deferred.resolveWith( elem, [ animation ] );
                return false;
            }
        },
        animation = deferred.promise({
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end ) {
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0;
                if ( stopped ) {
                    return this;
                }
                stopped = true;
                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                } else {
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    for ( ; index < length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
            return result;
        }
    }

    jQuery.map( props, createTween, animation );

    if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
    }

    jQuery.fx.timer(
        jQuery.extend( tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })
    );

    // attach callbacks from options
    return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
    tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
            callback = props;
            props = [ "*" ];
        } else {
            props = props.split(" ");
        }

        var prop,
            index = 0,
            length = props.length;

        for ( ; index < length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters.unshift( callback );
        } else {
            animationPrefilters.push( callback );
        }
    }
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
        opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
            opt.old.call( this );
        }

        if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
        }
    };

    return opt;
};

jQuery.fn.extend({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( "opacity", 0 ).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                // Empty animations, or finishing resolves immediately
                if ( empty || jQuery._data( this, "finish" ) ) {
                    anim.stop( true );
                }
            };
            doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
        };

        if ( typeof type !== "string" ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue && type !== false ) {
            this.queue( type || "fx", [] );
        }

        return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = jQuery._data( this );

            if ( index ) {
                if ( data[ index ] && data[ index ].stop ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = false;
                    timers.splice( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn't forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery.dequeue( this, type );
            }
        });
    },
    finish: function( type ) {
        if ( type !== false ) {
            type = type || "fx";
        }
        return this.each(function() {
            var index,
                data = jQuery._data( this ),
                queue = data[ type + "queue" ],
                hooks = data[ type + "queueHooks" ],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;

            // enable finishing flag on private data
            data.finish = true;

            // empty the queue first
            jQuery.queue( this, type, [] );

            if ( hooks && hooks.stop ) {
                hooks.stop.call( this, true );
            }

            // look for any active animations, and finish them
            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                    timers[ index ].anim.stop( true );
                    timers.splice( index, 1 );
                }
            }

            // look for any animations in the old queue and finish them
            for ( index = 0; index < length; index++ ) {
                if ( queue[ index ] && queue[ index ].finish ) {
                    queue[ index ].finish.call( this );
                }
            }

            // turn off finishing flag
            delete data.finish;
        });
    }
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === "boolean" ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
    };
});

// Generate shortcuts for custom animations
jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return this.animate( props, speed, easing, callback );
    };
});

jQuery.timers = [];
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i < timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
    jQuery.timers.push( timer );
    if ( timer() ) {
        jQuery.fx.start();
    } else {
        jQuery.timers.pop();
    }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
    if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};

jQuery.fx.stop = function() {
    clearInterval( timerId );
    timerId = null;
};

jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
            clearTimeout( timeout );
        };
    });
};


(function() {
    var a, input, select, opt,
        div = document.createElement("div" );

    // Setup
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[ 0 ];

    // First batch of tests.
    select = document.createElement("select");
    opt = select.appendChild( document.createElement("option") );
    input = div.getElementsByTagName("input")[ 0 ];

    a.style.cssText = "top:1px";

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    support.getSetAttribute = div.className !== "t";

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    support.style = /top/.test( a.getAttribute("style") );

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    support.hrefNormalized = a.getAttribute("href") === "/a";

    // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
    support.checkOn = !!input.value;

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    support.optSelected = opt.selected;

    // Tests for enctype support on a form (#6743)
    support.enctype = !!document.createElement("form").enctype;

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Support: IE8 only
    // Check if we can trust getAttribute("value")
    input = document.createElement( "input" );
    input.setAttribute( "value", "" );
    support.input = input.getAttribute( "value" ) === "";

    // Check if an input maintains its value after becoming a radio
    input.value = "t";
    input.setAttribute( "type", "radio" );
    support.radioValue = input.value === "t";

    // Null elements to avoid leaks in IE.
    a = input = select = opt = div = null;
})();


var rreturn = /\r/g;

jQuery.fn.extend({
    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments.length ) {
            if ( elem ) {
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                    return ret;
                }

                ret = elem.value;

                return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
            }

            return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
            var val;

            if ( this.nodeType !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value.call( this, i, jQuery( this ).val() );
            } else {
                val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == null ) {
                val = "";
            } else if ( typeof val === "number" ) {
                val += "";
            } else if ( jQuery.isArray( val ) ) {
                val = jQuery.map( val, function( value ) {
                    return value == null ? "" : value + "";
                });
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                this.value = val;
            }
        });
    }
});

jQuery.extend({
    valHooks: {
        option: {
            get: function( elem ) {
                var val = jQuery.find.attr( elem, "value" );
                return val != null ?
                    val :
                    jQuery.text( elem );
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i < max; i++ ) {
                    option = options[ i ];

                    // oldIE doesn't update selected after form reset (#2551)
                    if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don't need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values.push( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var optionSet, option,
                    options = elem.options,
                    values = jQuery.makeArray( value ),
                    i = options.length;

                while ( i-- ) {
                    option = options[ i ];

                    if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                        // Support: IE6
                        // When new option element is added to select box we need to
                        // force reflow of newly added node in order to workaround delay
                        // of initialization properties
                        try {
                            option.selected = optionSet = true;

                        } catch ( _ ) {

                            // Will be executed only in IE6
                            option.scrollHeight;
                        }

                    } else {
                        option.selected = false;
                    }
                }

                // Force browsers to behave consistently when non-matching value is set
                if ( !optionSet ) {
                    elem.selectedIndex = -1;
                }

                return options;
            }
        }
    }
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
        set: function( elem, value ) {
            if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
            }
        }
    };
    if ( !support.checkOn ) {
        jQuery.valHooks[ this ].get = function( elem ) {
            // Support: Webkit
            // "" is returned instead of "on" if a value isn't specified
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    }
});




var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle,
    ruseDefault = /^(?:checked|selected)$/i,
    getSetAttribute = support.getSetAttribute,
    getSetInput = support.input;

jQuery.fn.extend({
    attr: function( name, value ) {
        return access( this, jQuery.attr, name, value, arguments.length > 1 );
    },

    removeAttr: function( name ) {
        return this.each(function() {
            jQuery.removeAttr( this, name );
        });
    }
});

jQuery.extend({
    attr: function( elem, name, value ) {
        var hooks, ret,
            nType = elem.nodeType;

        // don't get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === strundefined ) {
            return jQuery.prop( elem, name, value );
        }

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] ||
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === null ) {
                jQuery.removeAttr( elem, name );

            } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem.setAttribute( name, value + "" );
                return value;
            }

        } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
            return ret;

        } else {
            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var name, propName,
            i = 0,
            attrNames = value && value.match( rnotwhite );

        if ( attrNames && elem.nodeType === 1 ) {
            while ( (name = attrNames[i++]) ) {
                propName = jQuery.propFix[ name ] || name;

                // Boolean attributes get special treatment (#10870)
                if ( jQuery.expr.match.bool.test( name ) ) {
                    // Set corresponding property to false
                    if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                        elem[ propName ] = false;
                    // Support: IE<9
                    // Also clear defaultChecked/defaultSelected (if appropriate)
                    } else {
                        elem[ jQuery.camelCase( "default-" + name ) ] =
                            elem[ propName ] = false;
                    }

                // See #9699 for explanation of this approach (setting first, then removal)
                } else {
                    jQuery.attr( elem, name, "" );
                }

                elem.removeAttribute( getSetAttribute ? name : propName );
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to default in case type is set after value during creation
                    var val = elem.value;
                    elem.setAttribute( "type", value );
                    if ( val ) {
                        elem.value = val;
                    }
                    return value;
                }
            }
        }
    }
});

// Hook for boolean attributes
boolHook = {
    set: function( elem, value, name ) {
        if ( value === false ) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
        } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
            // IE<8 needs the *property* name
            elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

        // Use defaultChecked and defaultSelected for oldIE
        } else {
            elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
        }

        return name;
    }
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

    var getter = attrHandle[ name ] || jQuery.find.attr;

    attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
        function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        } :
        function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem[ jQuery.camelCase( "default-" + name ) ] ?
                    name.toLowerCase() :
                    null;
            }
        };
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
    jQuery.attrHooks.value = {
        set: function( elem, value, name ) {
            if ( jQuery.nodeName( elem, "input" ) ) {
                // Does not return so that setAttribute is also used
                elem.defaultValue = value;
            } else {
                // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                return nodeHook && nodeHook.set( elem, value, name );
            }
        }
    };
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
        set: function( elem, value, name ) {
            // Set the existing or create a new attribute node
            var ret = elem.getAttributeNode( name );
            if ( !ret ) {
                elem.setAttributeNode(
                    (ret = elem.ownerDocument.createAttribute( name ))
                );
            }

            ret.value = value += "";

            // Break association with cloned elements by also using setAttribute (#9646)
            if ( name === "value" || value === elem.getAttribute( name ) ) {
                return value;
            }
        }
    };

    // Some attributes are constructed with empty-string values when not defined
    attrHandle.id = attrHandle.name = attrHandle.coords =
        function( elem, name, isXML ) {
            var ret;
            if ( !isXML ) {
                return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                    ret.value :
                    null;
            }
        };

    // Fixing value retrieval on a button requires this module
    jQuery.valHooks.button = {
        get: function( elem, name ) {
            var ret = elem.getAttributeNode( name );
            if ( ret && ret.specified ) {
                return ret.value;
            }
        },
        set: nodeHook.set
    };

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
        set: function( elem, value, name ) {
            nodeHook.set( elem, value === "" ? false : value, name );
        }
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each([ "width", "height" ], function( i, name ) {
        jQuery.attrHooks[ name ] = {
            set: function( elem, value ) {
                if ( value === "" ) {
                    elem.setAttribute( name, "auto" );
                    return value;
                }
            }
        };
    });
}

if ( !support.style ) {
    jQuery.attrHooks.style = {
        get: function( elem ) {
            // Return undefined in the case of empty string
            // Note: IE uppercases css property names, but if we were to .toLowerCase()
            // .cssText, that would destroy case senstitivity in URL's, like in "background"
            return elem.style.cssText || undefined;
        },
        set: function( elem, value ) {
            return ( elem.style.cssText = value + "" );
        }
    };
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
    rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
    prop: function( name, value ) {
        return access( this, jQuery.prop, name, value, arguments.length > 1 );
    },

    removeProp: function( name ) {
        name = jQuery.propFix[ name ] || name;
        return this.each(function() {
            // try/catch handles cases where IE balks (such as removing a property on window)
            try {
                this[ name ] = undefined;
                delete this[ name ];
            } catch( e ) {}
        });
    }
});

jQuery.extend({
    propFix: {
        "for": "htmlFor",
        "class": "className"
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don't get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
            return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                ret :
                ( elem[ name ] = value );

        } else {
            return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                ret :
                elem[ name ];
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                // Use proper attribute retrieval(#12072)
                var tabindex = jQuery.find.attr( elem, "tabindex" );

                return tabindex ?
                    parseInt( tabindex, 10 ) :
                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                        0 :
                        -1;
            }
        }
    }
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each([ "href", "src" ], function( i, name ) {
        jQuery.propHooks[ name ] = {
            get: function( elem ) {
                return elem.getAttribute( name, 4 );
            }
        };
    });
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
    jQuery.propHooks.selected = {
        get: function( elem ) {
            var parent = elem.parentNode;

            if ( parent ) {
                parent.selectedIndex;

                // Make sure that it also works with optgroups, see #5701
                if ( parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
            }
            return null;
        }
    };
}

jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
], function() {
    jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
    jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
    addClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).addClass( value.call( this, j, this.className ) );
            });
        }

        if ( proceed ) {
            // The disjunction here is for better compressibility (see removeClass)
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    " "
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                            cur += clazz + " ";
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = jQuery.trim( cur );
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = arguments.length === 0 || typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).removeClass( value.call( this, j, this.className ) );
            });
        }
        if ( proceed ) {
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    ""
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        // Remove *all* instances
                        while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                            cur = cur.replace( " " + clazz + " ", " " );
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = value ? jQuery.trim( cur ) : "";
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value;

        if ( typeof stateVal === "boolean" && type === "string" ) {
            return stateVal ? this.addClass( value ) : this.removeClass( value );
        }

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( i ) {
                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
            });
        }

        return this.each(function() {
            if ( type === "string" ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    classNames = value.match( rnotwhite ) || [];

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    if ( self.hasClass( className ) ) {
                        self.removeClass( className );
                    } else {
                        self.addClass( className );
                    }
                }

            // Toggle whole class name
            } else if ( type === strundefined || type === "boolean" ) {
                if ( this.className ) {
                    // store className if set
                    jQuery._data( this, "__className__", this.className );
                }

                // If the element has a class name or if we're passed "false",
                // then remove the whole classname (if there was one, the above saved it).
                // Otherwise bring back whatever was previously saved (if anything),
                // falling back to the empty string if nothing was stored.
                this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
            }
        });
    },

    hasClass: function( selector ) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for ( ; i < l; i++ ) {
            if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                return true;
            }
        }

        return false;
    }
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});

jQuery.fn.extend({
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
    }
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
        // Support: Android 2.3
        // Workaround failure to string-cast null input
        return window.JSON.parse( data + "" );
    }

    var requireNonComma,
        depth = null,
        str = jQuery.trim( data + "" );

    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
    // after removing valid tokens
    return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

        // Force termination if we see a misplaced comma
        if ( requireNonComma && comma ) {
            depth = 0;
        }

        // Perform no more replacements after returning to outermost depth
        if ( depth === 0 ) {
            return token;
        }

        // Commas must not follow "[", "{", or ","
        requireNonComma = open || comma;

        // Determine new depth
        // array/object open ("[" or "{"): depth += true - false (increment)
        // array/object close ("]" or "}"): depth += false - true (decrement)
        // other cases ("," or primitive): depth += true - true (numeric cast)
        depth += !close - !open;

        // Remove this token
        return "";
    }) ) ?
        ( Function( "return " + str ) )() :
        jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
    var xml, tmp;
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    try {
        if ( window.DOMParser ) { // Standard
            tmp = new DOMParser();
            xml = tmp.parseFromString( data, "text/xml" );
        } else { // IE
            xml = new ActiveXObject( "Microsoft.XMLDOM" );
            xml.async = "false";
            xml.loadXML( data );
        }
    } catch( e ) {
        xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
        jQuery.error( "Invalid XML: " + data );
    }
    return xml;
};


var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location.href;
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== "string" ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

        if ( jQuery.isFunction( func ) ) {
            // For each dataType in the dataTypeExpression
            while ( (dataType = dataTypes[i++]) ) {
                // Prepend if requested
                if ( dataType.charAt( 0 ) === "+" ) {
                    dataType = dataType.slice( 1 ) || "*";
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                // Otherwise append
                } else {
                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                }
            }
        }
    };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

    var inspected = {},
        seekingTransport = ( structure === transports );

    function inspect( dataType ) {
        var selected;
        inspected[ dataType ] = true;
        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                options.dataTypes.unshift( dataTypeOrTransport );
                inspect( dataTypeOrTransport );
                return false;
            } else if ( seekingTransport ) {
                return !( selected = dataTypeOrTransport );
            }
        });
        return selected;
    }

    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var deep, key,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery.extend( true, target, deep );
    }

    return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
    var firstDataType, ct, finalDataType, type,
        contents = s.contents,
        dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while ( dataTypes[ 0 ] === "*" ) {
        dataTypes.shift();
        if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
    }

    // Check if we're dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                dataTypes.unshift( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
    var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while ( current ) {

        if ( s.responseFields[ current ] ) {
            jqXHR[ s.responseFields[ current ] ] = response;
        }

        // Apply the dataFilter if provided
        if ( !prev && isSuccess && s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        prev = current;
        current = dataTypes.shift();

        if ( current ) {

            // There's only work to do if current dataType is non-auto
            if ( current === "*" ) {

                current = prev;

            // Convert response if prev dataType is non-auto and differs from current
            } else if ( prev !== "*" && prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2.split( " " );
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                converters[ "* " + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === true ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== true ) {
                                    current = tmp[ 0 ];
                                    dataTypes.unshift( tmp[ 1 ] );
                                }
                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== true ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv && s[ "throws" ] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                        }
                    }
                }
            }
        }
    }

    return { state: "success", data: response };
}

jQuery.extend({

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
        url: ajaxLocation,
        type: "GET",
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
        },

        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {

            // Convert anything to text
            "* text": String,

            // Text to html (true = no transformation)
            "text html": true,

            // Evaluate text as a json expression
            "text json": jQuery.parseJSON,

            // Parse text as xml
            "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
            url: true,
            context: true
        }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        return settings ?

            // Building a settings object
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
            ajaxExtend( jQuery.ajaxSettings, target );
    },

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === "object" ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var // Cross-domain detection vars
            parts,
            // Loop variable
            i,
            // URL without anti-cache param
            cacheURL,
            // Response headers as string
            responseHeadersString,
            // timeout handle
            timeoutTimer,

            // To know if global events are to be dispatched
            fireGlobals,

            transport,
            // Response headers
            responseHeaders,
            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while ( (match = rheaders.exec( responseHeadersString )) ) {
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key.toLowerCase() ];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function( name, value ) {
                    var lname = name.toLowerCase();
                    if ( !state ) {
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Overrides response content-type header
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks
                statusCode: function( map ) {
                    var code;
                    if ( map ) {
                        if ( state < 2 ) {
                            for ( code in map ) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            }
                        } else {
                            // Execute the appropriate callbacks
                            jqXHR.always( map[ jqXHR.status ] );
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    var finalText = statusText || strAbort;
                    if ( transport ) {
                        transport.abort( finalText );
                    }
                    done( 0, finalText );
                    return this;
                }
            };

        // Attach deferreds
        deferred.promise( jqXHR ).complete = completeDeferred.add;
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available
        s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

        // Alias method option to type as per ticket #12004
        s.type = options.method || options.type || s.method || s.type;

        // Extract dataTypes list
        s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s.crossDomain == null ) {
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
            );
        }

        // Convert data if not already a string
        if ( s.data && s.processData && typeof s.data !== "string" ) {
            s.data = jQuery.param( s.data, s.traditional );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s.global;

        // Watch for a new set of requests
        if ( fireGlobals && jQuery.active++ === 0 ) {
            jQuery.event.trigger("ajaxStart");
        }

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test( s.type );

        // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        cacheURL = s.url;

        // More options handling for requests with no content
        if ( !s.hasContent ) {

            // If data is available, append data to url
            if ( s.data ) {
                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                // #9682: remove data so that it's not used in an eventual retry
                delete s.data;
            }

            // Add anti-cache in url if needed
            if ( s.cache === false ) {
                s.url = rts.test( cacheURL ) ?

                    // If there is already a '_' parameter, set its value
                    cacheURL.replace( rts, "$1_=" + nonce++ ) :

                    // Otherwise add one to the end
                    cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
            }
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
            if ( jQuery.lastModified[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
            }
            if ( jQuery.etag[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
            }
        }

        // Set the correct header, if data is being sent
        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( "Content-Type", s.contentType );
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                s.accepts[ "*" ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
            // Abort if not done already and return
            return jqXHR.abort();
        }

        // aborting is no longer a cancellation
        strAbort = "abort";

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, "No Transport" );
        } else {
            jqXHR.readyState = 1;

            // Send global event
            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
            }
            // Timeout
            if ( s.async && s.timeout > 0 ) {
                timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch ( e ) {
                // Propagate exception as error if not done
                if ( state < 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        // Callback for when everything is done
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is "done" now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR.readyState = status > 0 ? 4 : 0;

            // Determine if successful
            isSuccess = status >= 200 && status < 300 || status === 304;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // Convert no matter what (that way responseXXX fields are always set)
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            // If successful, handle type chaining
            if ( isSuccess ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s.ifModified ) {
                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if ( modified ) {
                        jQuery.lastModified[ cacheURL ] = modified;
                    }
                    modified = jqXHR.getResponseHeader("etag");
                    if ( modified ) {
                        jQuery.etag[ cacheURL ] = modified;
                    }
                }

                // if no content
                if ( status === 204 || s.type === "HEAD" ) {
                    statusText = "nocontent";

                // if not modified
                } else if ( status === 304 ) {
                    statusText = "notmodified";

                // If we have data, let's convert it
                } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( status || !statusText ) {
                    statusText = "error";
                    if ( status < 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                    [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery.active ) ) {
                    jQuery.event.trigger("ajaxStop");
                }
            }
        }

        return jqXHR;
    },

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, "json" );
    },

    getScript: function( url, callback ) {
        return jQuery.get( url, undefined, callback, "script" );
    }
});

jQuery.each( [ "get", "post" ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        });
    };
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
    jQuery.fn[ type ] = function( fn ) {
        return this.on( type, fn );
    };
});


jQuery._evalUrl = function( url ) {
    return jQuery.ajax({
        url: url,
        type: "GET",
        dataType: "script",
        async: false,
        global: false,
        "throws": true
    });
};


jQuery.fn.extend({
    wrapAll: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapAll( html.call(this, i) );
            });
        }

        if ( this[0] ) {
            // The elements to wrap the target around
            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

            if ( this[0].parentNode ) {
                wrap.insertBefore( this[0] );
            }

            wrap.map(function() {
                var elem = this;

                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                    elem = elem.firstChild;
                }

                return elem;
            }).append( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapInner( html.call(this, i) );
            });
        }

        return this.each(function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents.length ) {
                contents.wrapAll( html );

            } else {
                self.append( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function(i) {
            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent().each(function() {
            if ( !jQuery.nodeName( this, "body" ) ) {
                jQuery( this ).replaceWith( this.childNodes );
            }
        }).end();
    }
});


jQuery.expr.filters.hidden = function( elem ) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
        (!support.reliableHiddenOffsets() &&
            ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // Item is non-scalar (array or object), encode its numeric index.
                buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
            }
        });

    } else if ( !traditional && jQuery.type( obj ) === "object" ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
            s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
            add( this.name, this.value );
        });

    } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
    serialize: function() {
        return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
        return this.map(function() {
            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop( this, "elements" );
            return elements ? jQuery.makeArray( elements ) : this;
        })
        .filter(function() {
            var type = this.type;
            // Use .is(":disabled") so that fieldset[disabled] works
            return this.name && !jQuery( this ).is( ":disabled" ) &&
                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                ( this.checked || !rcheckableType.test( type ) );
        })
        .map(function( i, elem ) {
            var val = jQuery( this ).val();

            return val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, function( val ) {
                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    }) :
                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        }).get();
    }
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
    // Support: IE6+
    function() {

        // XHR cannot access local files, always use ActiveX for that case
        return !this.isLocal &&

            // Support: IE7-8
            // oldIE XHR does not support non-RFC2616 methods (#13240)
            // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
            // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            // Although this check for six methods instead of eight
            // since IE also does not support "trace" and "connect"
            /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

            createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

var xhrId = 0,
    xhrCallbacks = {},
    xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
    jQuery( window ).on( "unload", function() {
        for ( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]( undefined, true );
        }
    });
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

    jQuery.ajaxTransport(function( options ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !options.crossDomain || support.cors ) {

            var callback;

            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId;

                    // Open the socket
                    xhr.open( options.type, options.url, options.async, options.username, options.password );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        // Support: IE<9
                        // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                        // request header to a null-value.
                        //
                        // To keep consistent with other XHR implementations, cast the value
                        // to string and ignore `undefined`.
                        if ( headers[ i ] !== undefined ) {
                            xhr.setRequestHeader( i, headers[ i ] + "" );
                        }
                    }

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send( ( options.hasContent && options.data ) || null );

                    // Listener
                    callback = function( _, isAbort ) {
                        var status, statusText, responses;

                        // Was never called and is aborted or complete
                        if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                            // Clean up
                            delete xhrCallbacks[ id ];
                            callback = undefined;
                            xhr.onreadystatechange = jQuery.noop;

                            // Abort manually if needed
                            if ( isAbort ) {
                                if ( xhr.readyState !== 4 ) {
                                    xhr.abort();
                                }
                            } else {
                                responses = {};
                                status = xhr.status;

                                // Support: IE<10
                                // Accessing binary-data responseText throws an exception
                                // (#11426)
                                if ( typeof xhr.responseText === "string" ) {
                                    responses.text = xhr.responseText;
                                }

                                // Firefox throws an exception when accessing
                                // statusText for faulty cross-domain requests
                                try {
                                    statusText = xhr.statusText;
                                } catch( e ) {
                                    // We normalize with Webkit giving an empty statusText
                                    statusText = "";
                                }

                                // Filter status for non standard behaviors

                                // If the request is local and we have data: assume a success
                                // (success with no data won't get notified, that's the best we
                                // can do given current implementations)
                                if ( !status && options.isLocal && !options.crossDomain ) {
                                    status = responses.text ? 200 : 404;
                                // IE - #1450: sometimes returns 1223 when it should be 204
                                } else if ( status === 1223 ) {
                                    status = 204;
                                }
                            }
                        }

                        // Call complete if needed
                        if ( responses ) {
                            complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                        }
                    };

                    if ( !options.async ) {
                        // if we're in sync mode we fire the callback
                        callback();
                    } else if ( xhr.readyState === 4 ) {
                        // (IE6 & IE7) if it's in cache and has been
                        // retrieved directly we need to fire the callback
                        setTimeout( callback );
                    } else {
                        // Add to the list of active xhr callbacks
                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback( undefined, true );
                    }
                }
            };
        }
    });
}

// Functions to create xhrs
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject( "Microsoft.XMLHTTP" );
    } catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
    accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
        script: /(?:java|ecma)script/
    },
    converters: {
        "text script": function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
    if ( s.cache === undefined ) {
        s.cache = false;
    }
    if ( s.crossDomain ) {
        s.type = "GET";
        s.global = false;
    }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

    // This transport only deals with cross domain requests
    if ( s.crossDomain ) {

        var script,
            head = document.head || jQuery("head")[0] || document.documentElement;

        return {

            send: function( _, callback ) {

                script = document.createElement("script");

                script.async = true;

                if ( s.scriptCharset ) {
                    script.charset = s.scriptCharset;
                }

                script.src = s.url;

                // Attach handlers for all browsers
                script.onload = script.onreadystatechange = function( _, isAbort ) {

                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                        // Handle memory leak in IE
                        script.onload = script.onreadystatechange = null;

                        // Remove the script
                        if ( script.parentNode ) {
                            script.parentNode.removeChild( script );
                        }

                        // Dereference the script
                        script = null;

                        // Callback if not abort
                        if ( !isAbort ) {
                            callback( 200, "success" );
                        }
                    }
                };

                // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                // Use native DOM manipulation to avoid our domManip AJAX trickery
                head.insertBefore( script, head.firstChild );
            },

            abort: function() {
                if ( script ) {
                    script.onload( undefined, true );
                }
            }
        };
    }
});




var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
            "url" :
            typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
        );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

        // Insert callback into url or form data
        if ( jsonProp ) {
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
        } else if ( s.jsonp !== false ) {
            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters["script json"] = function() {
            if ( !responseContainer ) {
                jQuery.error( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = "json";

        // Install callback
        overwritten = window[ callbackName ];
        window[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
            // Restore preexisting value
            window[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn't screw things around
                s.jsonpCallback = originalSettings.jsonpCallback;

                // save the callback name for future use
                oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return "script";
    }
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    if ( typeof context === "boolean" ) {
        keepScripts = context;
        context = false;
    }
    context = context || document;

    var parsed = rsingleTag.exec( data ),
        scripts = !keepScripts && [];

    // Single tag
    if ( parsed ) {
        return [ context.createElement( parsed[1] ) ];
    }

    parsed = jQuery.buildFragment( [ data ], context, scripts );

    if ( scripts && scripts.length ) {
        jQuery( scripts ).remove();
    }

    return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
        return _load.apply( this, arguments );
    }

    var selector, response, type,
        self = this,
        off = url.indexOf(" ");

    if ( off >= 0 ) {
        selector = url.slice( off, url.length );
        url = url.slice( 0, off );
    }

    // If it's a function
    if ( jQuery.isFunction( params ) ) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params && typeof params === "object" ) {
        type = "POST";
    }

    // If we have elements to modify, make the request
    if ( self.length > 0 ) {
        jQuery.ajax({
            url: url,

            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params
        }).done(function( responseText ) {

            // Save response for use in complete callback
            response = arguments;

            self.html( selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                // Otherwise use the full result
                responseText );

        }).complete( callback && function( jqXHR, status ) {
            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        });
    }

    return this;
};




jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
        return elem === fn.elem;
    }).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
    return jQuery.isWindow( elem ) ?
        elem :
        elem.nodeType === 9 ?
            elem.defaultView || elem.parentWindow :
            false;
}

jQuery.offset = {
    setOffset: function( elem, options, i ) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, "position" ),
            curElem = jQuery( elem ),
            props = {};

        // set position first, in-case top/left are set even on static elem
        if ( position === "static" ) {
            elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, "top" );
        curCSSLeft = jQuery.css( elem, "left" );
        calculatePosition = ( position === "absolute" || position === "fixed" ) &&
            jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
            options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( "using" in options ) {
            options.using.call( elem, props );
        } else {
            curElem.css( props );
        }
    }
};

jQuery.fn.extend({
    offset: function( options ) {
        if ( arguments.length ) {
            return options === undefined ?
                this :
                this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
        }

        var docElem, win,
            box = { top: 0, left: 0 },
            elem = this[ 0 ],
            doc = elem && elem.ownerDocument;

        if ( !doc ) {
            return;
        }

        docElem = doc.documentElement;

        // Make sure it's not a disconnected DOM node
        if ( !jQuery.contains( docElem, elem ) ) {
            return box;
        }

        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if ( typeof elem.getBoundingClientRect !== strundefined ) {
            box = elem.getBoundingClientRect();
        }
        win = getWindow( doc );
        return {
            top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
            left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
        };
    },

    position: function() {
        if ( !this[ 0 ] ) {
            return;
        }

        var offsetParent, offset,
            parentOffset = { top: 0, left: 0 },
            elem = this[ 0 ];

        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
        if ( jQuery.css( elem, "position" ) === "fixed" ) {
            // we assume that getBoundingClientRect is available when computed position is fixed
            offset = elem.getBoundingClientRect();
        } else {
            // Get *real* offsetParent
            offsetParent = this.offsetParent();

            // Get correct offsets
            offset = this.offset();
            if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                parentOffset = offsetParent.offset();
            }

            // Add offsetParent borders
            parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
            parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
        }

        // Subtract parent offsets and element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        return {
            top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
        };
    },

    offsetParent: function() {
        return this.map(function() {
            var offsetParent = this.offsetParent || docElem;

            while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElem;
        });
    }
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    var top = /Y/.test( prop );

    jQuery.fn[ method ] = function( val ) {
        return access( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? (prop in win) ? win[ prop ] :
                    win.document.documentElement[ method ] :
                    elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : jQuery( win ).scrollLeft(),
                    top ? val : jQuery( win ).scrollTop()
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments.length, null );
    };
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
        function( elem, computed ) {
            if ( computed ) {
                computed = curCSS( elem, prop );
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test( computed ) ?
                    jQuery( elem ).position()[ prop ] + "px" :
                    computed;
            }
        }
    );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

            return access( this, function( elem, type, value ) {
                var doc;

                if ( jQuery.isWindow( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem.document.documentElement[ "client" + name ];
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    doc = elem.documentElement;

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                    return Math.max(
                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                        doc[ "client" + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css( elem, type, extra ) :

                    // Set width or height on the element
                    jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, null );
        };
    });
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
    return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
    define( "jquery", [], function() {
        return jQuery;
    });
}




var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,

    // Map over the $ in case of overwrite
    _$ = window.$;

jQuery.noConflict = function( deep ) {
    if ( window.$ === jQuery ) {
        window.$ = _$;
    }

    if ( deep && window.jQuery === jQuery ) {
        window.jQuery = _jQuery;
    }

    return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
    window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

/*! jQuery UI - v1.10.4 - 2014-01-17
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */
(function( $, undefined ) {

var uuid = 0,
    runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
    version: "1.10.4",

    keyCode: {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
    }
});

// plugins
$.fn.extend({
    focus: (function( orig ) {
        return function( delay, fn ) {
            return typeof delay === "number" ?
                this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $( elem ).focus();
                        if ( fn ) {
                            fn.call( elem );
                        }
                    }, delay );
                }) :
                orig.apply( this, arguments );
        };
    })( $.fn.focus ),

    scrollParent: function() {
        var scrollParent;
        if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
            scrollParent = this.parents().filter(function() {
                return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
            }).eq(0);
        } else {
            scrollParent = this.parents().filter(function() {
                return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
            }).eq(0);
        }

        return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
    },

    zIndex: function( zIndex ) {
        if ( zIndex !== undefined ) {
            return this.css( "zIndex", zIndex );
        }

        if ( this.length ) {
            var elem = $( this[ 0 ] ), position, value;
            while ( elem.length && elem[ 0 ] !== document ) {
                // Ignore z-index if position is set to a value where z-index is ignored by the browser
                // This makes behavior of this function consistent across browsers
                // WebKit always returns auto if the element is positioned
                position = elem.css( "position" );
                if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                    // IE returns 0 when zIndex is not specified
                    // other browsers return a string
                    // we ignore the case of nested elements with an explicit value of 0
                    // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                    value = parseInt( elem.css( "zIndex" ), 10 );
                    if ( !isNaN( value ) && value !== 0 ) {
                        return value;
                    }
                }
                elem = elem.parent();
            }
        }

        return 0;
    },

    uniqueId: function() {
        return this.each(function() {
            if ( !this.id ) {
                this.id = "ui-id-" + (++uuid);
            }
        });
    },

    removeUniqueId: function() {
        return this.each(function() {
            if ( runiqueId.test( this.id ) ) {
                $( this ).removeAttr( "id" );
            }
        });
    }
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
    var map, mapName, img,
        nodeName = element.nodeName.toLowerCase();
    if ( "area" === nodeName ) {
        map = element.parentNode;
        mapName = map.name;
        if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
            return false;
        }
        img = $( "img[usemap=#" + mapName + "]" )[0];
        return !!img && visible( img );
    }
    return ( /input|select|textarea|button|object/.test( nodeName ) ?
        !element.disabled :
        "a" === nodeName ?
            element.href || isTabIndexNotNaN :
            isTabIndexNotNaN) &&
        // the element and all of its ancestors must be visible
        visible( element );
}

function visible( element ) {
    return $.expr.filters.visible( element ) &&
        !$( element ).parents().addBack().filter(function() {
            return $.css( this, "visibility" ) === "hidden";
        }).length;
}

$.extend( $.expr[ ":" ], {
    data: $.expr.createPseudo ?
        $.expr.createPseudo(function( dataName ) {
            return function( elem ) {
                return !!$.data( elem, dataName );
            };
        }) :
        // support: jQuery <1.8
        function( elem, i, match ) {
            return !!$.data( elem, match[ 3 ] );
        },

    focusable: function( element ) {
        return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
    },

    tabbable: function( element ) {
        var tabIndex = $.attr( element, "tabindex" ),
            isTabIndexNaN = isNaN( tabIndex );
        return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
    }
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
    $.each( [ "Width", "Height" ], function( i, name ) {
        var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
            type = name.toLowerCase(),
            orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };

        function reduce( elem, size, border, margin ) {
            $.each( side, function() {
                size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
                if ( border ) {
                    size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
                }
                if ( margin ) {
                    size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
                }
            });
            return size;
        }

        $.fn[ "inner" + name ] = function( size ) {
            if ( size === undefined ) {
                return orig[ "inner" + name ].call( this );
            }

            return this.each(function() {
                $( this ).css( type, reduce( this, size ) + "px" );
            });
        };

        $.fn[ "outer" + name] = function( size, margin ) {
            if ( typeof size !== "number" ) {
                return orig[ "outer" + name ].call( this, size );
            }

            return this.each(function() {
                $( this).css( type, reduce( this, size, true, margin ) + "px" );
            });
        };
    });
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
    $.fn.addBack = function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter( selector )
        );
    };
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
    $.fn.removeData = (function( removeData ) {
        return function( key ) {
            if ( arguments.length ) {
                return removeData.call( this, $.camelCase( key ) );
            } else {
                return removeData.call( this );
            }
        };
    })( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
    disableSelection: function() {
        return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
            ".ui-disableSelection", function( event ) {
                event.preventDefault();
            });
    },

    enableSelection: function() {
        return this.unbind( ".ui-disableSelection" );
    }
});

$.extend( $.ui, {
    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    plugin: {
        add: function( module, option, set ) {
            var i,
                proto = $.ui[ module ].prototype;
            for ( i in set ) {
                proto.plugins[ i ] = proto.plugins[ i ] || [];
                proto.plugins[ i ].push( [ option, set[ i ] ] );
            }
        },
        call: function( instance, name, args ) {
            var i,
                set = instance.plugins[ name ];
            if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
                return;
            }

            for ( i = 0; i < set.length; i++ ) {
                if ( instance.options[ set[ i ][ 0 ] ] ) {
                    set[ i ][ 1 ].apply( instance.element, args );
                }
            }
        }
    },

    // only used by resizable
    hasScroll: function( el, a ) {

        //If overflow is hidden, the element might have extra content, but the user wants to hide it
        if ( $( el ).css( "overflow" ) === "hidden") {
            return false;
        }

        var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
            has = false;

        if ( el[ scroll ] > 0 ) {
            return true;
        }

        // TODO: determine which cases actually cause this to happen
        // if the element doesn't have the scroll set, see if it's possible to
        // set the scroll
        el[ scroll ] = 1;
        has = ( el[ scroll ] > 0 );
        el[ scroll ] = 0;
        return has;
    }
});

})( jQuery );

(function( $, undefined ) {

var uuid = 0,
    slice = Array.prototype.slice,
    _cleanData = $.cleanData;
$.cleanData = function( elems ) {
    for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
        try {
            $( elem ).triggerHandler( "remove" );
        // http://bugs.jquery.com/ticket/8235
        } catch( e ) {}
    }
    _cleanData( elems );
};

$.widget = function( name, base, prototype ) {
    var fullName, existingConstructor, constructor, basePrototype,
        // proxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        proxiedPrototype = {},
        namespace = name.split( "." )[ 0 ];

    name = name.split( "." )[ 1 ];
    fullName = namespace + "-" + name;

    if ( !prototype ) {
        prototype = base;
        base = $.Widget;
    }

    // create selector for plugin
    $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
        return !!$.data( elem, fullName );
    };

    $[ namespace ] = $[ namespace ] || {};
    existingConstructor = $[ namespace ][ name ];
    constructor = $[ namespace ][ name ] = function( options, element ) {
        // allow instantiation without "new" keyword
        if ( !this._createWidget ) {
            return new constructor( options, element );
        }

        // allow instantiation without initializing for simple inheritance
        // must use "new" keyword (the code above always passes args)
        if ( arguments.length ) {
            this._createWidget( options, element );
        }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend( constructor, existingConstructor, {
        version: prototype.version,
        // copy the object used to create the prototype in case we need to
        // redefine the widget later
        _proto: $.extend( {}, prototype ),
        // track widgets that inherit from this widget in case this widget is
        // redefined after a widget inherits from it
        _childConstructors: []
    });

    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend( {}, basePrototype.options );
    $.each( prototype, function( prop, value ) {
        if ( !$.isFunction( value ) ) {
            proxiedPrototype[ prop ] = value;
            return;
        }
        proxiedPrototype[ prop ] = (function() {
            var _super = function() {
                    return base.prototype[ prop ].apply( this, arguments );
                },
                _superApply = function( args ) {
                    return base.prototype[ prop ].apply( this, args );
                };
            return function() {
                var __super = this._super,
                    __superApply = this._superApply,
                    returnValue;

                this._super = _super;
                this._superApply = _superApply;

                returnValue = value.apply( this, arguments );

                this._super = __super;
                this._superApply = __superApply;

                return returnValue;
            };
        })();
    });
    constructor.prototype = $.widget.extend( basePrototype, {
        // TODO: remove support for widgetEventPrefix
        // always use the name + a colon as the prefix, e.g., draggable:start
        // don't prefix for widgets that aren't DOM-based
        widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
    }, proxiedPrototype, {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if ( existingConstructor ) {
        $.each( existingConstructor._childConstructors, function( i, child ) {
            var childPrototype = child.prototype;

            // redefine the child widget using the same prototype that was
            // originally used, but inherit from the new version of the base
            $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
        });
        // remove the list of existing child constructors from the old constructor
        // so the old child constructors can be garbage collected
        delete existingConstructor._childConstructors;
    } else {
        base._childConstructors.push( constructor );
    }

    $.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
    var input = slice.call( arguments, 1 ),
        inputIndex = 0,
        inputLength = input.length,
        key,
        value;
    for ( ; inputIndex < inputLength; inputIndex++ ) {
        for ( key in input[ inputIndex ] ) {
            value = input[ inputIndex ][ key ];
            if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
                // Clone objects
                if ( $.isPlainObject( value ) ) {
                    target[ key ] = $.isPlainObject( target[ key ] ) ?
                        $.widget.extend( {}, target[ key ], value ) :
                        // Don't extend strings, arrays, etc. with objects
                        $.widget.extend( {}, value );
                // Copy everything else by reference
                } else {
                    target[ key ] = value;
                }
            }
        }
    }
    return target;
};

$.widget.bridge = function( name, object ) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[ name ] = function( options ) {
        var isMethodCall = typeof options === "string",
            args = slice.call( arguments, 1 ),
            returnValue = this;

        // allow multiple hashes to be passed on init
        options = !isMethodCall && args.length ?
            $.widget.extend.apply( null, [ options ].concat(args) ) :
            options;

        if ( isMethodCall ) {
            this.each(function() {
                var methodValue,
                    instance = $.data( this, fullName );
                if ( !instance ) {
                    return $.error( "cannot call methods on " + name + " prior to initialization; " +
                        "attempted to call method '" + options + "'" );
                }
                if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
                    return $.error( "no such method '" + options + "' for " + name + " widget instance" );
                }
                methodValue = instance[ options ].apply( instance, args );
                if ( methodValue !== instance && methodValue !== undefined ) {
                    returnValue = methodValue && methodValue.jquery ?
                        returnValue.pushStack( methodValue.get() ) :
                        methodValue;
                    return false;
                }
            });
        } else {
            this.each(function() {
                var instance = $.data( this, fullName );
                if ( instance ) {
                    instance.option( options || {} )._init();
                } else {
                    $.data( this, fullName, new object( options, this ) );
                }
            });
        }

        return returnValue;
    };
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
        disabled: false,

        // callbacks
        create: null
    },
    _createWidget: function( options, element ) {
        element = $( element || this.defaultElement || this )[ 0 ];
        this.element = $( element );
        this.uuid = uuid++;
        this.eventNamespace = "." + this.widgetName + this.uuid;
        this.options = $.widget.extend( {},
            this.options,
            this._getCreateOptions(),
            options );

        this.bindings = $();
        this.hoverable = $();
        this.focusable = $();

        if ( element !== this ) {
            $.data( element, this.widgetFullName, this );
            this._on( true, this.element, {
                remove: function( event ) {
                    if ( event.target === element ) {
                        this.destroy();
                    }
                }
            });
            this.document = $( element.style ?
                // element within the document
                element.ownerDocument :
                // element is window or document
                element.document || element );
            this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
        }

        this._create();
        this._trigger( "create", null, this._getCreateEventData() );
        this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,

    destroy: function() {
        this._destroy();
        // we can probably remove the unbind calls in 2.0
        // all event bindings should go through this._on()
        this.element
            .unbind( this.eventNamespace )
            // 1.9 BC for #7810
            // TODO remove dual storage
            .removeData( this.widgetName )
            .removeData( this.widgetFullName )
            // support: jquery <1.6.3
            // http://bugs.jquery.com/ticket/9413
            .removeData( $.camelCase( this.widgetFullName ) );
        this.widget()
            .unbind( this.eventNamespace )
            .removeAttr( "aria-disabled" )
            .removeClass(
                this.widgetFullName + "-disabled " +
                "ui-state-disabled" );

        // clean up events and states
        this.bindings.unbind( this.eventNamespace );
        this.hoverable.removeClass( "ui-state-hover" );
        this.focusable.removeClass( "ui-state-focus" );
    },
    _destroy: $.noop,

    widget: function() {
        return this.element;
    },

    option: function( key, value ) {
        var options = key,
            parts,
            curOption,
            i;

        if ( arguments.length === 0 ) {
            // don't return a reference to the internal hash
            return $.widget.extend( {}, this.options );
        }

        if ( typeof key === "string" ) {
            // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
            options = {};
            parts = key.split( "." );
            key = parts.shift();
            if ( parts.length ) {
                curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
                for ( i = 0; i < parts.length - 1; i++ ) {
                    curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
                    curOption = curOption[ parts[ i ] ];
                }
                key = parts.pop();
                if ( arguments.length === 1 ) {
                    return curOption[ key ] === undefined ? null : curOption[ key ];
                }
                curOption[ key ] = value;
            } else {
                if ( arguments.length === 1 ) {
                    return this.options[ key ] === undefined ? null : this.options[ key ];
                }
                options[ key ] = value;
            }
        }

        this._setOptions( options );

        return this;
    },
    _setOptions: function( options ) {
        var key;

        for ( key in options ) {
            this._setOption( key, options[ key ] );
        }

        return this;
    },
    _setOption: function( key, value ) {
        this.options[ key ] = value;

        if ( key === "disabled" ) {
            this.widget()
                .toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
                .attr( "aria-disabled", value );
            this.hoverable.removeClass( "ui-state-hover" );
            this.focusable.removeClass( "ui-state-focus" );
        }

        return this;
    },

    enable: function() {
        return this._setOption( "disabled", false );
    },
    disable: function() {
        return this._setOption( "disabled", true );
    },

    _on: function( suppressDisabledCheck, element, handlers ) {
        var delegateElement,
            instance = this;

        // no suppressDisabledCheck flag, shuffle arguments
        if ( typeof suppressDisabledCheck !== "boolean" ) {
            handlers = element;
            element = suppressDisabledCheck;
            suppressDisabledCheck = false;
        }

        // no element argument, shuffle and use this.element
        if ( !handlers ) {
            handlers = element;
            element = this.element;
            delegateElement = this.widget();
        } else {
            // accept selectors, DOM elements
            element = delegateElement = $( element );
            this.bindings = this.bindings.add( element );
        }

        $.each( handlers, function( event, handler ) {
            function handlerProxy() {
                // allow widgets to customize the disabled handling
                // - disabled as an array instead of boolean
                // - disabled class as method for disabling individual parts
                if ( !suppressDisabledCheck &&
                        ( instance.options.disabled === true ||
                            $( this ).hasClass( "ui-state-disabled" ) ) ) {
                    return;
                }
                return ( typeof handler === "string" ? instance[ handler ] : handler )
                    .apply( instance, arguments );
            }

            // copy the guid so direct unbinding works
            if ( typeof handler !== "string" ) {
                handlerProxy.guid = handler.guid =
                    handler.guid || handlerProxy.guid || $.guid++;
            }

            var match = event.match( /^(\w+)\s*(.*)$/ ),
                eventName = match[1] + instance.eventNamespace,
                selector = match[2];
            if ( selector ) {
                delegateElement.delegate( selector, eventName, handlerProxy );
            } else {
                element.bind( eventName, handlerProxy );
            }
        });
    },

    _off: function( element, eventName ) {
        eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
        element.unbind( eventName ).undelegate( eventName );
    },

    _delay: function( handler, delay ) {
        function handlerProxy() {
            return ( typeof handler === "string" ? instance[ handler ] : handler )
                .apply( instance, arguments );
        }
        var instance = this;
        return setTimeout( handlerProxy, delay || 0 );
    },

    _hoverable: function( element ) {
        this.hoverable = this.hoverable.add( element );
        this._on( element, {
            mouseenter: function( event ) {
                $( event.currentTarget ).addClass( "ui-state-hover" );
            },
            mouseleave: function( event ) {
                $( event.currentTarget ).removeClass( "ui-state-hover" );
            }
        });
    },

    _focusable: function( element ) {
        this.focusable = this.focusable.add( element );
        this._on( element, {
            focusin: function( event ) {
                $( event.currentTarget ).addClass( "ui-state-focus" );
            },
            focusout: function( event ) {
                $( event.currentTarget ).removeClass( "ui-state-focus" );
            }
        });
    },

    _trigger: function( type, event, data ) {
        var prop, orig,
            callback = this.options[ type ];

        data = data || {};
        event = $.Event( event );
        event.type = ( type === this.widgetEventPrefix ?
            type :
            this.widgetEventPrefix + type ).toLowerCase();
        // the original event may come from any element
        // so we need to reset the target on the new event
        event.target = this.element[ 0 ];

        // copy original event properties over to the new event
        orig = event.originalEvent;
        if ( orig ) {
            for ( prop in orig ) {
                if ( !( prop in event ) ) {
                    event[ prop ] = orig[ prop ];
                }
            }
        }

        this.element.trigger( event, data );
        return !( $.isFunction( callback ) &&
            callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
            event.isDefaultPrevented() );
    }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
    $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
        if ( typeof options === "string" ) {
            options = { effect: options };
        }
        var hasOptions,
            effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                    defaultEffect :
                    options.effect || defaultEffect;
        options = options || {};
        if ( typeof options === "number" ) {
            options = { duration: options };
        }
        hasOptions = !$.isEmptyObject( options );
        options.complete = callback;
        if ( options.delay ) {
            element.delay( options.delay );
        }
        if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
            element[ method ]( options );
        } else if ( effectName !== method && element[ effectName ] ) {
            element[ effectName ]( options.duration, options.easing, callback );
        } else {
            element.queue(function( next ) {
                $( this )[ method ]();
                if ( callback ) {
                    callback.call( element[ 0 ] );
                }
                next();
            });
        }
    };
});

})( jQuery );

(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
    mouseHandled = false;
});

$.widget("ui.mouse", {
    version: "1.10.4",
    options: {
        cancel: "input,textarea,button,select,option",
        distance: 1,
        delay: 0
    },
    _mouseInit: function() {
        var that = this;

        this.element
            .bind("mousedown."+this.widgetName, function(event) {
                return that._mouseDown(event);
            })
            .bind("click."+this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, that.widgetName + ".preventClickEvent");
                    event.stopImmediatePropagation();
                    return false;
                }
            });

        this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function() {
        this.element.unbind("."+this.widgetName);
        if ( this._mouseMoveDelegate ) {
            $(document)
                .unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
                .unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
        }
    },

    _mouseDown: function(event) {
        // don't let more than one widget handle mouseStart
        if( mouseHandled ) { return; }

        // we may have missed mouseup (out of window)
        (this._mouseStarted && this._mouseUp(event));

        this._mouseDownEvent = event;

        var that = this,
            btnIsLeft = (event.which === 1),
            // event.target.nodeName works around a bug in IE 8 with
            // disabled inputs (#7620)
            elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
            return true;
        }

        this.mouseDelayMet = !this.options.delay;
        if (!this.mouseDelayMet) {
            this._mouseDelayTimer = setTimeout(function() {
                that.mouseDelayMet = true;
            }, this.options.delay);
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted = (this._mouseStart(event) !== false);
            if (!this._mouseStarted) {
                event.preventDefault();
                return true;
            }
        }

        // Click event may never have fired (Gecko & Opera)
        if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, this.widgetName + ".preventClickEvent");
        }

        // these delegates are required to keep context
        this._mouseMoveDelegate = function(event) {
            return that._mouseMove(event);
        };
        this._mouseUpDelegate = function(event) {
            return that._mouseUp(event);
        };
        $(document)
            .bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
            .bind("mouseup."+this.widgetName, this._mouseUpDelegate);

        event.preventDefault();

        mouseHandled = true;
        return true;
    },

    _mouseMove: function(event) {
        // IE mouseup check - mouseup happened when mouse was out of window
        if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
            return this._mouseUp(event);
        }

        if (this._mouseStarted) {
            this._mouseDrag(event);
            return event.preventDefault();
        }

        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
            this._mouseStarted =
                (this._mouseStart(this._mouseDownEvent, event) !== false);
            (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
        }

        return !this._mouseStarted;
    },

    _mouseUp: function(event) {
        $(document)
            .unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
            .unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

        if (this._mouseStarted) {
            this._mouseStarted = false;

            if (event.target === this._mouseDownEvent.target) {
                $.data(event.target, this.widgetName + ".preventClickEvent", true);
            }

            this._mouseStop(event);
        }

        return false;
    },

    _mouseDistanceMet: function(event) {
        return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance
        );
    },

    _mouseDelayMet: function(/* event */) {
        return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    _mouseStart: function(/* event */) {},
    _mouseDrag: function(/* event */) {},
    _mouseStop: function(/* event */) {},
    _mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
    version: "1.10.4",
    widgetEventPrefix: "drag",
    options: {
        addClasses: true,
        appendTo: "parent",
        axis: false,
        connectToSortable: false,
        containment: false,
        cursor: "auto",
        cursorAt: false,
        grid: false,
        handle: false,
        helper: "original",
        iframeFix: false,
        opacity: false,
        refreshPositions: false,
        revert: false,
        revertDuration: 500,
        scope: "default",
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        snap: false,
        snapMode: "both",
        snapTolerance: 20,
        stack: false,
        zIndex: false,

        // callbacks
        drag: null,
        start: null,
        stop: null
    },
    _create: function() {

        if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
            this.element[0].style.position = "relative";
        }
        if (this.options.addClasses){
            this.element.addClass("ui-draggable");
        }
        if (this.options.disabled){
            this.element.addClass("ui-draggable-disabled");
        }

        this._mouseInit();

    },

    _destroy: function() {
        this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
        this._mouseDestroy();
    },

    _mouseCapture: function(event) {

        var o = this.options;

        // among others, prevent a drag on a resizable-handle
        if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
            return false;
        }

        //Quit if we're not on a valid handle
        this.handle = this._getHandle(event);
        if (!this.handle) {
            return false;
        }

        $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
            $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
            .css({
                width: this.offsetWidth+"px", height: this.offsetHeight+"px",
                position: "absolute", opacity: "0.001", zIndex: 1000
            })
            .css($(this).offset())
            .appendTo("body");
        });

        return true;

    },

    _mouseStart: function(event) {

        var o = this.options;

        //Create and append the visible helper
        this.helper = this._createHelper(event);

        this.helper.addClass("ui-draggable-dragging");

        //Cache the helper size
        this._cacheHelperProportions();

        //If ddmanager is used for droppables, set the global draggable
        if($.ui.ddmanager) {
            $.ui.ddmanager.current = this;
        }

        /*
         * - Position generation -
         * This block generates everything position related - it's the core of draggables.
         */

        //Cache the margins of the original element
        this._cacheMargins();

        //Store the helper's css position
        this.cssPosition = this.helper.css( "position" );
        this.scrollParent = this.helper.scrollParent();
        this.offsetParent = this.helper.offsetParent();
        this.offsetParentCssPosition = this.offsetParent.css( "position" );

        //The element's absolute position on the page minus margins
        this.offset = this.positionAbs = this.element.offset();
        this.offset = {
            top: this.offset.top - this.margins.top,
            left: this.offset.left - this.margins.left
        };

        //Reset scroll cache
        this.offset.scroll = false;

        $.extend(this.offset, {
            click: { //Where the click happened, relative to the element
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            },
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
        });

        //Generate the original position
        this.originalPosition = this.position = this._generatePosition(event);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY;

        //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

        //Set a containment if given in the options
        this._setContainment();

        //Trigger event + callbacks
        if(this._trigger("start", event) === false) {
            this._clear();
            return false;
        }

        //Recache the helper size
        this._cacheHelperProportions();

        //Prepare the droppable offsets
        if ($.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
        }


        this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

        //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
        if ( $.ui.ddmanager ) {
            $.ui.ddmanager.dragStart(this, event);
        }

        return true;
    },

    _mouseDrag: function(event, noPropagation) {
        // reset any necessary cached properties (see #5009)
        if ( this.offsetParentCssPosition === "fixed" ) {
            this.offset.parent = this._getParentOffset();
        }

        //Compute the helpers position
        this.position = this._generatePosition(event);
        this.positionAbs = this._convertPositionTo("absolute");

        //Call plugins and callbacks and use the resulting position if something is returned
        if (!noPropagation) {
            var ui = this._uiHash();
            if(this._trigger("drag", event, ui) === false) {
                this._mouseUp({});
                return false;
            }
            this.position = ui.position;
        }

        if(!this.options.axis || this.options.axis !== "y") {
            this.helper[0].style.left = this.position.left+"px";
        }
        if(!this.options.axis || this.options.axis !== "x") {
            this.helper[0].style.top = this.position.top+"px";
        }
        if($.ui.ddmanager) {
            $.ui.ddmanager.drag(this, event);
        }

        return false;
    },

    _mouseStop: function(event) {

        //If we are using droppables, inform the manager about the drop
        var that = this,
            dropped = false;
        if ($.ui.ddmanager && !this.options.dropBehaviour) {
            dropped = $.ui.ddmanager.drop(this, event);
        }

        //if a drop comes from outside (a sortable)
        if(this.dropped) {
            dropped = this.dropped;
            this.dropped = false;
        }

        //if the original element is no longer in the DOM don't bother to continue (see #8269)
        if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
            return false;
        }

        if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
            $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                if(that._trigger("stop", event) !== false) {
                    that._clear();
                }
            });
        } else {
            if(this._trigger("stop", event) !== false) {
                this._clear();
            }
        }

        return false;
    },

    _mouseUp: function(event) {
        //Remove frame helpers
        $("div.ui-draggable-iframeFix").each(function() {
            this.parentNode.removeChild(this);
        });

        //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
        if( $.ui.ddmanager ) {
            $.ui.ddmanager.dragStop(this, event);
        }

        return $.ui.mouse.prototype._mouseUp.call(this, event);
    },

    cancel: function() {

        if(this.helper.is(".ui-draggable-dragging")) {
            this._mouseUp({});
        } else {
            this._clear();
        }

        return this;

    },

    _getHandle: function(event) {
        return this.options.handle ?
            !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
            true;
    },

    _createHelper: function(event) {

        var o = this.options,
            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

        if(!helper.parents("body").length) {
            helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
        }

        if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
            helper.css("position", "absolute");
        }

        return helper;

    },

    _adjustOffsetFromHelper: function(obj) {
        if (typeof obj === "string") {
            obj = obj.split(" ");
        }
        if ($.isArray(obj)) {
            obj = {left: +obj[0], top: +obj[1] || 0};
        }
        if ("left" in obj) {
            this.offset.click.left = obj.left + this.margins.left;
        }
        if ("right" in obj) {
            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }
        if ("top" in obj) {
            this.offset.click.top = obj.top + this.margins.top;
        }
        if ("bottom" in obj) {
            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
    },

    _getParentOffset: function() {

        //Get the offsetParent and cache its position
        var po = this.offsetParent.offset();

        // This is a special case where we need to modify a offset calculated on start, since the following happened:
        // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
        //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
        if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
            po.left += this.scrollParent.scrollLeft();
            po.top += this.scrollParent.scrollTop();
        }

        //This needs to be actually done for all browsers, since pageX/pageY includes this information
        //Ugly IE fix
        if((this.offsetParent[0] === document.body) ||
            (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
            po = { top: 0, left: 0 };
        }

        return {
            top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
            left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
        };

    },

    _getRelativeOffset: function() {

        if(this.cssPosition === "relative") {
            var p = this.element.position();
            return {
                top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
            };
        } else {
            return { top: 0, left: 0 };
        }

    },

    _cacheMargins: function() {
        this.margins = {
            left: (parseInt(this.element.css("marginLeft"),10) || 0),
            top: (parseInt(this.element.css("marginTop"),10) || 0),
            right: (parseInt(this.element.css("marginRight"),10) || 0),
            bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
        };
    },

    _cacheHelperProportions: function() {
        this.helperProportions = {
            width: this.helper.outerWidth(),
            height: this.helper.outerHeight()
        };
    },

    _setContainment: function() {

        var over, c, ce,
            o = this.options;

        if ( !o.containment ) {
            this.containment = null;
            return;
        }

        if ( o.containment === "window" ) {
            this.containment = [
                $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
                $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
            ];
            return;
        }

        if ( o.containment === "document") {
            this.containment = [
                0,
                0,
                $( document ).width() - this.helperProportions.width - this.margins.left,
                ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
            ];
            return;
        }

        if ( o.containment.constructor === Array ) {
            this.containment = o.containment;
            return;
        }

        if ( o.containment === "parent" ) {
            o.containment = this.helper[ 0 ].parentNode;
        }

        c = $( o.containment );
        ce = c[ 0 ];

        if( !ce ) {
            return;
        }

        over = c.css( "overflow" ) !== "hidden";

        this.containment = [
            ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
            ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
            ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
            ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
        ];
        this.relative_container = c;
    },

    _convertPositionTo: function(d, pos) {

        if(!pos) {
            pos = this.position;
        }

        var mod = d === "absolute" ? 1 : -1,
            scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

        //Cache the scroll
        if (!this.offset.scroll) {
            this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
        }

        return {
            top: (
                pos.top +                                                               // The absolute mouse position
                this.offset.relative.top * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top * mod -                                      // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
            ),
            left: (
                pos.left +                                                              // The absolute mouse position
                this.offset.relative.left * mod +                                       // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left * mod   -                                       // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
            )
        };

    },

    _generatePosition: function(event) {

        var containment, co, top, left,
            o = this.options,
            scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
            pageX = event.pageX,
            pageY = event.pageY;

        //Cache the scroll
        if (!this.offset.scroll) {
            this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
        }

        /*
         * - Position constraining -
         * Constrain the position to a mix of grid, containment.
         */

        // If we are not dragging yet, we won't check for options
        if ( this.originalPosition ) {
            if ( this.containment ) {
                if ( this.relative_container ){
                    co = this.relative_container.offset();
                    containment = [
                        this.containment[ 0 ] + co.left,
                        this.containment[ 1 ] + co.top,
                        this.containment[ 2 ] + co.left,
                        this.containment[ 3 ] + co.top
                    ];
                }
                else {
                    containment = this.containment;
                }

                if(event.pageX - this.offset.click.left < containment[0]) {
                    pageX = containment[0] + this.offset.click.left;
                }
                if(event.pageY - this.offset.click.top < containment[1]) {
                    pageY = containment[1] + this.offset.click.top;
                }
                if(event.pageX - this.offset.click.left > containment[2]) {
                    pageX = containment[2] + this.offset.click.left;
                }
                if(event.pageY - this.offset.click.top > containment[3]) {
                    pageY = containment[3] + this.offset.click.top;
                }
            }

            if(o.grid) {
                //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
            }

        }

        return {
            top: (
                pageY -                                                                 // The absolute mouse position
                this.offset.click.top   -                                               // Click offset (relative to the element)
                this.offset.relative.top -                                              // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top +                                                // The offsetParent's offset without borders (offset + border)
                ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
            ),
            left: (
                pageX -                                                                 // The absolute mouse position
                this.offset.click.left -                                                // Click offset (relative to the element)
                this.offset.relative.left -                                             // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left +                                               // The offsetParent's offset without borders (offset + border)
                ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
            )
        };

    },

    _clear: function() {
        this.helper.removeClass("ui-draggable-dragging");
        if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
            this.helper.remove();
        }
        this.helper = null;
        this.cancelHelperRemoval = false;
    },

    // From now on bulk stuff - mainly helpers

    _trigger: function(type, event, ui) {
        ui = ui || this._uiHash();
        $.ui.plugin.call(this, type, [event, ui]);
        //The absolute position has to be recalculated after plugins
        if(type === "drag") {
            this.positionAbs = this._convertPositionTo("absolute");
        }
        return $.Widget.prototype._trigger.call(this, type, event, ui);
    },

    plugins: {},

    _uiHash: function() {
        return {
            helper: this.helper,
            position: this.position,
            originalPosition: this.originalPosition,
            offset: this.positionAbs
        };
    }

});

$.ui.plugin.add("draggable", "connectToSortable", {
    start: function(event, ui) {

        var inst = $(this).data("ui-draggable"), o = inst.options,
            uiSortable = $.extend({}, ui, { item: inst.element });
        inst.sortables = [];
        $(o.connectToSortable).each(function() {
            var sortable = $.data(this, "ui-sortable");
            if (sortable && !sortable.options.disabled) {
                inst.sortables.push({
                    instance: sortable,
                    shouldRevert: sortable.options.revert
                });
                sortable.refreshPositions();    // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                sortable._trigger("activate", event, uiSortable);
            }
        });

    },
    stop: function(event, ui) {

        //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
        var inst = $(this).data("ui-draggable"),
            uiSortable = $.extend({}, ui, { item: inst.element });

        $.each(inst.sortables, function() {
            if(this.instance.isOver) {

                this.instance.isOver = 0;

                inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
                this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

                //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                if(this.shouldRevert) {
                    this.instance.options.revert = this.shouldRevert;
                }

                //Trigger the stop of the sortable
                this.instance._mouseStop(event);

                this.instance.options.helper = this.instance.options._helper;

                //If the helper has been the original item, restore properties in the sortable
                if(inst.options.helper === "original") {
                    this.instance.currentItem.css({ top: "auto", left: "auto" });
                }

            } else {
                this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
                this.instance._trigger("deactivate", event, uiSortable);
            }

        });

    },
    drag: function(event, ui) {

        var inst = $(this).data("ui-draggable"), that = this;

        $.each(inst.sortables, function() {

            var innermostIntersecting = false,
                thisSortable = this;

            //Copy over some variables to allow calling the sortable's native _intersectsWith
            this.instance.positionAbs = inst.positionAbs;
            this.instance.helperProportions = inst.helperProportions;
            this.instance.offset.click = inst.offset.click;

            if(this.instance._intersectsWith(this.instance.containerCache)) {
                innermostIntersecting = true;
                $.each(inst.sortables, function () {
                    this.instance.positionAbs = inst.positionAbs;
                    this.instance.helperProportions = inst.helperProportions;
                    this.instance.offset.click = inst.offset.click;
                    if (this !== thisSortable &&
                        this.instance._intersectsWith(this.instance.containerCache) &&
                        $.contains(thisSortable.instance.element[0], this.instance.element[0])
                    ) {
                        innermostIntersecting = false;
                    }
                    return innermostIntersecting;
                });
            }


            if(innermostIntersecting) {
                //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                if(!this.instance.isOver) {

                    this.instance.isOver = 1;
                    //Now we fake the start of dragging for the sortable instance,
                    //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                    //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                    this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
                    this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
                    this.instance.options.helper = function() { return ui.helper[0]; };

                    event.target = this.instance.currentItem[0];
                    this.instance._mouseCapture(event, true);
                    this.instance._mouseStart(event, true, true);

                    //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                    this.instance.offset.click.top = inst.offset.click.top;
                    this.instance.offset.click.left = inst.offset.click.left;
                    this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
                    this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

                    inst._trigger("toSortable", event);
                    inst.dropped = this.instance.element; //draggable revert needs that
                    //hack so receive/update callbacks work (mostly)
                    inst.currentItem = inst.element;
                    this.instance.fromOutside = inst;

                }

                //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                if(this.instance.currentItem) {
                    this.instance._mouseDrag(event);
                }

            } else {

                //If it doesn't intersect with the sortable, and it intersected before,
                //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                if(this.instance.isOver) {

                    this.instance.isOver = 0;
                    this.instance.cancelHelperRemoval = true;

                    //Prevent reverting on this forced stop
                    this.instance.options.revert = false;

                    // The out event needs to be triggered independently
                    this.instance._trigger("out", event, this.instance._uiHash(this.instance));

                    this.instance._mouseStop(event, true);
                    this.instance.options.helper = this.instance.options._helper;

                    //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                    this.instance.currentItem.remove();
                    if(this.instance.placeholder) {
                        this.instance.placeholder.remove();
                    }

                    inst._trigger("fromSortable", event);
                    inst.dropped = false; //draggable revert needs that
                }

            }

        });

    }
});

$.ui.plugin.add("draggable", "cursor", {
    start: function() {
        var t = $("body"), o = $(this).data("ui-draggable").options;
        if (t.css("cursor")) {
            o._cursor = t.css("cursor");
        }
        t.css("cursor", o.cursor);
    },
    stop: function() {
        var o = $(this).data("ui-draggable").options;
        if (o._cursor) {
            $("body").css("cursor", o._cursor);
        }
    }
});

$.ui.plugin.add("draggable", "opacity", {
    start: function(event, ui) {
        var t = $(ui.helper), o = $(this).data("ui-draggable").options;
        if(t.css("opacity")) {
            o._opacity = t.css("opacity");
        }
        t.css("opacity", o.opacity);
    },
    stop: function(event, ui) {
        var o = $(this).data("ui-draggable").options;
        if(o._opacity) {
            $(ui.helper).css("opacity", o._opacity);
        }
    }
});

$.ui.plugin.add("draggable", "scroll", {
    start: function() {
        var i = $(this).data("ui-draggable");
        if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
            i.overflowOffset = i.scrollParent.offset();
        }
    },
    drag: function( event ) {

        var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

        if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

            if(!o.axis || o.axis !== "x") {
                if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                    i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
                } else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                    i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
                }
            }

            if(!o.axis || o.axis !== "y") {
                if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                    i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
                } else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                    i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
                }
            }

        } else {

            if(!o.axis || o.axis !== "x") {
                if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                    scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                    scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                }
            }

            if(!o.axis || o.axis !== "y") {
                if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                    scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                    scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                }
            }

        }

        if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(i, event);
        }

    }
});

$.ui.plugin.add("draggable", "snap", {
    start: function() {

        var i = $(this).data("ui-draggable"),
            o = i.options;

        i.snapElements = [];

        $(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
            var $t = $(this),
                $o = $t.offset();
            if(this !== i.element[0]) {
                i.snapElements.push({
                    item: this,
                    width: $t.outerWidth(), height: $t.outerHeight(),
                    top: $o.top, left: $o.left
                });
            }
        });

    },
    drag: function(event, ui) {

        var ts, bs, ls, rs, l, r, t, b, i, first,
            inst = $(this).data("ui-draggable"),
            o = inst.options,
            d = o.snapTolerance,
            x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
            y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

        for (i = inst.snapElements.length - 1; i >= 0; i--){

            l = inst.snapElements[i].left;
            r = l + inst.snapElements[i].width;
            t = inst.snapElements[i].top;
            b = t + inst.snapElements[i].height;

            if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
                if(inst.snapElements[i].snapping) {
                    (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                }
                inst.snapElements[i].snapping = false;
                continue;
            }

            if(o.snapMode !== "inner") {
                ts = Math.abs(t - y2) <= d;
                bs = Math.abs(b - y1) <= d;
                ls = Math.abs(l - x2) <= d;
                rs = Math.abs(r - x1) <= d;
                if(ts) {
                    ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                }
                if(bs) {
                    ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
                }
                if(ls) {
                    ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
                }
                if(rs) {
                    ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
                }
            }

            first = (ts || bs || ls || rs);

            if(o.snapMode !== "outer") {
                ts = Math.abs(t - y1) <= d;
                bs = Math.abs(b - y2) <= d;
                ls = Math.abs(l - x1) <= d;
                rs = Math.abs(r - x2) <= d;
                if(ts) {
                    ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
                }
                if(bs) {
                    ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
                }
                if(ls) {
                    ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
                }
                if(rs) {
                    ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
                }
            }

            if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
            }
            inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

        }

    }
});

$.ui.plugin.add("draggable", "stack", {
    start: function() {
        var min,
            o = this.data("ui-draggable").options,
            group = $.makeArray($(o.stack)).sort(function(a,b) {
                return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
            });

        if (!group.length) { return; }

        min = parseInt($(group[0]).css("zIndex"), 10) || 0;
        $(group).each(function(i) {
            $(this).css("zIndex", min + i);
        });
        this.css("zIndex", (min + group.length));
    }
});

$.ui.plugin.add("draggable", "zIndex", {
    start: function(event, ui) {
        var t = $(ui.helper), o = $(this).data("ui-draggable").options;
        if(t.css("zIndex")) {
            o._zIndex = t.css("zIndex");
        }
        t.css("zIndex", o.zIndex);
    },
    stop: function(event, ui) {
        var o = $(this).data("ui-draggable").options;
        if(o._zIndex) {
            $(ui.helper).css("zIndex", o._zIndex);
        }
    }
});

})(jQuery);

(function( $, undefined ) {

function isOverAxis( x, reference, size ) {
    return ( x > reference ) && ( x < ( reference + size ) );
}

$.widget("ui.droppable", {
    version: "1.10.4",
    widgetEventPrefix: "drop",
    options: {
        accept: "*",
        activeClass: false,
        addClasses: true,
        greedy: false,
        hoverClass: false,
        scope: "default",
        tolerance: "intersect",

        // callbacks
        activate: null,
        deactivate: null,
        drop: null,
        out: null,
        over: null
    },
    _create: function() {

        var proportions,
            o = this.options,
            accept = o.accept;

        this.isover = false;
        this.isout = true;

        this.accept = $.isFunction(accept) ? accept : function(d) {
            return d.is(accept);
        };

        this.proportions = function( /* valueToWrite */ ) {
            if ( arguments.length ) {
                // Store the droppable's proportions
                proportions = arguments[ 0 ];
            } else {
                // Retrieve or derive the droppable's proportions
                return proportions ?
                    proportions :
                    proportions = {
                        width: this.element[ 0 ].offsetWidth,
                        height: this.element[ 0 ].offsetHeight
                    };
            }
        };

        // Add the reference and positions to the manager
        $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
        $.ui.ddmanager.droppables[o.scope].push(this);

        (o.addClasses && this.element.addClass("ui-droppable"));

    },

    _destroy: function() {
        var i = 0,
            drop = $.ui.ddmanager.droppables[this.options.scope];

        for ( ; i < drop.length; i++ ) {
            if ( drop[i] === this ) {
                drop.splice(i, 1);
            }
        }

        this.element.removeClass("ui-droppable ui-droppable-disabled");
    },

    _setOption: function(key, value) {

        if(key === "accept") {
            this.accept = $.isFunction(value) ? value : function(d) {
                return d.is(value);
            };
        }
        $.Widget.prototype._setOption.apply(this, arguments);
    },

    _activate: function(event) {
        var draggable = $.ui.ddmanager.current;
        if(this.options.activeClass) {
            this.element.addClass(this.options.activeClass);
        }
        if(draggable){
            this._trigger("activate", event, this.ui(draggable));
        }
    },

    _deactivate: function(event) {
        var draggable = $.ui.ddmanager.current;
        if(this.options.activeClass) {
            this.element.removeClass(this.options.activeClass);
        }
        if(draggable){
            this._trigger("deactivate", event, this.ui(draggable));
        }
    },

    _over: function(event) {

        var draggable = $.ui.ddmanager.current;

        // Bail if draggable and droppable are same element
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return;
        }

        if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
            if(this.options.hoverClass) {
                this.element.addClass(this.options.hoverClass);
            }
            this._trigger("over", event, this.ui(draggable));
        }

    },

    _out: function(event) {

        var draggable = $.ui.ddmanager.current;

        // Bail if draggable and droppable are same element
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return;
        }

        if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
            if(this.options.hoverClass) {
                this.element.removeClass(this.options.hoverClass);
            }
            this._trigger("out", event, this.ui(draggable));
        }

    },

    _drop: function(event,custom) {

        var draggable = custom || $.ui.ddmanager.current,
            childrenIntersection = false;

        // Bail if draggable and droppable are same element
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
            return false;
        }

        this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
            var inst = $.data(this, "ui-droppable");
            if(
                inst.options.greedy &&
                !inst.options.disabled &&
                inst.options.scope === draggable.options.scope &&
                inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
            ) { childrenIntersection = true; return false; }
        });
        if(childrenIntersection) {
            return false;
        }

        if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
            if(this.options.activeClass) {
                this.element.removeClass(this.options.activeClass);
            }
            if(this.options.hoverClass) {
                this.element.removeClass(this.options.hoverClass);
            }
            this._trigger("drop", event, this.ui(draggable));
            return this.element;
        }

        return false;

    },

    ui: function(c) {
        return {
            draggable: (c.currentItem || c.element),
            helper: c.helper,
            position: c.position,
            offset: c.positionAbs
        };
    }

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

    if (!droppable.offset) {
        return false;
    }

    var draggableLeft, draggableTop,
        x1 = (draggable.positionAbs || draggable.position.absolute).left,
        y1 = (draggable.positionAbs || draggable.position.absolute).top,
        x2 = x1 + draggable.helperProportions.width,
        y2 = y1 + draggable.helperProportions.height,
        l = droppable.offset.left,
        t = droppable.offset.top,
        r = l + droppable.proportions().width,
        b = t + droppable.proportions().height;

    switch (toleranceMode) {
        case "fit":
            return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
        case "intersect":
            return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
        case "pointer":
            draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);
            draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);
            return isOverAxis( draggableTop, t, droppable.proportions().height ) && isOverAxis( draggableLeft, l, droppable.proportions().width );
        case "touch":
            return (
                (y1 >= t && y1 <= b) || // Top edge touching
                (y2 >= t && y2 <= b) || // Bottom edge touching
                (y1 < t && y2 > b)      // Surrounded vertically
            ) && (
                (x1 >= l && x1 <= r) || // Left edge touching
                (x2 >= l && x2 <= r) || // Right edge touching
                (x1 < l && x2 > r)      // Surrounded horizontally
            );
        default:
            return false;
        }

};

/*
    This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
    current: null,
    droppables: { "default": [] },
    prepareOffsets: function(t, event) {

        var i, j,
            m = $.ui.ddmanager.droppables[t.options.scope] || [],
            type = event ? event.type : null, // workaround for #2317
            list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

        droppablesLoop: for (i = 0; i < m.length; i++) {

            //No disabled and non-accepted
            if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {
                continue;
            }

            // Filter out elements in the current dragged item
            for (j=0; j < list.length; j++) {
                if(list[j] === m[i].element[0]) {
                    m[i].proportions().height = 0;
                    continue droppablesLoop;
                }
            }

            m[i].visible = m[i].element.css("display") !== "none";
            if(!m[i].visible) {
                continue;
            }

            //Activate the droppable if used directly from draggables
            if(type === "mousedown") {
                m[i]._activate.call(m[i], event);
            }

            m[ i ].offset = m[ i ].element.offset();
            m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

        }

    },
    drop: function(draggable, event) {

        var dropped = false;
        // Create a copy of the droppables in case the list changes during the drop (#9116)
        $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {

            if(!this.options) {
                return;
            }
            if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
                dropped = this._drop.call(this, event) || dropped;
            }

            if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
                this.isout = true;
                this.isover = false;
                this._deactivate.call(this, event);
            }

        });
        return dropped;

    },
    dragStart: function( draggable, event ) {
        //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
        draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
            if( !draggable.options.refreshPositions ) {
                $.ui.ddmanager.prepareOffsets( draggable, event );
            }
        });
    },
    drag: function(draggable, event) {

        //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
        if(draggable.options.refreshPositions) {
            $.ui.ddmanager.prepareOffsets(draggable, event);
        }

        //Run through all droppables and check their positions based on specific tolerance options
        $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

            if(this.options.disabled || this.greedyChild || !this.visible) {
                return;
            }

            var parentInstance, scope, parent,
                intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
            if(!c) {
                return;
            }

            if (this.options.greedy) {
                // find droppable parents with same scope
                scope = this.options.scope;
                parent = this.element.parents(":data(ui-droppable)").filter(function () {
                    return $.data(this, "ui-droppable").options.scope === scope;
                });

                if (parent.length) {
                    parentInstance = $.data(parent[0], "ui-droppable");
                    parentInstance.greedyChild = (c === "isover");
                }
            }

            // we just moved into a greedy child
            if (parentInstance && c === "isover") {
                parentInstance.isover = false;
                parentInstance.isout = true;
                parentInstance._out.call(parentInstance, event);
            }

            this[c] = true;
            this[c === "isout" ? "isover" : "isout"] = false;
            this[c === "isover" ? "_over" : "_out"].call(this, event);

            // we just moved out of a greedy child
            if (parentInstance && c === "isout") {
                parentInstance.isout = false;
                parentInstance.isover = true;
                parentInstance._over.call(parentInstance, event);
            }
        });

    },
    dragStop: function( draggable, event ) {
        draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
        //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
        if( !draggable.options.refreshPositions ) {
            $.ui.ddmanager.prepareOffsets( draggable, event );
        }
    }
};

})(jQuery);

(function( $, undefined ) {

function num(v) {
    return parseInt(v, 10) || 0;
}

function isNumber(value) {
    return !isNaN(parseInt(value, 10));
}

$.widget("ui.resizable", $.ui.mouse, {
    version: "1.10.4",
    widgetEventPrefix: "resize",
    options: {
        alsoResize: false,
        animate: false,
        animateDuration: "slow",
        animateEasing: "swing",
        aspectRatio: false,
        autoHide: false,
        containment: false,
        ghost: false,
        grid: false,
        handles: "e,s,se",
        helper: false,
        maxHeight: null,
        maxWidth: null,
        minHeight: 10,
        minWidth: 10,
        // See #7960
        zIndex: 90,

        // callbacks
        resize: null,
        start: null,
        stop: null
    },
    _create: function() {

        var n, i, handle, axis, hname,
            that = this,
            o = this.options;
        this.element.addClass("ui-resizable");

        $.extend(this, {
            _aspectRatio: !!(o.aspectRatio),
            aspectRatio: o.aspectRatio,
            originalElement: this.element,
            _proportionallyResizeElements: [],
            _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
        });

        //Wrap the element if it cannot hold child nodes
        if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

            //Create a wrapper element and set the wrapper to the new current internal element
            this.element.wrap(
                $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                })
            );

            //Overwrite the original this.element
            this.element = this.element.parent().data(
                "ui-resizable", this.element.data("ui-resizable")
            );

            this.elementIsWrapper = true;

            //Move margins to the wrapper
            this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
            this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

            //Prevent Safari textarea resize
            this.originalResizeStyle = this.originalElement.css("resize");
            this.originalElement.css("resize", "none");

            //Push the actual element to our proportionallyResize internal array
            this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

            // avoid IE jump (hard set the margin)
            this.originalElement.css({ margin: this.originalElement.css("margin") });

            // fix handlers offset
            this._proportionallyResize();

        }

        this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
        if(this.handles.constructor === String) {

            if ( this.handles === "all") {
                this.handles = "n,e,s,w,se,sw,ne,nw";
            }

            n = this.handles.split(",");
            this.handles = {};

            for(i = 0; i < n.length; i++) {

                handle = $.trim(n[i]);
                hname = "ui-resizable-"+handle;
                axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

                // Apply zIndex to all handles - see #7960
                axis.css({ zIndex: o.zIndex });

                //TODO : What's going on here?
                if ("se" === handle) {
                    axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                }

                //Insert into internal handles object and append to element
                this.handles[handle] = ".ui-resizable-"+handle;
                this.element.append(axis);
            }

        }

        this._renderAxis = function(target) {

            var i, axis, padPos, padWrapper;

            target = target || this.element;

            for(i in this.handles) {

                if(this.handles[i].constructor === String) {
                    this.handles[i] = $(this.handles[i], this.element).show();
                }

                //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

                    axis = $(this.handles[i], this.element);

                    //Checking the correct pad and border
                    padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

                    //The padding type i have to apply...
                    padPos = [ "padding",
                        /ne|nw|n/.test(i) ? "Top" :
                        /se|sw|s/.test(i) ? "Bottom" :
                        /^e$/.test(i) ? "Right" : "Left" ].join("");

                    target.css(padPos, padWrapper);

                    this._proportionallyResize();

                }

                //TODO: What's that good for? There's not anything to be executed left
                if(!$(this.handles[i]).length) {
                    continue;
                }
            }
        };

        //TODO: make renderAxis a prototype function
        this._renderAxis(this.element);

        this._handles = $(".ui-resizable-handle", this.element)
            .disableSelection();

        //Matching axis name
        this._handles.mouseover(function() {
            if (!that.resizing) {
                if (this.className) {
                    axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                }
                //Axis, default = se
                that.axis = axis && axis[1] ? axis[1] : "se";
            }
        });

        //If we want to auto hide the elements
        if (o.autoHide) {
            this._handles.hide();
            $(this.element)
                .addClass("ui-resizable-autohide")
                .mouseenter(function() {
                    if (o.disabled) {
                        return;
                    }
                    $(this).removeClass("ui-resizable-autohide");
                    that._handles.show();
                })
                .mouseleave(function(){
                    if (o.disabled) {
                        return;
                    }
                    if (!that.resizing) {
                        $(this).addClass("ui-resizable-autohide");
                        that._handles.hide();
                    }
                });
        }

        //Initialize the mouse interaction
        this._mouseInit();

    },

    _destroy: function() {

        this._mouseDestroy();

        var wrapper,
            _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                    .removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };

        //TODO: Unwrap at same DOM position
        if (this.elementIsWrapper) {
            _destroy(this.element);
            wrapper = this.element;
            this.originalElement.css({
                position: wrapper.css("position"),
                width: wrapper.outerWidth(),
                height: wrapper.outerHeight(),
                top: wrapper.css("top"),
                left: wrapper.css("left")
            }).insertAfter( wrapper );
            wrapper.remove();
        }

        this.originalElement.css("resize", this.originalResizeStyle);
        _destroy(this.originalElement);

        return this;
    },

    _mouseCapture: function(event) {
        var i, handle,
            capture = false;

        for (i in this.handles) {
            handle = $(this.handles[i])[0];
            if (handle === event.target || $.contains(handle, event.target)) {
                capture = true;
            }
        }

        return !this.options.disabled && capture;
    },

    _mouseStart: function(event) {

        var curleft, curtop, cursor,
            o = this.options,
            iniPos = this.element.position(),
            el = this.element;

        this.resizing = true;

        // bugfix for http://dev.jquery.com/ticket/1749
        if ( (/absolute/).test( el.css("position") ) ) {
            el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
        } else if (el.is(".ui-draggable")) {
            el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
        }

        this._renderProxy();

        curleft = num(this.helper.css("left"));
        curtop = num(this.helper.css("top"));

        if (o.containment) {
            curleft += $(o.containment).scrollLeft() || 0;
            curtop += $(o.containment).scrollTop() || 0;
        }

        //Store needed variables
        this.offset = this.helper.offset();
        this.position = { left: curleft, top: curtop };
        this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
        this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
        this.originalPosition = { left: curleft, top: curtop };
        this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
        this.originalMousePosition = { left: event.pageX, top: event.pageY };

        //Aspect Ratio
        this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

        cursor = $(".ui-resizable-" + this.axis).css("cursor");
        $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

        el.addClass("ui-resizable-resizing");
        this._propagate("start", event);
        return true;
    },

    _mouseDrag: function(event) {

        //Increase performance, avoid regex
        var data,
            el = this.helper, props = {},
            smp = this.originalMousePosition,
            a = this.axis,
            prevTop = this.position.top,
            prevLeft = this.position.left,
            prevWidth = this.size.width,
            prevHeight = this.size.height,
            dx = (event.pageX-smp.left)||0,
            dy = (event.pageY-smp.top)||0,
            trigger = this._change[a];

        if (!trigger) {
            return false;
        }

        // Calculate the attrs that will be change
        data = trigger.apply(this, [event, dx, dy]);

        // Put this in the mouseDrag handler since the user can start pressing shift while resizing
        this._updateVirtualBoundaries(event.shiftKey);
        if (this._aspectRatio || event.shiftKey) {
            data = this._updateRatio(data, event);
        }

        data = this._respectSize(data, event);

        this._updateCache(data);

        // plugins callbacks need to be called first
        this._propagate("resize", event);

        if (this.position.top !== prevTop) {
            props.top = this.position.top + "px";
        }
        if (this.position.left !== prevLeft) {
            props.left = this.position.left + "px";
        }
        if (this.size.width !== prevWidth) {
            props.width = this.size.width + "px";
        }
        if (this.size.height !== prevHeight) {
            props.height = this.size.height + "px";
        }
        el.css(props);

        if (!this._helper && this._proportionallyResizeElements.length) {
            this._proportionallyResize();
        }

        // Call the user callback if the element was resized
        if ( ! $.isEmptyObject(props) ) {
            this._trigger("resize", event, this.ui());
        }

        return false;
    },

    _mouseStop: function(event) {

        this.resizing = false;
        var pr, ista, soffseth, soffsetw, s, left, top,
            o = this.options, that = this;

        if(this._helper) {

            pr = this._proportionallyResizeElements;
            ista = pr.length && (/textarea/i).test(pr[0].nodeName);
            soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
            soffsetw = ista ? 0 : that.sizeDiff.width;

            s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
            left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
            top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

            if (!o.animate) {
                this.element.css($.extend(s, { top: top, left: left }));
            }

            that.helper.height(that.size.height);
            that.helper.width(that.size.width);

            if (this._helper && !o.animate) {
                this._proportionallyResize();
            }
        }

        $("body").css("cursor", "auto");

        this.element.removeClass("ui-resizable-resizing");

        this._propagate("stop", event);

        if (this._helper) {
            this.helper.remove();
        }

        return false;

    },

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
            o = this.options;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) {
                b.minWidth = pMinWidth;
            }
            if(pMinHeight > b.minHeight) {
                b.minHeight = pMinHeight;
            }
            if(pMaxWidth < b.maxWidth) {
                b.maxWidth = pMaxWidth;
            }
            if(pMaxHeight < b.maxHeight) {
                b.maxHeight = pMaxHeight;
            }
        }
        this._vBoundaries = b;
    },

    _updateCache: function(data) {
        this.offset = this.helper.offset();
        if (isNumber(data.left)) {
            this.position.left = data.left;
        }
        if (isNumber(data.top)) {
            this.position.top = data.top;
        }
        if (isNumber(data.height)) {
            this.size.height = data.height;
        }
        if (isNumber(data.width)) {
            this.size.width = data.width;
        }
    },

    _updateRatio: function( data ) {

        var cpos = this.position,
            csize = this.size,
            a = this.axis;

        if (isNumber(data.height)) {
            data.width = (data.height * this.aspectRatio);
        } else if (isNumber(data.width)) {
            data.height = (data.width / this.aspectRatio);
        }

        if (a === "sw") {
            data.left = cpos.left + (csize.width - data.width);
            data.top = null;
        }
        if (a === "nw") {
            data.top = cpos.top + (csize.height - data.height);
            data.left = cpos.left + (csize.width - data.width);
        }

        return data;
    },

    _respectSize: function( data ) {

        var o = this._vBoundaries,
            a = this.axis,
            ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
            isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
            dw = this.originalPosition.left + this.originalSize.width,
            dh = this.position.top + this.size.height,
            cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
        if (isminw) {
            data.width = o.minWidth;
        }
        if (isminh) {
            data.height = o.minHeight;
        }
        if (ismaxw) {
            data.width = o.maxWidth;
        }
        if (ismaxh) {
            data.height = o.maxHeight;
        }

        if (isminw && cw) {
            data.left = dw - o.minWidth;
        }
        if (ismaxw && cw) {
            data.left = dw - o.maxWidth;
        }
        if (isminh && ch) {
            data.top = dh - o.minHeight;
        }
        if (ismaxh && ch) {
            data.top = dh - o.maxHeight;
        }

        // fixing jump error on top/left - bug #2330
        if (!data.width && !data.height && !data.left && data.top) {
            data.top = null;
        } else if (!data.width && !data.height && !data.top && data.left) {
            data.left = null;
        }

        return data;
    },

    _proportionallyResize: function() {

        if (!this._proportionallyResizeElements.length) {
            return;
        }

        var i, j, borders, paddings, prel,
            element = this.helper || this.element;

        for ( i=0; i < this._proportionallyResizeElements.length; i++) {

            prel = this._proportionallyResizeElements[i];

            if (!this.borderDif) {
                this.borderDif = [];
                borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
                paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

                for ( j = 0; j < borders.length; j++ ) {
                    this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
                }
            }

            prel.css({
                height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
                width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
            });

        }

    },

    _renderProxy: function() {

        var el = this.element, o = this.options;
        this.elementOffset = el.offset();

        if(this._helper) {

            this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

            this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left +"px",
                top: this.elementOffset.top +"px",
                zIndex: ++o.zIndex //TODO: Don't modify option
            });

            this.helper
                .appendTo("body")
                .disableSelection();

        } else {
            this.helper = this.element;
        }

    },

    _change: {
        e: function(event, dx) {
            return { width: this.originalSize.width + dx };
        },
        w: function(event, dx) {
            var cs = this.originalSize, sp = this.originalPosition;
            return { left: sp.left + dx, width: cs.width - dx };
        },
        n: function(event, dx, dy) {
            var cs = this.originalSize, sp = this.originalPosition;
            return { top: sp.top + dy, height: cs.height - dy };
        },
        s: function(event, dx, dy) {
            return { height: this.originalSize.height + dy };
        },
        se: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        sw: function(event, dx, dy) {
            return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        },
        ne: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        nw: function(event, dx, dy) {
            return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        }
    },

    _propagate: function(n, event) {
        $.ui.plugin.call(this, n, [event, this.ui()]);
        (n !== "resize" && this._trigger(n, event, this.ui()));
    },

    plugins: {},

    ui: function() {
        return {
            originalElement: this.originalElement,
            element: this.element,
            helper: this.helper,
            position: this.position,
            size: this.size,
            originalSize: this.originalSize,
            originalPosition: this.originalPosition
        };
    }

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

    stop: function( event ) {
        var that = $(this).data("ui-resizable"),
            o = that.options,
            pr = that._proportionallyResizeElements,
            ista = pr.length && (/textarea/i).test(pr[0].nodeName),
            soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
            soffsetw = ista ? 0 : that.sizeDiff.width,
            style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
            left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
            top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

        that.element.animate(
            $.extend(style, top && left ? { top: top, left: left } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {

                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };

                    if (pr && pr.length) {
                        $(pr[0]).css({ width: data.width, height: data.height });
                    }

                    // propagating resize, and updating values for each animation step
                    that._updateCache(data);
                    that._propagate("resize", event);

                }
            }
        );
    }

});

$.ui.plugin.add("resizable", "containment", {

    start: function() {
        var element, p, co, ch, cw, width, height,
            that = $(this).data("ui-resizable"),
            o = that.options,
            el = that.element,
            oc = o.containment,
            ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

        if (!ce) {
            return;
        }

        that.containerElement = $(ce);

        if (/document/.test(oc) || oc === document) {
            that.containerOffset = { left: 0, top: 0 };
            that.containerPosition = { left: 0, top: 0 };

            that.parentData = {
                element: $(document), left: 0, top: 0,
                width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
            };
        }

        // i'm a node, so compute top, left, right, bottom
        else {
            element = $(ce);
            p = [];
            $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

            that.containerOffset = element.offset();
            that.containerPosition = element.position();
            that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

            co = that.containerOffset;
            ch = that.containerSize.height;
            cw = that.containerSize.width;
            width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
            height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

            that.parentData = {
                element: ce, left: co.left, top: co.top, width: width, height: height
            };
        }
    },

    resize: function( event ) {
        var woset, hoset, isParent, isOffsetRelative,
            that = $(this).data("ui-resizable"),
            o = that.options,
            co = that.containerOffset, cp = that.position,
            pRatio = that._aspectRatio || event.shiftKey,
            cop = { top:0, left:0 }, ce = that.containerElement;

        if (ce[0] !== document && (/static/).test(ce.css("position"))) {
            cop = co;
        }

        if (cp.left < (that._helper ? co.left : 0)) {
            that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
            if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio;
            }
            that.position.left = o.helper ? co.left : 0;
        }

        if (cp.top < (that._helper ? co.top : 0)) {
            that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
            if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio;
            }
            that.position.top = that._helper ? co.top : 0;
        }

        that.offset.left = that.parentData.left+that.position.left;
        that.offset.top = that.parentData.top+that.position.top;

        woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
        hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

        isParent = that.containerElement.get(0) === that.element.parent().get(0);
        isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

        if ( isParent && isOffsetRelative ) {
            woset -= Math.abs( that.parentData.left );
        }

        if (woset + that.size.width >= that.parentData.width) {
            that.size.width = that.parentData.width - woset;
            if (pRatio) {
                that.size.height = that.size.width / that.aspectRatio;
            }
        }

        if (hoset + that.size.height >= that.parentData.height) {
            that.size.height = that.parentData.height - hoset;
            if (pRatio) {
                that.size.width = that.size.height * that.aspectRatio;
            }
        }
    },

    stop: function(){
        var that = $(this).data("ui-resizable"),
            o = that.options,
            co = that.containerOffset,
            cop = that.containerPosition,
            ce = that.containerElement,
            helper = $(that.helper),
            ho = helper.offset(),
            w = helper.outerWidth() - that.sizeDiff.width,
            h = helper.outerHeight() - that.sizeDiff.height;

        if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
            $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
        }

        if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
            $(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
        }

    }
});

$.ui.plugin.add("resizable", "alsoResize", {

    start: function () {
        var that = $(this).data("ui-resizable"),
            o = that.options,
            _store = function (exp) {
                $(exp).each(function() {
                    var el = $(this);
                    el.data("ui-resizable-alsoresize", {
                        width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
                        left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
                    });
                });
            };

        if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
            if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
            else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
        }else{
            _store(o.alsoResize);
        }
    },

    resize: function (event, ui) {
        var that = $(this).data("ui-resizable"),
            o = that.options,
            os = that.originalSize,
            op = that.originalPosition,
            delta = {
                height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
                top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
            },

            _alsoResize = function (exp, c) {
                $(exp).each(function() {
                    var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
                        css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

                    $.each(css, function (i, prop) {
                        var sum = (start[prop]||0) + (delta[prop]||0);
                        if (sum && sum >= 0) {
                            style[prop] = sum || null;
                        }
                    });

                    el.css(style);
                });
            };

        if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
            $.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
        }else{
            _alsoResize(o.alsoResize);
        }
    },

    stop: function () {
        $(this).removeData("resizable-alsoresize");
    }
});

$.ui.plugin.add("resizable", "ghost", {

    start: function() {

        var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

        that.ghost = that.originalElement.clone();
        that.ghost
            .css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
            .addClass("ui-resizable-ghost")
            .addClass(typeof o.ghost === "string" ? o.ghost : "");

        that.ghost.appendTo(that.helper);

    },

    resize: function(){
        var that = $(this).data("ui-resizable");
        if (that.ghost) {
            that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
        }
    },

    stop: function() {
        var that = $(this).data("ui-resizable");
        if (that.ghost && that.helper) {
            that.helper.get(0).removeChild(that.ghost.get(0));
        }
    }

});

$.ui.plugin.add("resizable", "grid", {

    resize: function() {
        var that = $(this).data("ui-resizable"),
            o = that.options,
            cs = that.size,
            os = that.originalSize,
            op = that.originalPosition,
            a = that.axis,
            grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
            gridX = (grid[0]||1),
            gridY = (grid[1]||1),
            ox = Math.round((cs.width - os.width) / gridX) * gridX,
            oy = Math.round((cs.height - os.height) / gridY) * gridY,
            newWidth = os.width + ox,
            newHeight = os.height + oy,
            isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
            isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
            isMinWidth = o.minWidth && (o.minWidth > newWidth),
            isMinHeight = o.minHeight && (o.minHeight > newHeight);

        o.grid = grid;

        if (isMinWidth) {
            newWidth = newWidth + gridX;
        }
        if (isMinHeight) {
            newHeight = newHeight + gridY;
        }
        if (isMaxWidth) {
            newWidth = newWidth - gridX;
        }
        if (isMaxHeight) {
            newHeight = newHeight - gridY;
        }

        if (/^(se|s|e)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
        } else if (/^(ne)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
            that.position.top = op.top - oy;
        } else if (/^(sw)$/.test(a)) {
            that.size.width = newWidth;
            that.size.height = newHeight;
            that.position.left = op.left - ox;
        } else {
            if ( newHeight - gridY > 0 ) {
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else {
                that.size.height = gridY;
                that.position.top = op.top + os.height - gridY;
            }
            if ( newWidth - gridX > 0 ) {
                that.size.width = newWidth;
                that.position.left = op.left - ox;
            } else {
                that.size.width = gridX;
                that.position.left = op.left + os.width - gridX;
            }
        }
    }

});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
    version: "1.10.4",
    options: {
        appendTo: "body",
        autoRefresh: true,
        distance: 0,
        filter: "*",
        tolerance: "touch",

        // callbacks
        selected: null,
        selecting: null,
        start: null,
        stop: null,
        unselected: null,
        unselecting: null
    },
    _create: function() {
        var selectees,
            that = this;

        this.element.addClass("ui-selectable");

        this.dragged = false;

        // cache selectee children based on filter
        this.refresh = function() {
            selectees = $(that.options.filter, that.element[0]);
            selectees.addClass("ui-selectee");
            selectees.each(function() {
                var $this = $(this),
                    pos = $this.offset();
                $.data(this, "selectable-item", {
                    element: this,
                    $element: $this,
                    left: pos.left,
                    top: pos.top,
                    right: pos.left + $this.outerWidth(),
                    bottom: pos.top + $this.outerHeight(),
                    startselected: false,
                    selected: $this.hasClass("ui-selected"),
                    selecting: $this.hasClass("ui-selecting"),
                    unselecting: $this.hasClass("ui-unselecting")
                });
            });
        };
        this.refresh();

        this.selectees = selectees.addClass("ui-selectee");

        this._mouseInit();

        this.helper = $("<div class='ui-selectable-helper'></div>");
    },

    _destroy: function() {
        this.selectees
            .removeClass("ui-selectee")
            .removeData("selectable-item");
        this.element
            .removeClass("ui-selectable ui-selectable-disabled");
        this._mouseDestroy();
    },

    _mouseStart: function(event) {
        var that = this,
            options = this.options;

        this.opos = [event.pageX, event.pageY];

        if (this.options.disabled) {
            return;
        }

        this.selectees = $(options.filter, this.element[0]);

        this._trigger("start", event);

        $(options.appendTo).append(this.helper);
        // position helper (lasso)
        this.helper.css({
            "left": event.pageX,
            "top": event.pageY,
            "width": 0,
            "height": 0
        });

        if (options.autoRefresh) {
            this.refresh();
        }

        this.selectees.filter(".ui-selected").each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.startselected = true;
            if (!event.metaKey && !event.ctrlKey) {
                selectee.$element.removeClass("ui-selected");
                selectee.selected = false;
                selectee.$element.addClass("ui-unselecting");
                selectee.unselecting = true;
                // selectable UNSELECTING callback
                that._trigger("unselecting", event, {
                    unselecting: selectee.element
                });
            }
        });

        $(event.target).parents().addBack().each(function() {
            var doSelect,
                selectee = $.data(this, "selectable-item");
            if (selectee) {
                doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
                selectee.$element
                    .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
                    .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                selectee.unselecting = !doSelect;
                selectee.selecting = doSelect;
                selectee.selected = doSelect;
                // selectable (UN)SELECTING callback
                if (doSelect) {
                    that._trigger("selecting", event, {
                        selecting: selectee.element
                    });
                } else {
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
                return false;
            }
        });

    },

    _mouseDrag: function(event) {

        this.dragged = true;

        if (this.options.disabled) {
            return;
        }

        var tmp,
            that = this,
            options = this.options,
            x1 = this.opos[0],
            y1 = this.opos[1],
            x2 = event.pageX,
            y2 = event.pageY;

        if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
        if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
        this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

        this.selectees.each(function() {
            var selectee = $.data(this, "selectable-item"),
                hit = false;

            //prevent helper from being selected if appendTo: selectable
            if (!selectee || selectee.element === that.element[0]) {
                return;
            }

            if (options.tolerance === "touch") {
                hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
            } else if (options.tolerance === "fit") {
                hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
            }

            if (hit) {
                // SELECT
                if (selectee.selected) {
                    selectee.$element.removeClass("ui-selected");
                    selectee.selected = false;
                }
                if (selectee.unselecting) {
                    selectee.$element.removeClass("ui-unselecting");
                    selectee.unselecting = false;
                }
                if (!selectee.selecting) {
                    selectee.$element.addClass("ui-selecting");
                    selectee.selecting = true;
                    // selectable SELECTING callback
                    that._trigger("selecting", event, {
                        selecting: selectee.element
                    });
                }
            } else {
                // UNSELECT
                if (selectee.selecting) {
                    if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                        selectee.$element.removeClass("ui-selecting");
                        selectee.selecting = false;
                        selectee.$element.addClass("ui-selected");
                        selectee.selected = true;
                    } else {
                        selectee.$element.removeClass("ui-selecting");
                        selectee.selecting = false;
                        if (selectee.startselected) {
                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                        }
                        // selectable UNSELECTING callback
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                }
                if (selectee.selected) {
                    if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;

                        selectee.$element.addClass("ui-unselecting");
                        selectee.unselecting = true;
                        // selectable UNSELECTING callback
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                }
            }
        });

        return false;
    },

    _mouseStop: function(event) {
        var that = this;

        this.dragged = false;

        $(".ui-unselecting", this.element[0]).each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.$element.removeClass("ui-unselecting");
            selectee.unselecting = false;
            selectee.startselected = false;
            that._trigger("unselected", event, {
                unselected: selectee.element
            });
        });
        $(".ui-selecting", this.element[0]).each(function() {
            var selectee = $.data(this, "selectable-item");
            selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
            selectee.selecting = false;
            selectee.selected = true;
            selectee.startselected = true;
            that._trigger("selected", event, {
                selected: selectee.element
            });
        });
        this._trigger("stop", event);

        this.helper.remove();

        return false;
    }

});

})(jQuery);

(function( $, undefined ) {

function isOverAxis( x, reference, size ) {
    return ( x > reference ) && ( x < ( reference + size ) );
}

function isFloating(item) {
    return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
}

$.widget("ui.sortable", $.ui.mouse, {
    version: "1.10.4",
    widgetEventPrefix: "sort",
    ready: false,
    options: {
        appendTo: "parent",
        axis: false,
        connectWith: false,
        containment: false,
        cursor: "auto",
        cursorAt: false,
        dropOnEmpty: true,
        forcePlaceholderSize: false,
        forceHelperSize: false,
        grid: false,
        handle: false,
        helper: "original",
        items: "> *",
        opacity: false,
        placeholder: false,
        revert: false,
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        scope: "default",
        tolerance: "intersect",
        zIndex: 1000,

        // callbacks
        activate: null,
        beforeStop: null,
        change: null,
        deactivate: null,
        out: null,
        over: null,
        receive: null,
        remove: null,
        sort: null,
        start: null,
        stop: null,
        update: null
    },
    _create: function() {

        var o = this.options;
        this.containerCache = {};
        this.element.addClass("ui-sortable");

        //Get the items
        this.refresh();

        //Let's determine if the items are being displayed horizontally
        this.floating = this.items.length ? o.axis === "x" || isFloating(this.items[0].item) : false;

        //Let's determine the parent's offset
        this.offset = this.element.offset();

        //Initialize mouse events for interaction
        this._mouseInit();

        //We're ready to go
        this.ready = true;

    },

    _destroy: function() {
        this.element
            .removeClass("ui-sortable ui-sortable-disabled");
        this._mouseDestroy();

        for ( var i = this.items.length - 1; i >= 0; i-- ) {
            this.items[i].item.removeData(this.widgetName + "-item");
        }

        return this;
    },

    _setOption: function(key, value){
        if ( key === "disabled" ) {
            this.options[ key ] = value;

            this.widget().toggleClass( "ui-sortable-disabled", !!value );
        } else {
            // Don't call widget base _setOption for disable as it adds ui-state-disabled class
            $.Widget.prototype._setOption.apply(this, arguments);
        }
    },

    _mouseCapture: function(event, overrideHandle) {
        var currentItem = null,
            validHandle = false,
            that = this;

        if (this.reverting) {
            return false;
        }

        if(this.options.disabled || this.options.type === "static") {
            return false;
        }

        //We have to refresh the items data once first
        this._refreshItems(event);

        //Find out if the clicked node (or one of its parents) is a actual item in this.items
        $(event.target).parents().each(function() {
            if($.data(this, that.widgetName + "-item") === that) {
                currentItem = $(this);
                return false;
            }
        });
        if($.data(event.target, that.widgetName + "-item") === that) {
            currentItem = $(event.target);
        }

        if(!currentItem) {
            return false;
        }
        if(this.options.handle && !overrideHandle) {
            $(this.options.handle, currentItem).find("*").addBack().each(function() {
                if(this === event.target) {
                    validHandle = true;
                }
            });
            if(!validHandle) {
                return false;
            }
        }

        this.currentItem = currentItem;
        this._removeCurrentsFromItems();
        return true;

    },

    _mouseStart: function(event, overrideHandle, noActivation) {

        var i, body,
            o = this.options;

        this.currentContainer = this;

        //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
        this.refreshPositions();

        //Create and append the visible helper
        this.helper = this._createHelper(event);

        //Cache the helper size
        this._cacheHelperProportions();

        /*
         * - Position generation -
         * This block generates everything position related - it's the core of draggables.
         */

        //Cache the margins of the original element
        this._cacheMargins();

        //Get the next scrolling parent
        this.scrollParent = this.helper.scrollParent();

        //The element's absolute position on the page minus margins
        this.offset = this.currentItem.offset();
        this.offset = {
            top: this.offset.top - this.margins.top,
            left: this.offset.left - this.margins.left
        };

        $.extend(this.offset, {
            click: { //Where the click happened, relative to the element
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            },
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
        });

        // Only after we got the offset, we can change the helper's position to absolute
        // TODO: Still need to figure out a way to make relative sorting possible
        this.helper.css("position", "absolute");
        this.cssPosition = this.helper.css("position");

        //Generate the original position
        this.originalPosition = this._generatePosition(event);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY;

        //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

        //Cache the former DOM position
        this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

        //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
        if(this.helper[0] !== this.currentItem[0]) {
            this.currentItem.hide();
        }

        //Create the placeholder
        this._createPlaceholder();

        //Set a containment if given in the options
        if(o.containment) {
            this._setContainment();
        }

        if( o.cursor && o.cursor !== "auto" ) { // cursor option
            body = this.document.find( "body" );

            // support: IE
            this.storedCursor = body.css( "cursor" );
            body.css( "cursor", o.cursor );

            this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
        }

        if(o.opacity) { // opacity option
            if (this.helper.css("opacity")) {
                this._storedOpacity = this.helper.css("opacity");
            }
            this.helper.css("opacity", o.opacity);
        }

        if(o.zIndex) { // zIndex option
            if (this.helper.css("zIndex")) {
                this._storedZIndex = this.helper.css("zIndex");
            }
            this.helper.css("zIndex", o.zIndex);
        }

        //Prepare scrolling
        if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
            this.overflowOffset = this.scrollParent.offset();
        }

        //Call callbacks
        this._trigger("start", event, this._uiHash());

        //Recache the helper size
        if(!this._preserveHelperProportions) {
            this._cacheHelperProportions();
        }


        //Post "activate" events to possible containers
        if( !noActivation ) {
            for ( i = this.containers.length - 1; i >= 0; i-- ) {
                this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
            }
        }

        //Prepare possible droppables
        if($.ui.ddmanager) {
            $.ui.ddmanager.current = this;
        }

        if ($.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
        }

        this.dragging = true;

        this.helper.addClass("ui-sortable-helper");
        this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
        return true;

    },

    _mouseDrag: function(event) {
        var i, item, itemElement, intersection,
            o = this.options,
            scrolled = false;

        //Compute the helpers position
        this.position = this._generatePosition(event);
        this.positionAbs = this._convertPositionTo("absolute");

        if (!this.lastPositionAbs) {
            this.lastPositionAbs = this.positionAbs;
        }

        //Do scrolling
        if(this.options.scroll) {
            if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

                if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                    this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                } else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                    this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                }

                if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                    this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                } else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                    this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                }

            } else {

                if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                    scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                    scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                }

                if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                    scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                    scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                }

            }

            if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
        }

        //Regenerate the absolute position used for position checks
        this.positionAbs = this._convertPositionTo("absolute");

        //Set the helper position
        if(!this.options.axis || this.options.axis !== "y") {
            this.helper[0].style.left = this.position.left+"px";
        }
        if(!this.options.axis || this.options.axis !== "x") {
            this.helper[0].style.top = this.position.top+"px";
        }

        //Rearrange
        for (i = this.items.length - 1; i >= 0; i--) {

            //Cache variables and intersection, continue if no intersection
            item = this.items[i];
            itemElement = item.item[0];
            intersection = this._intersectsWithPointer(item);
            if (!intersection) {
                continue;
            }

            // Only put the placeholder inside the current Container, skip all
            // items from other containers. This works because when moving
            // an item from one container to another the
            // currentContainer is switched before the placeholder is moved.
            //
            // Without this, moving items in "sub-sortables" can cause
            // the placeholder to jitter beetween the outer and inner container.
            if (item.instance !== this.currentContainer) {
                continue;
            }

            // cannot intersect with itself
            // no useless actions that have been done before
            // no action if the item moved is the parent of the item checked
            if (itemElement !== this.currentItem[0] &&
                this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                !$.contains(this.placeholder[0], itemElement) &&
                (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
            ) {

                this.direction = intersection === 1 ? "down" : "up";

                if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                    this._rearrange(event, item);
                } else {
                    break;
                }

                this._trigger("change", event, this._uiHash());
                break;
            }
        }

        //Post events to containers
        this._contactContainers(event);

        //Interconnect with droppables
        if($.ui.ddmanager) {
            $.ui.ddmanager.drag(this, event);
        }

        //Call callbacks
        this._trigger("sort", event, this._uiHash());

        this.lastPositionAbs = this.positionAbs;
        return false;

    },

    _mouseStop: function(event, noPropagation) {

        if(!event) {
            return;
        }

        //If we are using droppables, inform the manager about the drop
        if ($.ui.ddmanager && !this.options.dropBehaviour) {
            $.ui.ddmanager.drop(this, event);
        }

        if(this.options.revert) {
            var that = this,
                cur = this.placeholder.offset(),
                axis = this.options.axis,
                animation = {};

            if ( !axis || axis === "x" ) {
                animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
            }
            if ( !axis || axis === "y" ) {
                animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
            }
            this.reverting = true;
            $(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
                that._clear(event);
            });
        } else {
            this._clear(event, noPropagation);
        }

        return false;

    },

    cancel: function() {

        if(this.dragging) {

            this._mouseUp({ target: null });

            if(this.options.helper === "original") {
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            //Post deactivating events to containers
            for (var i = this.containers.length - 1; i >= 0; i--){
                this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                if(this.containers[i].containerCache.over) {
                    this.containers[i]._trigger("out", null, this._uiHash(this));
                    this.containers[i].containerCache.over = 0;
                }
            }

        }

        if (this.placeholder) {
            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            if(this.placeholder[0].parentNode) {
                this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            }
            if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                this.helper.remove();
            }

            $.extend(this, {
                helper: null,
                dragging: false,
                reverting: false,
                _noFinalSort: null
            });

            if(this.domPosition.prev) {
                $(this.domPosition.prev).after(this.currentItem);
            } else {
                $(this.domPosition.parent).prepend(this.currentItem);
            }
        }

        return this;

    },

    serialize: function(o) {

        var items = this._getItemsAsjQuery(o && o.connected),
            str = [];
        o = o || {};

        $(items).each(function() {
            var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
            if (res) {
                str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
            }
        });

        if(!str.length && o.key) {
            str.push(o.key + "=");
        }

        return str.join("&");

    },

    toArray: function(o) {

        var items = this._getItemsAsjQuery(o && o.connected),
            ret = [];

        o = o || {};

        items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
        return ret;

    },

    /* Be careful with the following core functions */
    _intersectsWith: function(item) {

        var x1 = this.positionAbs.left,
            x2 = x1 + this.helperProportions.width,
            y1 = this.positionAbs.top,
            y2 = y1 + this.helperProportions.height,
            l = item.left,
            r = l + item.width,
            t = item.top,
            b = t + item.height,
            dyClick = this.offset.click.top,
            dxClick = this.offset.click.left,
            isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
            isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
            isOverElement = isOverElementHeight && isOverElementWidth;

        if ( this.options.tolerance === "pointer" ||
            this.options.forcePointerForContainers ||
            (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
        ) {
            return isOverElement;
        } else {

            return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                x2 - (this.helperProportions.width / 2) < r && // Left Half
                t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                y2 - (this.helperProportions.height / 2) < b ); // Top Half

        }
    },

    _intersectsWithPointer: function(item) {

        var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
            isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
            isOverElement = isOverElementHeight && isOverElementWidth,
            verticalDirection = this._getDragVerticalDirection(),
            horizontalDirection = this._getDragHorizontalDirection();

        if (!isOverElement) {
            return false;
        }

        return this.floating ?
            ( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
            : ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

    },

    _intersectsWithSides: function(item) {

        var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
            isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
            verticalDirection = this._getDragVerticalDirection(),
            horizontalDirection = this._getDragHorizontalDirection();

        if (this.floating && horizontalDirection) {
            return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
        } else {
            return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
        }

    },

    _getDragVerticalDirection: function() {
        var delta = this.positionAbs.top - this.lastPositionAbs.top;
        return delta !== 0 && (delta > 0 ? "down" : "up");
    },

    _getDragHorizontalDirection: function() {
        var delta = this.positionAbs.left - this.lastPositionAbs.left;
        return delta !== 0 && (delta > 0 ? "right" : "left");
    },

    refresh: function(event) {
        this._refreshItems(event);
        this.refreshPositions();
        return this;
    },

    _connectWith: function() {
        var options = this.options;
        return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
    },

    _getItemsAsjQuery: function(connected) {

        var i, j, cur, inst,
            items = [],
            queries = [],
            connectWith = this._connectWith();

        if(connectWith && connected) {
            for (i = connectWith.length - 1; i >= 0; i--){
                cur = $(connectWith[i]);
                for ( j = cur.length - 1; j >= 0; j--){
                    inst = $.data(cur[j], this.widgetFullName);
                    if(inst && inst !== this && !inst.options.disabled) {
                        queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                    }
                }
            }
        }

        queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

        function addItems() {
            items.push( this );
        }
        for (i = queries.length - 1; i >= 0; i--){
            queries[i][0].each( addItems );
        }

        return $(items);

    },

    _removeCurrentsFromItems: function() {

        var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

        this.items = $.grep(this.items, function (item) {
            for (var j=0; j < list.length; j++) {
                if(list[j] === item.item[0]) {
                    return false;
                }
            }
            return true;
        });

    },

    _refreshItems: function(event) {

        this.items = [];
        this.containers = [this];

        var i, j, cur, inst, targetData, _queries, item, queriesLength,
            items = this.items,
            queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
            connectWith = this._connectWith();

        if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
            for (i = connectWith.length - 1; i >= 0; i--){
                cur = $(connectWith[i]);
                for (j = cur.length - 1; j >= 0; j--){
                    inst = $.data(cur[j], this.widgetFullName);
                    if(inst && inst !== this && !inst.options.disabled) {
                        queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                        this.containers.push(inst);
                    }
                }
            }
        }

        for (i = queries.length - 1; i >= 0; i--) {
            targetData = queries[i][1];
            _queries = queries[i][0];

            for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
                item = $(_queries[j]);

                item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

                items.push({
                    item: item,
                    instance: targetData,
                    width: 0, height: 0,
                    left: 0, top: 0
                });
            }
        }

    },

    refreshPositions: function(fast) {

        //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
        if(this.offsetParent && this.helper) {
            this.offset.parent = this._getParentOffset();
        }

        var i, item, t, p;

        for (i = this.items.length - 1; i >= 0; i--){
            item = this.items[i];

            //We ignore calculating positions of all connected containers when we're not over them
            if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                continue;
            }

            t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

            if (!fast) {
                item.width = t.outerWidth();
                item.height = t.outerHeight();
            }

            p = t.offset();
            item.left = p.left;
            item.top = p.top;
        }

        if(this.options.custom && this.options.custom.refreshContainers) {
            this.options.custom.refreshContainers.call(this);
        } else {
            for (i = this.containers.length - 1; i >= 0; i--){
                p = this.containers[i].element.offset();
                this.containers[i].containerCache.left = p.left;
                this.containers[i].containerCache.top = p.top;
                this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
            }
        }

        return this;
    },

    _createPlaceholder: function(that) {
        that = that || this;
        var className,
            o = that.options;

        if(!o.placeholder || o.placeholder.constructor === String) {
            className = o.placeholder;
            o.placeholder = {
                element: function() {

                    var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                        element = $( "<" + nodeName + ">", that.document[0] )
                            .addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
                            .removeClass("ui-sortable-helper");

                    if ( nodeName === "tr" ) {
                        that.currentItem.children().each(function() {
                            $( "<td>&#160;</td>", that.document[0] )
                                .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
                                .appendTo( element );
                        });
                    } else if ( nodeName === "img" ) {
                        element.attr( "src", that.currentItem.attr( "src" ) );
                    }

                    if ( !className ) {
                        element.css( "visibility", "hidden" );
                    }

                    return element;
                },
                update: function(container, p) {

                    // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                    // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                    if(className && !o.forcePlaceholderSize) {
                        return;
                    }

                    //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                    if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
                    if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
                }
            };
        }

        //Create the placeholder
        that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

        //Append it after the actual current item
        that.currentItem.after(that.placeholder);

        //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
        o.placeholder.update(that, that.placeholder);

    },

    _contactContainers: function(event) {
        var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,
            innermostContainer = null,
            innermostIndex = null;

        // get innermost container that intersects with item
        for (i = this.containers.length - 1; i >= 0; i--) {

            // never consider a container that's located within the item itself
            if($.contains(this.currentItem[0], this.containers[i].element[0])) {
                continue;
            }

            if(this._intersectsWith(this.containers[i].containerCache)) {

                // if we've already found a container and it's more "inner" than this, then continue
                if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                    continue;
                }

                innermostContainer = this.containers[i];
                innermostIndex = i;

            } else {
                // container doesn't intersect. trigger "out" event if necessary
                if(this.containers[i].containerCache.over) {
                    this.containers[i]._trigger("out", event, this._uiHash(this));
                    this.containers[i].containerCache.over = 0;
                }
            }

        }

        // if no intersecting containers found, return
        if(!innermostContainer) {
            return;
        }

        // move the item into the container if it's not there already
        if(this.containers.length === 1) {
            if (!this.containers[innermostIndex].containerCache.over) {
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }
        } else {

            //When entering a new container, we will find the item with the least distance and append our item near it
            dist = 10000;
            itemWithLeastDistance = null;
            floating = innermostContainer.floating || isFloating(this.currentItem);
            posProperty = floating ? "left" : "top";
            sizeProperty = floating ? "width" : "height";
            base = this.positionAbs[posProperty] + this.offset.click[posProperty];
            for (j = this.items.length - 1; j >= 0; j--) {
                if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                    continue;
                }
                if(this.items[j].item[0] === this.currentItem[0]) {
                    continue;
                }
                if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
                    continue;
                }
                cur = this.items[j].item.offset()[posProperty];
                nearBottom = false;
                if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){
                    nearBottom = true;
                    cur += this.items[j][sizeProperty];
                }

                if(Math.abs(cur - base) < dist) {
                    dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
                    this.direction = nearBottom ? "up": "down";
                }
            }

            //Check if dropOnEmpty is enabled
            if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
                return;
            }

            if(this.currentContainer === this.containers[innermostIndex]) {
                return;
            }

            itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
            this._trigger("change", event, this._uiHash());
            this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
            this.currentContainer = this.containers[innermostIndex];

            //Update the placeholder
            this.options.placeholder.update(this.currentContainer, this.placeholder);

            this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
            this.containers[innermostIndex].containerCache.over = 1;
        }


    },

    _createHelper: function(event) {

        var o = this.options,
            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

        //Add the helper to the DOM if that didn't happen already
        if(!helper.parents("body").length) {
            $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
        }

        if(helper[0] === this.currentItem[0]) {
            this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
        }

        if(!helper[0].style.width || o.forceHelperSize) {
            helper.width(this.currentItem.width());
        }
        if(!helper[0].style.height || o.forceHelperSize) {
            helper.height(this.currentItem.height());
        }

        return helper;

    },

    _adjustOffsetFromHelper: function(obj) {
        if (typeof obj === "string") {
            obj = obj.split(" ");
        }
        if ($.isArray(obj)) {
            obj = {left: +obj[0], top: +obj[1] || 0};
        }
        if ("left" in obj) {
            this.offset.click.left = obj.left + this.margins.left;
        }
        if ("right" in obj) {
            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }
        if ("top" in obj) {
            this.offset.click.top = obj.top + this.margins.top;
        }
        if ("bottom" in obj) {
            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
    },

    _getParentOffset: function() {


        //Get the offsetParent and cache its position
        this.offsetParent = this.helper.offsetParent();
        var po = this.offsetParent.offset();

        // This is a special case where we need to modify a offset calculated on start, since the following happened:
        // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
        //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
        if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
            po.left += this.scrollParent.scrollLeft();
            po.top += this.scrollParent.scrollTop();
        }

        // This needs to be actually done for all browsers, since pageX/pageY includes this information
        // with an ugly IE fix
        if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
            po = { top: 0, left: 0 };
        }

        return {
            top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
            left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
        };

    },

    _getRelativeOffset: function() {

        if(this.cssPosition === "relative") {
            var p = this.currentItem.position();
            return {
                top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
                left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
            };
        } else {
            return { top: 0, left: 0 };
        }

    },

    _cacheMargins: function() {
        this.margins = {
            left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
            top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
        };
    },

    _cacheHelperProportions: function() {
        this.helperProportions = {
            width: this.helper.outerWidth(),
            height: this.helper.outerHeight()
        };
    },

    _setContainment: function() {

        var ce, co, over,
            o = this.options;
        if(o.containment === "parent") {
            o.containment = this.helper[0].parentNode;
        }
        if(o.containment === "document" || o.containment === "window") {
            this.containment = [
                0 - this.offset.relative.left - this.offset.parent.left,
                0 - this.offset.relative.top - this.offset.parent.top,
                $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
            ];
        }

        if(!(/^(document|window|parent)$/).test(o.containment)) {
            ce = $(o.containment)[0];
            co = $(o.containment).offset();
            over = ($(ce).css("overflow") !== "hidden");

            this.containment = [
                co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
                co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
                co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
                co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
            ];
        }

    },

    _convertPositionTo: function(d, pos) {

        if(!pos) {
            pos = this.position;
        }
        var mod = d === "absolute" ? 1 : -1,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

        return {
            top: (
                pos.top +                                                               // The absolute mouse position
                this.offset.relative.top * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top * mod -                                          // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
            ),
            left: (
                pos.left +                                                              // The absolute mouse position
                this.offset.relative.left * mod +                                       // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left * mod   -                                       // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
            )
        };

    },

    _generatePosition: function(event) {

        var top, left,
            o = this.options,
            pageX = event.pageX,
            pageY = event.pageY,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

        // This is another very weird special case that only happens for relative elements:
        // 1. If the css position is relative
        // 2. and the scroll parent is the document or similar to the offset parent
        // we have to refresh the relative offset during the scroll so there are no jumps
        if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
            this.offset.relative = this._getRelativeOffset();
        }

        /*
         * - Position constraining -
         * Constrain the position to a mix of grid, containment.
         */

        if(this.originalPosition) { //If we are not dragging yet, we won't check for options

            if(this.containment) {
                if(event.pageX - this.offset.click.left < this.containment[0]) {
                    pageX = this.containment[0] + this.offset.click.left;
                }
                if(event.pageY - this.offset.click.top < this.containment[1]) {
                    pageY = this.containment[1] + this.offset.click.top;
                }
                if(event.pageX - this.offset.click.left > this.containment[2]) {
                    pageX = this.containment[2] + this.offset.click.left;
                }
                if(event.pageY - this.offset.click.top > this.containment[3]) {
                    pageY = this.containment[3] + this.offset.click.top;
                }
            }

            if(o.grid) {
                top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
            }

        }

        return {
            top: (
                pageY -                                                             // The absolute mouse position
                this.offset.click.top -                                                 // Click offset (relative to the element)
                this.offset.relative.top    -                                           // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top +                                                // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
            ),
            left: (
                pageX -                                                             // The absolute mouse position
                this.offset.click.left -                                                // Click offset (relative to the element)
                this.offset.relative.left   -                                           // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left +                                               // The offsetParent's offset without borders (offset + border)
                ( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
            )
        };

    },

    _rearrange: function(event, i, a, hardRefresh) {

        a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

        //Various things done here to improve the performance:
        // 1. we create a setTimeout, that calls refreshPositions
        // 2. on the instance, we have a counter variable, that get's higher after every append
        // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
        // 4. this lets only the last addition to the timeout stack through
        this.counter = this.counter ? ++this.counter : 1;
        var counter = this.counter;

        this._delay(function() {
            if(counter === this.counter) {
                this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
            }
        });

    },

    _clear: function(event, noPropagation) {

        this.reverting = false;
        // We delay all events that have to be triggered to after the point where the placeholder has been removed and
        // everything else normalized again
        var i,
            delayedTriggers = [];

        // We first have to update the dom position of the actual currentItem
        // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
        if(!this._noFinalSort && this.currentItem.parent().length) {
            this.placeholder.before(this.currentItem);
        }
        this._noFinalSort = null;

        if(this.helper[0] === this.currentItem[0]) {
            for(i in this._storedCSS) {
                if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                    this._storedCSS[i] = "";
                }
            }
            this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
        } else {
            this.currentItem.show();
        }

        if(this.fromOutside && !noPropagation) {
            delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
        }
        if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
            delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
        }

        // Check if the items Container has Changed and trigger appropriate
        // events.
        if (this !== this.currentContainer) {
            if(!noPropagation) {
                delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
                delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
                delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
            }
        }


        //Post events to containers
        function delayEvent( type, instance, container ) {
            return function( event ) {
                container._trigger( type, event, instance._uiHash( instance ) );
            };
        }
        for (i = this.containers.length - 1; i >= 0; i--){
            if (!noPropagation) {
                delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
            }
            if(this.containers[i].containerCache.over) {
                delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
                this.containers[i].containerCache.over = 0;
            }
        }

        //Do what was originally in plugins
        if ( this.storedCursor ) {
            this.document.find( "body" ).css( "cursor", this.storedCursor );
            this.storedStylesheet.remove();
        }
        if(this._storedOpacity) {
            this.helper.css("opacity", this._storedOpacity);
        }
        if(this._storedZIndex) {
            this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
        }

        this.dragging = false;
        if(this.cancelHelperRemoval) {
            if(!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
                for (i=0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                } //Trigger all delayed events
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return false;
        }

        if(!noPropagation) {
            this._trigger("beforeStop", event, this._uiHash());
        }

        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

        if(this.helper[0] !== this.currentItem[0]) {
            this.helper.remove();
        }
        this.helper = null;

        if(!noPropagation) {
            for (i=0; i < delayedTriggers.length; i++) {
                delayedTriggers[i].call(this, event);
            } //Trigger all delayed events
            this._trigger("stop", event, this._uiHash());
        }

        this.fromOutside = false;
        return true;

    },

    _trigger: function() {
        if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
            this.cancel();
        }
    },

    _uiHash: function(_inst) {
        var inst = _inst || this;
        return {
            helper: inst.helper,
            placeholder: inst.placeholder || $([]),
            position: inst.position,
            originalPosition: inst.originalPosition,
            offset: inst.positionAbs,
            item: inst.currentItem,
            sender: _inst ? _inst.element : null
        };
    }

});

})(jQuery);

(function($, undefined) {

var dataSpace = "ui-effects-";

$.effects = {
    effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

    var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

    // plusequals test for += 100 -= 100
    rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
    // a set of RE's that can match strings and generate color tuples.
    stringParsers = [{
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ],
                    execResult[ 3 ],
                    execResult[ 4 ]
                ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function( execResult ) {
                return [
                    execResult[ 1 ] * 2.55,
                    execResult[ 2 ] * 2.55,
                    execResult[ 3 ] * 2.55,
                    execResult[ 4 ]
                ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ], 16 )
                ];
            }
        }, {
            // this regex ignores A-F because it's compared against an already lowercased string
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function( execResult ) {
                return [
                    parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
                    parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
                    parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
                ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function( execResult ) {
                return [
                    execResult[ 1 ],
                    execResult[ 2 ] / 100,
                    execResult[ 3 ] / 100,
                    execResult[ 4 ]
                ];
            }
        }],

    // jQuery.Color( )
    color = jQuery.Color = function( color, green, blue, alpha ) {
        return new jQuery.Color.fn.parse( color, green, blue, alpha );
    },
    spaces = {
        rgba: {
            props: {
                red: {
                    idx: 0,
                    type: "byte"
                },
                green: {
                    idx: 1,
                    type: "byte"
                },
                blue: {
                    idx: 2,
                    type: "byte"
                }
            }
        },

        hsla: {
            props: {
                hue: {
                    idx: 0,
                    type: "degrees"
                },
                saturation: {
                    idx: 1,
                    type: "percent"
                },
                lightness: {
                    idx: 2,
                    type: "percent"
                }
            }
        }
    },
    propTypes = {
        "byte": {
            floor: true,
            max: 255
        },
        "percent": {
            max: 1
        },
        "degrees": {
            mod: 360,
            floor: true
        }
    },
    support = color.support = {},

    // element for support tests
    supportElem = jQuery( "<p>" )[ 0 ],

    // colors = jQuery.Color.names
    colors,

    // local aliases of functions called often
    each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
    space.cache = "_" + spaceName;
    space.props.alpha = {
        idx: 3,
        type: "percent",
        def: 1
    };
});

function clamp( value, prop, allowEmpty ) {
    var type = propTypes[ prop.type ] || {};

    if ( value == null ) {
        return (allowEmpty || !prop.def) ? null : prop.def;
    }

    // ~~ is an short way of doing floor for positive numbers
    value = type.floor ? ~~value : parseFloat( value );

    // IE will pass in empty strings as value for alpha,
    // which will hit this case
    if ( isNaN( value ) ) {
        return prop.def;
    }

    if ( type.mod ) {
        // we add mod before modding to make sure that negatives values
        // get converted properly: -10 -> 350
        return (value + type.mod) % type.mod;
    }

    // for now all property types without mod have min and max
    return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
    var inst = color(),
        rgba = inst._rgba = [];

    string = string.toLowerCase();

    each( stringParsers, function( i, parser ) {
        var parsed,
            match = parser.re.exec( string ),
            values = match && parser.parse( match ),
            spaceName = parser.space || "rgba";

        if ( values ) {
            parsed = inst[ spaceName ]( values );

            // if this was an rgba parse the assignment might happen twice
            // oh well....
            inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
            rgba = inst._rgba = parsed._rgba;

            // exit each( stringParsers ) here because we matched
            return false;
        }
    });

    // Found a stringParser that handled it
    if ( rgba.length ) {

        // if this came from a parsed string, force "transparent" when alpha is 0
        // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
        if ( rgba.join() === "0,0,0,0" ) {
            jQuery.extend( rgba, colors.transparent );
        }
        return inst;
    }

    // named colors
    return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
    parse: function( red, green, blue, alpha ) {
        if ( red === undefined ) {
            this._rgba = [ null, null, null, null ];
            return this;
        }
        if ( red.jquery || red.nodeType ) {
            red = jQuery( red ).css( green );
            green = undefined;
        }

        var inst = this,
            type = jQuery.type( red ),
            rgba = this._rgba = [];

        // more than 1 argument specified - assume ( red, green, blue, alpha )
        if ( green !== undefined ) {
            red = [ red, green, blue, alpha ];
            type = "array";
        }

        if ( type === "string" ) {
            return this.parse( stringParse( red ) || colors._default );
        }

        if ( type === "array" ) {
            each( spaces.rgba.props, function( key, prop ) {
                rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
            });
            return this;
        }

        if ( type === "object" ) {
            if ( red instanceof color ) {
                each( spaces, function( spaceName, space ) {
                    if ( red[ space.cache ] ) {
                        inst[ space.cache ] = red[ space.cache ].slice();
                    }
                });
            } else {
                each( spaces, function( spaceName, space ) {
                    var cache = space.cache;
                    each( space.props, function( key, prop ) {

                        // if the cache doesn't exist, and we know how to convert
                        if ( !inst[ cache ] && space.to ) {

                            // if the value was null, we don't need to copy it
                            // if the key was alpha, we don't need to copy it either
                            if ( key === "alpha" || red[ key ] == null ) {
                                return;
                            }
                            inst[ cache ] = space.to( inst._rgba );
                        }

                        // this is the only case where we allow nulls for ALL properties.
                        // call clamp with alwaysAllowEmpty
                        inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
                    });

                    // everything defined but alpha?
                    if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
                        // use the default of 1
                        inst[ cache ][ 3 ] = 1;
                        if ( space.from ) {
                            inst._rgba = space.from( inst[ cache ] );
                        }
                    }
                });
            }
            return this;
        }
    },
    is: function( compare ) {
        var is = color( compare ),
            same = true,
            inst = this;

        each( spaces, function( _, space ) {
            var localCache,
                isCache = is[ space.cache ];
            if (isCache) {
                localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
                each( space.props, function( _, prop ) {
                    if ( isCache[ prop.idx ] != null ) {
                        same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
                        return same;
                    }
                });
            }
            return same;
        });
        return same;
    },
    _space: function() {
        var used = [],
            inst = this;
        each( spaces, function( spaceName, space ) {
            if ( inst[ space.cache ] ) {
                used.push( spaceName );
            }
        });
        return used.pop();
    },
    transition: function( other, distance ) {
        var end = color( other ),
            spaceName = end._space(),
            space = spaces[ spaceName ],
            startColor = this.alpha() === 0 ? color( "transparent" ) : this,
            start = startColor[ space.cache ] || space.to( startColor._rgba ),
            result = start.slice();

        end = end[ space.cache ];
        each( space.props, function( key, prop ) {
            var index = prop.idx,
                startValue = start[ index ],
                endValue = end[ index ],
                type = propTypes[ prop.type ] || {};

            // if null, don't override start value
            if ( endValue === null ) {
                return;
            }
            // if null - use end
            if ( startValue === null ) {
                result[ index ] = endValue;
            } else {
                if ( type.mod ) {
                    if ( endValue - startValue > type.mod / 2 ) {
                        startValue += type.mod;
                    } else if ( startValue - endValue > type.mod / 2 ) {
                        startValue -= type.mod;
                    }
                }
                result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
            }
        });
        return this[ spaceName ]( result );
    },
    blend: function( opaque ) {
        // if we are already opaque - return ourself
        if ( this._rgba[ 3 ] === 1 ) {
            return this;
        }

        var rgb = this._rgba.slice(),
            a = rgb.pop(),
            blend = color( opaque )._rgba;

        return color( jQuery.map( rgb, function( v, i ) {
            return ( 1 - a ) * blend[ i ] + a * v;
        }));
    },
    toRgbaString: function() {
        var prefix = "rgba(",
            rgba = jQuery.map( this._rgba, function( v, i ) {
                return v == null ? ( i > 2 ? 1 : 0 ) : v;
            });

        if ( rgba[ 3 ] === 1 ) {
            rgba.pop();
            prefix = "rgb(";
        }

        return prefix + rgba.join() + ")";
    },
    toHslaString: function() {
        var prefix = "hsla(",
            hsla = jQuery.map( this.hsla(), function( v, i ) {
                if ( v == null ) {
                    v = i > 2 ? 1 : 0;
                }

                // catch 1 and 2
                if ( i && i < 3 ) {
                    v = Math.round( v * 100 ) + "%";
                }
                return v;
            });

        if ( hsla[ 3 ] === 1 ) {
            hsla.pop();
            prefix = "hsl(";
        }
        return prefix + hsla.join() + ")";
    },
    toHexString: function( includeAlpha ) {
        var rgba = this._rgba.slice(),
            alpha = rgba.pop();

        if ( includeAlpha ) {
            rgba.push( ~~( alpha * 255 ) );
        }

        return "#" + jQuery.map( rgba, function( v ) {

            // default to 0 when nulls exist
            v = ( v || 0 ).toString( 16 );
            return v.length === 1 ? "0" + v : v;
        }).join("");
    },
    toString: function() {
        return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
    }
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
    h = ( h + 1 ) % 1;
    if ( h * 6 < 1 ) {
        return p + (q - p) * h * 6;
    }
    if ( h * 2 < 1) {
        return q;
    }
    if ( h * 3 < 2 ) {
        return p + (q - p) * ((2/3) - h) * 6;
    }
    return p;
}

spaces.hsla.to = function ( rgba ) {
    if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
        return [ null, null, null, rgba[ 3 ] ];
    }
    var r = rgba[ 0 ] / 255,
        g = rgba[ 1 ] / 255,
        b = rgba[ 2 ] / 255,
        a = rgba[ 3 ],
        max = Math.max( r, g, b ),
        min = Math.min( r, g, b ),
        diff = max - min,
        add = max + min,
        l = add * 0.5,
        h, s;

    if ( min === max ) {
        h = 0;
    } else if ( r === max ) {
        h = ( 60 * ( g - b ) / diff ) + 360;
    } else if ( g === max ) {
        h = ( 60 * ( b - r ) / diff ) + 120;
    } else {
        h = ( 60 * ( r - g ) / diff ) + 240;
    }

    // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
    // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
    if ( diff === 0 ) {
        s = 0;
    } else if ( l <= 0.5 ) {
        s = diff / add;
    } else {
        s = diff / ( 2 - add );
    }
    return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
    if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
        return [ null, null, null, hsla[ 3 ] ];
    }
    var h = hsla[ 0 ] / 360,
        s = hsla[ 1 ],
        l = hsla[ 2 ],
        a = hsla[ 3 ],
        q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
        p = 2 * l - q;

    return [
        Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
        Math.round( hue2rgb( p, q, h ) * 255 ),
        Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
        a
    ];
};


each( spaces, function( spaceName, space ) {
    var props = space.props,
        cache = space.cache,
        to = space.to,
        from = space.from;

    // makes rgba() and hsla()
    color.fn[ spaceName ] = function( value ) {

        // generate a cache for this space if it doesn't exist
        if ( to && !this[ cache ] ) {
            this[ cache ] = to( this._rgba );
        }
        if ( value === undefined ) {
            return this[ cache ].slice();
        }

        var ret,
            type = jQuery.type( value ),
            arr = ( type === "array" || type === "object" ) ? value : arguments,
            local = this[ cache ].slice();

        each( props, function( key, prop ) {
            var val = arr[ type === "object" ? key : prop.idx ];
            if ( val == null ) {
                val = local[ prop.idx ];
            }
            local[ prop.idx ] = clamp( val, prop );
        });

        if ( from ) {
            ret = color( from( local ) );
            ret[ cache ] = local;
            return ret;
        } else {
            return color( local );
        }
    };

    // makes red() green() blue() alpha() hue() saturation() lightness()
    each( props, function( key, prop ) {
        // alpha is included in more than one space
        if ( color.fn[ key ] ) {
            return;
        }
        color.fn[ key ] = function( value ) {
            var vtype = jQuery.type( value ),
                fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
                local = this[ fn ](),
                cur = local[ prop.idx ],
                match;

            if ( vtype === "undefined" ) {
                return cur;
            }

            if ( vtype === "function" ) {
                value = value.call( this, cur );
                vtype = jQuery.type( value );
            }
            if ( value == null && prop.empty ) {
                return this;
            }
            if ( vtype === "string" ) {
                match = rplusequals.exec( value );
                if ( match ) {
                    value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
                }
            }
            local[ prop.idx ] = value;
            return this[ fn ]( local );
        };
    });
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
    var hooks = hook.split( " " );
    each( hooks, function( i, hook ) {
        jQuery.cssHooks[ hook ] = {
            set: function( elem, value ) {
                var parsed, curElem,
                    backgroundColor = "";

                if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
                    value = color( parsed || value );
                    if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
                        curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                        while (
                            (backgroundColor === "" || backgroundColor === "transparent") &&
                            curElem && curElem.style
                        ) {
                            try {
                                backgroundColor = jQuery.css( curElem, "backgroundColor" );
                                curElem = curElem.parentNode;
                            } catch ( e ) {
                            }
                        }

                        value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
                            backgroundColor :
                            "_default" );
                    }

                    value = value.toRgbaString();
                }
                try {
                    elem.style[ hook ] = value;
                } catch( e ) {
                    // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                }
            }
        };
        jQuery.fx.step[ hook ] = function( fx ) {
            if ( !fx.colorInit ) {
                fx.start = color( fx.elem, hook );
                fx.end = color( fx.end );
                fx.colorInit = true;
            }
            jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
        };
    });

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
    expand: function( value ) {
        var expanded = {};

        each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
            expanded[ "border" + part + "Color" ] = value;
        });
        return expanded;
    }
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
    // 4.1. Basic color keywords
    aqua: "#00ffff",
    black: "#000000",
    blue: "#0000ff",
    fuchsia: "#ff00ff",
    gray: "#808080",
    green: "#008000",
    lime: "#00ff00",
    maroon: "#800000",
    navy: "#000080",
    olive: "#808000",
    purple: "#800080",
    red: "#ff0000",
    silver: "#c0c0c0",
    teal: "#008080",
    white: "#ffffff",
    yellow: "#ffff00",

    // 4.2.3. "transparent" color keyword
    transparent: [ null, null, null, 0 ],

    _default: "#ffffff"
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
    shorthandStyles = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
    };

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
    $.fx.step[ prop ] = function( fx ) {
        if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
            jQuery.style( fx.elem, prop, fx.end );
            fx.setAttr = true;
        }
    };
});

function getElementStyles( elem ) {
    var key, len,
        style = elem.ownerDocument.defaultView ?
            elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
            elem.currentStyle,
        styles = {};

    if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
        len = style.length;
        while ( len-- ) {
            key = style[ len ];
            if ( typeof style[ key ] === "string" ) {
                styles[ $.camelCase( key ) ] = style[ key ];
            }
        }
    // support: Opera, IE <9
    } else {
        for ( key in style ) {
            if ( typeof style[ key ] === "string" ) {
                styles[ key ] = style[ key ];
            }
        }
    }

    return styles;
}


function styleDifference( oldStyle, newStyle ) {
    var diff = {},
        name, value;

    for ( name in newStyle ) {
        value = newStyle[ name ];
        if ( oldStyle[ name ] !== value ) {
            if ( !shorthandStyles[ name ] ) {
                if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
                    diff[ name ] = value;
                }
            }
        }
    }

    return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
    $.fn.addBack = function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter( selector )
        );
    };
}

$.effects.animateClass = function( value, duration, easing, callback ) {
    var o = $.speed( duration, easing, callback );

    return this.queue( function() {
        var animated = $( this ),
            baseClass = animated.attr( "class" ) || "",
            applyClassChange,
            allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

        // map the animated objects to store the original styles.
        allAnimations = allAnimations.map(function() {
            var el = $( this );
            return {
                el: el,
                start: getElementStyles( this )
            };
        });

        // apply class change
        applyClassChange = function() {
            $.each( classAnimationActions, function(i, action) {
                if ( value[ action ] ) {
                    animated[ action + "Class" ]( value[ action ] );
                }
            });
        };
        applyClassChange();

        // map all animated objects again - calculate new styles and diff
        allAnimations = allAnimations.map(function() {
            this.end = getElementStyles( this.el[ 0 ] );
            this.diff = styleDifference( this.start, this.end );
            return this;
        });

        // apply original class
        animated.attr( "class", baseClass );

        // map all animated objects again - this time collecting a promise
        allAnimations = allAnimations.map(function() {
            var styleInfo = this,
                dfd = $.Deferred(),
                opts = $.extend({}, o, {
                    queue: false,
                    complete: function() {
                        dfd.resolve( styleInfo );
                    }
                });

            this.el.animate( this.diff, opts );
            return dfd.promise();
        });

        // once all animations have completed:
        $.when.apply( $, allAnimations.get() ).done(function() {

            // set the final class
            applyClassChange();

            // for each animated element,
            // clear all css properties that were animated
            $.each( arguments, function() {
                var el = this.el;
                $.each( this.diff, function(key) {
                    el.css( key, "" );
                });
            });

            // this is guarnteed to be there if you use jQuery.speed()
            // it also handles dequeuing the next anim...
            o.complete.call( animated[ 0 ] );
        });
    });
};

$.fn.extend({
    addClass: (function( orig ) {
        return function( classNames, speed, easing, callback ) {
            return speed ?
                $.effects.animateClass.call( this,
                    { add: classNames }, speed, easing, callback ) :
                orig.apply( this, arguments );
        };
    })( $.fn.addClass ),

    removeClass: (function( orig ) {
        return function( classNames, speed, easing, callback ) {
            return arguments.length > 1 ?
                $.effects.animateClass.call( this,
                    { remove: classNames }, speed, easing, callback ) :
                orig.apply( this, arguments );
        };
    })( $.fn.removeClass ),

    toggleClass: (function( orig ) {
        return function( classNames, force, speed, easing, callback ) {
            if ( typeof force === "boolean" || force === undefined ) {
                if ( !speed ) {
                    // without speed parameter
                    return orig.apply( this, arguments );
                } else {
                    return $.effects.animateClass.call( this,
                        (force ? { add: classNames } : { remove: classNames }),
                        speed, easing, callback );
                }
            } else {
                // without force parameter
                return $.effects.animateClass.call( this,
                    { toggle: classNames }, force, speed, easing );
            }
        };
    })( $.fn.toggleClass ),

    switchClass: function( remove, add, speed, easing, callback) {
        return $.effects.animateClass.call( this, {
            add: add,
            remove: remove
        }, speed, easing, callback );
    }
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
    version: "1.10.4",

    // Saves a set of properties in a data storage
    save: function( element, set ) {
        for( var i=0; i < set.length; i++ ) {
            if ( set[ i ] !== null ) {
                element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
            }
        }
    },

    // Restores a set of previously saved properties from a data storage
    restore: function( element, set ) {
        var val, i;
        for( i=0; i < set.length; i++ ) {
            if ( set[ i ] !== null ) {
                val = element.data( dataSpace + set[ i ] );
                // support: jQuery 1.6.2
                // http://bugs.jquery.com/ticket/9917
                // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                // We can't differentiate between "" and 0 here, so we just assume
                // empty string since it's likely to be a more common value...
                if ( val === undefined ) {
                    val = "";
                }
                element.css( set[ i ], val );
            }
        }
    },

    setMode: function( el, mode ) {
        if (mode === "toggle") {
            mode = el.is( ":hidden" ) ? "show" : "hide";
        }
        return mode;
    },

    // Translates a [top,left] array into a baseline value
    // this should be a little more flexible in the future to handle a string & hash
    getBaseline: function( origin, original ) {
        var y, x;
        switch ( origin[ 0 ] ) {
            case "top": y = 0; break;
            case "middle": y = 0.5; break;
            case "bottom": y = 1; break;
            default: y = origin[ 0 ] / original.height;
        }
        switch ( origin[ 1 ] ) {
            case "left": x = 0; break;
            case "center": x = 0.5; break;
            case "right": x = 1; break;
            default: x = origin[ 1 ] / original.width;
        }
        return {
            x: x,
            y: y
        };
    },

    // Wraps the element around a wrapper that copies position properties
    createWrapper: function( element ) {

        // if the element is already wrapped, return it
        if ( element.parent().is( ".ui-effects-wrapper" )) {
            return element.parent();
        }

        // wrap the element
        var props = {
                width: element.outerWidth(true),
                height: element.outerHeight(true),
                "float": element.css( "float" )
            },
            wrapper = $( "<div></div>" )
                .addClass( "ui-effects-wrapper" )
                .css({
                    fontSize: "100%",
                    background: "transparent",
                    border: "none",
                    margin: 0,
                    padding: 0
                }),
            // Store the size in case width/height are defined in % - Fixes #5245
            size = {
                width: element.width(),
                height: element.height()
            },
            active = document.activeElement;

        // support: Firefox
        // Firefox incorrectly exposes anonymous content
        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
        try {
            active.id;
        } catch( e ) {
            active = document.body;
        }

        element.wrap( wrapper );

        // Fixes #7595 - Elements lose focus when wrapped.
        if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
            $( active ).focus();
        }

        wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

        // transfer positioning properties to the wrapper
        if ( element.css( "position" ) === "static" ) {
            wrapper.css({ position: "relative" });
            element.css({ position: "relative" });
        } else {
            $.extend( props, {
                position: element.css( "position" ),
                zIndex: element.css( "z-index" )
            });
            $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                props[ pos ] = element.css( pos );
                if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
                    props[ pos ] = "auto";
                }
            });
            element.css({
                position: "relative",
                top: 0,
                left: 0,
                right: "auto",
                bottom: "auto"
            });
        }
        element.css(size);

        return wrapper.css( props ).show();
    },

    removeWrapper: function( element ) {
        var active = document.activeElement;

        if ( element.parent().is( ".ui-effects-wrapper" ) ) {
            element.parent().replaceWith( element );

            // Fixes #7595 - Elements lose focus when wrapped.
            if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
                $( active ).focus();
            }
        }


        return element;
    },

    setTransition: function( element, list, factor, value ) {
        value = value || {};
        $.each( list, function( i, x ) {
            var unit = element.cssUnit( x );
            if ( unit[ 0 ] > 0 ) {
                value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
            }
        });
        return value;
    }
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

    // allow passing all options as the first parameter
    if ( $.isPlainObject( effect ) ) {
        options = effect;
        effect = effect.effect;
    }

    // convert to an object
    effect = { effect: effect };

    // catch (effect, null, ...)
    if ( options == null ) {
        options = {};
    }

    // catch (effect, callback)
    if ( $.isFunction( options ) ) {
        callback = options;
        speed = null;
        options = {};
    }

    // catch (effect, speed, ?)
    if ( typeof options === "number" || $.fx.speeds[ options ] ) {
        callback = speed;
        speed = options;
        options = {};
    }

    // catch (effect, options, callback)
    if ( $.isFunction( speed ) ) {
        callback = speed;
        speed = null;
    }

    // add options to effect
    if ( options ) {
        $.extend( effect, options );
    }

    speed = speed || options.duration;
    effect.duration = $.fx.off ? 0 :
        typeof speed === "number" ? speed :
        speed in $.fx.speeds ? $.fx.speeds[ speed ] :
        $.fx.speeds._default;

    effect.complete = callback || options.complete;

    return effect;
}

function standardAnimationOption( option ) {
    // Valid standard speeds (nothing, number, named speed)
    if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
        return true;
    }

    // Invalid strings - treat as "normal" speed
    if ( typeof option === "string" && !$.effects.effect[ option ] ) {
        return true;
    }

    // Complete callback
    if ( $.isFunction( option ) ) {
        return true;
    }

    // Options hash (but not naming an effect)
    if ( typeof option === "object" && !option.effect ) {
        return true;
    }

    // Didn't match any standard API
    return false;
}

$.fn.extend({
    effect: function( /* effect, options, speed, callback */ ) {
        var args = _normalizeArguments.apply( this, arguments ),
            mode = args.mode,
            queue = args.queue,
            effectMethod = $.effects.effect[ args.effect ];

        if ( $.fx.off || !effectMethod ) {
            // delegate to the original method (e.g., .show()) if possible
            if ( mode ) {
                return this[ mode ]( args.duration, args.complete );
            } else {
                return this.each( function() {
                    if ( args.complete ) {
                        args.complete.call( this );
                    }
                });
            }
        }

        function run( next ) {
            var elem = $( this ),
                complete = args.complete,
                mode = args.mode;

            function done() {
                if ( $.isFunction( complete ) ) {
                    complete.call( elem[0] );
                }
                if ( $.isFunction( next ) ) {
                    next();
                }
            }

            // If the element already has the correct final state, delegate to
            // the core methods so the internal tracking of "olddisplay" works.
            if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
                elem[ mode ]();
                done();
            } else {
                effectMethod.call( elem[0], args, done );
            }
        }

        return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
    },

    show: (function( orig ) {
        return function( option ) {
            if ( standardAnimationOption( option ) ) {
                return orig.apply( this, arguments );
            } else {
                var args = _normalizeArguments.apply( this, arguments );
                args.mode = "show";
                return this.effect.call( this, args );
            }
        };
    })( $.fn.show ),

    hide: (function( orig ) {
        return function( option ) {
            if ( standardAnimationOption( option ) ) {
                return orig.apply( this, arguments );
            } else {
                var args = _normalizeArguments.apply( this, arguments );
                args.mode = "hide";
                return this.effect.call( this, args );
            }
        };
    })( $.fn.hide ),

    toggle: (function( orig ) {
        return function( option ) {
            if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
                return orig.apply( this, arguments );
            } else {
                var args = _normalizeArguments.apply( this, arguments );
                args.mode = "toggle";
                return this.effect.call( this, args );
            }
        };
    })( $.fn.toggle ),

    // helper functions
    cssUnit: function(key) {
        var style = this.css( key ),
            val = [];

        $.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
            if ( style.indexOf( unit ) > 0 ) {
                val = [ parseFloat( style ), unit ];
            }
        });
        return val;
    }
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
    baseEasings[ name ] = function( p ) {
        return Math.pow( p, i + 2 );
    };
});

$.extend( baseEasings, {
    Sine: function ( p ) {
        return 1 - Math.cos( p * Math.PI / 2 );
    },
    Circ: function ( p ) {
        return 1 - Math.sqrt( 1 - p * p );
    },
    Elastic: function( p ) {
        return p === 0 || p === 1 ? p :
            -Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
    },
    Back: function( p ) {
        return p * p * ( 3 * p - 2 );
    },
    Bounce: function ( p ) {
        var pow2,
            bounce = 4;

        while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
        return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
    }
});

$.each( baseEasings, function( name, easeIn ) {
    $.easing[ "easeIn" + name ] = easeIn;
    $.easing[ "easeOut" + name ] = function( p ) {
        return 1 - easeIn( 1 - p );
    };
    $.easing[ "easeInOut" + name ] = function( p ) {
        return p < 0.5 ?
            easeIn( p * 2 ) / 2 :
            1 - easeIn( p * -2 + 2 ) / 2;
    };
});

})();

})(jQuery);

(function( $, undefined ) {

var uid = 0,
    hideProps = {},
    showProps = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
    hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
    showProps.borderTopWidth = showProps.borderBottomWidth = "show";

$.widget( "ui.accordion", {
    version: "1.10.4",
    options: {
        active: 0,
        animate: {},
        collapsible: false,
        event: "click",
        header: "> li > :first-child,> :not(li):even",
        heightStyle: "auto",
        icons: {
            activeHeader: "ui-icon-triangle-1-s",
            header: "ui-icon-triangle-1-e"
        },

        // callbacks
        activate: null,
        beforeActivate: null
    },

    _create: function() {
        var options = this.options;
        this.prevShow = this.prevHide = $();
        this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
            // ARIA
            .attr( "role", "tablist" );

        // don't allow collapsible: false and active: false / null
        if ( !options.collapsible && (options.active === false || options.active == null) ) {
            options.active = 0;
        }

        this._processPanels();
        // handle negative values
        if ( options.active < 0 ) {
            options.active += this.headers.length;
        }
        this._refresh();
    },

    _getCreateEventData: function() {
        return {
            header: this.active,
            panel: !this.active.length ? $() : this.active.next(),
            content: !this.active.length ? $() : this.active.next()
        };
    },

    _createIcons: function() {
        var icons = this.options.icons;
        if ( icons ) {
            $( "<span>" )
                .addClass( "ui-accordion-header-icon ui-icon " + icons.header )
                .prependTo( this.headers );
            this.active.children( ".ui-accordion-header-icon" )
                .removeClass( icons.header )
                .addClass( icons.activeHeader );
            this.headers.addClass( "ui-accordion-icons" );
        }
    },

    _destroyIcons: function() {
        this.headers
            .removeClass( "ui-accordion-icons" )
            .children( ".ui-accordion-header-icon" )
                .remove();
    },

    _destroy: function() {
        var contents;

        // clean up main element
        this.element
            .removeClass( "ui-accordion ui-widget ui-helper-reset" )
            .removeAttr( "role" );

        // clean up headers
        this.headers
            .removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
            .removeAttr( "role" )
            .removeAttr( "aria-expanded" )
            .removeAttr( "aria-selected" )
            .removeAttr( "aria-controls" )
            .removeAttr( "tabIndex" )
            .each(function() {
                if ( /^ui-accordion/.test( this.id ) ) {
                    this.removeAttribute( "id" );
                }
            });
        this._destroyIcons();

        // clean up content panels
        contents = this.headers.next()
            .css( "display", "" )
            .removeAttr( "role" )
            .removeAttr( "aria-hidden" )
            .removeAttr( "aria-labelledby" )
            .removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
            .each(function() {
                if ( /^ui-accordion/.test( this.id ) ) {
                    this.removeAttribute( "id" );
                }
            });
        if ( this.options.heightStyle !== "content" ) {
            contents.css( "height", "" );
        }
    },

    _setOption: function( key, value ) {
        if ( key === "active" ) {
            // _activate() will handle invalid values and update this.options
            this._activate( value );
            return;
        }

        if ( key === "event" ) {
            if ( this.options.event ) {
                this._off( this.headers, this.options.event );
            }
            this._setupEvents( value );
        }

        this._super( key, value );

        // setting collapsible: false while collapsed; open first panel
        if ( key === "collapsible" && !value && this.options.active === false ) {
            this._activate( 0 );
        }

        if ( key === "icons" ) {
            this._destroyIcons();
            if ( value ) {
                this._createIcons();
            }
        }

        // #5332 - opacity doesn't cascade to positioned elements in IE
        // so we need to add the disabled class to the headers and panels
        if ( key === "disabled" ) {
            this.headers.add( this.headers.next() )
                .toggleClass( "ui-state-disabled", !!value );
        }
    },

    _keydown: function( event ) {
        if ( event.altKey || event.ctrlKey ) {
            return;
        }

        var keyCode = $.ui.keyCode,
            length = this.headers.length,
            currentIndex = this.headers.index( event.target ),
            toFocus = false;

        switch ( event.keyCode ) {
            case keyCode.RIGHT:
            case keyCode.DOWN:
                toFocus = this.headers[ ( currentIndex + 1 ) % length ];
                break;
            case keyCode.LEFT:
            case keyCode.UP:
                toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
                break;
            case keyCode.SPACE:
            case keyCode.ENTER:
                this._eventHandler( event );
                break;
            case keyCode.HOME:
                toFocus = this.headers[ 0 ];
                break;
            case keyCode.END:
                toFocus = this.headers[ length - 1 ];
                break;
        }

        if ( toFocus ) {
            $( event.target ).attr( "tabIndex", -1 );
            $( toFocus ).attr( "tabIndex", 0 );
            toFocus.focus();
            event.preventDefault();
        }
    },

    _panelKeyDown : function( event ) {
        if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
            $( event.currentTarget ).prev().focus();
        }
    },

    refresh: function() {
        var options = this.options;
        this._processPanels();

        // was collapsed or no panel
        if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
            options.active = false;
            this.active = $();
        // active false only when collapsible is true
        } else if ( options.active === false ) {
            this._activate( 0 );
        // was active, but active panel is gone
        } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
            // all remaining panel are disabled
            if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
                options.active = false;
                this.active = $();
            // activate previous panel
            } else {
                this._activate( Math.max( 0, options.active - 1 ) );
            }
        // was active, active panel still exists
        } else {
            // make sure active index is correct
            options.active = this.headers.index( this.active );
        }

        this._destroyIcons();

        this._refresh();
    },

    _processPanels: function() {
        this.headers = this.element.find( this.options.header )
            .addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );

        this.headers.next()
            .addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
            .filter(":not(.ui-accordion-content-active)")
            .hide();
    },

    _refresh: function() {
        var maxHeight,
            options = this.options,
            heightStyle = options.heightStyle,
            parent = this.element.parent(),
            accordionId = this.accordionId = "ui-accordion-" +
                (this.element.attr( "id" ) || ++uid);

        this.active = this._findActive( options.active )
            .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
            .removeClass( "ui-corner-all" );
        this.active.next()
            .addClass( "ui-accordion-content-active" )
            .show();

        this.headers
            .attr( "role", "tab" )
            .each(function( i ) {
                var header = $( this ),
                    headerId = header.attr( "id" ),
                    panel = header.next(),
                    panelId = panel.attr( "id" );
                if ( !headerId ) {
                    headerId = accordionId + "-header-" + i;
                    header.attr( "id", headerId );
                }
                if ( !panelId ) {
                    panelId = accordionId + "-panel-" + i;
                    panel.attr( "id", panelId );
                }
                header.attr( "aria-controls", panelId );
                panel.attr( "aria-labelledby", headerId );
            })
            .next()
                .attr( "role", "tabpanel" );

        this.headers
            .not( this.active )
            .attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            })
            .next()
                .attr({
                    "aria-hidden": "true"
                })
                .hide();

        // make sure at least one header is in the tab order
        if ( !this.active.length ) {
            this.headers.eq( 0 ).attr( "tabIndex", 0 );
        } else {
            this.active.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            })
            .next()
                .attr({
                    "aria-hidden": "false"
                });
        }

        this._createIcons();

        this._setupEvents( options.event );

        if ( heightStyle === "fill" ) {
            maxHeight = parent.height();
            this.element.siblings( ":visible" ).each(function() {
                var elem = $( this ),
                    position = elem.css( "position" );

                if ( position === "absolute" || position === "fixed" ) {
                    return;
                }
                maxHeight -= elem.outerHeight( true );
            });

            this.headers.each(function() {
                maxHeight -= $( this ).outerHeight( true );
            });

            this.headers.next()
                .each(function() {
                    $( this ).height( Math.max( 0, maxHeight -
                        $( this ).innerHeight() + $( this ).height() ) );
                })
                .css( "overflow", "auto" );
        } else if ( heightStyle === "auto" ) {
            maxHeight = 0;
            this.headers.next()
                .each(function() {
                    maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
                })
                .height( maxHeight );
        }
    },

    _activate: function( index ) {
        var active = this._findActive( index )[ 0 ];

        // trying to activate the already active panel
        if ( active === this.active[ 0 ] ) {
            return;
        }

        // trying to collapse, simulate a click on the currently active header
        active = active || this.active[ 0 ];

        this._eventHandler({
            target: active,
            currentTarget: active,
            preventDefault: $.noop
        });
    },

    _findActive: function( selector ) {
        return typeof selector === "number" ? this.headers.eq( selector ) : $();
    },

    _setupEvents: function( event ) {
        var events = {
            keydown: "_keydown"
        };
        if ( event ) {
            $.each( event.split(" "), function( index, eventName ) {
                events[ eventName ] = "_eventHandler";
            });
        }

        this._off( this.headers.add( this.headers.next() ) );
        this._on( this.headers, events );
        this._on( this.headers.next(), { keydown: "_panelKeyDown" });
        this._hoverable( this.headers );
        this._focusable( this.headers );
    },

    _eventHandler: function( event ) {
        var options = this.options,
            active = this.active,
            clicked = $( event.currentTarget ),
            clickedIsActive = clicked[ 0 ] === active[ 0 ],
            collapsing = clickedIsActive && options.collapsible,
            toShow = collapsing ? $() : clicked.next(),
            toHide = active.next(),
            eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
            };

        event.preventDefault();

        if (
                // click on active header, but not collapsible
                ( clickedIsActive && !options.collapsible ) ||
                // allow canceling activation
                ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
            return;
        }

        options.active = collapsing ? false : this.headers.index( clicked );

        // when the call to ._toggle() comes after the class changes
        // it causes a very odd bug in IE 8 (see #6720)
        this.active = clickedIsActive ? $() : clicked;
        this._toggle( eventData );

        // switch classes
        // corner classes on the previously active header stay after the animation
        active.removeClass( "ui-accordion-header-active ui-state-active" );
        if ( options.icons ) {
            active.children( ".ui-accordion-header-icon" )
                .removeClass( options.icons.activeHeader )
                .addClass( options.icons.header );
        }

        if ( !clickedIsActive ) {
            clicked
                .removeClass( "ui-corner-all" )
                .addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
            if ( options.icons ) {
                clicked.children( ".ui-accordion-header-icon" )
                    .removeClass( options.icons.header )
                    .addClass( options.icons.activeHeader );
            }

            clicked
                .next()
                .addClass( "ui-accordion-content-active" );
        }
    },

    _toggle: function( data ) {
        var toShow = data.newPanel,
            toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

        // handle activating a panel during the animation for another activation
        this.prevShow.add( this.prevHide ).stop( true, true );
        this.prevShow = toShow;
        this.prevHide = toHide;

        if ( this.options.animate ) {
            this._animate( toShow, toHide, data );
        } else {
            toHide.hide();
            toShow.show();
            this._toggleComplete( data );
        }

        toHide.attr({
            "aria-hidden": "true"
        });
        toHide.prev().attr( "aria-selected", "false" );
        // if we're switching panels, remove the old header from the tab order
        // if we're opening from collapsed state, remove the previous header from the tab order
        // if we're collapsing, then keep the collapsing header in the tab order
        if ( toShow.length && toHide.length ) {
            toHide.prev().attr({
                "tabIndex": -1,
                "aria-expanded": "false"
            });
        } else if ( toShow.length ) {
            this.headers.filter(function() {
                return $( this ).attr( "tabIndex" ) === 0;
            })
            .attr( "tabIndex", -1 );
        }

        toShow
            .attr( "aria-hidden", "false" )
            .prev()
                .attr({
                    "aria-selected": "true",
                    tabIndex: 0,
                    "aria-expanded": "true"
                });
    },

    _animate: function( toShow, toHide, data ) {
        var total, easing, duration,
            that = this,
            adjust = 0,
            down = toShow.length &&
                ( !toHide.length || ( toShow.index() < toHide.index() ) ),
            animate = this.options.animate || {},
            options = down && animate.down || animate,
            complete = function() {
                that._toggleComplete( data );
            };

        if ( typeof options === "number" ) {
            duration = options;
        }
        if ( typeof options === "string" ) {
            easing = options;
        }
        // fall back from options to animation in case of partial down settings
        easing = easing || options.easing || animate.easing;
        duration = duration || options.duration || animate.duration;

        if ( !toHide.length ) {
            return toShow.animate( showProps, duration, easing, complete );
        }
        if ( !toShow.length ) {
            return toHide.animate( hideProps, duration, easing, complete );
        }

        total = toShow.show().outerHeight();
        toHide.animate( hideProps, {
            duration: duration,
            easing: easing,
            step: function( now, fx ) {
                fx.now = Math.round( now );
            }
        });
        toShow
            .hide()
            .animate( showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function( now, fx ) {
                    fx.now = Math.round( now );
                    if ( fx.prop !== "height" ) {
                        adjust += fx.now;
                    } else if ( that.options.heightStyle !== "content" ) {
                        fx.now = Math.round( total - toHide.outerHeight() - adjust );
                        adjust = 0;
                    }
                }
            });
    },

    _toggleComplete: function( data ) {
        var toHide = data.oldPanel;

        toHide
            .removeClass( "ui-accordion-content-active" )
            .prev()
                .removeClass( "ui-corner-top" )
                .addClass( "ui-corner-all" );

        // Work around for rendering bug in IE (#5421)
        if ( toHide.length ) {
            toHide.parent()[0].className = toHide.parent()[0].className;
        }
        this._trigger( "activate", null, data );
    }
});

})( jQuery );

(function( $, undefined ) {

$.widget( "ui.autocomplete", {
    version: "1.10.4",
    defaultElement: "<input>",
    options: {
        appendTo: null,
        autoFocus: false,
        delay: 300,
        minLength: 1,
        position: {
            my: "left top",
            at: "left bottom",
            collision: "none"
        },
        source: null,

        // callbacks
        change: null,
        close: null,
        focus: null,
        open: null,
        response: null,
        search: null,
        select: null
    },

    requestIndex: 0,
    pending: 0,

    _create: function() {
        // Some browsers only repeat keydown events, not keypress events,
        // so we use the suppressKeyPress flag to determine if we've already
        // handled the keydown event. #7269
        // Unfortunately the code for & in keypress is the same as the up arrow,
        // so we use the suppressKeyPressRepeat flag to avoid handling keypress
        // events when we know the keydown event was used to modify the
        // search term. #7799
        var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
            nodeName = this.element[0].nodeName.toLowerCase(),
            isTextarea = nodeName === "textarea",
            isInput = nodeName === "input";

        this.isMultiLine =
            // Textareas are always multi-line
            isTextarea ? true :
            // Inputs are always single-line, even if inside a contentEditable element
            // IE also treats inputs as contentEditable
            isInput ? false :
            // All other element types are determined by whether or not they're contentEditable
            this.element.prop( "isContentEditable" );

        this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
        this.isNewMenu = true;

        this.element
            .addClass( "ui-autocomplete-input" )
            .attr( "autocomplete", "off" );

        this._on( this.element, {
            keydown: function( event ) {
                if ( this.element.prop( "readOnly" ) ) {
                    suppressKeyPress = true;
                    suppressInput = true;
                    suppressKeyPressRepeat = true;
                    return;
                }

                suppressKeyPress = false;
                suppressInput = false;
                suppressKeyPressRepeat = false;
                var keyCode = $.ui.keyCode;
                switch( event.keyCode ) {
                case keyCode.PAGE_UP:
                    suppressKeyPress = true;
                    this._move( "previousPage", event );
                    break;
                case keyCode.PAGE_DOWN:
                    suppressKeyPress = true;
                    this._move( "nextPage", event );
                    break;
                case keyCode.UP:
                    suppressKeyPress = true;
                    this._keyEvent( "previous", event );
                    break;
                case keyCode.DOWN:
                    suppressKeyPress = true;
                    this._keyEvent( "next", event );
                    break;
                case keyCode.ENTER:
                case keyCode.NUMPAD_ENTER:
                    // when menu is open and has focus
                    if ( this.menu.active ) {
                        // #6055 - Opera still allows the keypress to occur
                        // which causes forms to submit
                        suppressKeyPress = true;
                        event.preventDefault();
                        this.menu.select( event );
                    }
                    break;
                case keyCode.TAB:
                    if ( this.menu.active ) {
                        this.menu.select( event );
                    }
                    break;
                case keyCode.ESCAPE:
                    if ( this.menu.element.is( ":visible" ) ) {
                        this._value( this.term );
                        this.close( event );
                        // Different browsers have different default behavior for escape
                        // Single press can mean undo or clear
                        // Double press in IE means clear the whole form
                        event.preventDefault();
                    }
                    break;
                default:
                    suppressKeyPressRepeat = true;
                    // search timeout should be triggered before the input value is changed
                    this._searchTimeout( event );
                    break;
                }
            },
            keypress: function( event ) {
                if ( suppressKeyPress ) {
                    suppressKeyPress = false;
                    if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
                        event.preventDefault();
                    }
                    return;
                }
                if ( suppressKeyPressRepeat ) {
                    return;
                }

                // replicate some key handlers to allow them to repeat in Firefox and Opera
                var keyCode = $.ui.keyCode;
                switch( event.keyCode ) {
                case keyCode.PAGE_UP:
                    this._move( "previousPage", event );
                    break;
                case keyCode.PAGE_DOWN:
                    this._move( "nextPage", event );
                    break;
                case keyCode.UP:
                    this._keyEvent( "previous", event );
                    break;
                case keyCode.DOWN:
                    this._keyEvent( "next", event );
                    break;
                }
            },
            input: function( event ) {
                if ( suppressInput ) {
                    suppressInput = false;
                    event.preventDefault();
                    return;
                }
                this._searchTimeout( event );
            },
            focus: function() {
                this.selectedItem = null;
                this.previous = this._value();
            },
            blur: function( event ) {
                if ( this.cancelBlur ) {
                    delete this.cancelBlur;
                    return;
                }

                clearTimeout( this.searching );
                this.close( event );
                this._change( event );
            }
        });

        this._initSource();
        this.menu = $( "<ul>" )
            .addClass( "ui-autocomplete ui-front" )
            .appendTo( this._appendTo() )
            .menu({
                // disable ARIA support, the live region takes care of that
                role: null
            })
            .hide()
            .data( "ui-menu" );

        this._on( this.menu.element, {
            mousedown: function( event ) {
                // prevent moving focus out of the text field
                event.preventDefault();

                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                });

                // clicking on the scrollbar causes focus to shift to the body
                // but we can't detect a mouseup or a click immediately afterward
                // so we have to track the next mousedown and close the menu if
                // the user clicks somewhere outside of the autocomplete
                var menuElement = this.menu.element[ 0 ];
                if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
                    this._delay(function() {
                        var that = this;
                        this.document.one( "mousedown", function( event ) {
                            if ( event.target !== that.element[ 0 ] &&
                                    event.target !== menuElement &&
                                    !$.contains( menuElement, event.target ) ) {
                                that.close();
                            }
                        });
                    });
                }
            },
            menufocus: function( event, ui ) {
                // support: Firefox
                // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                if ( this.isNewMenu ) {
                    this.isNewMenu = false;
                    if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
                        this.menu.blur();

                        this.document.one( "mousemove", function() {
                            $( event.target ).trigger( event.originalEvent );
                        });

                        return;
                    }
                }

                var item = ui.item.data( "ui-autocomplete-item" );
                if ( false !== this._trigger( "focus", event, { item: item } ) ) {
                    // use value to match what will end up in the input, if it was a key event
                    if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
                        this._value( item.value );
                    }
                } else {
                    // Normally the input is populated with the item's value as the
                    // menu is navigated, causing screen readers to notice a change and
                    // announce the item. Since the focus event was canceled, this doesn't
                    // happen, so we update the live region so that screen readers can
                    // still notice the change and announce it.
                    this.liveRegion.text( item.value );
                }
            },
            menuselect: function( event, ui ) {
                var item = ui.item.data( "ui-autocomplete-item" ),
                    previous = this.previous;

                // only trigger when focus was lost (click on menu)
                if ( this.element[0] !== this.document[0].activeElement ) {
                    this.element.focus();
                    this.previous = previous;
                    // #6109 - IE triggers two focus events and the second
                    // is asynchronous, so we need to reset the previous
                    // term synchronously and asynchronously :-(
                    this._delay(function() {
                        this.previous = previous;
                        this.selectedItem = item;
                    });
                }

                if ( false !== this._trigger( "select", event, { item: item } ) ) {
                    this._value( item.value );
                }
                // reset the term after the select event
                // this allows custom select handling to work properly
                this.term = this._value();

                this.close( event );
                this.selectedItem = item;
            }
        });

        this.liveRegion = $( "<span>", {
                role: "status",
                "aria-live": "polite"
            })
            .addClass( "ui-helper-hidden-accessible" )
            .insertBefore( this.element );

        // turning off autocomplete prevents the browser from remembering the
        // value when navigating through history, so we re-enable autocomplete
        // if the page is unloaded before the widget is destroyed. #7790
        this._on( this.window, {
            beforeunload: function() {
                this.element.removeAttr( "autocomplete" );
            }
        });
    },

    _destroy: function() {
        clearTimeout( this.searching );
        this.element
            .removeClass( "ui-autocomplete-input" )
            .removeAttr( "autocomplete" );
        this.menu.element.remove();
        this.liveRegion.remove();
    },

    _setOption: function( key, value ) {
        this._super( key, value );
        if ( key === "source" ) {
            this._initSource();
        }
        if ( key === "appendTo" ) {
            this.menu.element.appendTo( this._appendTo() );
        }
        if ( key === "disabled" && value && this.xhr ) {
            this.xhr.abort();
        }
    },

    _appendTo: function() {
        var element = this.options.appendTo;

        if ( element ) {
            element = element.jquery || element.nodeType ?
                $( element ) :
                this.document.find( element ).eq( 0 );
        }

        if ( !element ) {
            element = this.element.closest( ".ui-front" );
        }

        if ( !element.length ) {
            element = this.document[0].body;
        }

        return element;
    },

    _initSource: function() {
        var array, url,
            that = this;
        if ( $.isArray(this.options.source) ) {
            array = this.options.source;
            this.source = function( request, response ) {
                response( $.ui.autocomplete.filter( array, request.term ) );
            };
        } else if ( typeof this.options.source === "string" ) {
            url = this.options.source;
            this.source = function( request, response ) {
                if ( that.xhr ) {
                    that.xhr.abort();
                }
                that.xhr = $.ajax({
                    url: url,
                    data: request,
                    dataType: "json",
                    success: function( data ) {
                        response( data );
                    },
                    error: function() {
                        response( [] );
                    }
                });
            };
        } else {
            this.source = this.options.source;
        }
    },

    _searchTimeout: function( event ) {
        clearTimeout( this.searching );
        this.searching = this._delay(function() {
            // only search if the value has changed
            if ( this.term !== this._value() ) {
                this.selectedItem = null;
                this.search( null, event );
            }
        }, this.options.delay );
    },

    search: function( value, event ) {
        value = value != null ? value : this._value();

        // always save the actual value, not the one passed as an argument
        this.term = this._value();

        if ( value.length < this.options.minLength ) {
            return this.close( event );
        }

        if ( this._trigger( "search", event ) === false ) {
            return;
        }

        return this._search( value );
    },

    _search: function( value ) {
        this.pending++;
        this.element.addClass( "ui-autocomplete-loading" );
        this.cancelSearch = false;

        this.source( { term: value }, this._response() );
    },

    _response: function() {
        var index = ++this.requestIndex;

        return $.proxy(function( content ) {
            if ( index === this.requestIndex ) {
                this.__response( content );
            }

            this.pending--;
            if ( !this.pending ) {
                this.element.removeClass( "ui-autocomplete-loading" );
            }
        }, this );
    },

    __response: function( content ) {
        if ( content ) {
            content = this._normalize( content );
        }
        this._trigger( "response", null, { content: content } );
        if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
            this._suggest( content );
            this._trigger( "open" );
        } else {
            // use ._close() instead of .close() so we don't cancel future searches
            this._close();
        }
    },

    close: function( event ) {
        this.cancelSearch = true;
        this._close( event );
    },

    _close: function( event ) {
        if ( this.menu.element.is( ":visible" ) ) {
            this.menu.element.hide();
            this.menu.blur();
            this.isNewMenu = true;
            this._trigger( "close", event );
        }
    },

    _change: function( event ) {
        if ( this.previous !== this._value() ) {
            this._trigger( "change", event, { item: this.selectedItem } );
        }
    },

    _normalize: function( items ) {
        // assume all items have the right format when the first item is complete
        if ( items.length && items[0].label && items[0].value ) {
            return items;
        }
        return $.map( items, function( item ) {
            if ( typeof item === "string" ) {
                return {
                    label: item,
                    value: item
                };
            }
            return $.extend({
                label: item.label || item.value,
                value: item.value || item.label
            }, item );
        });
    },

    _suggest: function( items ) {
        var ul = this.menu.element.empty();
        this._renderMenu( ul, items );
        this.isNewMenu = true;
        this.menu.refresh();

        // size and position menu
        ul.show();
        this._resizeMenu();
        ul.position( $.extend({
            of: this.element
        }, this.options.position ));

        if ( this.options.autoFocus ) {
            this.menu.next();
        }
    },

    _resizeMenu: function() {
        var ul = this.menu.element;
        ul.outerWidth( Math.max(
            // Firefox wraps long text (possibly a rounding bug)
            // so we add 1px to avoid the wrapping (#7513)
            ul.width( "" ).outerWidth() + 1,
            this.element.outerWidth()
        ) );
    },

    _renderMenu: function( ul, items ) {
        var that = this;
        $.each( items, function( index, item ) {
            that._renderItemData( ul, item );
        });
    },

    _renderItemData: function( ul, item ) {
        return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
    },

    _renderItem: function( ul, item ) {
        return $( "<li>" )
            .append( $( "<a>" ).text( item.label ) )
            .appendTo( ul );
    },

    _move: function( direction, event ) {
        if ( !this.menu.element.is( ":visible" ) ) {
            this.search( null, event );
            return;
        }
        if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
                this.menu.isLastItem() && /^next/.test( direction ) ) {
            this._value( this.term );
            this.menu.blur();
            return;
        }
        this.menu[ direction ]( event );
    },

    widget: function() {
        return this.menu.element;
    },

    _value: function() {
        return this.valueMethod.apply( this.element, arguments );
    },

    _keyEvent: function( keyEvent, event ) {
        if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
            this._move( keyEvent, event );

            // prevents moving cursor to beginning/end of the text field in some browsers
            event.preventDefault();
        }
    }
});

$.extend( $.ui.autocomplete, {
    escapeRegex: function( value ) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    },
    filter: function(array, term) {
        var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
        return $.grep( array, function(value) {
            return matcher.test( value.label || value.value || value );
        });
    }
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
    options: {
        messages: {
            noResults: "No search results.",
            results: function( amount ) {
                return amount + ( amount > 1 ? " results are" : " result is" ) +
                    " available, use up and down arrow keys to navigate.";
            }
        }
    },

    __response: function( content ) {
        var message;
        this._superApply( arguments );
        if ( this.options.disabled || this.cancelSearch ) {
            return;
        }
        if ( content && content.length ) {
            message = this.options.messages.results( content.length );
        } else {
            message = this.options.messages.noResults;
        }
        this.liveRegion.text( message );
    }
});

}( jQuery ));

(function( $, undefined ) {

var lastActive,
    baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
    typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
    formResetHandler = function() {
        var form = $( this );
        setTimeout(function() {
            form.find( ":ui-button" ).button( "refresh" );
        }, 1 );
    },
    radioGroup = function( radio ) {
        var name = radio.name,
            form = radio.form,
            radios = $( [] );
        if ( name ) {
            name = name.replace( /'/g, "\\'" );
            if ( form ) {
                radios = $( form ).find( "[name='" + name + "']" );
            } else {
                radios = $( "[name='" + name + "']", radio.ownerDocument )
                    .filter(function() {
                        return !this.form;
                    });
            }
        }
        return radios;
    };

$.widget( "ui.button", {
    version: "1.10.4",
    defaultElement: "<button>",
    options: {
        disabled: null,
        text: true,
        label: null,
        icons: {
            primary: null,
            secondary: null
        }
    },
    _create: function() {
        this.element.closest( "form" )
            .unbind( "reset" + this.eventNamespace )
            .bind( "reset" + this.eventNamespace, formResetHandler );

        if ( typeof this.options.disabled !== "boolean" ) {
            this.options.disabled = !!this.element.prop( "disabled" );
        } else {
            this.element.prop( "disabled", this.options.disabled );
        }

        this._determineButtonType();
        this.hasTitle = !!this.buttonElement.attr( "title" );

        var that = this,
            options = this.options,
            toggleButton = this.type === "checkbox" || this.type === "radio",
            activeClass = !toggleButton ? "ui-state-active" : "";

        if ( options.label === null ) {
            options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
        }

        this._hoverable( this.buttonElement );

        this.buttonElement
            .addClass( baseClasses )
            .attr( "role", "button" )
            .bind( "mouseenter" + this.eventNamespace, function() {
                if ( options.disabled ) {
                    return;
                }
                if ( this === lastActive ) {
                    $( this ).addClass( "ui-state-active" );
                }
            })
            .bind( "mouseleave" + this.eventNamespace, function() {
                if ( options.disabled ) {
                    return;
                }
                $( this ).removeClass( activeClass );
            })
            .bind( "click" + this.eventNamespace, function( event ) {
                if ( options.disabled ) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
            });

        // Can't use _focusable() because the element that receives focus
        // and the element that gets the ui-state-focus class are different
        this._on({
            focus: function() {
                this.buttonElement.addClass( "ui-state-focus" );
            },
            blur: function() {
                this.buttonElement.removeClass( "ui-state-focus" );
            }
        });

        if ( toggleButton ) {
            this.element.bind( "change" + this.eventNamespace, function() {
                that.refresh();
            });
        }

        if ( this.type === "checkbox" ) {
            this.buttonElement.bind( "click" + this.eventNamespace, function() {
                if ( options.disabled ) {
                    return false;
                }
            });
        } else if ( this.type === "radio" ) {
            this.buttonElement.bind( "click" + this.eventNamespace, function() {
                if ( options.disabled ) {
                    return false;
                }
                $( this ).addClass( "ui-state-active" );
                that.buttonElement.attr( "aria-pressed", "true" );

                var radio = that.element[ 0 ];
                radioGroup( radio )
                    .not( radio )
                    .map(function() {
                        return $( this ).button( "widget" )[ 0 ];
                    })
                    .removeClass( "ui-state-active" )
                    .attr( "aria-pressed", "false" );
            });
        } else {
            this.buttonElement
                .bind( "mousedown" + this.eventNamespace, function() {
                    if ( options.disabled ) {
                        return false;
                    }
                    $( this ).addClass( "ui-state-active" );
                    lastActive = this;
                    that.document.one( "mouseup", function() {
                        lastActive = null;
                    });
                })
                .bind( "mouseup" + this.eventNamespace, function() {
                    if ( options.disabled ) {
                        return false;
                    }
                    $( this ).removeClass( "ui-state-active" );
                })
                .bind( "keydown" + this.eventNamespace, function(event) {
                    if ( options.disabled ) {
                        return false;
                    }
                    if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
                        $( this ).addClass( "ui-state-active" );
                    }
                })
                // see #8559, we bind to blur here in case the button element loses
                // focus between keydown and keyup, it would be left in an "active" state
                .bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                    $( this ).removeClass( "ui-state-active" );
                });

            if ( this.buttonElement.is("a") ) {
                this.buttonElement.keyup(function(event) {
                    if ( event.keyCode === $.ui.keyCode.SPACE ) {
                        // TODO pass through original event correctly (just as 2nd argument doesn't work)
                        $( this ).click();
                    }
                });
            }
        }

        // TODO: pull out $.Widget's handling for the disabled option into
        // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
        // be overridden by individual plugins
        this._setOption( "disabled", options.disabled );
        this._resetButton();
    },

    _determineButtonType: function() {
        var ancestor, labelSelector, checked;

        if ( this.element.is("[type=checkbox]") ) {
            this.type = "checkbox";
        } else if ( this.element.is("[type=radio]") ) {
            this.type = "radio";
        } else if ( this.element.is("input") ) {
            this.type = "input";
        } else {
            this.type = "button";
        }

        if ( this.type === "checkbox" || this.type === "radio" ) {
            // we don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.element.parents().last();
            labelSelector = "label[for='" + this.element.attr("id") + "']";
            this.buttonElement = ancestor.find( labelSelector );
            if ( !this.buttonElement.length ) {
                ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                this.buttonElement = ancestor.filter( labelSelector );
                if ( !this.buttonElement.length ) {
                    this.buttonElement = ancestor.find( labelSelector );
                }
            }
            this.element.addClass( "ui-helper-hidden-accessible" );

            checked = this.element.is( ":checked" );
            if ( checked ) {
                this.buttonElement.addClass( "ui-state-active" );
            }
            this.buttonElement.prop( "aria-pressed", checked );
        } else {
            this.buttonElement = this.element;
        }
    },

    widget: function() {
        return this.buttonElement;
    },

    _destroy: function() {
        this.element
            .removeClass( "ui-helper-hidden-accessible" );
        this.buttonElement
            .removeClass( baseClasses + " ui-state-active " + typeClasses )
            .removeAttr( "role" )
            .removeAttr( "aria-pressed" )
            .html( this.buttonElement.find(".ui-button-text").html() );

        if ( !this.hasTitle ) {
            this.buttonElement.removeAttr( "title" );
        }
    },

    _setOption: function( key, value ) {
        this._super( key, value );
        if ( key === "disabled" ) {
            this.element.prop( "disabled", !!value );
            if ( value ) {
                this.buttonElement.removeClass( "ui-state-focus" );
            }
            return;
        }
        this._resetButton();
    },

    refresh: function() {
        //See #8237 & #8828
        var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

        if ( isDisabled !== this.options.disabled ) {
            this._setOption( "disabled", isDisabled );
        }
        if ( this.type === "radio" ) {
            radioGroup( this.element[0] ).each(function() {
                if ( $( this ).is( ":checked" ) ) {
                    $( this ).button( "widget" )
                        .addClass( "ui-state-active" )
                        .attr( "aria-pressed", "true" );
                } else {
                    $( this ).button( "widget" )
                        .removeClass( "ui-state-active" )
                        .attr( "aria-pressed", "false" );
                }
            });
        } else if ( this.type === "checkbox" ) {
            if ( this.element.is( ":checked" ) ) {
                this.buttonElement
                    .addClass( "ui-state-active" )
                    .attr( "aria-pressed", "true" );
            } else {
                this.buttonElement
                    .removeClass( "ui-state-active" )
                    .attr( "aria-pressed", "false" );
            }
        }
    },

    _resetButton: function() {
        if ( this.type === "input" ) {
            if ( this.options.label ) {
                this.element.val( this.options.label );
            }
            return;
        }
        var buttonElement = this.buttonElement.removeClass( typeClasses ),
            buttonText = $( "<span></span>", this.document[0] )
                .addClass( "ui-button-text" )
                .html( this.options.label )
                .appendTo( buttonElement.empty() )
                .text(),
            icons = this.options.icons,
            multipleIcons = icons.primary && icons.secondary,
            buttonClasses = [];

        if ( icons.primary || icons.secondary ) {
            if ( this.options.text ) {
                buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
            }

            if ( icons.primary ) {
                buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
            }

            if ( icons.secondary ) {
                buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
            }

            if ( !this.options.text ) {
                buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

                if ( !this.hasTitle ) {
                    buttonElement.attr( "title", $.trim( buttonText ) );
                }
            }
        } else {
            buttonClasses.push( "ui-button-text-only" );
        }
        buttonElement.addClass( buttonClasses.join( " " ) );
    }
});

$.widget( "ui.buttonset", {
    version: "1.10.4",
    options: {
        items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
    },

    _create: function() {
        this.element.addClass( "ui-buttonset" );
    },

    _init: function() {
        this.refresh();
    },

    _setOption: function( key, value ) {
        if ( key === "disabled" ) {
            this.buttons.button( "option", key, value );
        }

        this._super( key, value );
    },

    refresh: function() {
        var rtl = this.element.css( "direction" ) === "rtl";

        this.buttons = this.element.find( this.options.items )
            .filter( ":ui-button" )
                .button( "refresh" )
            .end()
            .not( ":ui-button" )
                .button()
            .end()
            .map(function() {
                return $( this ).button( "widget" )[ 0 ];
            })
                .removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
                .filter( ":first" )
                    .addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
                .end()
                .filter( ":last" )
                    .addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
                .end()
            .end();
    },

    _destroy: function() {
        this.element.removeClass( "ui-buttonset" );
        this.buttons
            .map(function() {
                return $( this ).button( "widget" )[ 0 ];
            })
                .removeClass( "ui-corner-left ui-corner-right" )
            .end()
            .button( "destroy" );
    }
});

}( jQuery ) );

(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.10.4" } });

var PROP_NAME = "datepicker",
    instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
    this._curInst = null; // The current instance in use
    this._keyEvent = false; // If the last event was a key event
    this._disabledInputs = []; // List of date picker inputs that have been disabled
    this._datepickerShowing = false; // True if the popup picker is showing , false if not
    this._inDialog = false; // True if showing within a "dialog", false if not
    this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
    this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
    this._appendClass = "ui-datepicker-append"; // The name of the append marker class
    this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
    this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
    this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
    this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
    this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
    this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
    this.regional = []; // Available regional settings, indexed by language code
    this.regional[""] = { // Default regional settings
        closeText: "Done", // Display text for close link
        prevText: "Prev", // Display text for previous month link
        nextText: "Next", // Display text for next month link
        currentText: "Today", // Display text for current month link
        monthNames: ["January","February","March","April","May","June",
            "July","August","September","October","November","December"], // Names of months for drop-down and formatting
        monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
        dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
        weekHeader: "Wk", // Column header for week of the year
        dateFormat: "mm/dd/yy", // See format options on parseDate
        firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
        isRTL: false, // True if right-to-left language, false if left-to-right
        showMonthAfterYear: false, // True if the year select precedes month, false for month then year
        yearSuffix: "" // Additional text to append to the year in the month headers
    };
    this._defaults = { // Global defaults for all the date picker instances
        showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
        showAnim: "fadeIn", // Name of jQuery animation for popup
        showOptions: {}, // Options for enhanced animations
        defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
        appendText: "", // Display text following the input box, e.g. showing the format
        buttonText: "...", // Text for trigger button
        buttonImage: "", // URL for trigger button image
        buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
        hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
        navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
        gotoCurrent: false, // True if today link goes back to current selection instead
        changeMonth: false, // True if month can be selected directly, false if only prev/next
        changeYear: false, // True if year can be selected directly, false if only prev/next
        yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
        showOtherMonths: false, // True to show dates in other months, false to leave blank
        selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
        showWeek: false, // True to show week of the year, false to not show it
        calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
        shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
        minDate: null, // The earliest selectable date, or null for no limit
        maxDate: null, // The latest selectable date, or null for no limit
        duration: "fast", // Duration of display/closure
        beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
        beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
        onSelect: null, // Define a callback function when a date is selected
        onChangeMonthYear: null, // Define a callback function when the month or year is changed
        onClose: null, // Define a callback function when the datepicker is closed
        numberOfMonths: 1, // Number of months to show at a time
        showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
        stepMonths: 1, // Number of months to step back/forward
        stepBigMonths: 12, // Number of months to step back/forward for the big links
        altField: "", // Selector for an alternate field to store selected dates into
        altFormat: "", // The date format to use for the alternate field
        constrainInput: true, // The input is constrained by the current date format
        showButtonPanel: false, // True to show button panel, false to not show it
        autoSize: false, // True to size the input for the date format, false to leave as is
        disabled: false // The initial disabled state
    };
    $.extend(this._defaults, this.regional[""]);
    this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
    /* Class name added to elements to indicate already configured with a date picker. */
    markerClassName: "hasDatepicker",

    //Keep track of the maximum number of rows displayed (see #7043)
    maxRows: 4,

    // TODO rename to "widget" when switching to widget factory
    _widgetDatepicker: function() {
        return this.dpDiv;
    },

    /* Override the default settings for all instances of the date picker.
     * @param  settings  object - the new settings to use as defaults (anonymous object)
     * @return the manager object
     */
    setDefaults: function(settings) {
        extendRemove(this._defaults, settings || {});
        return this;
    },

    /* Attach the date picker to a jQuery selection.
     * @param  target   element - the target input field or division or span
     * @param  settings  object - the new settings to use for this date picker instance (anonymous)
     */
    _attachDatepicker: function(target, settings) {
        var nodeName, inline, inst;
        nodeName = target.nodeName.toLowerCase();
        inline = (nodeName === "div" || nodeName === "span");
        if (!target.id) {
            this.uuid += 1;
            target.id = "dp" + this.uuid;
        }
        inst = this._newInst($(target), inline);
        inst.settings = $.extend({}, settings || {});
        if (nodeName === "input") {
            this._connectDatepicker(target, inst);
        } else if (inline) {
            this._inlineDatepicker(target, inst);
        }
    },

    /* Create a new instance object. */
    _newInst: function(target, inline) {
        var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
        return {id: id, input: target, // associated target
            selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
            drawMonth: 0, drawYear: 0, // month being drawn
            inline: inline, // is datepicker inline or not
            dpDiv: (!inline ? this.dpDiv : // presentation div
            bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
    },

    /* Attach the date picker to an input field. */
    _connectDatepicker: function(target, inst) {
        var input = $(target);
        inst.append = $([]);
        inst.trigger = $([]);
        if (input.hasClass(this.markerClassName)) {
            return;
        }
        this._attachments(input, inst);
        input.addClass(this.markerClassName).keydown(this._doKeyDown).
            keypress(this._doKeyPress).keyup(this._doKeyUp);
        this._autoSize(inst);
        $.data(target, PROP_NAME, inst);
        //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
        if( inst.settings.disabled ) {
            this._disableDatepicker( target );
        }
    },

    /* Make attachments based on settings. */
    _attachments: function(input, inst) {
        var showOn, buttonText, buttonImage,
            appendText = this._get(inst, "appendText"),
            isRTL = this._get(inst, "isRTL");

        if (inst.append) {
            inst.append.remove();
        }
        if (appendText) {
            inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
            input[isRTL ? "before" : "after"](inst.append);
        }

        input.unbind("focus", this._showDatepicker);

        if (inst.trigger) {
            inst.trigger.remove();
        }

        showOn = this._get(inst, "showOn");
        if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
            input.focus(this._showDatepicker);
        }
        if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
            buttonText = this._get(inst, "buttonText");
            buttonImage = this._get(inst, "buttonImage");
            inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                $("<img/>").addClass(this._triggerClass).
                    attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
                $("<button type='button'></button>").addClass(this._triggerClass).
                    html(!buttonImage ? buttonText : $("<img/>").attr(
                    { src:buttonImage, alt:buttonText, title:buttonText })));
            input[isRTL ? "before" : "after"](inst.trigger);
            inst.trigger.click(function() {
                if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                    $.datepicker._hideDatepicker();
                } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                    $.datepicker._hideDatepicker();
                    $.datepicker._showDatepicker(input[0]);
                } else {
                    $.datepicker._showDatepicker(input[0]);
                }
                return false;
            });
        }
    },

    /* Apply the maximum length for the date format. */
    _autoSize: function(inst) {
        if (this._get(inst, "autoSize") && !inst.inline) {
            var findMax, max, maxI, i,
                date = new Date(2009, 12 - 1, 20), // Ensure double digits
                dateFormat = this._get(inst, "dateFormat");

            if (dateFormat.match(/[DM]/)) {
                findMax = function(names) {
                    max = 0;
                    maxI = 0;
                    for (i = 0; i < names.length; i++) {
                        if (names[i].length > max) {
                            max = names[i].length;
                            maxI = i;
                        }
                    }
                    return maxI;
                };
                date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                    "monthNames" : "monthNamesShort"))));
                date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                    "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
            }
            inst.input.attr("size", this._formatDate(inst, date).length);
        }
    },

    /* Attach an inline date picker to a div. */
    _inlineDatepicker: function(target, inst) {
        var divSpan = $(target);
        if (divSpan.hasClass(this.markerClassName)) {
            return;
        }
        divSpan.addClass(this.markerClassName).append(inst.dpDiv);
        $.data(target, PROP_NAME, inst);
        this._setDate(inst, this._getDefaultDate(inst), true);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
        //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
        if( inst.settings.disabled ) {
            this._disableDatepicker( target );
        }
        // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
        // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
        inst.dpDiv.css( "display", "block" );
    },

    /* Pop-up the date picker in a "dialog" box.
     * @param  input element - ignored
     * @param  date string or Date - the initial date to display
     * @param  onSelect  function - the function to call when a date is selected
     * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
     * @param  pos int[2] - coordinates for the dialog's position within the screen or
     *                  event - with x/y coordinates or
     *                  leave empty for default (screen centre)
     * @return the manager object
     */
    _dialogDatepicker: function(input, date, onSelect, settings, pos) {
        var id, browserWidth, browserHeight, scrollX, scrollY,
            inst = this._dialogInst; // internal instance

        if (!inst) {
            this.uuid += 1;
            id = "dp" + this.uuid;
            this._dialogInput = $("<input type='text' id='" + id +
                "' style='position: absolute; top: -100px; width: 0px;'/>");
            this._dialogInput.keydown(this._doKeyDown);
            $("body").append(this._dialogInput);
            inst = this._dialogInst = this._newInst(this._dialogInput, false);
            inst.settings = {};
            $.data(this._dialogInput[0], PROP_NAME, inst);
        }
        extendRemove(inst.settings, settings || {});
        date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
        this._dialogInput.val(date);

        this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
        if (!this._pos) {
            browserWidth = document.documentElement.clientWidth;
            browserHeight = document.documentElement.clientHeight;
            scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
            scrollY = document.documentElement.scrollTop || document.body.scrollTop;
            this._pos = // should use actual width/height below
                [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
        }

        // move input on screen for focus, but hidden behind dialog
        this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
        inst.settings.onSelect = onSelect;
        this._inDialog = true;
        this.dpDiv.addClass(this._dialogClass);
        this._showDatepicker(this._dialogInput[0]);
        if ($.blockUI) {
            $.blockUI(this.dpDiv);
        }
        $.data(this._dialogInput[0], PROP_NAME, inst);
        return this;
    },

    /* Detach a datepicker from its control.
     * @param  target   element - the target input field or division or span
     */
    _destroyDatepicker: function(target) {
        var nodeName,
            $target = $(target),
            inst = $.data(target, PROP_NAME);

        if (!$target.hasClass(this.markerClassName)) {
            return;
        }

        nodeName = target.nodeName.toLowerCase();
        $.removeData(target, PROP_NAME);
        if (nodeName === "input") {
            inst.append.remove();
            inst.trigger.remove();
            $target.removeClass(this.markerClassName).
                unbind("focus", this._showDatepicker).
                unbind("keydown", this._doKeyDown).
                unbind("keypress", this._doKeyPress).
                unbind("keyup", this._doKeyUp);
        } else if (nodeName === "div" || nodeName === "span") {
            $target.removeClass(this.markerClassName).empty();
        }
    },

    /* Enable the date picker to a jQuery selection.
     * @param  target   element - the target input field or division or span
     */
    _enableDatepicker: function(target) {
        var nodeName, inline,
            $target = $(target),
            inst = $.data(target, PROP_NAME);

        if (!$target.hasClass(this.markerClassName)) {
            return;
        }

        nodeName = target.nodeName.toLowerCase();
        if (nodeName === "input") {
            target.disabled = false;
            inst.trigger.filter("button").
                each(function() { this.disabled = false; }).end().
                filter("img").css({opacity: "1.0", cursor: ""});
        } else if (nodeName === "div" || nodeName === "span") {
            inline = $target.children("." + this._inlineClass);
            inline.children().removeClass("ui-state-disabled");
            inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", false);
        }
        this._disabledInputs = $.map(this._disabledInputs,
            function(value) { return (value === target ? null : value); }); // delete entry
    },

    /* Disable the date picker to a jQuery selection.
     * @param  target   element - the target input field or division or span
     */
    _disableDatepicker: function(target) {
        var nodeName, inline,
            $target = $(target),
            inst = $.data(target, PROP_NAME);

        if (!$target.hasClass(this.markerClassName)) {
            return;
        }

        nodeName = target.nodeName.toLowerCase();
        if (nodeName === "input") {
            target.disabled = true;
            inst.trigger.filter("button").
                each(function() { this.disabled = true; }).end().
                filter("img").css({opacity: "0.5", cursor: "default"});
        } else if (nodeName === "div" || nodeName === "span") {
            inline = $target.children("." + this._inlineClass);
            inline.children().addClass("ui-state-disabled");
            inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", true);
        }
        this._disabledInputs = $.map(this._disabledInputs,
            function(value) { return (value === target ? null : value); }); // delete entry
        this._disabledInputs[this._disabledInputs.length] = target;
    },

    /* Is the first field in a jQuery collection disabled as a datepicker?
     * @param  target   element - the target input field or division or span
     * @return boolean - true if disabled, false if enabled
     */
    _isDisabledDatepicker: function(target) {
        if (!target) {
            return false;
        }
        for (var i = 0; i < this._disabledInputs.length; i++) {
            if (this._disabledInputs[i] === target) {
                return true;
            }
        }
        return false;
    },

    /* Retrieve the instance data for the target control.
     * @param  target  element - the target input field or division or span
     * @return  object - the associated instance data
     * @throws  error if a jQuery problem getting data
     */
    _getInst: function(target) {
        try {
            return $.data(target, PROP_NAME);
        }
        catch (err) {
            throw "Missing instance data for this datepicker";
        }
    },

    /* Update or retrieve the settings for a date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     * @param  name object - the new settings to update or
     *              string - the name of the setting to change or retrieve,
     *              when retrieving also "all" for all instance settings or
     *              "defaults" for all global defaults
     * @param  value   any - the new value for the setting
     *              (omit if above is an object or to retrieve a value)
     */
    _optionDatepicker: function(target, name, value) {
        var settings, date, minDate, maxDate,
            inst = this._getInst(target);

        if (arguments.length === 2 && typeof name === "string") {
            return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                (inst ? (name === "all" ? $.extend({}, inst.settings) :
                this._get(inst, name)) : null));
        }

        settings = name || {};
        if (typeof name === "string") {
            settings = {};
            settings[name] = value;
        }

        if (inst) {
            if (this._curInst === inst) {
                this._hideDatepicker();
            }

            date = this._getDateDatepicker(target, true);
            minDate = this._getMinMaxDate(inst, "min");
            maxDate = this._getMinMaxDate(inst, "max");
            extendRemove(inst.settings, settings);
            // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
            if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                inst.settings.minDate = this._formatDate(inst, minDate);
            }
            if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                inst.settings.maxDate = this._formatDate(inst, maxDate);
            }
            if ( "disabled" in settings ) {
                if ( settings.disabled ) {
                    this._disableDatepicker(target);
                } else {
                    this._enableDatepicker(target);
                }
            }
            this._attachments($(target), inst);
            this._autoSize(inst);
            this._setDate(inst, date);
            this._updateAlternate(inst);
            this._updateDatepicker(inst);
        }
    },

    // change method deprecated
    _changeDatepicker: function(target, name, value) {
        this._optionDatepicker(target, name, value);
    },

    /* Redraw the date picker attached to an input field or division.
     * @param  target  element - the target input field or division or span
     */
    _refreshDatepicker: function(target) {
        var inst = this._getInst(target);
        if (inst) {
            this._updateDatepicker(inst);
        }
    },

    /* Set the dates for a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  date Date - the new date
     */
    _setDateDatepicker: function(target, date) {
        var inst = this._getInst(target);
        if (inst) {
            this._setDate(inst, date);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
        }
    },

    /* Get the date(s) for the first entry in a jQuery selection.
     * @param  target element - the target input field or division or span
     * @param  noDefault boolean - true if no default date is to be used
     * @return Date - the current date
     */
    _getDateDatepicker: function(target, noDefault) {
        var inst = this._getInst(target);
        if (inst && !inst.inline) {
            this._setDateFromField(inst, noDefault);
        }
        return (inst ? this._getDate(inst) : null);
    },

    /* Handle keystrokes. */
    _doKeyDown: function(event) {
        var onSelect, dateStr, sel,
            inst = $.datepicker._getInst(event.target),
            handled = true,
            isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

        inst._keyEvent = true;
        if ($.datepicker._datepickerShowing) {
            switch (event.keyCode) {
                case 9: $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                                    $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // trigger custom callback
                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                case 27: $.datepicker._hideDatepicker();
                        break; // hide on escape
                case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            -$.datepicker._get(inst, "stepBigMonths") :
                            -$.datepicker._get(inst, "stepMonths")), "M");
                        break; // previous month/year on page up/+ ctrl
                case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            +$.datepicker._get(inst, "stepBigMonths") :
                            +$.datepicker._get(inst, "stepMonths")), "M");
                        break; // next month/year on page down/+ ctrl
                case 35: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                case 36: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                case 37: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                -$.datepicker._get(inst, "stepBigMonths") :
                                -$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +left on Mac
                        break;
                case 38: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                case 39: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                +$.datepicker._get(inst, "stepBigMonths") :
                                +$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +right
                        break;
                case 40: if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                default: handled = false;
            }
        } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
            $.datepicker._showDatepicker(this);
        } else {
            handled = false;
        }

        if (handled) {
            event.preventDefault();
            event.stopPropagation();
        }
    },

    /* Filter entered characters - based on date format. */
    _doKeyPress: function(event) {
        var chars, chr,
            inst = $.datepicker._getInst(event.target);

        if ($.datepicker._get(inst, "constrainInput")) {
            chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
            chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
            return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
        }
    },

    /* Synchronise manual entry and field/alternate field. */
    _doKeyUp: function(event) {
        var date,
            inst = $.datepicker._getInst(event.target);

        if (inst.input.val() !== inst.lastVal) {
            try {
                date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                    (inst.input ? inst.input.val() : null),
                    $.datepicker._getFormatConfig(inst));

                if (date) { // only if valid
                    $.datepicker._setDateFromField(inst);
                    $.datepicker._updateAlternate(inst);
                    $.datepicker._updateDatepicker(inst);
                }
            }
            catch (err) {
            }
        }
        return true;
    },

    /* Pop-up the date picker for a given input field.
     * If false returned from beforeShow event handler do not show.
     * @param  input  element - the input field attached to the date picker or
     *                  event - if triggered by focus
     */
    _showDatepicker: function(input) {
        input = input.target || input;
        if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
            input = $("input", input.parentNode)[0];
        }

        if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
            return;
        }

        var inst, beforeShow, beforeShowSettings, isFixed,
            offset, showAnim, duration;

        inst = $.datepicker._getInst(input);
        if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
            $.datepicker._curInst.dpDiv.stop(true, true);
            if ( inst && $.datepicker._datepickerShowing ) {
                $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
            }
        }

        beforeShow = $.datepicker._get(inst, "beforeShow");
        beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
        if(beforeShowSettings === false){
            return;
        }
        extendRemove(inst.settings, beforeShowSettings);

        inst.lastVal = null;
        $.datepicker._lastInput = input;
        $.datepicker._setDateFromField(inst);

        if ($.datepicker._inDialog) { // hide cursor
            input.value = "";
        }
        if (!$.datepicker._pos) { // position below input
            $.datepicker._pos = $.datepicker._findPos(input);
            $.datepicker._pos[1] += input.offsetHeight; // add the height
        }

        isFixed = false;
        $(input).parents().each(function() {
            isFixed |= $(this).css("position") === "fixed";
            return !isFixed;
        });

        offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
        $.datepicker._pos = null;
        //to avoid flashes on Firefox
        inst.dpDiv.empty();
        // determine sizing offscreen
        inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
        $.datepicker._updateDatepicker(inst);
        // fix width for dynamic number of date pickers
        // and adjust position before showing
        offset = $.datepicker._checkOffset(inst, offset, isFixed);
        inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
            "static" : (isFixed ? "fixed" : "absolute")), display: "none",
            left: offset.left + "px", top: offset.top + "px"});

        if (!inst.inline) {
            showAnim = $.datepicker._get(inst, "showAnim");
            duration = $.datepicker._get(inst, "duration");
            inst.dpDiv.zIndex($(input).zIndex()+1);
            $.datepicker._datepickerShowing = true;

            if ( $.effects && $.effects.effect[ showAnim ] ) {
                inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
            } else {
                inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
            }

            if ( $.datepicker._shouldFocusInput( inst ) ) {
                inst.input.focus();
            }

            $.datepicker._curInst = inst;
        }
    },

    /* Generate the date picker content. */
    _updateDatepicker: function(inst) {
        this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
        instActive = inst; // for delegate hover events
        inst.dpDiv.empty().append(this._generateHTML(inst));
        this._attachHandlers(inst);
        inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();

        var origyearshtml,
            numMonths = this._getNumberOfMonths(inst),
            cols = numMonths[1],
            width = 17;

        inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
        if (cols > 1) {
            inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
        }
        inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
            "Class"]("ui-datepicker-multi");
        inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
            "Class"]("ui-datepicker-rtl");

        if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
            inst.input.focus();
        }

        // deffered render of the years select (to avoid flashes on Firefox)
        if( inst.yearshtml ){
            origyearshtml = inst.yearshtml;
            setTimeout(function(){
                //assure that inst.yearshtml didn't change.
                if( origyearshtml === inst.yearshtml && inst.yearshtml ){
                    inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                }
                origyearshtml = inst.yearshtml = null;
            }, 0);
        }
    },

    // #6694 - don't focus the input if it's already focused
    // this breaks the change event in IE
    // Support: IE and jQuery <1.9
    _shouldFocusInput: function( inst ) {
        return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
    },

    /* Check positioning to remain on screen. */
    _checkOffset: function(inst, offset, isFixed) {
        var dpWidth = inst.dpDiv.outerWidth(),
            dpHeight = inst.dpDiv.outerHeight(),
            inputWidth = inst.input ? inst.input.outerWidth() : 0,
            inputHeight = inst.input ? inst.input.outerHeight() : 0,
            viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
            viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

        offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
        offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
        offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

        // now check if datepicker is showing outside window viewport - move to a better place if so.
        offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offset.left + dpWidth - viewWidth) : 0);
        offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + inputHeight) : 0);

        return offset;
    },

    /* Find an object's position on the screen. */
    _findPos: function(obj) {
        var position,
            inst = this._getInst(obj),
            isRTL = this._get(inst, "isRTL");

        while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? "previousSibling" : "nextSibling"];
        }

        position = $(obj).offset();
        return [position.left, position.top];
    },

    /* Hide the date picker from view.
     * @param  input  element - the input field attached to the date picker
     */
    _hideDatepicker: function(input) {
        var showAnim, duration, postProcess, onClose,
            inst = this._curInst;

        if (!inst || (input && inst !== $.data(input, PROP_NAME))) {
            return;
        }

        if (this._datepickerShowing) {
            showAnim = this._get(inst, "showAnim");
            duration = this._get(inst, "duration");
            postProcess = function() {
                $.datepicker._tidyDialog(inst);
            };

            // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
            if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
                inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
            } else {
                inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                    (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
            }

            if (!showAnim) {
                postProcess();
            }
            this._datepickerShowing = false;

            onClose = this._get(inst, "onClose");
            if (onClose) {
                onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
            }

            this._lastInput = null;
            if (this._inDialog) {
                this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
                if ($.blockUI) {
                    $.unblockUI();
                    $("body").append(this.dpDiv);
                }
            }
            this._inDialog = false;
        }
    },

    /* Tidy up after a dialog display. */
    _tidyDialog: function(inst) {
        inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
    },

    /* Close date picker if clicked elsewhere. */
    _checkExternalClick: function(event) {
        if (!$.datepicker._curInst) {
            return;
        }

        var $target = $(event.target),
            inst = $.datepicker._getInst($target[0]);

        if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
                $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                !$target.hasClass($.datepicker.markerClassName) &&
                !$target.closest("." + $.datepicker._triggerClass).length &&
                $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
            ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
                $.datepicker._hideDatepicker();
        }
    },

    /* Adjust one of the date sub-fields. */
    _adjustDate: function(id, offset, period) {
        var target = $(id),
            inst = this._getInst(target[0]);

        if (this._isDisabledDatepicker(target[0])) {
            return;
        }
        this._adjustInstDate(inst, offset +
            (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
            period);
        this._updateDatepicker(inst);
    },

    /* Action for current link. */
    _gotoToday: function(id) {
        var date,
            target = $(id),
            inst = this._getInst(target[0]);

        if (this._get(inst, "gotoCurrent") && inst.currentDay) {
            inst.selectedDay = inst.currentDay;
            inst.drawMonth = inst.selectedMonth = inst.currentMonth;
            inst.drawYear = inst.selectedYear = inst.currentYear;
        } else {
            date = new Date();
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
        }
        this._notifyChange(inst);
        this._adjustDate(target);
    },

    /* Action for selecting a new month/year. */
    _selectMonthYear: function(id, select, period) {
        var target = $(id),
            inst = this._getInst(target[0]);

        inst["selected" + (period === "M" ? "Month" : "Year")] =
        inst["draw" + (period === "M" ? "Month" : "Year")] =
            parseInt(select.options[select.selectedIndex].value,10);

        this._notifyChange(inst);
        this._adjustDate(target);
    },

    /* Action for selecting a day. */
    _selectDay: function(id, month, year, td) {
        var inst,
            target = $(id);

        if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
            return;
        }

        inst = this._getInst(target[0]);
        inst.selectedDay = inst.currentDay = $("a", td).html();
        inst.selectedMonth = inst.currentMonth = month;
        inst.selectedYear = inst.currentYear = year;
        this._selectDate(id, this._formatDate(inst,
            inst.currentDay, inst.currentMonth, inst.currentYear));
    },

    /* Erase the input field and hide the date picker. */
    _clearDate: function(id) {
        var target = $(id);
        this._selectDate(target, "");
    },

    /* Update the input field with the selected date. */
    _selectDate: function(id, dateStr) {
        var onSelect,
            target = $(id),
            inst = this._getInst(target[0]);

        dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
        if (inst.input) {
            inst.input.val(dateStr);
        }
        this._updateAlternate(inst);

        onSelect = this._get(inst, "onSelect");
        if (onSelect) {
            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
        } else if (inst.input) {
            inst.input.trigger("change"); // fire the change event
        }

        if (inst.inline){
            this._updateDatepicker(inst);
        } else {
            this._hideDatepicker();
            this._lastInput = inst.input[0];
            if (typeof(inst.input[0]) !== "object") {
                inst.input.focus(); // restore focus
            }
            this._lastInput = null;
        }
    },

    /* Update any alternate field to synchronise with the main field. */
    _updateAlternate: function(inst) {
        var altFormat, date, dateStr,
            altField = this._get(inst, "altField");

        if (altField) { // update alternate field too
            altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
            date = this._getDate(inst);
            dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
            $(altField).each(function() { $(this).val(dateStr); });
        }
    },

    /* Set as beforeShowDay function to prevent selection of weekends.
     * @param  date  Date - the date to customise
     * @return [boolean, string] - is this date selectable?, what is its CSS class?
     */
    noWeekends: function(date) {
        var day = date.getDay();
        return [(day > 0 && day < 6), ""];
    },

    /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
     * @param  date  Date - the date to get the week for
     * @return  number - the number of the week within the year that contains this date
     */
    iso8601Week: function(date) {
        var time,
            checkDate = new Date(date.getTime());

        // Find Thursday of this week starting on Monday
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

        time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },

    /* Parse a string value into a date object.
     * See formatDate below for the possible formats.
     *
     * @param  format string - the expected format of the date
     * @param  value string - the date in the above format
     * @param  settings Object - attributes include:
     *                  shortYearCutoff  number - the cutoff year for determining the century (optional)
     *                  dayNamesShort   string[7] - abbreviated names of the days from Sunday (optional)
     *                  dayNames        string[7] - names of the days from Sunday (optional)
     *                  monthNamesShort string[12] - abbreviated names of the months (optional)
     *                  monthNames      string[12] - names of the months (optional)
     * @return  Date - the extracted date value or null if value is blank
     */
    parseDate: function (format, value, settings) {
        if (format == null || value == null) {
            throw "Invalid arguments";
        }

        value = (typeof value === "object" ? value.toString() : value + "");
        if (value === "") {
            return null;
        }

        var iFormat, dim, extra,
            iValue = 0,
            shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
            shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            year = -1,
            month = -1,
            day = -1,
            doy = -1,
            literal = false,
            date,
            // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                    iFormat++;
                }
                return matches;
            },
            // Extract a number from the string value
            getNumber = function(match) {
                var isDoubled = lookAhead(match),
                    size = (match === "@" ? 14 : (match === "!" ? 20 :
                    (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                    digits = new RegExp("^\\d{1," + size + "}"),
                    num = value.substring(iValue).match(digits);
                if (!num) {
                    throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            },
            // Extract a name from the string value and convert to an index
            getName = function(match, shortNames, longNames) {
                var index = -1,
                    names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                        return [ [k, v] ];
                    }).sort(function (a, b) {
                        return -(a[1].length - b[1].length);
                    });

                $.each(names, function (i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index !== -1) {
                    return index + 1;
                } else {
                    throw "Unknown name at position " + iValue;
                }
            },
            // Confirm that a literal character matches the string value
            checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue;
                }
                iValue++;
            };

        for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                    literal = false;
                } else {
                    checkLiteral();
                }
            } else {
                switch (format.charAt(iFormat)) {
                    case "d":
                        day = getNumber("d");
                        break;
                    case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;
                    case "o":
                        doy = getNumber("o");
                        break;
                    case "m":
                        month = getNumber("m");
                        break;
                    case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;
                    case "y":
                        year = getNumber("y");
                        break;
                    case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case "'":
                        if (lookAhead("'")){
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        checkLiteral();
                }
            }
        }

        if (iValue < value.length){
            extra = value.substr(iValue);
            if (!/^\s+/.test(extra)) {
                throw "Extra/unparsed characters found in date: " + extra;
            }
        }

        if (year === -1) {
            year = new Date().getFullYear();
        } else if (year < 100) {
            year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                (year <= shortYearCutoff ? 0 : -100);
        }

        if (doy > -1) {
            month = 1;
            day = doy;
            do {
                dim = this._getDaysInMonth(year, month - 1);
                if (day <= dim) {
                    break;
                }
                month++;
                day -= dim;
            } while (true);
        }

        date = this._daylightSavingAdjust(new Date(year, month - 1, day));
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
            throw "Invalid date"; // E.g. 31/02/00
        }
        return date;
    },

    /* Standard date formats. */
    ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
    COOKIE: "D, dd M yy",
    ISO_8601: "yy-mm-dd",
    RFC_822: "D, d M y",
    RFC_850: "DD, dd-M-y",
    RFC_1036: "D, d M y",
    RFC_1123: "D, d M yy",
    RFC_2822: "D, d M yy",
    RSS: "D, d M y", // RFC 822
    TICKS: "!",
    TIMESTAMP: "@",
    W3C: "yy-mm-dd", // ISO 8601

    _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
        Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

    /* Format a date object into a string value.
     * The format can be combinations of the following:
     * d  - day of month (no leading zero)
     * dd - day of month (two digit)
     * o  - day of year (no leading zeros)
     * oo - day of year (three digit)
     * D  - day name short
     * DD - day name long
     * m  - month of year (no leading zero)
     * mm - month of year (two digit)
     * M  - month name short
     * MM - month name long
     * y  - year (two digit)
     * yy - year (four digit)
     * @ - Unix timestamp (ms since 01/01/1970)
     * ! - Windows ticks (100ns since 01/01/0001)
     * "..." - literal text
     * '' - single quote
     *
     * @param  format string - the desired format of the date
     * @param  date Date - the date value to format
     * @param  settings Object - attributes include:
     *                  dayNamesShort   string[7] - abbreviated names of the days from Sunday (optional)
     *                  dayNames        string[7] - names of the days from Sunday (optional)
     *                  monthNamesShort string[12] - abbreviated names of the months (optional)
     *                  monthNames      string[12] - names of the months (optional)
     * @return  string - the date in the above format
     */
    formatDate: function (format, date, settings) {
        if (!date) {
            return "";
        }

        var iFormat,
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                    iFormat++;
                }
                return matches;
            },
            // Format a number, with leading zero if necessary
            formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                    while (num.length < len) {
                        num = "0" + num;
                    }
                }
                return num;
            },
            // Format a name, short or long as requested
            formatName = function(match, value, shortNames, longNames) {
                return (lookAhead(match) ? longNames[value] : shortNames[value]);
            },
            output = "",
            literal = false;

        if (date) {
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        output += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;
                        case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;
                        case "o":
                            output += formatNumber("o",
                                Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                            break;
                        case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;
                        case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;
                        case "y":
                            output += (lookAhead("y") ? date.getFullYear() :
                                (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                            break;
                        case "@":
                            output += date.getTime();
                            break;
                        case "!":
                            output += date.getTime() * 10000 + this._ticksTo1970;
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                output += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            output += format.charAt(iFormat);
                    }
                }
            }
        }
        return output;
    },

    /* Extract all possible characters from the date format. */
    _possibleChars: function (format) {
        var iFormat,
            chars = "",
            literal = false,
            // Check whether a format character is doubled
            lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                if (matches) {
                    iFormat++;
                }
                return matches;
            };

        for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
                if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                    literal = false;
                } else {
                    chars += format.charAt(iFormat);
                }
            } else {
                switch (format.charAt(iFormat)) {
                    case "d": case "m": case "y": case "@":
                        chars += "0123456789";
                        break;
                    case "D": case "M":
                        return null; // Accept anything
                    case "'":
                        if (lookAhead("'")) {
                            chars += "'";
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        chars += format.charAt(iFormat);
                }
            }
        }
        return chars;
    },

    /* Get a setting value, defaulting if necessary. */
    _get: function(inst, name) {
        return inst.settings[name] !== undefined ?
            inst.settings[name] : this._defaults[name];
    },

    /* Parse existing date and initialise date picker. */
    _setDateFromField: function(inst, noDefault) {
        if (inst.input.val() === inst.lastVal) {
            return;
        }

        var dateFormat = this._get(inst, "dateFormat"),
            dates = inst.lastVal = inst.input ? inst.input.val() : null,
            defaultDate = this._getDefaultDate(inst),
            date = defaultDate,
            settings = this._getFormatConfig(inst);

        try {
            date = this.parseDate(dateFormat, dates, settings) || defaultDate;
        } catch (event) {
            dates = (noDefault ? "" : dates);
        }
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        inst.currentDay = (dates ? date.getDate() : 0);
        inst.currentMonth = (dates ? date.getMonth() : 0);
        inst.currentYear = (dates ? date.getFullYear() : 0);
        this._adjustInstDate(inst);
    },

    /* Retrieve the default date shown on opening. */
    _getDefaultDate: function(inst) {
        return this._restrictMinMax(inst,
            this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
    },

    /* A date may be specified as an exact value or a relative one. */
    _determineDate: function(inst, date, defaultDate) {
        var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            },
            offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                        offset, $.datepicker._getFormatConfig(inst));
                }
                catch (e) {
                    // Ignore
                }

                var date = (offset.toLowerCase().match(/^c/) ?
                    $.datepicker._getDate(inst) : null) || new Date(),
                    year = date.getFullYear(),
                    month = date.getMonth(),
                    day = date.getDate(),
                    pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                    matches = pattern.exec(offset);

                while (matches) {
                    switch (matches[2] || "d") {
                        case "d" : case "D" :
                            day += parseInt(matches[1],10); break;
                        case "w" : case "W" :
                            day += parseInt(matches[1],10) * 7; break;
                        case "m" : case "M" :
                            month += parseInt(matches[1],10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        case "y": case "Y" :
                            year += parseInt(matches[1],10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            },
            newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

        newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
        if (newDate) {
            newDate.setHours(0);
            newDate.setMinutes(0);
            newDate.setSeconds(0);
            newDate.setMilliseconds(0);
        }
        return this._daylightSavingAdjust(newDate);
    },

    /* Handle switch to/from daylight saving.
     * Hours may be non-zero on daylight saving cut-over:
     * > 12 when midnight changeover, but then cannot generate
     * midnight datetime, so jump to 1AM, otherwise reset.
     * @param  date  (Date) the date to check
     * @return  (Date) the corrected date
     */
    _daylightSavingAdjust: function(date) {
        if (!date) {
            return null;
        }
        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
        return date;
    },

    /* Set the date(s) directly. */
    _setDate: function(inst, date, noChange) {
        var clear = !date,
            origMonth = inst.selectedMonth,
            origYear = inst.selectedYear,
            newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

        inst.selectedDay = inst.currentDay = newDate.getDate();
        inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
        inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
        if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
            this._notifyChange(inst);
        }
        this._adjustInstDate(inst);
        if (inst.input) {
            inst.input.val(clear ? "" : this._formatDate(inst));
        }
    },

    /* Retrieve the date(s) directly. */
    _getDate: function(inst) {
        var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
            this._daylightSavingAdjust(new Date(
            inst.currentYear, inst.currentMonth, inst.currentDay)));
            return startDate;
    },

    /* Attach the onxxx handlers.  These are declared statically so
     * they work with static code transformers like Caja.
     */
    _attachHandlers: function(inst) {
        var stepMonths = this._get(inst, "stepMonths"),
            id = "#" + inst.id.replace( /\\\\/g, "\\" );
        inst.dpDiv.find("[data-handler]").map(function () {
            var handler = {
                prev: function () {
                    $.datepicker._adjustDate(id, -stepMonths, "M");
                },
                next: function () {
                    $.datepicker._adjustDate(id, +stepMonths, "M");
                },
                hide: function () {
                    $.datepicker._hideDatepicker();
                },
                today: function () {
                    $.datepicker._gotoToday(id);
                },
                selectDay: function () {
                    $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                    return false;
                },
                selectMonth: function () {
                    $.datepicker._selectMonthYear(id, this, "M");
                    return false;
                },
                selectYear: function () {
                    $.datepicker._selectMonthYear(id, this, "Y");
                    return false;
                }
            };
            $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
        });
    },

    /* Generate the HTML for the current state of the date picker. */
    _generateHTML: function(inst) {
        var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
            controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
            monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
            selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
            cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
            printDate, dRow, tbody, daySettings, otherMonth, unselectable,
            tempDate = new Date(),
            today = this._daylightSavingAdjust(
                new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
            isRTL = this._get(inst, "isRTL"),
            showButtonPanel = this._get(inst, "showButtonPanel"),
            hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
            navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
            numMonths = this._getNumberOfMonths(inst),
            showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
            stepMonths = this._get(inst, "stepMonths"),
            isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
            currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            drawMonth = inst.drawMonth - showCurrentAtPos,
            drawYear = inst.drawYear;

        if (drawMonth < 0) {
            drawMonth += 12;
            drawYear--;
        }
        if (maxDate) {
            maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
            maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
            while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                drawMonth--;
                if (drawMonth < 0) {
                    drawMonth = 11;
                    drawYear--;
                }
            }
        }
        inst.drawMonth = drawMonth;
        inst.drawYear = drawYear;

        prevText = this._get(inst, "prevText");
        prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
            this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
            this._getFormatConfig(inst)));

        prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
            "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
            " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
            (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

        nextText = this._get(inst, "nextText");
        nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
            this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
            this._getFormatConfig(inst)));

        next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
            "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
            " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
            (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

        currentText = this._get(inst, "currentText");
        gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
        currentText = (!navigationAsDateFormat ? currentText :
            this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

        controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
            this._get(inst, "closeText") + "</button>" : "");

        buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
            (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
            ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

        firstDay = parseInt(this._get(inst, "firstDay"),10);
        firstDay = (isNaN(firstDay) ? 0 : firstDay);

        showWeek = this._get(inst, "showWeek");
        dayNames = this._get(inst, "dayNames");
        dayNamesMin = this._get(inst, "dayNamesMin");
        monthNames = this._get(inst, "monthNames");
        monthNamesShort = this._get(inst, "monthNamesShort");
        beforeShowDay = this._get(inst, "beforeShowDay");
        showOtherMonths = this._get(inst, "showOtherMonths");
        selectOtherMonths = this._get(inst, "selectOtherMonths");
        defaultDate = this._getDefaultDate(inst);
        html = "";
        dow;
        for (row = 0; row < numMonths[0]; row++) {
            group = "";
            this.maxRows = 4;
            for (col = 0; col < numMonths[1]; col++) {
                selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                cornerClass = " ui-corner-all";
                calender = "";
                if (isMultiMonth) {
                    calender += "<div class='ui-datepicker-group";
                    if (numMonths[1] > 1) {
                        switch (col) {
                            case 0: calender += " ui-datepicker-group-first";
                                cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                            case numMonths[1]-1: calender += " ui-datepicker-group-last";
                                cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                            default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                        }
                    }
                    calender += "'>";
                }
                calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                    (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                    (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                    this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                    row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                    "</div><table class='ui-datepicker-calendar'><thead>" +
                    "<tr>";
                thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                for (dow = 0; dow < 7; dow++) { // days of the week
                    day = (dow + firstDay) % 7;
                    thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                        "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                }
                calender += thead + "</tr></thead><tbody>";
                daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                    inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                }
                leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                this.maxRows = numRows;
                printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                    calender += "<tr>";
                    tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                        this._get(inst, "calculateWeek")(printDate) + "</td>");
                    for (dow = 0; dow < 7; dow++) { // create date picker days
                        daySettings = (beforeShowDay ?
                            beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                        otherMonth = (printDate.getMonth() !== drawMonth);
                        unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                            (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                        tbody += "<td class='" +
                            ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                            (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                            ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                            (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                            // or defaultDate is current printedDate and defaultDate is selectedDate
                            " " + this._dayOverClass : "") + // highlight selected day
                            (unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
                            (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                            (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                            (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                            ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                            (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                            (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                            (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                            (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                            (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                            (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                            "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                        printDate.setDate(printDate.getDate() + 1);
                        printDate = this._daylightSavingAdjust(printDate);
                    }
                    calender += tbody + "</tr>";
                }
                drawMonth++;
                if (drawMonth > 11) {
                    drawMonth = 0;
                    drawYear++;
                }
                calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                            ((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                group += calender;
            }
            html += group;
        }
        html += buttonPanel;
        inst._keyEvent = false;
        return html;
    },

    /* Generate the month and year header. */
    _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
            secondary, monthNames, monthNamesShort) {

        var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
            changeMonth = this._get(inst, "changeMonth"),
            changeYear = this._get(inst, "changeYear"),
            showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
            html = "<div class='ui-datepicker-title'>",
            monthHtml = "";

        // month selection
        if (secondary || !changeMonth) {
            monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
        } else {
            inMinYear = (minDate && minDate.getFullYear() === drawYear);
            inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
            monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
            for ( month = 0; month < 12; month++) {
                if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                    monthHtml += "<option value='" + month + "'" +
                        (month === drawMonth ? " selected='selected'" : "") +
                        ">" + monthNamesShort[month] + "</option>";
                }
            }
            monthHtml += "</select>";
        }

        if (!showMonthAfterYear) {
            html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
        }

        // year selection
        if ( !inst.yearshtml ) {
            inst.yearshtml = "";
            if (secondary || !changeYear) {
                html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
            } else {
                // determine range of years to display
                years = this._get(inst, "yearRange").split(":");
                thisYear = new Date().getFullYear();
                determineYear = function(value) {
                    var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                        (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                        parseInt(value, 10)));
                    return (isNaN(year) ? thisYear : year);
                };
                year = determineYear(years[0]);
                endYear = Math.max(year, determineYear(years[1] || ""));
                year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                for (; year <= endYear; year++) {
                    inst.yearshtml += "<option value='" + year + "'" +
                        (year === drawYear ? " selected='selected'" : "") +
                        ">" + year + "</option>";
                }
                inst.yearshtml += "</select>";

                html += inst.yearshtml;
                inst.yearshtml = null;
            }
        }

        html += this._get(inst, "yearSuffix");
        if (showMonthAfterYear) {
            html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
        }
        html += "</div>"; // Close datepicker_header
        return html;
    },

    /* Adjust one of the date sub-fields. */
    _adjustInstDate: function(inst, offset, period) {
        var year = inst.drawYear + (period === "Y" ? offset : 0),
            month = inst.drawMonth + (period === "M" ? offset : 0),
            day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
            date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        if (period === "M" || period === "Y") {
            this._notifyChange(inst);
        }
    },

    /* Ensure a date is within any min/max bounds. */
    _restrictMinMax: function(inst, date) {
        var minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            newDate = (minDate && date < minDate ? minDate : date);
        return (maxDate && newDate > maxDate ? maxDate : newDate);
    },

    /* Notify change of month/year. */
    _notifyChange: function(inst) {
        var onChange = this._get(inst, "onChangeMonthYear");
        if (onChange) {
            onChange.apply((inst.input ? inst.input[0] : null),
                [inst.selectedYear, inst.selectedMonth + 1, inst]);
        }
    },

    /* Determine the number of months to show. */
    _getNumberOfMonths: function(inst) {
        var numMonths = this._get(inst, "numberOfMonths");
        return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
    },

    /* Determine the current maximum date - ensure no time components are set. */
    _getMinMaxDate: function(inst, minMax) {
        return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
    },

    /* Find the number of days in a given month. */
    _getDaysInMonth: function(year, month) {
        return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },

    /* Find the day of the week of the first of a month. */
    _getFirstDayOfMonth: function(year, month) {
        return new Date(year, month, 1).getDay();
    },

    /* Determines if we should allow a "next/prev" month display change. */
    _canAdjustMonth: function(inst, offset, curYear, curMonth) {
        var numMonths = this._getNumberOfMonths(inst),
            date = this._daylightSavingAdjust(new Date(curYear,
            curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

        if (offset < 0) {
            date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
        }
        return this._isInRange(inst, date);
    },

    /* Is the given date in the accepted range? */
    _isInRange: function(inst, date) {
        var yearSplit, currentYear,
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            minYear = null,
            maxYear = null,
            years = this._get(inst, "yearRange");
            if (years){
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if ( yearSplit[0].match(/[+\-].*/) ) {
                    minYear += currentYear;
                }
                if ( yearSplit[1].match(/[+\-].*/) ) {
                    maxYear += currentYear;
                }
            }

        return ((!minDate || date.getTime() >= minDate.getTime()) &&
            (!maxDate || date.getTime() <= maxDate.getTime()) &&
            (!minYear || date.getFullYear() >= minYear) &&
            (!maxYear || date.getFullYear() <= maxYear));
    },

    /* Provide the configuration settings for formatting/parsing. */
    _getFormatConfig: function(inst) {
        var shortYearCutoff = this._get(inst, "shortYearCutoff");
        shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
            new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
        return {shortYearCutoff: shortYearCutoff,
            dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
            monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
    },

    /* Format the given date for display. */
    _formatDate: function(inst, day, month, year) {
        if (!day) {
            inst.currentDay = inst.selectedDay;
            inst.currentMonth = inst.selectedMonth;
            inst.currentYear = inst.selectedYear;
        }
        var date = (day ? (typeof day === "object" ? day :
            this._daylightSavingAdjust(new Date(year, month, day))) :
            this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
        return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
    }
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
    var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
    return dpDiv.delegate(selector, "mouseout", function() {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        })
        .delegate(selector, "mouseover", function(){
            if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
                $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                $(this).addClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).addClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).addClass("ui-datepicker-next-hover");
                }
            }
        });
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
        if (props[name] == null) {
            target[name] = props[name];
        }
    }
    return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

    /* Verify an empty collection wasn't passed - Fixes #6976 */
    if ( !this.length ) {
        return this;
    }

    /* Initialise the date picker. */
    if (!$.datepicker.initialized) {
        $(document).mousedown($.datepicker._checkExternalClick);
        $.datepicker.initialized = true;
    }

    /* Append datepicker main container to body if not exist. */
    if ($("#"+$.datepicker._mainDivId).length === 0) {
        $("body").append($.datepicker.dpDiv);
    }

    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
        return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
        return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function() {
        typeof options === "string" ?
            $.datepicker["_" + options + "Datepicker"].
                apply($.datepicker, [this].concat(otherArgs)) :
            $.datepicker._attachDatepicker(this, options);
    });
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.10.4";

})(jQuery);

(function( $, undefined ) {

var sizeRelatedOptions = {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
    },
    resizableRelatedOptions = {
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true
    };

$.widget( "ui.dialog", {
    version: "1.10.4",
    options: {
        appendTo: "body",
        autoOpen: true,
        buttons: [],
        closeOnEscape: true,
        closeText: "close",
        dialogClass: "",
        draggable: true,
        hide: null,
        height: "auto",
        maxHeight: null,
        maxWidth: null,
        minHeight: 150,
        minWidth: 150,
        modal: false,
        position: {
            my: "center",
            at: "center",
            of: window,
            collision: "fit",
            // Ensure the titlebar is always visible
            using: function( pos ) {
                var topOffset = $( this ).css( pos ).offset().top;
                if ( topOffset < 0 ) {
                    $( this ).css( "top", pos.top - topOffset );
                }
            }
        },
        resizable: true,
        show: null,
        title: null,
        width: 300,

        // callbacks
        beforeClose: null,
        close: null,
        drag: null,
        dragStart: null,
        dragStop: null,
        focus: null,
        open: null,
        resize: null,
        resizeStart: null,
        resizeStop: null
    },

    _create: function() {
        this.originalCss = {
            display: this.element[0].style.display,
            width: this.element[0].style.width,
            minHeight: this.element[0].style.minHeight,
            maxHeight: this.element[0].style.maxHeight,
            height: this.element[0].style.height
        };
        this.originalPosition = {
            parent: this.element.parent(),
            index: this.element.parent().children().index( this.element )
        };
        this.originalTitle = this.element.attr("title");
        this.options.title = this.options.title || this.originalTitle;

        this._createWrapper();

        this.element
            .show()
            .removeAttr("title")
            .addClass("ui-dialog-content ui-widget-content")
            .appendTo( this.uiDialog );

        this._createTitlebar();
        this._createButtonPane();

        if ( this.options.draggable && $.fn.draggable ) {
            this._makeDraggable();
        }
        if ( this.options.resizable && $.fn.resizable ) {
            this._makeResizable();
        }

        this._isOpen = false;
    },

    _init: function() {
        if ( this.options.autoOpen ) {
            this.open();
        }
    },

    _appendTo: function() {
        var element = this.options.appendTo;
        if ( element && (element.jquery || element.nodeType) ) {
            return $( element );
        }
        return this.document.find( element || "body" ).eq( 0 );
    },

    _destroy: function() {
        var next,
            originalPosition = this.originalPosition;

        this._destroyOverlay();

        this.element
            .removeUniqueId()
            .removeClass("ui-dialog-content ui-widget-content")
            .css( this.originalCss )
            // Without detaching first, the following becomes really slow
            .detach();

        this.uiDialog.stop( true, true ).remove();

        if ( this.originalTitle ) {
            this.element.attr( "title", this.originalTitle );
        }

        next = originalPosition.parent.children().eq( originalPosition.index );
        // Don't try to place the dialog next to itself (#8613)
        if ( next.length && next[0] !== this.element[0] ) {
            next.before( this.element );
        } else {
            originalPosition.parent.append( this.element );
        }
    },

    widget: function() {
        return this.uiDialog;
    },

    disable: $.noop,
    enable: $.noop,

    close: function( event ) {
        var activeElement,
            that = this;

        if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
            return;
        }

        this._isOpen = false;
        this._destroyOverlay();

        if ( !this.opener.filter(":focusable").focus().length ) {

            // support: IE9
            // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
            try {
                activeElement = this.document[ 0 ].activeElement;

                // Support: IE9, IE10
                // If the <body> is blurred, IE will switch windows, see #4520
                if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

                    // Hiding a focused element doesn't trigger blur in WebKit
                    // so in case we have nothing to focus on, explicitly blur the active element
                    // https://bugs.webkit.org/show_bug.cgi?id=47182
                    $( activeElement ).blur();
                }
            } catch ( error ) {}
        }

        this._hide( this.uiDialog, this.options.hide, function() {
            that._trigger( "close", event );
        });
    },

    isOpen: function() {
        return this._isOpen;
    },

    moveToTop: function() {
        this._moveToTop();
    },

    _moveToTop: function( event, silent ) {
        var moved = !!this.uiDialog.nextAll(":visible").insertBefore( this.uiDialog ).length;
        if ( moved && !silent ) {
            this._trigger( "focus", event );
        }
        return moved;
    },

    open: function() {
        var that = this;
        if ( this._isOpen ) {
            if ( this._moveToTop() ) {
                this._focusTabbable();
            }
            return;
        }

        this._isOpen = true;
        this.opener = $( this.document[0].activeElement );

        this._size();
        this._position();
        this._createOverlay();
        this._moveToTop( null, true );
        this._show( this.uiDialog, this.options.show, function() {
            that._focusTabbable();
            that._trigger("focus");
        });

        this._trigger("open");
    },

    _focusTabbable: function() {
        // Set focus to the first match:
        // 1. First element inside the dialog matching [autofocus]
        // 2. Tabbable element inside the content element
        // 3. Tabbable element inside the buttonpane
        // 4. The close button
        // 5. The dialog itself
        var hasFocus = this.element.find("[autofocus]");
        if ( !hasFocus.length ) {
            hasFocus = this.element.find(":tabbable");
        }
        if ( !hasFocus.length ) {
            hasFocus = this.uiDialogButtonPane.find(":tabbable");
        }
        if ( !hasFocus.length ) {
            hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
        }
        if ( !hasFocus.length ) {
            hasFocus = this.uiDialog;
        }
        hasFocus.eq( 0 ).focus();
    },

    _keepFocus: function( event ) {
        function checkFocus() {
            var activeElement = this.document[0].activeElement,
                isActive = this.uiDialog[0] === activeElement ||
                    $.contains( this.uiDialog[0], activeElement );
            if ( !isActive ) {
                this._focusTabbable();
            }
        }
        event.preventDefault();
        checkFocus.call( this );
        // support: IE
        // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
        // so we check again later
        this._delay( checkFocus );
    },

    _createWrapper: function() {
        this.uiDialog = $("<div>")
            .addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
                this.options.dialogClass )
            .hide()
            .attr({
                // Setting tabIndex makes the div focusable
                tabIndex: -1,
                role: "dialog"
            })
            .appendTo( this._appendTo() );

        this._on( this.uiDialog, {
            keydown: function( event ) {
                if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE ) {
                    event.preventDefault();
                    this.close( event );
                    return;
                }

                // prevent tabbing out of dialogs
                if ( event.keyCode !== $.ui.keyCode.TAB ) {
                    return;
                }
                var tabbables = this.uiDialog.find(":tabbable"),
                    first = tabbables.filter(":first"),
                    last  = tabbables.filter(":last");

                if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
                    first.focus( 1 );
                    event.preventDefault();
                } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
                    last.focus( 1 );
                    event.preventDefault();
                }
            },
            mousedown: function( event ) {
                if ( this._moveToTop( event ) ) {
                    this._focusTabbable();
                }
            }
        });

        // We assume that any existing aria-describedby attribute means
        // that the dialog content is marked up properly
        // otherwise we brute force the content as the description
        if ( !this.element.find("[aria-describedby]").length ) {
            this.uiDialog.attr({
                "aria-describedby": this.element.uniqueId().attr("id")
            });
        }
    },

    _createTitlebar: function() {
        var uiDialogTitle;

        this.uiDialogTitlebar = $("<div>")
            .addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
            .prependTo( this.uiDialog );
        this._on( this.uiDialogTitlebar, {
            mousedown: function( event ) {
                // Don't prevent click on close button (#8838)
                // Focusing a dialog that is partially scrolled out of view
                // causes the browser to scroll it into view, preventing the click event
                if ( !$( event.target ).closest(".ui-dialog-titlebar-close") ) {
                    // Dialog isn't getting focus when dragging (#8063)
                    this.uiDialog.focus();
                }
            }
        });

        // support: IE
        // Use type="button" to prevent enter keypresses in textboxes from closing the
        // dialog in IE (#9312)
        this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
            .button({
                label: this.options.closeText,
                icons: {
                    primary: "ui-icon-closethick"
                },
                text: false
            })
            .addClass("ui-dialog-titlebar-close")
            .appendTo( this.uiDialogTitlebar );
        this._on( this.uiDialogTitlebarClose, {
            click: function( event ) {
                event.preventDefault();
                this.close( event );
            }
        });

        uiDialogTitle = $("<span>")
            .uniqueId()
            .addClass("ui-dialog-title")
            .prependTo( this.uiDialogTitlebar );
        this._title( uiDialogTitle );

        this.uiDialog.attr({
            "aria-labelledby": uiDialogTitle.attr("id")
        });
    },

    _title: function( title ) {
        if ( !this.options.title ) {
            title.html("&#160;");
        }
        title.text( this.options.title );
    },

    _createButtonPane: function() {
        this.uiDialogButtonPane = $("<div>")
            .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

        this.uiButtonSet = $("<div>")
            .addClass("ui-dialog-buttonset")
            .appendTo( this.uiDialogButtonPane );

        this._createButtons();
    },

    _createButtons: function() {
        var that = this,
            buttons = this.options.buttons;

        // if we already have a button pane, remove it
        this.uiDialogButtonPane.remove();
        this.uiButtonSet.empty();

        if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
            this.uiDialog.removeClass("ui-dialog-buttons");
            return;
        }

        $.each( buttons, function( name, props ) {
            var click, buttonOptions;
            props = $.isFunction( props ) ?
                { click: props, text: name } :
                props;
            // Default to a non-submitting button
            props = $.extend( { type: "button" }, props );
            // Change the context for the click callback to be the main element
            click = props.click;
            props.click = function() {
                click.apply( that.element[0], arguments );
            };
            buttonOptions = {
                icons: props.icons,
                text: props.showText
            };
            delete props.icons;
            delete props.showText;
            $( "<button></button>", props )
                .button( buttonOptions )
                .appendTo( that.uiButtonSet );
        });
        this.uiDialog.addClass("ui-dialog-buttons");
        this.uiDialogButtonPane.appendTo( this.uiDialog );
    },

    _makeDraggable: function() {
        var that = this,
            options = this.options;

        function filteredUi( ui ) {
            return {
                position: ui.position,
                offset: ui.offset
            };
        }

        this.uiDialog.draggable({
            cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
            handle: ".ui-dialog-titlebar",
            containment: "document",
            start: function( event, ui ) {
                $( this ).addClass("ui-dialog-dragging");
                that._blockFrames();
                that._trigger( "dragStart", event, filteredUi( ui ) );
            },
            drag: function( event, ui ) {
                that._trigger( "drag", event, filteredUi( ui ) );
            },
            stop: function( event, ui ) {
                options.position = [
                    ui.position.left - that.document.scrollLeft(),
                    ui.position.top - that.document.scrollTop()
                ];
                $( this ).removeClass("ui-dialog-dragging");
                that._unblockFrames();
                that._trigger( "dragStop", event, filteredUi( ui ) );
            }
        });
    },

    _makeResizable: function() {
        var that = this,
            options = this.options,
            handles = options.resizable,
            // .ui-resizable has position: relative defined in the stylesheet
            // but dialogs have to use absolute or fixed positioning
            position = this.uiDialog.css("position"),
            resizeHandles = typeof handles === "string" ?
                handles :
                "n,e,s,w,se,sw,ne,nw";

        function filteredUi( ui ) {
            return {
                originalPosition: ui.originalPosition,
                originalSize: ui.originalSize,
                position: ui.position,
                size: ui.size
            };
        }

        this.uiDialog.resizable({
            cancel: ".ui-dialog-content",
            containment: "document",
            alsoResize: this.element,
            maxWidth: options.maxWidth,
            maxHeight: options.maxHeight,
            minWidth: options.minWidth,
            minHeight: this._minHeight(),
            handles: resizeHandles,
            start: function( event, ui ) {
                $( this ).addClass("ui-dialog-resizing");
                that._blockFrames();
                that._trigger( "resizeStart", event, filteredUi( ui ) );
            },
            resize: function( event, ui ) {
                that._trigger( "resize", event, filteredUi( ui ) );
            },
            stop: function( event, ui ) {
                options.height = $( this ).height();
                options.width = $( this ).width();
                $( this ).removeClass("ui-dialog-resizing");
                that._unblockFrames();
                that._trigger( "resizeStop", event, filteredUi( ui ) );
            }
        })
        .css( "position", position );
    },

    _minHeight: function() {
        var options = this.options;

        return options.height === "auto" ?
            options.minHeight :
            Math.min( options.minHeight, options.height );
    },

    _position: function() {
        // Need to show the dialog to get the actual offset in the position plugin
        var isVisible = this.uiDialog.is(":visible");
        if ( !isVisible ) {
            this.uiDialog.show();
        }
        this.uiDialog.position( this.options.position );
        if ( !isVisible ) {
            this.uiDialog.hide();
        }
    },

    _setOptions: function( options ) {
        var that = this,
            resize = false,
            resizableOptions = {};

        $.each( options, function( key, value ) {
            that._setOption( key, value );

            if ( key in sizeRelatedOptions ) {
                resize = true;
            }
            if ( key in resizableRelatedOptions ) {
                resizableOptions[ key ] = value;
            }
        });

        if ( resize ) {
            this._size();
            this._position();
        }
        if ( this.uiDialog.is(":data(ui-resizable)") ) {
            this.uiDialog.resizable( "option", resizableOptions );
        }
    },

    _setOption: function( key, value ) {
        var isDraggable, isResizable,
            uiDialog = this.uiDialog;

        if ( key === "dialogClass" ) {
            uiDialog
                .removeClass( this.options.dialogClass )
                .addClass( value );
        }

        if ( key === "disabled" ) {
            return;
        }

        this._super( key, value );

        if ( key === "appendTo" ) {
            this.uiDialog.appendTo( this._appendTo() );
        }

        if ( key === "buttons" ) {
            this._createButtons();
        }

        if ( key === "closeText" ) {
            this.uiDialogTitlebarClose.button({
                // Ensure that we always pass a string
                label: "" + value
            });
        }

        if ( key === "draggable" ) {
            isDraggable = uiDialog.is(":data(ui-draggable)");
            if ( isDraggable && !value ) {
                uiDialog.draggable("destroy");
            }

            if ( !isDraggable && value ) {
                this._makeDraggable();
            }
        }

        if ( key === "position" ) {
            this._position();
        }

        if ( key === "resizable" ) {
            // currently resizable, becoming non-resizable
            isResizable = uiDialog.is(":data(ui-resizable)");
            if ( isResizable && !value ) {
                uiDialog.resizable("destroy");
            }

            // currently resizable, changing handles
            if ( isResizable && typeof value === "string" ) {
                uiDialog.resizable( "option", "handles", value );
            }

            // currently non-resizable, becoming resizable
            if ( !isResizable && value !== false ) {
                this._makeResizable();
            }
        }

        if ( key === "title" ) {
            this._title( this.uiDialogTitlebar.find(".ui-dialog-title") );
        }
    },

    _size: function() {
        // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
        // divs will both have width and height set, so we need to reset them
        var nonContentHeight, minContentHeight, maxContentHeight,
            options = this.options;

        // Reset content sizing
        this.element.show().css({
            width: "auto",
            minHeight: 0,
            maxHeight: "none",
            height: 0
        });

        if ( options.minWidth > options.width ) {
            options.width = options.minWidth;
        }

        // reset wrapper sizing
        // determine the height of all the non-content elements
        nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            })
            .outerHeight();
        minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
        maxContentHeight = typeof options.maxHeight === "number" ?
            Math.max( 0, options.maxHeight - nonContentHeight ) :
            "none";

        if ( options.height === "auto" ) {
            this.element.css({
                minHeight: minContentHeight,
                maxHeight: maxContentHeight,
                height: "auto"
            });
        } else {
            this.element.height( Math.max( 0, options.height - nonContentHeight ) );
        }

        if (this.uiDialog.is(":data(ui-resizable)") ) {
            this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
        }
    },

    _blockFrames: function() {
        this.iframeBlocks = this.document.find( "iframe" ).map(function() {
            var iframe = $( this );

            return $( "<div>" )
                .css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                })
                .appendTo( iframe.parent() )
                .offset( iframe.offset() )[0];
        });
    },

    _unblockFrames: function() {
        if ( this.iframeBlocks ) {
            this.iframeBlocks.remove();
            delete this.iframeBlocks;
        }
    },

    _allowInteraction: function( event ) {
        if ( $( event.target ).closest(".ui-dialog").length ) {
            return true;
        }

        // TODO: Remove hack when datepicker implements
        // the .ui-front logic (#8989)
        return !!$( event.target ).closest(".ui-datepicker").length;
    },

    _createOverlay: function() {
        if ( !this.options.modal ) {
            return;
        }

        var that = this,
            widgetFullName = this.widgetFullName;
        if ( !$.ui.dialog.overlayInstances ) {
            // Prevent use of anchors and inputs.
            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling. (#2804)
            this._delay(function() {
                // Handle .dialog().dialog("close") (#4065)
                if ( $.ui.dialog.overlayInstances ) {
                    this.document.bind( "focusin.dialog", function( event ) {
                        if ( !that._allowInteraction( event ) ) {
                            event.preventDefault();
                            $(".ui-dialog:visible:last .ui-dialog-content")
                                .data( widgetFullName )._focusTabbable();
                        }
                    });
                }
            });
        }

        this.overlay = $("<div>")
            .addClass("ui-widget-overlay ui-front")
            .appendTo( this._appendTo() );
        this._on( this.overlay, {
            mousedown: "_keepFocus"
        });
        $.ui.dialog.overlayInstances++;
    },

    _destroyOverlay: function() {
        if ( !this.options.modal ) {
            return;
        }

        if ( this.overlay ) {
            $.ui.dialog.overlayInstances--;

            if ( !$.ui.dialog.overlayInstances ) {
                this.document.unbind( "focusin.dialog" );
            }
            this.overlay.remove();
            this.overlay = null;
        }
    }
});

$.ui.dialog.overlayInstances = 0;

// DEPRECATED
if ( $.uiBackCompat !== false ) {
    // position option with array notation
    // just override with old implementation
    $.widget( "ui.dialog", $.ui.dialog, {
        _position: function() {
            var position = this.options.position,
                myAt = [],
                offset = [ 0, 0 ],
                isVisible;

            if ( position ) {
                if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
                    myAt = position.split ? position.split(" ") : [ position[0], position[1] ];
                    if ( myAt.length === 1 ) {
                        myAt[1] = myAt[0];
                    }

                    $.each( [ "left", "top" ], function( i, offsetPosition ) {
                        if ( +myAt[ i ] === myAt[ i ] ) {
                            offset[ i ] = myAt[ i ];
                            myAt[ i ] = offsetPosition;
                        }
                    });

                    position = {
                        my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " +
                            myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                        at: myAt.join(" ")
                    };
                }

                position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
            } else {
                position = $.ui.dialog.prototype.options.position;
            }

            // need to show the dialog to get the actual offset in the position plugin
            isVisible = this.uiDialog.is(":visible");
            if ( !isVisible ) {
                this.uiDialog.show();
            }
            this.uiDialog.position( position );
            if ( !isVisible ) {
                this.uiDialog.hide();
            }
        }
    });
}

}( jQuery ) );

(function( $, undefined ) {

var rvertical = /up|down|vertical/,
    rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
    // Create element
    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
        mode = $.effects.setMode( el, o.mode || "hide" ),
        direction = o.direction || "up",
        vertical = rvertical.test( direction ),
        ref = vertical ? "height" : "width",
        ref2 = vertical ? "top" : "left",
        motion = rpositivemotion.test( direction ),
        animation = {},
        show = mode === "show",
        wrapper, distance, margin;

    // if already wrapped, the wrapper's properties are my property. #6245
    if ( el.parent().is( ".ui-effects-wrapper" ) ) {
        $.effects.save( el.parent(), props );
    } else {
        $.effects.save( el, props );
    }
    el.show();
    wrapper = $.effects.createWrapper( el ).css({
        overflow: "hidden"
    });

    distance = wrapper[ ref ]();
    margin = parseFloat( wrapper.css( ref2 ) ) || 0;

    animation[ ref ] = show ? distance : 0;
    if ( !motion ) {
        el
            .css( vertical ? "bottom" : "right", 0 )
            .css( vertical ? "top" : "left", "auto" )
            .css({ position: "absolute" });

        animation[ ref2 ] = show ? margin : distance + margin;
    }

    // start at 0 if we are showing
    if ( show ) {
        wrapper.css( ref, 0 );
        if ( ! motion ) {
            wrapper.css( ref2, margin + distance );
        }
    }

    // Animate
    wrapper.animate( animation, {
        duration: o.duration,
        easing: o.easing,
        queue: false,
        complete: function() {
            if ( mode === "hide" ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        }
    });

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

        // defaults:
        mode = $.effects.setMode( el, o.mode || "effect" ),
        hide = mode === "hide",
        show = mode === "show",
        direction = o.direction || "up",
        distance = o.distance,
        times = o.times || 5,

        // number of internal animations
        anims = times * 2 + ( show || hide ? 1 : 0 ),
        speed = o.duration / anims,
        easing = o.easing,

        // utility:
        ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
        motion = ( direction === "up" || direction === "left" ),
        i,
        upAnim,
        downAnim,

        // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(),
        queuelen = queue.length;

    // Avoid touching opacity to prevent clearType and PNG issues in IE
    if ( show || hide ) {
        props.push( "opacity" );
    }

    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el ); // Create Wrapper

    // default distance for the BIGGEST bounce is the outer Distance / 3
    if ( !distance ) {
        distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
    }

    if ( show ) {
        downAnim = { opacity: 1 };
        downAnim[ ref ] = 0;

        // if we are showing, force opacity 0 and set the initial position
        // then do the "first" animation
        el.css( "opacity", 0 )
            .css( ref, motion ? -distance * 2 : distance * 2 )
            .animate( downAnim, speed, easing );
    }

    // start at the smallest distance if we are hiding
    if ( hide ) {
        distance = distance / Math.pow( 2, times - 1 );
    }

    downAnim = {};
    downAnim[ ref ] = 0;
    // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
    for ( i = 0; i < times; i++ ) {
        upAnim = {};
        upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

        el.animate( upAnim, speed, easing )
            .animate( downAnim, speed, easing );

        distance = hide ? distance * 2 : distance / 2;
    }

    // Last Bounce when Hiding
    if ( hide ) {
        upAnim = { opacity: 0 };
        upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

        el.animate( upAnim, speed, easing );
    }

    el.queue(function() {
        if ( hide ) {
            el.hide();
        }
        $.effects.restore( el, props );
        $.effects.removeWrapper( el );
        done();
    });

    // inject all the animations we just queued to be first in line (after "inprogress")
    if ( queuelen > 1) {
        queue.splice.apply( queue,
            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
    // Create element
    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
        mode = $.effects.setMode( el, o.mode || "hide" ),
        show = mode === "show",
        direction = o.direction || "vertical",
        vert = direction === "vertical",
        size = vert ? "height" : "width",
        position = vert ? "top" : "left",
        animation = {},
        wrapper, animate, distance;

    // Save & Show
    $.effects.save( el, props );
    el.show();

    // Create Wrapper
    wrapper = $.effects.createWrapper( el ).css({
        overflow: "hidden"
    });
    animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
    distance = animate[ size ]();

    // Shift
    if ( show ) {
        animate.css( size, 0 );
        animate.css( position, distance / 2 );
    }

    // Create Animation Object:
    animation[ size ] = show ? distance : 0;
    animation[ position ] = show ? 0 : distance / 2;

    // Animate
    animate.animate( animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
            if ( !show ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        }
    });

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
        mode = $.effects.setMode( el, o.mode || "hide" ),
        show = mode === "show",
        direction = o.direction || "left",
        ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
        motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
        animation = {
            opacity: show ? 1 : 0
        },
        distance;

    // Adjust
    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );

    distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

    if ( show ) {
        el
            .css( "opacity", 0 )
            .css( ref, motion === "pos" ? -distance : distance );
    }

    // Animation
    animation[ ref ] = ( show ?
        ( motion === "pos" ? "+=" : "-=" ) :
        ( motion === "pos" ? "-=" : "+=" ) ) +
        distance;

    // Animate
    el.animate( animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
            if ( mode === "hide" ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        }
    });
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

    var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
        cells = rows,
        el = $( this ),
        mode = $.effects.setMode( el, o.mode || "hide" ),
        show = mode === "show",

        // show and then visibility:hidden the element before calculating offset
        offset = el.show().css( "visibility", "hidden" ).offset(),

        // width and height of a piece
        width = Math.ceil( el.outerWidth() / cells ),
        height = Math.ceil( el.outerHeight() / rows ),
        pieces = [],

        // loop
        i, j, left, top, mx, my;

    // children animate complete:
    function childComplete() {
        pieces.push( this );
        if ( pieces.length === rows * cells ) {
            animComplete();
        }
    }

    // clone the element for each row and cell.
    for( i = 0; i < rows ; i++ ) { // ===>
        top = offset.top + i * height;
        my = i - ( rows - 1 ) / 2 ;

        for( j = 0; j < cells ; j++ ) { // |||
            left = offset.left + j * width;
            mx = j - ( cells - 1 ) / 2 ;

            // Create a clone of the now hidden main element that will be absolute positioned
            // within a wrapper div off the -left and -top equal to size of our pieces
            el
                .clone()
                .appendTo( "body" )
                .wrap( "<div></div>" )
                .css({
                    position: "absolute",
                    visibility: "visible",
                    left: -j * width,
                    top: -i * height
                })

            // select the wrapper - make it overflow: hidden and absolute positioned based on
            // where the original was located +left and +top equal to the size of pieces
                .parent()
                .addClass( "ui-effects-explode" )
                .css({
                    position: "absolute",
                    overflow: "hidden",
                    width: width,
                    height: height,
                    left: left + ( show ? mx * width : 0 ),
                    top: top + ( show ? my * height : 0 ),
                    opacity: show ? 0 : 1
                }).animate({
                    left: left + ( show ? 0 : mx * width ),
                    top: top + ( show ? 0 : my * height ),
                    opacity: show ? 1 : 0
                }, o.duration || 500, o.easing, childComplete );
        }
    }

    function animComplete() {
        el.css({
            visibility: "visible"
        });
        $( pieces ).remove();
        if ( !show ) {
            el.hide();
        }
        done();
    }
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
    var el = $( this ),
        mode = $.effects.setMode( el, o.mode || "toggle" );

    el.animate({
        opacity: mode
    }, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: done
    });
};

})( jQuery );

(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

    // Create element
    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
        mode = $.effects.setMode( el, o.mode || "hide" ),
        show = mode === "show",
        hide = mode === "hide",
        size = o.size || 15,
        percent = /([0-9]+)%/.exec( size ),
        horizFirst = !!o.horizFirst,
        widthFirst = show !== horizFirst,
        ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
        duration = o.duration / 2,
        wrapper, distance,
        animation1 = {},
        animation2 = {};

    $.effects.save( el, props );
    el.show();

    // Create Wrapper
    wrapper = $.effects.createWrapper( el ).css({
        overflow: "hidden"
    });
    distance = widthFirst ?
        [ wrapper.width(), wrapper.height() ] :
        [ wrapper.height(), wrapper.width() ];

    if ( percent ) {
        size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
    }
    if ( show ) {
        wrapper.css( horizFirst ? {
            height: 0,
            width: size
        } : {
            height: size,
            width: 0
        });
    }

    // Animation
    animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
    animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

    // Animate
    wrapper
        .animate( animation1, duration, o.easing )
        .animate( animation2, duration, o.easing, function() {
            if ( hide ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        });

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
    var elem = $( this ),
        props = [ "backgroundImage", "backgroundColor", "opacity" ],
        mode = $.effects.setMode( elem, o.mode || "show" ),
        animation = {
            backgroundColor: elem.css( "backgroundColor" )
        };

    if (mode === "hide") {
        animation.opacity = 0;
    }

    $.effects.save( elem, props );

    elem
        .show()
        .css({
            backgroundImage: "none",
            backgroundColor: o.color || "#ffff99"
        })
        .animate( animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if ( mode === "hide" ) {
                    elem.hide();
                }
                $.effects.restore( elem, props );
                done();
            }
        });
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
    var elem = $( this ),
        mode = $.effects.setMode( elem, o.mode || "show" ),
        show = mode === "show",
        hide = mode === "hide",
        showhide = ( show || mode === "hide" ),

        // showing or hiding leaves of the "last" animation
        anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
        duration = o.duration / anims,
        animateTo = 0,
        queue = elem.queue(),
        queuelen = queue.length,
        i;

    if ( show || !elem.is(":visible")) {
        elem.css( "opacity", 0 ).show();
        animateTo = 1;
    }

    // anims - 1 opacity "toggles"
    for ( i = 1; i < anims; i++ ) {
        elem.animate({
            opacity: animateTo
        }, duration, o.easing );
        animateTo = 1 - animateTo;
    }

    elem.animate({
        opacity: animateTo
    }, duration, o.easing);

    elem.queue(function() {
        if ( hide ) {
            elem.hide();
        }
        done();
    });

    // We just queued up "anims" animations, we need to put them next in the queue
    if ( queuelen > 1 ) {
        queue.splice.apply( queue,
            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    elem.dequeue();
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
    var elem = $( this ),
        mode = $.effects.setMode( elem, o.mode || "hide" ),
        hide = mode === "hide",
        percent = parseInt( o.percent, 10 ) || 150,
        factor = percent / 100,
        original = {
            height: elem.height(),
            width: elem.width(),
            outerHeight: elem.outerHeight(),
            outerWidth: elem.outerWidth()
        };

    $.extend( o, {
        effect: "scale",
        queue: false,
        fade: true,
        mode: mode,
        complete: done,
        percent: hide ? percent : 100,
        from: hide ?
            original :
            {
                height: original.height * factor,
                width: original.width * factor,
                outerHeight: original.outerHeight * factor,
                outerWidth: original.outerWidth * factor
            }
    });

    elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

    // Create element
    var el = $( this ),
        options = $.extend( true, {}, o ),
        mode = $.effects.setMode( el, o.mode || "effect" ),
        percent = parseInt( o.percent, 10 ) ||
            ( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
        direction = o.direction || "both",
        origin = o.origin,
        original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        },
        factor = {
            y: direction !== "horizontal" ? (percent / 100) : 1,
            x: direction !== "vertical" ? (percent / 100) : 1
        };

    // We are going to pass this effect to the size effect:
    options.effect = "size";
    options.queue = false;
    options.complete = done;

    // Set default origin and restore for show/hide
    if ( mode !== "effect" ) {
        options.origin = origin || ["middle","center"];
        options.restore = true;
    }

    options.from = o.from || ( mode === "show" ? {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
    } : original );
    options.to = {
        height: original.height * factor.y,
        width: original.width * factor.x,
        outerHeight: original.outerHeight * factor.y,
        outerWidth: original.outerWidth * factor.x
    };

    // Fade option to support puff
    if ( options.fade ) {
        if ( mode === "show" ) {
            options.from.opacity = 0;
            options.to.opacity = 1;
        }
        if ( mode === "hide" ) {
            options.from.opacity = 1;
            options.to.opacity = 0;
        }
    }

    // Animate
    el.effect( options );

};

$.effects.effect.size = function( o, done ) {

    // Create element
    var original, baseline, factor,
        el = $( this ),
        props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

        // Always restore
        props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

        // Copy for children
        props2 = [ "width", "height", "overflow" ],
        cProps = [ "fontSize" ],
        vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
        hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

        // Set options
        mode = $.effects.setMode( el, o.mode || "effect" ),
        restore = o.restore || mode !== "effect",
        scale = o.scale || "both",
        origin = o.origin || [ "middle", "center" ],
        position = el.css( "position" ),
        props = restore ? props0 : props1,
        zero = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        };

    if ( mode === "show" ) {
        el.show();
    }
    original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
    };

    if ( o.mode === "toggle" && mode === "show" ) {
        el.from = o.to || zero;
        el.to = o.from || original;
    } else {
        el.from = o.from || ( mode === "show" ? zero : original );
        el.to = o.to || ( mode === "hide" ? zero : original );
    }

    // Set scaling factor
    factor = {
        from: {
            y: el.from.height / original.height,
            x: el.from.width / original.width
        },
        to: {
            y: el.to.height / original.height,
            x: el.to.width / original.width
        }
    };

    // Scale the css box
    if ( scale === "box" || scale === "both" ) {

        // Vertical props scaling
        if ( factor.from.y !== factor.to.y ) {
            props = props.concat( vProps );
            el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
            el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
        }

        // Horizontal props scaling
        if ( factor.from.x !== factor.to.x ) {
            props = props.concat( hProps );
            el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
            el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
        }
    }

    // Scale the content
    if ( scale === "content" || scale === "both" ) {

        // Vertical props scaling
        if ( factor.from.y !== factor.to.y ) {
            props = props.concat( cProps ).concat( props2 );
            el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
            el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
        }
    }

    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );
    el.css( "overflow", "hidden" ).css( el.from );

    // Adjust
    if (origin) { // Calculate baseline shifts
        baseline = $.effects.getBaseline( origin, original );
        el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
        el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
        el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
        el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
    }
    el.css( el.from ); // set top & left

    // Animate
    if ( scale === "content" || scale === "both" ) { // Scale the children

        // Add margins/font-size
        vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
        hProps = hProps.concat([ "marginLeft", "marginRight" ]);
        props2 = props0.concat(vProps).concat(hProps);

        el.find( "*[width]" ).each( function(){
            var child = $( this ),
                c_original = {
                    height: child.height(),
                    width: child.width(),
                    outerHeight: child.outerHeight(),
                    outerWidth: child.outerWidth()
                };
            if (restore) {
                $.effects.save(child, props2);
            }

            child.from = {
                height: c_original.height * factor.from.y,
                width: c_original.width * factor.from.x,
                outerHeight: c_original.outerHeight * factor.from.y,
                outerWidth: c_original.outerWidth * factor.from.x
            };
            child.to = {
                height: c_original.height * factor.to.y,
                width: c_original.width * factor.to.x,
                outerHeight: c_original.height * factor.to.y,
                outerWidth: c_original.width * factor.to.x
            };

            // Vertical props scaling
            if ( factor.from.y !== factor.to.y ) {
                child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
                child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
            }

            // Horizontal props scaling
            if ( factor.from.x !== factor.to.x ) {
                child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
                child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
            }

            // Animate children
            child.css( child.from );
            child.animate( child.to, o.duration, o.easing, function() {

                // Restore children
                if ( restore ) {
                    $.effects.restore( child, props2 );
                }
            });
        });
    }

    // Animate
    el.animate( el.to, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
            if ( el.to.opacity === 0 ) {
                el.css( "opacity", el.from.opacity );
            }
            if( mode === "hide" ) {
                el.hide();
            }
            $.effects.restore( el, props );
            if ( !restore ) {

                // we need to calculate our new positioning based on the scaling
                if ( position === "static" ) {
                    el.css({
                        position: "relative",
                        top: el.to.top,
                        left: el.to.left
                    });
                } else {
                    $.each([ "top", "left" ], function( idx, pos ) {
                        el.css( pos, function( _, str ) {
                            var val = parseInt( str, 10 ),
                                toRef = idx ? el.to.left : el.to.top;

                            // if original was "auto", recalculate the new value from wrapper
                            if ( str === "auto" ) {
                                return toRef + "px";
                            }

                            return val + toRef + "px";
                        });
                    });
                }
            }

            $.effects.removeWrapper( el );
            done();
        }
    });

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
        mode = $.effects.setMode( el, o.mode || "effect" ),
        direction = o.direction || "left",
        distance = o.distance || 20,
        times = o.times || 3,
        anims = times * 2 + 1,
        speed = Math.round(o.duration/anims),
        ref = (direction === "up" || direction === "down") ? "top" : "left",
        positiveMotion = (direction === "up" || direction === "left"),
        animation = {},
        animation1 = {},
        animation2 = {},
        i,

        // we will need to re-assemble the queue to stack our animations in place
        queue = el.queue(),
        queuelen = queue.length;

    $.effects.save( el, props );
    el.show();
    $.effects.createWrapper( el );

    // Animation
    animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
    animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
    animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

    // Animate
    el.animate( animation, speed, o.easing );

    // Shakes
    for ( i = 1; i < times; i++ ) {
        el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
    }
    el
        .animate( animation1, speed, o.easing )
        .animate( animation, speed / 2, o.easing )
        .queue(function() {
            if ( mode === "hide" ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        });

    // inject all the animations we just queued to be first in line (after "inprogress")
    if ( queuelen > 1) {
        queue.splice.apply( queue,
            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
    }
    el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

    // Create element
    var el = $( this ),
        props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
        mode = $.effects.setMode( el, o.mode || "show" ),
        show = mode === "show",
        direction = o.direction || "left",
        ref = (direction === "up" || direction === "down") ? "top" : "left",
        positiveMotion = (direction === "up" || direction === "left"),
        distance,
        animation = {};

    // Adjust
    $.effects.save( el, props );
    el.show();
    distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

    $.effects.createWrapper( el ).css({
        overflow: "hidden"
    });

    if ( show ) {
        el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
    }

    // Animation
    animation[ ref ] = ( show ?
        ( positiveMotion ? "+=" : "-=") :
        ( positiveMotion ? "-=" : "+=")) +
        distance;

    // Animate
    el.animate( animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
            if ( mode === "hide" ) {
                el.hide();
            }
            $.effects.restore( el, props );
            $.effects.removeWrapper( el );
            done();
        }
    });
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
    var elem = $( this ),
        target = $( o.to ),
        targetFixed = target.css( "position" ) === "fixed",
        body = $("body"),
        fixTop = targetFixed ? body.scrollTop() : 0,
        fixLeft = targetFixed ? body.scrollLeft() : 0,
        endPosition = target.offset(),
        animation = {
            top: endPosition.top - fixTop ,
            left: endPosition.left - fixLeft ,
            height: target.innerHeight(),
            width: target.innerWidth()
        },
        startPosition = elem.offset(),
        transfer = $( "<div class='ui-effects-transfer'></div>" )
            .appendTo( document.body )
            .addClass( o.className )
            .css({
                top: startPosition.top - fixTop ,
                left: startPosition.left - fixLeft ,
                height: elem.innerHeight(),
                width: elem.innerWidth(),
                position: targetFixed ? "fixed" : "absolute"
            })
            .animate( animation, o.duration, o.easing, function() {
                transfer.remove();
                done();
            });
};

})(jQuery);

(function( $, undefined ) {

$.widget( "ui.menu", {
    version: "1.10.4",
    defaultElement: "<ul>",
    delay: 300,
    options: {
        icons: {
            submenu: "ui-icon-carat-1-e"
        },
        menus: "ul",
        position: {
            my: "left top",
            at: "right top"
        },
        role: "menu",

        // callbacks
        blur: null,
        focus: null,
        select: null
    },

    _create: function() {
        this.activeMenu = this.element;
        // flag used to prevent firing of the click handler
        // as the event bubbles up through nested menus
        this.mouseHandled = false;
        this.element
            .uniqueId()
            .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
            .toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
            .attr({
                role: this.options.role,
                tabIndex: 0
            })
            // need to catch all clicks on disabled menu
            // not possible through _on
            .bind( "click" + this.eventNamespace, $.proxy(function( event ) {
                if ( this.options.disabled ) {
                    event.preventDefault();
                }
            }, this ));

        if ( this.options.disabled ) {
            this.element
                .addClass( "ui-state-disabled" )
                .attr( "aria-disabled", "true" );
        }

        this._on({
            // Prevent focus from sticking to links inside menu after clicking
            // them (focus should always stay on UL during navigation).
            "mousedown .ui-menu-item > a": function( event ) {
                event.preventDefault();
            },
            "click .ui-state-disabled > a": function( event ) {
                event.preventDefault();
            },
            "click .ui-menu-item:has(a)": function( event ) {
                var target = $( event.target ).closest( ".ui-menu-item" );
                if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
                    this.select( event );

                    // Only set the mouseHandled flag if the event will bubble, see #9469.
                    if ( !event.isPropagationStopped() ) {
                        this.mouseHandled = true;
                    }

                    // Open submenu on click
                    if ( target.has( ".ui-menu" ).length ) {
                        this.expand( event );
                    } else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

                        // Redirect focus to the menu
                        this.element.trigger( "focus", [ true ] );

                        // If the active item is on the top level, let it stay active.
                        // Otherwise, blur the active item since it is no longer visible.
                        if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
                            clearTimeout( this.timer );
                        }
                    }
                }
            },
            "mouseenter .ui-menu-item": function( event ) {
                var target = $( event.currentTarget );
                // Remove ui-state-active class from siblings of the newly focused menu item
                // to avoid a jump caused by adjacent elements both having a class with a border
                target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
                this.focus( event, target );
            },
            mouseleave: "collapseAll",
            "mouseleave .ui-menu": "collapseAll",
            focus: function( event, keepActiveItem ) {
                // If there's already an active item, keep it active
                // If not, activate the first item
                var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

                if ( !keepActiveItem ) {
                    this.focus( event, item );
                }
            },
            blur: function( event ) {
                this._delay(function() {
                    if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
                        this.collapseAll( event );
                    }
                });
            },
            keydown: "_keydown"
        });

        this.refresh();

        // Clicks outside of a menu collapse any open menus
        this._on( this.document, {
            click: function( event ) {
                if ( !$( event.target ).closest( ".ui-menu" ).length ) {
                    this.collapseAll( event );
                }

                // Reset the mouseHandled flag
                this.mouseHandled = false;
            }
        });
    },

    _destroy: function() {
        // Destroy (sub)menus
        this.element
            .removeAttr( "aria-activedescendant" )
            .find( ".ui-menu" ).addBack()
                .removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
                .removeAttr( "role" )
                .removeAttr( "tabIndex" )
                .removeAttr( "aria-labelledby" )
                .removeAttr( "aria-expanded" )
                .removeAttr( "aria-hidden" )
                .removeAttr( "aria-disabled" )
                .removeUniqueId()
                .show();

        // Destroy menu items
        this.element.find( ".ui-menu-item" )
            .removeClass( "ui-menu-item" )
            .removeAttr( "role" )
            .removeAttr( "aria-disabled" )
            .children( "a" )
                .removeUniqueId()
                .removeClass( "ui-corner-all ui-state-hover" )
                .removeAttr( "tabIndex" )
                .removeAttr( "role" )
                .removeAttr( "aria-haspopup" )
                .children().each( function() {
                    var elem = $( this );
                    if ( elem.data( "ui-menu-submenu-carat" ) ) {
                        elem.remove();
                    }
                });

        // Destroy menu dividers
        this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
    },

    _keydown: function( event ) {
        var match, prev, character, skip, regex,
            preventDefault = true;

        function escape( value ) {
            return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
        }

        switch ( event.keyCode ) {
        case $.ui.keyCode.PAGE_UP:
            this.previousPage( event );
            break;
        case $.ui.keyCode.PAGE_DOWN:
            this.nextPage( event );
            break;
        case $.ui.keyCode.HOME:
            this._move( "first", "first", event );
            break;
        case $.ui.keyCode.END:
            this._move( "last", "last", event );
            break;
        case $.ui.keyCode.UP:
            this.previous( event );
            break;
        case $.ui.keyCode.DOWN:
            this.next( event );
            break;
        case $.ui.keyCode.LEFT:
            this.collapse( event );
            break;
        case $.ui.keyCode.RIGHT:
            if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
                this.expand( event );
            }
            break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
            this._activate( event );
            break;
        case $.ui.keyCode.ESCAPE:
            this.collapse( event );
            break;
        default:
            preventDefault = false;
            prev = this.previousFilter || "";
            character = String.fromCharCode( event.keyCode );
            skip = false;

            clearTimeout( this.filterTimer );

            if ( character === prev ) {
                skip = true;
            } else {
                character = prev + character;
            }

            regex = new RegExp( "^" + escape( character ), "i" );
            match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                return regex.test( $( this ).children( "a" ).text() );
            });
            match = skip && match.index( this.active.next() ) !== -1 ?
                this.active.nextAll( ".ui-menu-item" ) :
                match;

            // If no matches on the current filter, reset to the last character pressed
            // to move down the menu to the first item that starts with that character
            if ( !match.length ) {
                character = String.fromCharCode( event.keyCode );
                regex = new RegExp( "^" + escape( character ), "i" );
                match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
                    return regex.test( $( this ).children( "a" ).text() );
                });
            }

            if ( match.length ) {
                this.focus( event, match );
                if ( match.length > 1 ) {
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1000 );
                } else {
                    delete this.previousFilter;
                }
            } else {
                delete this.previousFilter;
            }
        }

        if ( preventDefault ) {
            event.preventDefault();
        }
    },

    _activate: function( event ) {
        if ( !this.active.is( ".ui-state-disabled" ) ) {
            if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
                this.expand( event );
            } else {
                this.select( event );
            }
        }
    },

    refresh: function() {
        var menus,
            icon = this.options.icons.submenu,
            submenus = this.element.find( this.options.menus );

        this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

        // Initialize nested menus
        submenus.filter( ":not(.ui-menu)" )
            .addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
            .hide()
            .attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            })
            .each(function() {
                var menu = $( this ),
                    item = menu.prev( "a" ),
                    submenuCarat = $( "<span>" )
                        .addClass( "ui-menu-icon ui-icon " + icon )
                        .data( "ui-menu-submenu-carat", true );

                item
                    .attr( "aria-haspopup", "true" )
                    .prepend( submenuCarat );
                menu.attr( "aria-labelledby", item.attr( "id" ) );
            });

        menus = submenus.add( this.element );

        // Don't refresh list items that are already adapted
        menus.children( ":not(.ui-menu-item):has(a)" )
            .addClass( "ui-menu-item" )
            .attr( "role", "presentation" )
            .children( "a" )
                .uniqueId()
                .addClass( "ui-corner-all" )
                .attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });

        // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
        menus.children( ":not(.ui-menu-item)" ).each(function() {
            var item = $( this );
            // hyphen, em dash, en dash
            if ( !/[^\-\u2014\u2013\s]/.test( item.text() ) ) {
                item.addClass( "ui-widget-content ui-menu-divider" );
            }
        });

        // Add aria-disabled attribute to any disabled menu item
        menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

        // If the active item has been removed, blur the menu
        if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
            this.blur();
        }
    },

    _itemRole: function() {
        return {
            menu: "menuitem",
            listbox: "option"
        }[ this.options.role ];
    },

    _setOption: function( key, value ) {
        if ( key === "icons" ) {
            this.element.find( ".ui-menu-icon" )
                .removeClass( this.options.icons.submenu )
                .addClass( value.submenu );
        }
        this._super( key, value );
    },

    focus: function( event, item ) {
        var nested, focused;
        this.blur( event, event && event.type === "focus" );

        this._scrollIntoView( item );

        this.active = item.first();
        focused = this.active.children( "a" ).addClass( "ui-state-focus" );
        // Only update aria-activedescendant if there's a role
        // otherwise we assume focus is managed elsewhere
        if ( this.options.role ) {
            this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
        }

        // Highlight active parent menu item, if any
        this.active
            .parent()
            .closest( ".ui-menu-item" )
            .children( "a:first" )
            .addClass( "ui-state-active" );

        if ( event && event.type === "keydown" ) {
            this._close();
        } else {
            this.timer = this._delay(function() {
                this._close();
            }, this.delay );
        }

        nested = item.children( ".ui-menu" );
        if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
            this._startOpening(nested);
        }
        this.activeMenu = item.parent();

        this._trigger( "focus", event, { item: item } );
    },

    _scrollIntoView: function( item ) {
        var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
        if ( this._hasScroll() ) {
            borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
            paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
            offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
            scroll = this.activeMenu.scrollTop();
            elementHeight = this.activeMenu.height();
            itemHeight = item.height();

            if ( offset < 0 ) {
                this.activeMenu.scrollTop( scroll + offset );
            } else if ( offset + itemHeight > elementHeight ) {
                this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
            }
        }
    },

    blur: function( event, fromFocus ) {
        if ( !fromFocus ) {
            clearTimeout( this.timer );
        }

        if ( !this.active ) {
            return;
        }

        this.active.children( "a" ).removeClass( "ui-state-focus" );
        this.active = null;

        this._trigger( "blur", event, { item: this.active } );
    },

    _startOpening: function( submenu ) {
        clearTimeout( this.timer );

        // Don't open if already open fixes a Firefox bug that caused a .5 pixel
        // shift in the submenu position when mousing over the carat icon
        if ( submenu.attr( "aria-hidden" ) !== "true" ) {
            return;
        }

        this.timer = this._delay(function() {
            this._close();
            this._open( submenu );
        }, this.delay );
    },

    _open: function( submenu ) {
        var position = $.extend({
            of: this.active
        }, this.options.position );

        clearTimeout( this.timer );
        this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
            .hide()
            .attr( "aria-hidden", "true" );

        submenu
            .show()
            .removeAttr( "aria-hidden" )
            .attr( "aria-expanded", "true" )
            .position( position );
    },

    collapseAll: function( event, all ) {
        clearTimeout( this.timer );
        this.timer = this._delay(function() {
            // If we were passed an event, look for the submenu that contains the event
            var currentMenu = all ? this.element :
                $( event && event.target ).closest( this.element.find( ".ui-menu" ) );

            // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
            if ( !currentMenu.length ) {
                currentMenu = this.element;
            }

            this._close( currentMenu );

            this.blur( event );
            this.activeMenu = currentMenu;
        }, this.delay );
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function( startMenu ) {
        if ( !startMenu ) {
            startMenu = this.active ? this.active.parent() : this.element;
        }

        startMenu
            .find( ".ui-menu" )
                .hide()
                .attr( "aria-hidden", "true" )
                .attr( "aria-expanded", "false" )
            .end()
            .find( "a.ui-state-active" )
                .removeClass( "ui-state-active" );
    },

    collapse: function( event ) {
        var newItem = this.active &&
            this.active.parent().closest( ".ui-menu-item", this.element );
        if ( newItem && newItem.length ) {
            this._close();
            this.focus( event, newItem );
        }
    },

    expand: function( event ) {
        var newItem = this.active &&
            this.active
                .children( ".ui-menu " )
                .children( ".ui-menu-item" )
                .first();

        if ( newItem && newItem.length ) {
            this._open( newItem.parent() );

            // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
            this._delay(function() {
                this.focus( event, newItem );
            });
        }
    },

    next: function( event ) {
        this._move( "next", "first", event );
    },

    previous: function( event ) {
        this._move( "prev", "last", event );
    },

    isFirstItem: function() {
        return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
    },

    isLastItem: function() {
        return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
    },

    _move: function( direction, filter, event ) {
        var next;
        if ( this.active ) {
            if ( direction === "first" || direction === "last" ) {
                next = this.active
                    [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
                    .eq( -1 );
            } else {
                next = this.active
                    [ direction + "All" ]( ".ui-menu-item" )
                    .eq( 0 );
            }
        }
        if ( !next || !next.length || !this.active ) {
            next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
        }

        this.focus( event, next );
    },

    nextPage: function( event ) {
        var item, base, height;

        if ( !this.active ) {
            this.next( event );
            return;
        }
        if ( this.isLastItem() ) {
            return;
        }
        if ( this._hasScroll() ) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.nextAll( ".ui-menu-item" ).each(function() {
                item = $( this );
                return item.offset().top - base - height < 0;
            });

            this.focus( event, item );
        } else {
            this.focus( event, this.activeMenu.children( ".ui-menu-item" )
                [ !this.active ? "first" : "last" ]() );
        }
    },

    previousPage: function( event ) {
        var item, base, height;
        if ( !this.active ) {
            this.next( event );
            return;
        }
        if ( this.isFirstItem() ) {
            return;
        }
        if ( this._hasScroll() ) {
            base = this.active.offset().top;
            height = this.element.height();
            this.active.prevAll( ".ui-menu-item" ).each(function() {
                item = $( this );
                return item.offset().top - base + height > 0;
            });

            this.focus( event, item );
        } else {
            this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
        }
    },

    _hasScroll: function() {
        return this.element.outerHeight() < this.element.prop( "scrollHeight" );
    },

    select: function( event ) {
        // TODO: It should never be possible to not have an active item at this
        // point, but the tests don't trigger mouseenter before click.
        this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
        var ui = { item: this.active };
        if ( !this.active.has( ".ui-menu" ).length ) {
            this.collapseAll( event, true );
        }
        this._trigger( "select", event, ui );
    }
});

}( jQuery ));

(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
    max = Math.max,
    abs = Math.abs,
    round = Math.round,
    rhorizontal = /left|center|right/,
    rvertical = /top|center|bottom/,
    roffset = /[\+\-]\d+(\.[\d]+)?%?/,
    rposition = /^\w+/,
    rpercent = /%$/,
    _position = $.fn.position;

function getOffsets( offsets, width, height ) {
    return [
        parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
        parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
    ];
}

function parseCss( element, property ) {
    return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
    var raw = elem[0];
    if ( raw.nodeType === 9 ) {
        return {
            width: elem.width(),
            height: elem.height(),
            offset: { top: 0, left: 0 }
        };
    }
    if ( $.isWindow( raw ) ) {
        return {
            width: elem.width(),
            height: elem.height(),
            offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
        };
    }
    if ( raw.preventDefault ) {
        return {
            width: 0,
            height: 0,
            offset: { top: raw.pageY, left: raw.pageX }
        };
    }
    return {
        width: elem.outerWidth(),
        height: elem.outerHeight(),
        offset: elem.offset()
    };
}

$.position = {
    scrollbarWidth: function() {
        if ( cachedScrollbarWidth !== undefined ) {
            return cachedScrollbarWidth;
        }
        var w1, w2,
            div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
            innerDiv = div.children()[0];

        $( "body" ).append( div );
        w1 = innerDiv.offsetWidth;
        div.css( "overflow", "scroll" );

        w2 = innerDiv.offsetWidth;

        if ( w1 === w2 ) {
            w2 = div[0].clientWidth;
        }

        div.remove();

        return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function( within ) {
        var overflowX = within.isWindow || within.isDocument ? "" :
                within.element.css( "overflow-x" ),
            overflowY = within.isWindow || within.isDocument ? "" :
                within.element.css( "overflow-y" ),
            hasOverflowX = overflowX === "scroll" ||
                ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
            hasOverflowY = overflowY === "scroll" ||
                ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
        return {
            width: hasOverflowY ? $.position.scrollbarWidth() : 0,
            height: hasOverflowX ? $.position.scrollbarWidth() : 0
        };
    },
    getWithinInfo: function( element ) {
        var withinElement = $( element || window ),
            isWindow = $.isWindow( withinElement[0] ),
            isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
        return {
            element: withinElement,
            isWindow: isWindow,
            isDocument: isDocument,
            offset: withinElement.offset() || { left: 0, top: 0 },
            scrollLeft: withinElement.scrollLeft(),
            scrollTop: withinElement.scrollTop(),
            width: isWindow ? withinElement.width() : withinElement.outerWidth(),
            height: isWindow ? withinElement.height() : withinElement.outerHeight()
        };
    }
};

$.fn.position = function( options ) {
    if ( !options || !options.of ) {
        return _position.apply( this, arguments );
    }

    // make a copy, we don't want to modify arguments
    options = $.extend( {}, options );

    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
        target = $( options.of ),
        within = $.position.getWithinInfo( options.within ),
        scrollInfo = $.position.getScrollInfo( within ),
        collision = ( options.collision || "flip" ).split( " " ),
        offsets = {};

    dimensions = getDimensions( target );
    if ( target[0].preventDefault ) {
        // force left top to allow flipping
        options.at = "left top";
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    // clone to reuse original targetOffset later
    basePosition = $.extend( {}, targetOffset );

    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each( [ "my", "at" ], function() {
        var pos = ( options[ this ] || "" ).split( " " ),
            horizontalOffset,
            verticalOffset;

        if ( pos.length === 1) {
            pos = rhorizontal.test( pos[ 0 ] ) ?
                pos.concat( [ "center" ] ) :
                rvertical.test( pos[ 0 ] ) ?
                    [ "center" ].concat( pos ) :
                    [ "center", "center" ];
        }
        pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
        pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

        // calculate offsets
        horizontalOffset = roffset.exec( pos[ 0 ] );
        verticalOffset = roffset.exec( pos[ 1 ] );
        offsets[ this ] = [
            horizontalOffset ? horizontalOffset[ 0 ] : 0,
            verticalOffset ? verticalOffset[ 0 ] : 0
        ];

        // reduce to just the positions without the offsets
        options[ this ] = [
            rposition.exec( pos[ 0 ] )[ 0 ],
            rposition.exec( pos[ 1 ] )[ 0 ]
        ];
    });

    // normalize collision option
    if ( collision.length === 1 ) {
        collision[ 1 ] = collision[ 0 ];
    }

    if ( options.at[ 0 ] === "right" ) {
        basePosition.left += targetWidth;
    } else if ( options.at[ 0 ] === "center" ) {
        basePosition.left += targetWidth / 2;
    }

    if ( options.at[ 1 ] === "bottom" ) {
        basePosition.top += targetHeight;
    } else if ( options.at[ 1 ] === "center" ) {
        basePosition.top += targetHeight / 2;
    }

    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
    basePosition.left += atOffset[ 0 ];
    basePosition.top += atOffset[ 1 ];

    return this.each(function() {
        var collisionPosition, using,
            elem = $( this ),
            elemWidth = elem.outerWidth(),
            elemHeight = elem.outerHeight(),
            marginLeft = parseCss( this, "marginLeft" ),
            marginTop = parseCss( this, "marginTop" ),
            collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
            collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
            position = $.extend( {}, basePosition ),
            myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

        if ( options.my[ 0 ] === "right" ) {
            position.left -= elemWidth;
        } else if ( options.my[ 0 ] === "center" ) {
            position.left -= elemWidth / 2;
        }

        if ( options.my[ 1 ] === "bottom" ) {
            position.top -= elemHeight;
        } else if ( options.my[ 1 ] === "center" ) {
            position.top -= elemHeight / 2;
        }

        position.left += myOffset[ 0 ];
        position.top += myOffset[ 1 ];

        // if the browser doesn't support fractions, then round for consistent results
        if ( !$.support.offsetFractions ) {
            position.left = round( position.left );
            position.top = round( position.top );
        }

        collisionPosition = {
            marginLeft: marginLeft,
            marginTop: marginTop
        };

        $.each( [ "left", "top" ], function( i, dir ) {
            if ( $.ui.position[ collision[ i ] ] ) {
                $.ui.position[ collision[ i ] ][ dir ]( position, {
                    targetWidth: targetWidth,
                    targetHeight: targetHeight,
                    elemWidth: elemWidth,
                    elemHeight: elemHeight,
                    collisionPosition: collisionPosition,
                    collisionWidth: collisionWidth,
                    collisionHeight: collisionHeight,
                    offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
                    my: options.my,
                    at: options.at,
                    within: within,
                    elem : elem
                });
            }
        });

        if ( options.using ) {
            // adds feedback as second argument to using callback, if present
            using = function( props ) {
                var left = targetOffset.left - position.left,
                    right = left + targetWidth - elemWidth,
                    top = targetOffset.top - position.top,
                    bottom = top + targetHeight - elemHeight,
                    feedback = {
                        target: {
                            element: target,
                            left: targetOffset.left,
                            top: targetOffset.top,
                            width: targetWidth,
                            height: targetHeight
                        },
                        element: {
                            element: elem,
                            left: position.left,
                            top: position.top,
                            width: elemWidth,
                            height: elemHeight
                        },
                        horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                        vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                    };
                if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
                    feedback.horizontal = "center";
                }
                if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
                    feedback.vertical = "middle";
                }
                if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
                    feedback.important = "horizontal";
                } else {
                    feedback.important = "vertical";
                }
                options.using.call( this, props, feedback );
            };
        }

        elem.offset( $.extend( position, { using: using } ) );
    });
};

$.ui.position = {
    fit: {
        left: function( position, data ) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                outerWidth = within.width,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = withinOffset - collisionPosLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                newOverRight;

            // element is wider than within
            if ( data.collisionWidth > outerWidth ) {
                // element is initially over the left side of within
                if ( overLeft > 0 && overRight <= 0 ) {
                    newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                    position.left += overLeft - newOverRight;
                // element is initially over right side of within
                } else if ( overRight > 0 && overLeft <= 0 ) {
                    position.left = withinOffset;
                // element is initially over both left and right sides of within
                } else {
                    if ( overLeft > overRight ) {
                        position.left = withinOffset + outerWidth - data.collisionWidth;
                    } else {
                        position.left = withinOffset;
                    }
                }
            // too far left -> align with left edge
            } else if ( overLeft > 0 ) {
                position.left += overLeft;
            // too far right -> align with right edge
            } else if ( overRight > 0 ) {
                position.left -= overRight;
            // adjust based on position and margin
            } else {
                position.left = max( position.left - collisionPosLeft, position.left );
            }
        },
        top: function( position, data ) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                outerHeight = data.within.height,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = withinOffset - collisionPosTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                newOverBottom;

            // element is taller than within
            if ( data.collisionHeight > outerHeight ) {
                // element is initially over the top of within
                if ( overTop > 0 && overBottom <= 0 ) {
                    newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                    position.top += overTop - newOverBottom;
                // element is initially over bottom of within
                } else if ( overBottom > 0 && overTop <= 0 ) {
                    position.top = withinOffset;
                // element is initially over both top and bottom of within
                } else {
                    if ( overTop > overBottom ) {
                        position.top = withinOffset + outerHeight - data.collisionHeight;
                    } else {
                        position.top = withinOffset;
                    }
                }
            // too far up -> align with top
            } else if ( overTop > 0 ) {
                position.top += overTop;
            // too far down -> align with bottom edge
            } else if ( overBottom > 0 ) {
                position.top -= overBottom;
            // adjust based on position and margin
            } else {
                position.top = max( position.top - collisionPosTop, position.top );
            }
        }
    },
    flip: {
        left: function( position, data ) {
            var within = data.within,
                withinOffset = within.offset.left + within.scrollLeft,
                outerWidth = within.width,
                offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = collisionPosLeft - offsetLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                myOffset = data.my[ 0 ] === "left" ?
                    -data.elemWidth :
                    data.my[ 0 ] === "right" ?
                        data.elemWidth :
                        0,
                atOffset = data.at[ 0 ] === "left" ?
                    data.targetWidth :
                    data.at[ 0 ] === "right" ?
                        -data.targetWidth :
                        0,
                offset = -2 * data.offset[ 0 ],
                newOverRight,
                newOverLeft;

            if ( overLeft < 0 ) {
                newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
                    position.left += myOffset + atOffset + offset;
                }
            }
            else if ( overRight > 0 ) {
                newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
                    position.left += myOffset + atOffset + offset;
                }
            }
        },
        top: function( position, data ) {
            var within = data.within,
                withinOffset = within.offset.top + within.scrollTop,
                outerHeight = within.height,
                offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = collisionPosTop - offsetTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                top = data.my[ 1 ] === "top",
                myOffset = top ?
                    -data.elemHeight :
                    data.my[ 1 ] === "bottom" ?
                        data.elemHeight :
                        0,
                atOffset = data.at[ 1 ] === "top" ?
                    data.targetHeight :
                    data.at[ 1 ] === "bottom" ?
                        -data.targetHeight :
                        0,
                offset = -2 * data.offset[ 1 ],
                newOverTop,
                newOverBottom;
            if ( overTop < 0 ) {
                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
            else if ( overBottom > 0 ) {
                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
                    position.top += myOffset + atOffset + offset;
                }
            }
        }
    },
    flipfit: {
        left: function() {
            $.ui.position.flip.left.apply( this, arguments );
            $.ui.position.fit.left.apply( this, arguments );
        },
        top: function() {
            $.ui.position.flip.top.apply( this, arguments );
            $.ui.position.fit.top.apply( this, arguments );
        }
    }
};

// fraction support test
(function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i,
        body = document.getElementsByTagName( "body" )[ 0 ],
        div = document.createElement( "div" );

    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement( body ? "div" : "body" );
    testElementStyle = {
        visibility: "hidden",
        width: 0,
        height: 0,
        border: 0,
        margin: 0,
        background: "none"
    };
    if ( body ) {
        $.extend( testElementStyle, {
            position: "absolute",
            left: "-1000px",
            top: "-1000px"
        });
    }
    for ( i in testElementStyle ) {
        testElement.style[ i ] = testElementStyle[ i ];
    }
    testElement.appendChild( div );
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore( testElement, testElementParent.firstChild );

    div.style.cssText = "position: absolute; left: 10.7432222px;";

    offsetLeft = $( div ).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

    testElement.innerHTML = "";
    testElementParent.removeChild( testElement );
})();

}( jQuery ) );

(function( $, undefined ) {

$.widget( "ui.progressbar", {
    version: "1.10.4",
    options: {
        max: 100,
        value: 0,

        change: null,
        complete: null
    },

    min: 0,

    _create: function() {
        // Constrain initial value
        this.oldValue = this.options.value = this._constrainedValue();

        this.element
            .addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
            .attr({
                // Only set static values, aria-valuenow and aria-valuemax are
                // set inside _refreshValue()
                role: "progressbar",
                "aria-valuemin": this.min
            });

        this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
            .appendTo( this.element );

        this._refreshValue();
    },

    _destroy: function() {
        this.element
            .removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
            .removeAttr( "role" )
            .removeAttr( "aria-valuemin" )
            .removeAttr( "aria-valuemax" )
            .removeAttr( "aria-valuenow" );

        this.valueDiv.remove();
    },

    value: function( newValue ) {
        if ( newValue === undefined ) {
            return this.options.value;
        }

        this.options.value = this._constrainedValue( newValue );
        this._refreshValue();
    },

    _constrainedValue: function( newValue ) {
        if ( newValue === undefined ) {
            newValue = this.options.value;
        }

        this.indeterminate = newValue === false;

        // sanitize value
        if ( typeof newValue !== "number" ) {
            newValue = 0;
        }

        return this.indeterminate ? false :
            Math.min( this.options.max, Math.max( this.min, newValue ) );
    },

    _setOptions: function( options ) {
        // Ensure "value" option is set after other values (like max)
        var value = options.value;
        delete options.value;

        this._super( options );

        this.options.value = this._constrainedValue( value );
        this._refreshValue();
    },

    _setOption: function( key, value ) {
        if ( key === "max" ) {
            // Don't allow a max less than min
            value = Math.max( this.min, value );
        }

        this._super( key, value );
    },

    _percentage: function() {
        return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
    },

    _refreshValue: function() {
        var value = this.options.value,
            percentage = this._percentage();

        this.valueDiv
            .toggle( this.indeterminate || value > this.min )
            .toggleClass( "ui-corner-right", value === this.options.max )
            .width( percentage.toFixed(0) + "%" );

        this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

        if ( this.indeterminate ) {
            this.element.removeAttr( "aria-valuenow" );
            if ( !this.overlayDiv ) {
                this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
            }
        } else {
            this.element.attr({
                "aria-valuemax": this.options.max,
                "aria-valuenow": value
            });
            if ( this.overlayDiv ) {
                this.overlayDiv.remove();
                this.overlayDiv = null;
            }
        }

        if ( this.oldValue !== value ) {
            this.oldValue = value;
            this._trigger( "change" );
        }
        if ( value === this.options.max ) {
            this._trigger( "complete" );
        }
    }
});

})( jQuery );

(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
    version: "1.10.4",
    widgetEventPrefix: "slide",

    options: {
        animate: false,
        distance: 0,
        max: 100,
        min: 0,
        orientation: "horizontal",
        range: false,
        step: 1,
        value: 0,
        values: null,

        // callbacks
        change: null,
        slide: null,
        start: null,
        stop: null
    },

    _create: function() {
        this._keySliding = false;
        this._mouseSliding = false;
        this._animateOff = true;
        this._handleIndex = null;
        this._detectOrientation();
        this._mouseInit();

        this.element
            .addClass( "ui-slider" +
                " ui-slider-" + this.orientation +
                " ui-widget" +
                " ui-widget-content" +
                " ui-corner-all");

        this._refresh();
        this._setOption( "disabled", this.options.disabled );

        this._animateOff = false;
    },

    _refresh: function() {
        this._createRange();
        this._createHandles();
        this._setupEvents();
        this._refreshValue();
    },

    _createHandles: function() {
        var i, handleCount,
            options = this.options,
            existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
            handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
            handles = [];

        handleCount = ( options.values && options.values.length ) || 1;

        if ( existingHandles.length > handleCount ) {
            existingHandles.slice( handleCount ).remove();
            existingHandles = existingHandles.slice( 0, handleCount );
        }

        for ( i = existingHandles.length; i < handleCount; i++ ) {
            handles.push( handle );
        }

        this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

        this.handle = this.handles.eq( 0 );

        this.handles.each(function( i ) {
            $( this ).data( "ui-slider-handle-index", i );
        });
    },

    _createRange: function() {
        var options = this.options,
            classes = "";

        if ( options.range ) {
            if ( options.range === true ) {
                if ( !options.values ) {
                    options.values = [ this._valueMin(), this._valueMin() ];
                } else if ( options.values.length && options.values.length !== 2 ) {
                    options.values = [ options.values[0], options.values[0] ];
                } else if ( $.isArray( options.values ) ) {
                    options.values = options.values.slice(0);
                }
            }

            if ( !this.range || !this.range.length ) {
                this.range = $( "<div></div>" )
                    .appendTo( this.element );

                classes = "ui-slider-range" +
                // note: this isn't the most fittingly semantic framework class for this element,
                // but worked best visually with a variety of themes
                " ui-widget-header ui-corner-all";
            } else {
                this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
                    // Handle range switching from true to min/max
                    .css({
                        "left": "",
                        "bottom": ""
                    });
            }

            this.range.addClass( classes +
                ( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
        } else {
            if ( this.range ) {
                this.range.remove();
            }
            this.range = null;
        }
    },

    _setupEvents: function() {
        var elements = this.handles.add( this.range ).filter( "a" );
        this._off( elements );
        this._on( elements, this._handleEvents );
        this._hoverable( elements );
        this._focusable( elements );
    },

    _destroy: function() {
        this.handles.remove();
        if ( this.range ) {
            this.range.remove();
        }

        this.element
            .removeClass( "ui-slider" +
                " ui-slider-horizontal" +
                " ui-slider-vertical" +
                " ui-widget" +
                " ui-widget-content" +
                " ui-corner-all" );

        this._mouseDestroy();
    },

    _mouseCapture: function( event ) {
        var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
            that = this,
            o = this.options;

        if ( o.disabled ) {
            return false;
        }

        this.elementSize = {
            width: this.element.outerWidth(),
            height: this.element.outerHeight()
        };
        this.elementOffset = this.element.offset();

        position = { x: event.pageX, y: event.pageY };
        normValue = this._normValueFromMouse( position );
        distance = this._valueMax() - this._valueMin() + 1;
        this.handles.each(function( i ) {
            var thisDistance = Math.abs( normValue - that.values(i) );
            if (( distance > thisDistance ) ||
                ( distance === thisDistance &&
                    (i === that._lastChangedValue || that.values(i) === o.min ))) {
                distance = thisDistance;
                closestHandle = $( this );
                index = i;
            }
        });

        allowed = this._start( event, index );
        if ( allowed === false ) {
            return false;
        }
        this._mouseSliding = true;

        this._handleIndex = index;

        closestHandle
            .addClass( "ui-state-active" )
            .focus();

        offset = closestHandle.offset();
        mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
        this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
            left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
            top: event.pageY - offset.top -
                ( closestHandle.height() / 2 ) -
                ( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
                ( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
                ( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
        };

        if ( !this.handles.hasClass( "ui-state-hover" ) ) {
            this._slide( event, index, normValue );
        }
        this._animateOff = true;
        return true;
    },

    _mouseStart: function() {
        return true;
    },

    _mouseDrag: function( event ) {
        var position = { x: event.pageX, y: event.pageY },
            normValue = this._normValueFromMouse( position );

        this._slide( event, this._handleIndex, normValue );

        return false;
    },

    _mouseStop: function( event ) {
        this.handles.removeClass( "ui-state-active" );
        this._mouseSliding = false;

        this._stop( event, this._handleIndex );
        this._change( event, this._handleIndex );

        this._handleIndex = null;
        this._clickOffset = null;
        this._animateOff = false;

        return false;
    },

    _detectOrientation: function() {
        this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
    },

    _normValueFromMouse: function( position ) {
        var pixelTotal,
            pixelMouse,
            percentMouse,
            valueTotal,
            valueMouse;

        if ( this.orientation === "horizontal" ) {
            pixelTotal = this.elementSize.width;
            pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
        } else {
            pixelTotal = this.elementSize.height;
            pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
        }

        percentMouse = ( pixelMouse / pixelTotal );
        if ( percentMouse > 1 ) {
            percentMouse = 1;
        }
        if ( percentMouse < 0 ) {
            percentMouse = 0;
        }
        if ( this.orientation === "vertical" ) {
            percentMouse = 1 - percentMouse;
        }

        valueTotal = this._valueMax() - this._valueMin();
        valueMouse = this._valueMin() + percentMouse * valueTotal;

        return this._trimAlignValue( valueMouse );
    },

    _start: function( event, index ) {
        var uiHash = {
            handle: this.handles[ index ],
            value: this.value()
        };
        if ( this.options.values && this.options.values.length ) {
            uiHash.value = this.values( index );
            uiHash.values = this.values();
        }
        return this._trigger( "start", event, uiHash );
    },

    _slide: function( event, index, newVal ) {
        var otherVal,
            newValues,
            allowed;

        if ( this.options.values && this.options.values.length ) {
            otherVal = this.values( index ? 0 : 1 );

            if ( ( this.options.values.length === 2 && this.options.range === true ) &&
                    ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
                ) {
                newVal = otherVal;
            }

            if ( newVal !== this.values( index ) ) {
                newValues = this.values();
                newValues[ index ] = newVal;
                // A slide can be canceled by returning false from the slide callback
                allowed = this._trigger( "slide", event, {
                    handle: this.handles[ index ],
                    value: newVal,
                    values: newValues
                } );
                otherVal = this.values( index ? 0 : 1 );
                if ( allowed !== false ) {
                    this.values( index, newVal );
                }
            }
        } else {
            if ( newVal !== this.value() ) {
                // A slide can be canceled by returning false from the slide callback
                allowed = this._trigger( "slide", event, {
                    handle: this.handles[ index ],
                    value: newVal
                } );
                if ( allowed !== false ) {
                    this.value( newVal );
                }
            }
        }
    },

    _stop: function( event, index ) {
        var uiHash = {
            handle: this.handles[ index ],
            value: this.value()
        };
        if ( this.options.values && this.options.values.length ) {
            uiHash.value = this.values( index );
            uiHash.values = this.values();
        }

        this._trigger( "stop", event, uiHash );
    },

    _change: function( event, index ) {
        if ( !this._keySliding && !this._mouseSliding ) {
            var uiHash = {
                handle: this.handles[ index ],
                value: this.value()
            };
            if ( this.options.values && this.options.values.length ) {
                uiHash.value = this.values( index );
                uiHash.values = this.values();
            }

            //store the last changed value index for reference when handles overlap
            this._lastChangedValue = index;

            this._trigger( "change", event, uiHash );
        }
    },

    value: function( newValue ) {
        if ( arguments.length ) {
            this.options.value = this._trimAlignValue( newValue );
            this._refreshValue();
            this._change( null, 0 );
            return;
        }

        return this._value();
    },

    values: function( index, newValue ) {
        var vals,
            newValues,
            i;

        if ( arguments.length > 1 ) {
            this.options.values[ index ] = this._trimAlignValue( newValue );
            this._refreshValue();
            this._change( null, index );
            return;
        }

        if ( arguments.length ) {
            if ( $.isArray( arguments[ 0 ] ) ) {
                vals = this.options.values;
                newValues = arguments[ 0 ];
                for ( i = 0; i < vals.length; i += 1 ) {
                    vals[ i ] = this._trimAlignValue( newValues[ i ] );
                    this._change( null, i );
                }
                this._refreshValue();
            } else {
                if ( this.options.values && this.options.values.length ) {
                    return this._values( index );
                } else {
                    return this.value();
                }
            }
        } else {
            return this._values();
        }
    },

    _setOption: function( key, value ) {
        var i,
            valsLength = 0;

        if ( key === "range" && this.options.range === true ) {
            if ( value === "min" ) {
                this.options.value = this._values( 0 );
                this.options.values = null;
            } else if ( value === "max" ) {
                this.options.value = this._values( this.options.values.length-1 );
                this.options.values = null;
            }
        }

        if ( $.isArray( this.options.values ) ) {
            valsLength = this.options.values.length;
        }

        $.Widget.prototype._setOption.apply( this, arguments );

        switch ( key ) {
            case "orientation":
                this._detectOrientation();
                this.element
                    .removeClass( "ui-slider-horizontal ui-slider-vertical" )
                    .addClass( "ui-slider-" + this.orientation );
                this._refreshValue();
                break;
            case "value":
                this._animateOff = true;
                this._refreshValue();
                this._change( null, 0 );
                this._animateOff = false;
                break;
            case "values":
                this._animateOff = true;
                this._refreshValue();
                for ( i = 0; i < valsLength; i += 1 ) {
                    this._change( null, i );
                }
                this._animateOff = false;
                break;
            case "min":
            case "max":
                this._animateOff = true;
                this._refreshValue();
                this._animateOff = false;
                break;
            case "range":
                this._animateOff = true;
                this._refresh();
                this._animateOff = false;
                break;
        }
    },

    //internal value getter
    // _value() returns value trimmed by min and max, aligned by step
    _value: function() {
        var val = this.options.value;
        val = this._trimAlignValue( val );

        return val;
    },

    //internal values getter
    // _values() returns array of values trimmed by min and max, aligned by step
    // _values( index ) returns single value trimmed by min and max, aligned by step
    _values: function( index ) {
        var val,
            vals,
            i;

        if ( arguments.length ) {
            val = this.options.values[ index ];
            val = this._trimAlignValue( val );

            return val;
        } else if ( this.options.values && this.options.values.length ) {
            // .slice() creates a copy of the array
            // this copy gets trimmed by min and max and then returned
            vals = this.options.values.slice();
            for ( i = 0; i < vals.length; i+= 1) {
                vals[ i ] = this._trimAlignValue( vals[ i ] );
            }

            return vals;
        } else {
            return [];
        }
    },

    // returns the step-aligned value that val is closest to, between (inclusive) min and max
    _trimAlignValue: function( val ) {
        if ( val <= this._valueMin() ) {
            return this._valueMin();
        }
        if ( val >= this._valueMax() ) {
            return this._valueMax();
        }
        var step = ( this.options.step > 0 ) ? this.options.step : 1,
            valModStep = (val - this._valueMin()) % step,
            alignValue = val - valModStep;

        if ( Math.abs(valModStep) * 2 >= step ) {
            alignValue += ( valModStep > 0 ) ? step : ( -step );
        }

        // Since JavaScript has problems with large floats, round
        // the final value to 5 digits after the decimal point (see #4124)
        return parseFloat( alignValue.toFixed(5) );
    },

    _valueMin: function() {
        return this.options.min;
    },

    _valueMax: function() {
        return this.options.max;
    },

    _refreshValue: function() {
        var lastValPercent, valPercent, value, valueMin, valueMax,
            oRange = this.options.range,
            o = this.options,
            that = this,
            animate = ( !this._animateOff ) ? o.animate : false,
            _set = {};

        if ( this.options.values && this.options.values.length ) {
            this.handles.each(function( i ) {
                valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
                _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
                $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
                if ( that.options.range === true ) {
                    if ( that.orientation === "horizontal" ) {
                        if ( i === 0 ) {
                            that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
                        }
                        if ( i === 1 ) {
                            that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                        }
                    } else {
                        if ( i === 0 ) {
                            that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
                        }
                        if ( i === 1 ) {
                            that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
                        }
                    }
                }
                lastValPercent = valPercent;
            });
        } else {
            value = this.value();
            valueMin = this._valueMin();
            valueMax = this._valueMax();
            valPercent = ( valueMax !== valueMin ) ?
                    ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
                    0;
            _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
            this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

            if ( oRange === "min" && this.orientation === "horizontal" ) {
                this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
            }
            if ( oRange === "max" && this.orientation === "horizontal" ) {
                this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
            }
            if ( oRange === "min" && this.orientation === "vertical" ) {
                this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
            }
            if ( oRange === "max" && this.orientation === "vertical" ) {
                this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
            }
        }
    },

    _handleEvents: {
        keydown: function( event ) {
            var allowed, curVal, newVal, step,
                index = $( event.target ).data( "ui-slider-handle-index" );

            switch ( event.keyCode ) {
                case $.ui.keyCode.HOME:
                case $.ui.keyCode.END:
                case $.ui.keyCode.PAGE_UP:
                case $.ui.keyCode.PAGE_DOWN:
                case $.ui.keyCode.UP:
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                case $.ui.keyCode.LEFT:
                    event.preventDefault();
                    if ( !this._keySliding ) {
                        this._keySliding = true;
                        $( event.target ).addClass( "ui-state-active" );
                        allowed = this._start( event, index );
                        if ( allowed === false ) {
                            return;
                        }
                    }
                    break;
            }

            step = this.options.step;
            if ( this.options.values && this.options.values.length ) {
                curVal = newVal = this.values( index );
            } else {
                curVal = newVal = this.value();
            }

            switch ( event.keyCode ) {
                case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;
                case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;
                case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.RIGHT:
                    if ( curVal === this._valueMax() ) {
                        return;
                    }
                    newVal = this._trimAlignValue( curVal + step );
                    break;
                case $.ui.keyCode.DOWN:
                case $.ui.keyCode.LEFT:
                    if ( curVal === this._valueMin() ) {
                        return;
                    }
                    newVal = this._trimAlignValue( curVal - step );
                    break;
            }

            this._slide( event, index, newVal );
        },
        click: function( event ) {
            event.preventDefault();
        },
        keyup: function( event ) {
            var index = $( event.target ).data( "ui-slider-handle-index" );

            if ( this._keySliding ) {
                this._keySliding = false;
                this._stop( event, index );
                this._change( event, index );
                $( event.target ).removeClass( "ui-state-active" );
            }
        }
    }

});

}(jQuery));

(function( $ ) {

function modifier( fn ) {
    return function() {
        var previous = this.element.val();
        fn.apply( this, arguments );
        this._refresh();
        if ( previous !== this.element.val() ) {
            this._trigger( "change" );
        }
    };
}

$.widget( "ui.spinner", {
    version: "1.10.4",
    defaultElement: "<input>",
    widgetEventPrefix: "spin",
    options: {
        culture: null,
        icons: {
            down: "ui-icon-triangle-1-s",
            up: "ui-icon-triangle-1-n"
        },
        incremental: true,
        max: null,
        min: null,
        numberFormat: null,
        page: 10,
        step: 1,

        change: null,
        spin: null,
        start: null,
        stop: null
    },

    _create: function() {
        // handle string values that need to be parsed
        this._setOption( "max", this.options.max );
        this._setOption( "min", this.options.min );
        this._setOption( "step", this.options.step );

        // Only format if there is a value, prevents the field from being marked
        // as invalid in Firefox, see #9573.
        if ( this.value() !== "" ) {
            // Format the value, but don't constrain.
            this._value( this.element.val(), true );
        }

        this._draw();
        this._on( this._events );
        this._refresh();

        // turning off autocomplete prevents the browser from remembering the
        // value when navigating through history, so we re-enable autocomplete
        // if the page is unloaded before the widget is destroyed. #7790
        this._on( this.window, {
            beforeunload: function() {
                this.element.removeAttr( "autocomplete" );
            }
        });
    },

    _getCreateOptions: function() {
        var options = {},
            element = this.element;

        $.each( [ "min", "max", "step" ], function( i, option ) {
            var value = element.attr( option );
            if ( value !== undefined && value.length ) {
                options[ option ] = value;
            }
        });

        return options;
    },

    _events: {
        keydown: function( event ) {
            if ( this._start( event ) && this._keydown( event ) ) {
                event.preventDefault();
            }
        },
        keyup: "_stop",
        focus: function() {
            this.previous = this.element.val();
        },
        blur: function( event ) {
            if ( this.cancelBlur ) {
                delete this.cancelBlur;
                return;
            }

            this._stop();
            this._refresh();
            if ( this.previous !== this.element.val() ) {
                this._trigger( "change", event );
            }
        },
        mousewheel: function( event, delta ) {
            if ( !delta ) {
                return;
            }
            if ( !this.spinning && !this._start( event ) ) {
                return false;
            }

            this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
            clearTimeout( this.mousewheelTimer );
            this.mousewheelTimer = this._delay(function() {
                if ( this.spinning ) {
                    this._stop( event );
                }
            }, 100 );
            event.preventDefault();
        },
        "mousedown .ui-spinner-button": function( event ) {
            var previous;

            // We never want the buttons to have focus; whenever the user is
            // interacting with the spinner, the focus should be on the input.
            // If the input is focused then this.previous is properly set from
            // when the input first received focus. If the input is not focused
            // then we need to set this.previous based on the value before spinning.
            previous = this.element[0] === this.document[0].activeElement ?
                this.previous : this.element.val();
            function checkFocus() {
                var isActive = this.element[0] === this.document[0].activeElement;
                if ( !isActive ) {
                    this.element.focus();
                    this.previous = previous;
                    // support: IE
                    // IE sets focus asynchronously, so we need to check if focus
                    // moved off of the input because the user clicked on the button.
                    this._delay(function() {
                        this.previous = previous;
                    });
                }
            }

            // ensure focus is on (or stays on) the text field
            event.preventDefault();
            checkFocus.call( this );

            // support: IE
            // IE doesn't prevent moving focus even with event.preventDefault()
            // so we set a flag to know when we should ignore the blur event
            // and check (again) if focus moved off of the input.
            this.cancelBlur = true;
            this._delay(function() {
                delete this.cancelBlur;
                checkFocus.call( this );
            });

            if ( this._start( event ) === false ) {
                return;
            }

            this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
        },
        "mouseup .ui-spinner-button": "_stop",
        "mouseenter .ui-spinner-button": function( event ) {
            // button will add ui-state-active if mouse was down while mouseleave and kept down
            if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
                return;
            }

            if ( this._start( event ) === false ) {
                return false;
            }
            this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
        },
        // TODO: do we really want to consider this a stop?
        // shouldn't we just stop the repeater and wait until mouseup before
        // we trigger the stop event?
        "mouseleave .ui-spinner-button": "_stop"
    },

    _draw: function() {
        var uiSpinner = this.uiSpinner = this.element
            .addClass( "ui-spinner-input" )
            .attr( "autocomplete", "off" )
            .wrap( this._uiSpinnerHtml() )
            .parent()
                // add buttons
                .append( this._buttonHtml() );

        this.element.attr( "role", "spinbutton" );

        // button bindings
        this.buttons = uiSpinner.find( ".ui-spinner-button" )
            .attr( "tabIndex", -1 )
            .button()
            .removeClass( "ui-corner-all" );

        // IE 6 doesn't understand height: 50% for the buttons
        // unless the wrapper has an explicit height
        if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
                uiSpinner.height() > 0 ) {
            uiSpinner.height( uiSpinner.height() );
        }

        // disable spinner if element was already disabled
        if ( this.options.disabled ) {
            this.disable();
        }
    },

    _keydown: function( event ) {
        var options = this.options,
            keyCode = $.ui.keyCode;

        switch ( event.keyCode ) {
        case keyCode.UP:
            this._repeat( null, 1, event );
            return true;
        case keyCode.DOWN:
            this._repeat( null, -1, event );
            return true;
        case keyCode.PAGE_UP:
            this._repeat( null, options.page, event );
            return true;
        case keyCode.PAGE_DOWN:
            this._repeat( null, -options.page, event );
            return true;
        }

        return false;
    },

    _uiSpinnerHtml: function() {
        return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
    },

    _buttonHtml: function() {
        return "" +
            "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
                "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
            "</a>" +
            "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
                "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
            "</a>";
    },

    _start: function( event ) {
        if ( !this.spinning && this._trigger( "start", event ) === false ) {
            return false;
        }

        if ( !this.counter ) {
            this.counter = 1;
        }
        this.spinning = true;
        return true;
    },

    _repeat: function( i, steps, event ) {
        i = i || 500;

        clearTimeout( this.timer );
        this.timer = this._delay(function() {
            this._repeat( 40, steps, event );
        }, i );

        this._spin( steps * this.options.step, event );
    },

    _spin: function( step, event ) {
        var value = this.value() || 0;

        if ( !this.counter ) {
            this.counter = 1;
        }

        value = this._adjustValue( value + step * this._increment( this.counter ) );

        if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
            this._value( value );
            this.counter++;
        }
    },

    _increment: function( i ) {
        var incremental = this.options.incremental;

        if ( incremental ) {
            return $.isFunction( incremental ) ?
                incremental( i ) :
                Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
        }

        return 1;
    },

    _precision: function() {
        var precision = this._precisionOf( this.options.step );
        if ( this.options.min !== null ) {
            precision = Math.max( precision, this._precisionOf( this.options.min ) );
        }
        return precision;
    },

    _precisionOf: function( num ) {
        var str = num.toString(),
            decimal = str.indexOf( "." );
        return decimal === -1 ? 0 : str.length - decimal - 1;
    },

    _adjustValue: function( value ) {
        var base, aboveMin,
            options = this.options;

        // make sure we're at a valid step
        // - find out where we are relative to the base (min or 0)
        base = options.min !== null ? options.min : 0;
        aboveMin = value - base;
        // - round to the nearest step
        aboveMin = Math.round(aboveMin / options.step) * options.step;
        // - rounding is based on 0, so adjust back to our base
        value = base + aboveMin;

        // fix precision from bad JS floating point math
        value = parseFloat( value.toFixed( this._precision() ) );

        // clamp the value
        if ( options.max !== null && value > options.max) {
            return options.max;
        }
        if ( options.min !== null && value < options.min ) {
            return options.min;
        }

        return value;
    },

    _stop: function( event ) {
        if ( !this.spinning ) {
            return;
        }

        clearTimeout( this.timer );
        clearTimeout( this.mousewheelTimer );
        this.counter = 0;
        this.spinning = false;
        this._trigger( "stop", event );
    },

    _setOption: function( key, value ) {
        if ( key === "culture" || key === "numberFormat" ) {
            var prevValue = this._parse( this.element.val() );
            this.options[ key ] = value;
            this.element.val( this._format( prevValue ) );
            return;
        }

        if ( key === "max" || key === "min" || key === "step" ) {
            if ( typeof value === "string" ) {
                value = this._parse( value );
            }
        }
        if ( key === "icons" ) {
            this.buttons.first().find( ".ui-icon" )
                .removeClass( this.options.icons.up )
                .addClass( value.up );
            this.buttons.last().find( ".ui-icon" )
                .removeClass( this.options.icons.down )
                .addClass( value.down );
        }

        this._super( key, value );

        if ( key === "disabled" ) {
            if ( value ) {
                this.element.prop( "disabled", true );
                this.buttons.button( "disable" );
            } else {
                this.element.prop( "disabled", false );
                this.buttons.button( "enable" );
            }
        }
    },

    _setOptions: modifier(function( options ) {
        this._super( options );
        this._value( this.element.val() );
    }),

    _parse: function( val ) {
        if ( typeof val === "string" && val !== "" ) {
            val = window.Globalize && this.options.numberFormat ?
                Globalize.parseFloat( val, 10, this.options.culture ) : +val;
        }
        return val === "" || isNaN( val ) ? null : val;
    },

    _format: function( value ) {
        if ( value === "" ) {
            return "";
        }
        return window.Globalize && this.options.numberFormat ?
            Globalize.format( value, this.options.numberFormat, this.options.culture ) :
            value;
    },

    _refresh: function() {
        this.element.attr({
            "aria-valuemin": this.options.min,
            "aria-valuemax": this.options.max,
            // TODO: what should we do with values that can't be parsed?
            "aria-valuenow": this._parse( this.element.val() )
        });
    },

    // update the value without triggering change
    _value: function( value, allowAny ) {
        var parsed;
        if ( value !== "" ) {
            parsed = this._parse( value );
            if ( parsed !== null ) {
                if ( !allowAny ) {
                    parsed = this._adjustValue( parsed );
                }
                value = this._format( parsed );
            }
        }
        this.element.val( value );
        this._refresh();
    },

    _destroy: function() {
        this.element
            .removeClass( "ui-spinner-input" )
            .prop( "disabled", false )
            .removeAttr( "autocomplete" )
            .removeAttr( "role" )
            .removeAttr( "aria-valuemin" )
            .removeAttr( "aria-valuemax" )
            .removeAttr( "aria-valuenow" );
        this.uiSpinner.replaceWith( this.element );
    },

    stepUp: modifier(function( steps ) {
        this._stepUp( steps );
    }),
    _stepUp: function( steps ) {
        if ( this._start() ) {
            this._spin( (steps || 1) * this.options.step );
            this._stop();
        }
    },

    stepDown: modifier(function( steps ) {
        this._stepDown( steps );
    }),
    _stepDown: function( steps ) {
        if ( this._start() ) {
            this._spin( (steps || 1) * -this.options.step );
            this._stop();
        }
    },

    pageUp: modifier(function( pages ) {
        this._stepUp( (pages || 1) * this.options.page );
    }),

    pageDown: modifier(function( pages ) {
        this._stepDown( (pages || 1) * this.options.page );
    }),

    value: function( newVal ) {
        if ( !arguments.length ) {
            return this._parse( this.element.val() );
        }
        modifier( this._value ).call( this, newVal );
    },

    widget: function() {
        return this.uiSpinner;
    }
});

}( jQuery ) );

(function( $, undefined ) {

var tabId = 0,
    rhash = /#.*$/;

function getNextTabId() {
    return ++tabId;
}

function isLocal( anchor ) {
    // support: IE7
    // IE7 doesn't normalize the href property when set via script (#9317)
    anchor = anchor.cloneNode( false );

    return anchor.hash.length > 1 &&
        decodeURIComponent( anchor.href.replace( rhash, "" ) ) ===
            decodeURIComponent( location.href.replace( rhash, "" ) );
}

$.widget( "ui.tabs", {
    version: "1.10.4",
    delay: 300,
    options: {
        active: null,
        collapsible: false,
        event: "click",
        heightStyle: "content",
        hide: null,
        show: null,

        // callbacks
        activate: null,
        beforeActivate: null,
        beforeLoad: null,
        load: null
    },

    _create: function() {
        var that = this,
            options = this.options;

        this.running = false;

        this.element
            .addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
            .toggleClass( "ui-tabs-collapsible", options.collapsible )
            // Prevent users from focusing disabled tabs via click
            .delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
                if ( $( this ).is( ".ui-state-disabled" ) ) {
                    event.preventDefault();
                }
            })
            // support: IE <9
            // Preventing the default action in mousedown doesn't prevent IE
            // from focusing the element, so if the anchor gets focused, blur.
            // We don't have to worry about focusing the previously focused
            // element since clicking on a non-focusable element should focus
            // the body anyway.
            .delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
                    this.blur();
                }
            });

        this._processTabs();
        options.active = this._initialActive();

        // Take disabling tabs via class attribute from HTML
        // into account and update option properly.
        if ( $.isArray( options.disabled ) ) {
            options.disabled = $.unique( options.disabled.concat(
                $.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
                    return that.tabs.index( li );
                })
            ) ).sort();
        }

        // check for length avoids error when initializing empty list
        if ( this.options.active !== false && this.anchors.length ) {
            this.active = this._findActive( options.active );
        } else {
            this.active = $();
        }

        this._refresh();

        if ( this.active.length ) {
            this.load( options.active );
        }
    },

    _initialActive: function() {
        var active = this.options.active,
            collapsible = this.options.collapsible,
            locationHash = location.hash.substring( 1 );

        if ( active === null ) {
            // check the fragment identifier in the URL
            if ( locationHash ) {
                this.tabs.each(function( i, tab ) {
                    if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
                        active = i;
                        return false;
                    }
                });
            }

            // check for a tab marked active via a class
            if ( active === null ) {
                active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
            }

            // no active tab, set to false
            if ( active === null || active === -1 ) {
                active = this.tabs.length ? 0 : false;
            }
        }

        // handle numbers: negative, out of range
        if ( active !== false ) {
            active = this.tabs.index( this.tabs.eq( active ) );
            if ( active === -1 ) {
                active = collapsible ? false : 0;
            }
        }

        // don't allow collapsible: false and active: false
        if ( !collapsible && active === false && this.anchors.length ) {
            active = 0;
        }

        return active;
    },

    _getCreateEventData: function() {
        return {
            tab: this.active,
            panel: !this.active.length ? $() : this._getPanelForTab( this.active )
        };
    },

    _tabKeydown: function( event ) {
        var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
            selectedIndex = this.tabs.index( focusedTab ),
            goingForward = true;

        if ( this._handlePageNav( event ) ) {
            return;
        }

        switch ( event.keyCode ) {
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
                selectedIndex++;
                break;
            case $.ui.keyCode.UP:
            case $.ui.keyCode.LEFT:
                goingForward = false;
                selectedIndex--;
                break;
            case $.ui.keyCode.END:
                selectedIndex = this.anchors.length - 1;
                break;
            case $.ui.keyCode.HOME:
                selectedIndex = 0;
                break;
            case $.ui.keyCode.SPACE:
                // Activate only, no collapsing
                event.preventDefault();
                clearTimeout( this.activating );
                this._activate( selectedIndex );
                return;
            case $.ui.keyCode.ENTER:
                // Toggle (cancel delayed activation, allow collapsing)
                event.preventDefault();
                clearTimeout( this.activating );
                // Determine if we should collapse or activate
                this._activate( selectedIndex === this.options.active ? false : selectedIndex );
                return;
            default:
                return;
        }

        // Focus the appropriate tab, based on which key was pressed
        event.preventDefault();
        clearTimeout( this.activating );
        selectedIndex = this._focusNextTab( selectedIndex, goingForward );

        // Navigating with control key will prevent automatic activation
        if ( !event.ctrlKey ) {
            // Update aria-selected immediately so that AT think the tab is already selected.
            // Otherwise AT may confuse the user by stating that they need to activate the tab,
            // but the tab will already be activated by the time the announcement finishes.
            focusedTab.attr( "aria-selected", "false" );
            this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

            this.activating = this._delay(function() {
                this.option( "active", selectedIndex );
            }, this.delay );
        }
    },

    _panelKeydown: function( event ) {
        if ( this._handlePageNav( event ) ) {
            return;
        }

        // Ctrl+up moves focus to the current tab
        if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
            event.preventDefault();
            this.active.focus();
        }
    },

    // Alt+page up/down moves focus to the previous/next tab (and activates)
    _handlePageNav: function( event ) {
        if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
            this._activate( this._focusNextTab( this.options.active - 1, false ) );
            return true;
        }
        if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
            this._activate( this._focusNextTab( this.options.active + 1, true ) );
            return true;
        }
    },

    _findNextTab: function( index, goingForward ) {
        var lastTabIndex = this.tabs.length - 1;

        function constrain() {
            if ( index > lastTabIndex ) {
                index = 0;
            }
            if ( index < 0 ) {
                index = lastTabIndex;
            }
            return index;
        }

        while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
            index = goingForward ? index + 1 : index - 1;
        }

        return index;
    },

    _focusNextTab: function( index, goingForward ) {
        index = this._findNextTab( index, goingForward );
        this.tabs.eq( index ).focus();
        return index;
    },

    _setOption: function( key, value ) {
        if ( key === "active" ) {
            // _activate() will handle invalid values and update this.options
            this._activate( value );
            return;
        }

        if ( key === "disabled" ) {
            // don't use the widget factory's disabled handling
            this._setupDisabled( value );
            return;
        }

        this._super( key, value);

        if ( key === "collapsible" ) {
            this.element.toggleClass( "ui-tabs-collapsible", value );
            // Setting collapsible: false while collapsed; open first panel
            if ( !value && this.options.active === false ) {
                this._activate( 0 );
            }
        }

        if ( key === "event" ) {
            this._setupEvents( value );
        }

        if ( key === "heightStyle" ) {
            this._setupHeightStyle( value );
        }
    },

    _tabId: function( tab ) {
        return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
    },

    _sanitizeSelector: function( hash ) {
        return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
    },

    refresh: function() {
        var options = this.options,
            lis = this.tablist.children( ":has(a[href])" );

        // get disabled tabs from class attribute from HTML
        // this will get converted to a boolean if needed in _refresh()
        options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
            return lis.index( tab );
        });

        this._processTabs();

        // was collapsed or no tabs
        if ( options.active === false || !this.anchors.length ) {
            options.active = false;
            this.active = $();
        // was active, but active tab is gone
        } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
            // all remaining tabs are disabled
            if ( this.tabs.length === options.disabled.length ) {
                options.active = false;
                this.active = $();
            // activate previous tab
            } else {
                this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
            }
        // was active, active tab still exists
        } else {
            // make sure active index is correct
            options.active = this.tabs.index( this.active );
        }

        this._refresh();
    },

    _refresh: function() {
        this._setupDisabled( this.options.disabled );
        this._setupEvents( this.options.event );
        this._setupHeightStyle( this.options.heightStyle );

        this.tabs.not( this.active ).attr({
            "aria-selected": "false",
            tabIndex: -1
        });
        this.panels.not( this._getPanelForTab( this.active ) )
            .hide()
            .attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });

        // Make sure one tab is in the tab order
        if ( !this.active.length ) {
            this.tabs.eq( 0 ).attr( "tabIndex", 0 );
        } else {
            this.active
                .addClass( "ui-tabs-active ui-state-active" )
                .attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
            this._getPanelForTab( this.active )
                .show()
                .attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                });
        }
    },

    _processTabs: function() {
        var that = this;

        this.tablist = this._getList()
            .addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
            .attr( "role", "tablist" );

        this.tabs = this.tablist.find( "> li:has(a[href])" )
            .addClass( "ui-state-default ui-corner-top" )
            .attr({
                role: "tab",
                tabIndex: -1
            });

        this.anchors = this.tabs.map(function() {
                return $( "a", this )[ 0 ];
            })
            .addClass( "ui-tabs-anchor" )
            .attr({
                role: "presentation",
                tabIndex: -1
            });

        this.panels = $();

        this.anchors.each(function( i, anchor ) {
            var selector, panel, panelId,
                anchorId = $( anchor ).uniqueId().attr( "id" ),
                tab = $( anchor ).closest( "li" ),
                originalAriaControls = tab.attr( "aria-controls" );

            // inline tab
            if ( isLocal( anchor ) ) {
                selector = anchor.hash;
                panel = that.element.find( that._sanitizeSelector( selector ) );
            // remote tab
            } else {
                panelId = that._tabId( tab );
                selector = "#" + panelId;
                panel = that.element.find( selector );
                if ( !panel.length ) {
                    panel = that._createPanel( panelId );
                    panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
                }
                panel.attr( "aria-live", "polite" );
            }

            if ( panel.length) {
                that.panels = that.panels.add( panel );
            }
            if ( originalAriaControls ) {
                tab.data( "ui-tabs-aria-controls", originalAriaControls );
            }
            tab.attr({
                "aria-controls": selector.substring( 1 ),
                "aria-labelledby": anchorId
            });
            panel.attr( "aria-labelledby", anchorId );
        });

        this.panels
            .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
            .attr( "role", "tabpanel" );
    },

    // allow overriding how to find the list for rare usage scenarios (#7715)
    _getList: function() {
        return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
    },

    _createPanel: function( id ) {
        return $( "<div>" )
            .attr( "id", id )
            .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
            .data( "ui-tabs-destroy", true );
    },

    _setupDisabled: function( disabled ) {
        if ( $.isArray( disabled ) ) {
            if ( !disabled.length ) {
                disabled = false;
            } else if ( disabled.length === this.anchors.length ) {
                disabled = true;
            }
        }

        // disable tabs
        for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
            if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
                $( li )
                    .addClass( "ui-state-disabled" )
                    .attr( "aria-disabled", "true" );
            } else {
                $( li )
                    .removeClass( "ui-state-disabled" )
                    .removeAttr( "aria-disabled" );
            }
        }

        this.options.disabled = disabled;
    },

    _setupEvents: function( event ) {
        var events = {
            click: function( event ) {
                event.preventDefault();
            }
        };
        if ( event ) {
            $.each( event.split(" "), function( index, eventName ) {
                events[ eventName ] = "_eventHandler";
            });
        }

        this._off( this.anchors.add( this.tabs ).add( this.panels ) );
        this._on( this.anchors, events );
        this._on( this.tabs, { keydown: "_tabKeydown" } );
        this._on( this.panels, { keydown: "_panelKeydown" } );

        this._focusable( this.tabs );
        this._hoverable( this.tabs );
    },

    _setupHeightStyle: function( heightStyle ) {
        var maxHeight,
            parent = this.element.parent();

        if ( heightStyle === "fill" ) {
            maxHeight = parent.height();
            maxHeight -= this.element.outerHeight() - this.element.height();

            this.element.siblings( ":visible" ).each(function() {
                var elem = $( this ),
                    position = elem.css( "position" );

                if ( position === "absolute" || position === "fixed" ) {
                    return;
                }
                maxHeight -= elem.outerHeight( true );
            });

            this.element.children().not( this.panels ).each(function() {
                maxHeight -= $( this ).outerHeight( true );
            });

            this.panels.each(function() {
                $( this ).height( Math.max( 0, maxHeight -
                    $( this ).innerHeight() + $( this ).height() ) );
            })
            .css( "overflow", "auto" );
        } else if ( heightStyle === "auto" ) {
            maxHeight = 0;
            this.panels.each(function() {
                maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
            }).height( maxHeight );
        }
    },

    _eventHandler: function( event ) {
        var options = this.options,
            active = this.active,
            anchor = $( event.currentTarget ),
            tab = anchor.closest( "li" ),
            clickedIsActive = tab[ 0 ] === active[ 0 ],
            collapsing = clickedIsActive && options.collapsible,
            toShow = collapsing ? $() : this._getPanelForTab( tab ),
            toHide = !active.length ? $() : this._getPanelForTab( active ),
            eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
            };

        event.preventDefault();

        if ( tab.hasClass( "ui-state-disabled" ) ||
                // tab is already loading
                tab.hasClass( "ui-tabs-loading" ) ||
                // can't switch durning an animation
                this.running ||
                // click on active header, but not collapsible
                ( clickedIsActive && !options.collapsible ) ||
                // allow canceling activation
                ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
            return;
        }

        options.active = collapsing ? false : this.tabs.index( tab );

        this.active = clickedIsActive ? $() : tab;
        if ( this.xhr ) {
            this.xhr.abort();
        }

        if ( !toHide.length && !toShow.length ) {
            $.error( "jQuery UI Tabs: Mismatching fragment identifier." );
        }

        if ( toShow.length ) {
            this.load( this.tabs.index( tab ), event );
        }
        this._toggle( event, eventData );
    },

    // handles show/hide for selecting tabs
    _toggle: function( event, eventData ) {
        var that = this,
            toShow = eventData.newPanel,
            toHide = eventData.oldPanel;

        this.running = true;

        function complete() {
            that.running = false;
            that._trigger( "activate", event, eventData );
        }

        function show() {
            eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

            if ( toShow.length && that.options.show ) {
                that._show( toShow, that.options.show, complete );
            } else {
                toShow.show();
                complete();
            }
        }

        // start out by hiding, then showing, then completing
        if ( toHide.length && this.options.hide ) {
            this._hide( toHide, this.options.hide, function() {
                eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
                show();
            });
        } else {
            eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
            toHide.hide();
            show();
        }

        toHide.attr({
            "aria-expanded": "false",
            "aria-hidden": "true"
        });
        eventData.oldTab.attr( "aria-selected", "false" );
        // If we're switching tabs, remove the old tab from the tab order.
        // If we're opening from collapsed state, remove the previous tab from the tab order.
        // If we're collapsing, then keep the collapsing tab in the tab order.
        if ( toShow.length && toHide.length ) {
            eventData.oldTab.attr( "tabIndex", -1 );
        } else if ( toShow.length ) {
            this.tabs.filter(function() {
                return $( this ).attr( "tabIndex" ) === 0;
            })
            .attr( "tabIndex", -1 );
        }

        toShow.attr({
            "aria-expanded": "true",
            "aria-hidden": "false"
        });
        eventData.newTab.attr({
            "aria-selected": "true",
            tabIndex: 0
        });
    },

    _activate: function( index ) {
        var anchor,
            active = this._findActive( index );

        // trying to activate the already active panel
        if ( active[ 0 ] === this.active[ 0 ] ) {
            return;
        }

        // trying to collapse, simulate a click on the current active header
        if ( !active.length ) {
            active = this.active;
        }

        anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
        this._eventHandler({
            target: anchor,
            currentTarget: anchor,
            preventDefault: $.noop
        });
    },

    _findActive: function( index ) {
        return index === false ? $() : this.tabs.eq( index );
    },

    _getIndex: function( index ) {
        // meta-function to give users option to provide a href string instead of a numerical index.
        if ( typeof index === "string" ) {
            index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
        }

        return index;
    },

    _destroy: function() {
        if ( this.xhr ) {
            this.xhr.abort();
        }

        this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

        this.tablist
            .removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
            .removeAttr( "role" );

        this.anchors
            .removeClass( "ui-tabs-anchor" )
            .removeAttr( "role" )
            .removeAttr( "tabIndex" )
            .removeUniqueId();

        this.tabs.add( this.panels ).each(function() {
            if ( $.data( this, "ui-tabs-destroy" ) ) {
                $( this ).remove();
            } else {
                $( this )
                    .removeClass( "ui-state-default ui-state-active ui-state-disabled " +
                        "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
                    .removeAttr( "tabIndex" )
                    .removeAttr( "aria-live" )
                    .removeAttr( "aria-busy" )
                    .removeAttr( "aria-selected" )
                    .removeAttr( "aria-labelledby" )
                    .removeAttr( "aria-hidden" )
                    .removeAttr( "aria-expanded" )
                    .removeAttr( "role" );
            }
        });

        this.tabs.each(function() {
            var li = $( this ),
                prev = li.data( "ui-tabs-aria-controls" );
            if ( prev ) {
                li
                    .attr( "aria-controls", prev )
                    .removeData( "ui-tabs-aria-controls" );
            } else {
                li.removeAttr( "aria-controls" );
            }
        });

        this.panels.show();

        if ( this.options.heightStyle !== "content" ) {
            this.panels.css( "height", "" );
        }
    },

    enable: function( index ) {
        var disabled = this.options.disabled;
        if ( disabled === false ) {
            return;
        }

        if ( index === undefined ) {
            disabled = false;
        } else {
            index = this._getIndex( index );
            if ( $.isArray( disabled ) ) {
                disabled = $.map( disabled, function( num ) {
                    return num !== index ? num : null;
                });
            } else {
                disabled = $.map( this.tabs, function( li, num ) {
                    return num !== index ? num : null;
                });
            }
        }
        this._setupDisabled( disabled );
    },

    disable: function( index ) {
        var disabled = this.options.disabled;
        if ( disabled === true ) {
            return;
        }

        if ( index === undefined ) {
            disabled = true;
        } else {
            index = this._getIndex( index );
            if ( $.inArray( index, disabled ) !== -1 ) {
                return;
            }
            if ( $.isArray( disabled ) ) {
                disabled = $.merge( [ index ], disabled ).sort();
            } else {
                disabled = [ index ];
            }
        }
        this._setupDisabled( disabled );
    },

    load: function( index, event ) {
        index = this._getIndex( index );
        var that = this,
            tab = this.tabs.eq( index ),
            anchor = tab.find( ".ui-tabs-anchor" ),
            panel = this._getPanelForTab( tab ),
            eventData = {
                tab: tab,
                panel: panel
            };

        // not remote
        if ( isLocal( anchor[ 0 ] ) ) {
            return;
        }

        this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

        // support: jQuery <1.8
        // jQuery <1.8 returns false if the request is canceled in beforeSend,
        // but as of 1.8, $.ajax() always returns a jqXHR object.
        if ( this.xhr && this.xhr.statusText !== "canceled" ) {
            tab.addClass( "ui-tabs-loading" );
            panel.attr( "aria-busy", "true" );

            this.xhr
                .success(function( response ) {
                    // support: jQuery <1.8
                    // http://bugs.jquery.com/ticket/11778
                    setTimeout(function() {
                        panel.html( response );
                        that._trigger( "load", event, eventData );
                    }, 1 );
                })
                .complete(function( jqXHR, status ) {
                    // support: jQuery <1.8
                    // http://bugs.jquery.com/ticket/11778
                    setTimeout(function() {
                        if ( status === "abort" ) {
                            that.panels.stop( false, true );
                        }

                        tab.removeClass( "ui-tabs-loading" );
                        panel.removeAttr( "aria-busy" );

                        if ( jqXHR === that.xhr ) {
                            delete that.xhr;
                        }
                    }, 1 );
                });
        }
    },

    _ajaxSettings: function( anchor, event, eventData ) {
        var that = this;
        return {
            url: anchor.attr( "href" ),
            beforeSend: function( jqXHR, settings ) {
                return that._trigger( "beforeLoad", event,
                    $.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
            }
        };
    },

    _getPanelForTab: function( tab ) {
        var id = $( tab ).attr( "aria-controls" );
        return this.element.find( this._sanitizeSelector( "#" + id ) );
    }
});

})( jQuery );

(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
    var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
    describedby.push( id );
    elem
        .data( "ui-tooltip-id", id )
        .attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
}

function removeDescribedBy( elem ) {
    var id = elem.data( "ui-tooltip-id" ),
        describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
        index = $.inArray( id, describedby );
    if ( index !== -1 ) {
        describedby.splice( index, 1 );
    }

    elem.removeData( "ui-tooltip-id" );
    describedby = $.trim( describedby.join( " " ) );
    if ( describedby ) {
        elem.attr( "aria-describedby", describedby );
    } else {
        elem.removeAttr( "aria-describedby" );
    }
}

$.widget( "ui.tooltip", {
    version: "1.10.4",
    options: {
        content: function() {
            // support: IE<9, Opera in jQuery <1.7
            // .text() can't accept undefined, so coerce to a string
            var title = $( this ).attr( "title" ) || "";
            // Escape title, since we're going from an attribute to raw HTML
            return $( "<a>" ).text( title ).html();
        },
        hide: true,
        // Disabled elements have inconsistent behavior across browsers (#8661)
        items: "[title]:not([disabled])",
        position: {
            my: "left top+15",
            at: "left bottom",
            collision: "flipfit flip"
        },
        show: true,
        tooltipClass: null,
        track: false,

        // callbacks
        close: null,
        open: null
    },

    _create: function() {
        this._on({
            mouseover: "open",
            focusin: "open"
        });

        // IDs of generated tooltips, needed for destroy
        this.tooltips = {};
        // IDs of parent tooltips where we removed the title attribute
        this.parents = {};

        if ( this.options.disabled ) {
            this._disable();
        }
    },

    _setOption: function( key, value ) {
        var that = this;

        if ( key === "disabled" ) {
            this[ value ? "_disable" : "_enable" ]();
            this.options[ key ] = value;
            // disable element style changes
            return;
        }

        this._super( key, value );

        if ( key === "content" ) {
            $.each( this.tooltips, function( id, element ) {
                that._updateContent( element );
            });
        }
    },

    _disable: function() {
        var that = this;

        // close open tooltips
        $.each( this.tooltips, function( id, element ) {
            var event = $.Event( "blur" );
            event.target = event.currentTarget = element[0];
            that.close( event, true );
        });

        // remove title attributes to prevent native tooltips
        this.element.find( this.options.items ).addBack().each(function() {
            var element = $( this );
            if ( element.is( "[title]" ) ) {
                element
                    .data( "ui-tooltip-title", element.attr( "title" ) )
                    .attr( "title", "" );
            }
        });
    },

    _enable: function() {
        // restore title attributes
        this.element.find( this.options.items ).addBack().each(function() {
            var element = $( this );
            if ( element.data( "ui-tooltip-title" ) ) {
                element.attr( "title", element.data( "ui-tooltip-title" ) );
            }
        });
    },

    open: function( event ) {
        var that = this,
            target = $( event ? event.target : this.element )
                // we need closest here due to mouseover bubbling,
                // but always pointing at the same event target
                .closest( this.options.items );

        // No element to show a tooltip for or the tooltip is already open
        if ( !target.length || target.data( "ui-tooltip-id" ) ) {
            return;
        }

        if ( target.attr( "title" ) ) {
            target.data( "ui-tooltip-title", target.attr( "title" ) );
        }

        target.data( "ui-tooltip-open", true );

        // kill parent tooltips, custom or native, for hover
        if ( event && event.type === "mouseover" ) {
            target.parents().each(function() {
                var parent = $( this ),
                    blurEvent;
                if ( parent.data( "ui-tooltip-open" ) ) {
                    blurEvent = $.Event( "blur" );
                    blurEvent.target = blurEvent.currentTarget = this;
                    that.close( blurEvent, true );
                }
                if ( parent.attr( "title" ) ) {
                    parent.uniqueId();
                    that.parents[ this.id ] = {
                        element: this,
                        title: parent.attr( "title" )
                    };
                    parent.attr( "title", "" );
                }
            });
        }

        this._updateContent( target, event );
    },

    _updateContent: function( target, event ) {
        var content,
            contentOption = this.options.content,
            that = this,
            eventType = event ? event.type : null;

        if ( typeof contentOption === "string" ) {
            return this._open( event, target, contentOption );
        }

        content = contentOption.call( target[0], function( response ) {
            // ignore async response if tooltip was closed already
            if ( !target.data( "ui-tooltip-open" ) ) {
                return;
            }
            // IE may instantly serve a cached response for ajax requests
            // delay this call to _open so the other call to _open runs first
            that._delay(function() {
                // jQuery creates a special event for focusin when it doesn't
                // exist natively. To improve performance, the native event
                // object is reused and the type is changed. Therefore, we can't
                // rely on the type being correct after the event finished
                // bubbling, so we set it back to the previous value. (#8740)
                if ( event ) {
                    event.type = eventType;
                }
                this._open( event, target, response );
            });
        });
        if ( content ) {
            this._open( event, target, content );
        }
    },

    _open: function( event, target, content ) {
        var tooltip, events, delayedShow,
            positionOption = $.extend( {}, this.options.position );

        if ( !content ) {
            return;
        }

        // Content can be updated multiple times. If the tooltip already
        // exists, then just update the content and bail.
        tooltip = this._find( target );
        if ( tooltip.length ) {
            tooltip.find( ".ui-tooltip-content" ).html( content );
            return;
        }

        // if we have a title, clear it to prevent the native tooltip
        // we have to check first to avoid defining a title if none exists
        // (we don't want to cause an element to start matching [title])
        //
        // We use removeAttr only for key events, to allow IE to export the correct
        // accessible attributes. For mouse events, set to empty string to avoid
        // native tooltip showing up (happens only when removing inside mouseover).
        if ( target.is( "[title]" ) ) {
            if ( event && event.type === "mouseover" ) {
                target.attr( "title", "" );
            } else {
                target.removeAttr( "title" );
            }
        }

        tooltip = this._tooltip( target );
        addDescribedBy( target, tooltip.attr( "id" ) );
        tooltip.find( ".ui-tooltip-content" ).html( content );

        function position( event ) {
            positionOption.of = event;
            if ( tooltip.is( ":hidden" ) ) {
                return;
            }
            tooltip.position( positionOption );
        }
        if ( this.options.track && event && /^mouse/.test( event.type ) ) {
            this._on( this.document, {
                mousemove: position
            });
            // trigger once to override element-relative positioning
            position( event );
        } else {
            tooltip.position( $.extend({
                of: target
            }, this.options.position ) );
        }

        tooltip.hide();

        this._show( tooltip, this.options.show );
        // Handle tracking tooltips that are shown with a delay (#8644). As soon
        // as the tooltip is visible, position the tooltip using the most recent
        // event.
        if ( this.options.show && this.options.show.delay ) {
            delayedShow = this.delayedShow = setInterval(function() {
                if ( tooltip.is( ":visible" ) ) {
                    position( positionOption.of );
                    clearInterval( delayedShow );
                }
            }, $.fx.interval );
        }

        this._trigger( "open", event, { tooltip: tooltip } );

        events = {
            keyup: function( event ) {
                if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
                    var fakeEvent = $.Event(event);
                    fakeEvent.currentTarget = target[0];
                    this.close( fakeEvent, true );
                }
            },
            remove: function() {
                this._removeTooltip( tooltip );
            }
        };
        if ( !event || event.type === "mouseover" ) {
            events.mouseleave = "close";
        }
        if ( !event || event.type === "focusin" ) {
            events.focusout = "close";
        }
        this._on( true, target, events );
    },

    close: function( event ) {
        var that = this,
            target = $( event ? event.currentTarget : this.element ),
            tooltip = this._find( target );

        // disabling closes the tooltip, so we need to track when we're closing
        // to avoid an infinite loop in case the tooltip becomes disabled on close
        if ( this.closing ) {
            return;
        }

        // Clear the interval for delayed tracking tooltips
        clearInterval( this.delayedShow );

        // only set title if we had one before (see comment in _open())
        if ( target.data( "ui-tooltip-title" ) ) {
            target.attr( "title", target.data( "ui-tooltip-title" ) );
        }

        removeDescribedBy( target );

        tooltip.stop( true );
        this._hide( tooltip, this.options.hide, function() {
            that._removeTooltip( $( this ) );
        });

        target.removeData( "ui-tooltip-open" );
        this._off( target, "mouseleave focusout keyup" );
        // Remove 'remove' binding only on delegated targets
        if ( target[0] !== this.element[0] ) {
            this._off( target, "remove" );
        }
        this._off( this.document, "mousemove" );

        if ( event && event.type === "mouseleave" ) {
            $.each( this.parents, function( id, parent ) {
                $( parent.element ).attr( "title", parent.title );
                delete that.parents[ id ];
            });
        }

        this.closing = true;
        this._trigger( "close", event, { tooltip: tooltip } );
        this.closing = false;
    },

    _tooltip: function( element ) {
        var id = "ui-tooltip-" + increments++,
            tooltip = $( "<div>" )
                .attr({
                    id: id,
                    role: "tooltip"
                })
                .addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
                    ( this.options.tooltipClass || "" ) );
        $( "<div>" )
            .addClass( "ui-tooltip-content" )
            .appendTo( tooltip );
        tooltip.appendTo( this.document[0].body );
        this.tooltips[ id ] = element;
        return tooltip;
    },

    _find: function( target ) {
        var id = target.data( "ui-tooltip-id" );
        return id ? $( "#" + id ) : $();
    },

    _removeTooltip: function( tooltip ) {
        tooltip.remove();
        delete this.tooltips[ tooltip.attr( "id" ) ];
    },

    _destroy: function() {
        var that = this;

        // close open tooltips
        $.each( this.tooltips, function( id, element ) {
            // Delegate to close method to handle common cleanup
            var event = $.Event( "blur" );
            event.target = event.currentTarget = element[0];
            that.close( event, true );

            // Remove immediately; destroying an open tooltip doesn't use the
            // hide animation
            $( "#" + id ).remove();

            // Restore the title
            if ( element.data( "ui-tooltip-title" ) ) {
                element.attr( "title", element.data( "ui-tooltip-title" ) );
                element.removeData( "ui-tooltip-title" );
            }
        });
    }
});

}( jQuery ) );

// License: MIT

/**
 * jQuery JSON plugin 2.4.0
 *
 * @author Brantley Harris, 2009-2011
 * @author Timo Tijhof, 2011-2012
 * @source This plugin is heavily influenced by MochiKit's serializeJSON, which is
 *         copyrighted 2005 by Bob Ippolito.
 * @source Brantley Harris wrote this plugin. It is based somewhat on the JSON.org
 *         website's http://www.json.org/json2.js, which proclaims:
 *         "NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.", a sentiment that
 *         I uphold.
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
 */
(function ($) {
    'use strict';

    var escape = /["\\\x00-\x1f\x7f-\x9f]/g,
        meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        hasOwn = Object.prototype.hasOwnProperty;

    /**
     * jQuery.toJSON
     * Converts the given argument into a JSON representation.
     *
     * @param o {Mixed} The json-serializable *thing* to be converted
     *
     * If an object has a toJSON prototype, that will be used to get the representation.
     * Non-integer/string keys are skipped in the object, as are keys that point to a
     * function.
     *
     */
    $.toJSON = typeof JSON === 'object' && JSON.stringify ? JSON.stringify : function (o) {
        if (o === null) {
            return 'null';
        }

        var pairs, k, name, val,
            type = $.type(o);

        if (type === 'undefined') {
            return undefined;
        }

        // Also covers instantiated Number and Boolean objects,
        // which are typeof 'object' but thanks to $.type, we
        // catch them here. I don't know whether it is right
        // or wrong that instantiated primitives are not
        // exported to JSON as an {"object":..}.
        // We choose this path because that's what the browsers did.
        if (type === 'number' || type === 'boolean') {
            return String(o);
        }
        if (type === 'string') {
            return $.quoteString(o);
        }
        if (typeof o.toJSON === 'function') {
            return $.toJSON(o.toJSON());
        }
        if (type === 'date') {
            var month = o.getUTCMonth() + 1,
                day = o.getUTCDate(),
                year = o.getUTCFullYear(),
                hours = o.getUTCHours(),
                minutes = o.getUTCMinutes(),
                seconds = o.getUTCSeconds(),
                milli = o.getUTCMilliseconds();

            if (month < 10) {
                month = '0' + month;
            }
            if (day < 10) {
                day = '0' + day;
            }
            if (hours < 10) {
                hours = '0' + hours;
            }
            if (minutes < 10) {
                minutes = '0' + minutes;
            }
            if (seconds < 10) {
                seconds = '0' + seconds;
            }
            if (milli < 100) {
                milli = '0' + milli;
            }
            if (milli < 10) {
                milli = '0' + milli;
            }
            return '"' + year + '-' + month + '-' + day + 'T' +
                hours + ':' + minutes + ':' + seconds +
                '.' + milli + 'Z"';
        }

        pairs = [];

        if ($.isArray(o)) {
            for (k = 0; k < o.length; k++) {
                pairs.push($.toJSON(o[k]) || 'null');
            }
            return '[' + pairs.join(',') + ']';
        }

        // Any other object (plain object, RegExp, ..)
        // Need to do typeof instead of $.type, because we also
        // want to catch non-plain objects.
        if (typeof o === 'object') {
            for (k in o) {
                // Only include own properties,
                // Filter out inherited prototypes
                if (hasOwn.call(o, k)) {
                    // Keys must be numerical or string. Skip others
                    type = typeof k;
                    if (type === 'number') {
                        name = '"' + k + '"';
                    } else if (type === 'string') {
                        name = $.quoteString(k);
                    } else {
                        continue;
                    }
                    type = typeof o[k];

                    // Invalid values like these return undefined
                    // from toJSON, however those object members
                    // shouldn't be included in the JSON string at all.
                    if (type !== 'function' && type !== 'undefined') {
                        val = $.toJSON(o[k]);
                        pairs.push(name + ':' + val);
                    }
                }
            }
            return '{' + pairs.join(',') + '}';
        }
    };

    /**
     * jQuery.evalJSON
     * Evaluates a given json string.
     *
     * @param str {String}
     */
    $.evalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function (str) {
        /*jshint evil: true */
        return eval('(' + str + ')');
    };

    /**
     * jQuery.secureEvalJSON
     * Evals JSON in a way that is *more* secure.
     *
     * @param str {String}
     */
    $.secureEvalJSON = typeof JSON === 'object' && JSON.parse ? JSON.parse : function (str) {
        var filtered =
            str
            .replace(/\\["\\\/bfnrtu]/g, '@')
            .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
            .replace(/(?:^|:|,)(?:\s*\[)+/g, '');

        if (/^[\],:{}\s]*$/.test(filtered)) {
            /*jshint evil: true */
            return eval('(' + str + ')');
        }
        throw new SyntaxError('Error parsing JSON, source is not valid.');
    };

    /**
     * jQuery.quoteString
     * Returns a string-repr of a string, escaping quotes intelligently.
     * Mostly a support function for toJSON.
     * Examples:
     * >>> jQuery.quoteString('apple')
     * "apple"
     *
     * >>> jQuery.quoteString('"Where are we going?", she asked.')
     * "\"Where are we going?\", she asked."
     */
    $.quoteString = function (str) {
        if (str.match(escape)) {
            return '"' + str.replace(escape, function (a) {
                var c = meta[a];
                if (typeof c === 'string') {
                    return c;
                }
                c = a.charCodeAt();
                return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
            }) + '"';
        }
        return '"' + str + '"';
    };

}(jQuery));

/*!
 * jQuery Form Plugin
 * version: 3.48.0-2013.12.28
 * Requires jQuery v1.5 or later
 * Copyright (c) 2013 M. Alsup
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Project repository: https://github.com/malsup/form
 * Dual licensed under the MIT and GPL licenses.
 * https://github.com/malsup/form#copyright-and-license
 */
/*global ActiveXObject */

// AMD support
(function (factory) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        // using AMD; register as anon module
        define(['jquery'], factory);
    } else {
        // no AMD; invoke directly
        factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto );
    }
}

(function($) {
"use strict";

/*
    Usage Note:
    -----------
    Do not use both ajaxSubmit and ajaxForm on the same form.  These
    functions are mutually exclusive.  Use ajaxSubmit if you want
    to bind your own submit handler to the form.  For example,

    $(document).ready(function() {
        $('#myForm').on('submit', function(e) {
            e.preventDefault(); // <-- important
            $(this).ajaxSubmit({
                target: '#output'
            });
        });
    });

    Use ajaxForm when you want the plugin to manage all the event binding
    for you.  For example,

    $(document).ready(function() {
        $('#myForm').ajaxForm({
            target: '#output'
        });
    });

    You can also use ajaxForm with delegation (requires jQuery v1.7+), so the
    form does not have to exist when you invoke ajaxForm:

    $('#myForm').ajaxForm({
        delegation: true,
        target: '#output'
    });

    When using ajaxForm, the ajaxSubmit function will be invoked for you
    at the appropriate time.
*/

/**
 * Feature detection
 */
var feature = {};
feature.fileapi = $("<input type='file'/>").get(0).files !== undefined;
feature.formdata = window.FormData !== undefined;

var hasProp = !!$.fn.prop;

// attr2 uses prop when it can but checks the return type for
// an expected string.  this accounts for the case where a form 
// contains inputs with names like "action" or "method"; in those
// cases "prop" returns the element
$.fn.attr2 = function() {
    if ( ! hasProp ) {
        return this.attr.apply(this, arguments);
    }
    var val = this.prop.apply(this, arguments);
    if ( ( val && val.jquery ) || typeof val === 'string' ) {
        return val;
    }
    return this.attr.apply(this, arguments);
};

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
    /*jshint scripturl:true */

    // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
    if (!this.length) {
        log('ajaxSubmit: skipping submit process - no element selected');
        return this;
    }

    var method, action, url, $form = this;

    if (typeof options == 'function') {
        options = { success: options };
    }
    else if ( options === undefined ) {
        options = {};
    }

    method = options.type || this.attr2('method');
    action = options.url  || this.attr2('action');

    url = (typeof action === 'string') ? $.trim(action) : '';
    url = url || window.location.href || '';
    if (url) {
        // clean url (don't include hash vaue)
        url = (url.match(/^([^#]+)/)||[])[1];
    }

    options = $.extend(true, {
        url:  url,
        success: $.ajaxSettings.success,
        type: method || $.ajaxSettings.type,
        iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
    }, options);

    // hook for manipulating the form data before it is extracted;
    // convenient for use with rich editors like tinyMCE or FCKEditor
    var veto = {};
    this.trigger('form-pre-serialize', [this, options, veto]);
    if (veto.veto) {
        log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
        return this;
    }

    // provide opportunity to alter form data before it is serialized
    if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
        log('ajaxSubmit: submit aborted via beforeSerialize callback');
        return this;
    }

    var traditional = options.traditional;
    if ( traditional === undefined ) {
        traditional = $.ajaxSettings.traditional;
    }

    var elements = [];
    var qx, a = this.formToArray(options.semantic, elements);
    if (options.data) {
        options.extraData = options.data;
        qx = $.param(options.data, traditional);
    }

    // give pre-submit callback an opportunity to abort the submit
    if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
        log('ajaxSubmit: submit aborted via beforeSubmit callback');
        return this;
    }

    // fire vetoable 'validate' event
    this.trigger('form-submit-validate', [a, this, options, veto]);
    if (veto.veto) {
        log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
        return this;
    }

    var q = $.param(a, traditional);
    if (qx) {
        q = ( q ? (q + '&' + qx) : qx );
    }
    if (options.type.toUpperCase() == 'GET') {
        options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
        options.data = null;  // data is null for 'get'
    }
    else {
        options.data = q; // data is the query string for 'post'
    }

    var callbacks = [];
    if (options.resetForm) {
        callbacks.push(function() { $form.resetForm(); });
    }
    if (options.clearForm) {
        callbacks.push(function() { $form.clearForm(options.includeHidden); });
    }

    // perform a load on the target only if dataType is not provided
    if (!options.dataType && options.target) {
        var oldSuccess = options.success || function(){};
        callbacks.push(function(data) {
            var fn = options.replaceTarget ? 'replaceWith' : 'html';
            $(options.target)[fn](data).each(oldSuccess, arguments);
        });
    }
    else if (options.success) {
        callbacks.push(options.success);
    }

    options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
        var context = options.context || this ;    // jQuery 1.4+ supports scope context
        for (var i=0, max=callbacks.length; i < max; i++) {
            callbacks[i].apply(context, [data, status, xhr || $form, $form]);
        }
    };

    if (options.error) {
        var oldError = options.error;
        options.error = function(xhr, status, error) {
            var context = options.context || this;
            oldError.apply(context, [xhr, status, error, $form]);
        };
    }

     if (options.complete) {
        var oldComplete = options.complete;
        options.complete = function(xhr, status) {
            var context = options.context || this;
            oldComplete.apply(context, [xhr, status, $form]);
        };
    }

    // are there files to upload?

    // [value] (issue #113), also see comment:
    // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219
    var fileInputs = $('input[type=file]:enabled', this).filter(function() { return $(this).val() !== ''; });

    var hasFileInputs = fileInputs.length > 0;
    var mp = 'multipart/form-data';
    var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

    var fileAPI = feature.fileapi && feature.formdata;
    log("fileAPI :" + fileAPI);
    var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;

    var jqxhr;

    // options.iframe allows user to force iframe mode
    // 06-NOV-09: now defaulting to iframe mode if file input is detected
    if (options.iframe !== false && (options.iframe || shouldUseFrame)) {
        // hack to fix Safari hang (thanks to Tim Molendijk for this)
        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });
        }
        else {
            jqxhr = fileUploadIframe(a);
        }
    }
    else if ((hasFileInputs || multipart) && fileAPI) {
        jqxhr = fileUploadXhr(a);
    }
    else {
        jqxhr = $.ajax(options);
    }

    $form.removeData('jqxhr').data('jqxhr', jqxhr);

    // clear element array
    for (var k=0; k < elements.length; k++) {
        elements[k] = null;
    }

    // fire 'notify' event
    this.trigger('form-submit-notify', [this, options]);
    return this;

    // utility fn for deep serialization
    function deepSerialize(extraData){
        var serialized = $.param(extraData, options.traditional).split('&');
        var len = serialized.length;
        var result = [];
        var i, part;
        for (i=0; i < len; i++) {
            // #252; undo param space replacement
            serialized[i] = serialized[i].replace(/\+/g,' ');
            part = serialized[i].split('=');
            // #278; use array instead of object storage, favoring array serializations
            result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);
        }
        return result;
    }

     // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)
    function fileUploadXhr(a) {
        var formdata = new FormData();

        for (var i=0; i < a.length; i++) {
            formdata.append(a[i].name, a[i].value);
        }

        if (options.extraData) {
            var serializedData = deepSerialize(options.extraData);
            for (i=0; i < serializedData.length; i++) {
                if (serializedData[i]) {
                    formdata.append(serializedData[i][0], serializedData[i][1]);
                }
            }
        }

        options.data = null;

        var s = $.extend(true, {}, $.ajaxSettings, options, {
            contentType: false,
            processData: false,
            cache: false,
            type: method || 'POST'
        });

        if (options.uploadProgress) {
            // workaround because jqXHR does not expose upload property
            s.xhr = function() {
                var xhr = $.ajaxSettings.xhr();
                if (xhr.upload) {
                    xhr.upload.addEventListener('progress', function(event) {
                        var percent = 0;
                        var position = event.loaded || event.position; /*event.position is deprecated*/
                        var total = event.total;
                        if (event.lengthComputable) {
                            percent = Math.ceil(position / total * 100);
                        }
                        options.uploadProgress(event, position, total, percent);
                    }, false);
                }
                return xhr;
            };
        }

        s.data = null;
        var beforeSend = s.beforeSend;
        s.beforeSend = function(xhr, o) {
            //Send FormData() provided by user
            if (options.formData) {
                o.data = options.formData;
            }
            else {
                o.data = formdata;
            }
            if(beforeSend) {
                beforeSend.call(this, xhr, o);
            }
        };
        return $.ajax(s);
    }

    // private function for handling file uploads (hat tip to YAHOO!)
    function fileUploadIframe(a) {
        var form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;
        var deferred = $.Deferred();

        // #341
        deferred.abort = function(status) {
            xhr.abort(status);
        };

        if (a) {
            // ensure that every serialized input is still enabled
            for (i=0; i < elements.length; i++) {
                el = $(elements[i]);
                if ( hasProp ) {
                    el.prop('disabled', false);
                }
                else {
                    el.removeAttr('disabled');
                }
            }
        }

        s = $.extend(true, {}, $.ajaxSettings, options);
        s.context = s.context || s;
        id = 'jqFormIO' + (new Date().getTime());
        if (s.iframeTarget) {
            $io = $(s.iframeTarget);
            n = $io.attr2('name');
            if (!n) {
                $io.attr2('name', id);
            }
            else {
                id = n;
            }
        }
        else {
            $io = $('<iframe name="' + id + '" src="'+ s.iframeSrc +'" />');
            $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });
        }
        io = $io[0];


        xhr = { // mock object
            aborted: 0,
            responseText: null,
            responseXML: null,
            status: 0,
            statusText: 'n/a',
            getAllResponseHeaders: function() {},
            getResponseHeader: function() {},
            setRequestHeader: function() {},
            abort: function(status) {
                var e = (status === 'timeout' ? 'timeout' : 'aborted');
                log('aborting upload... ' + e);
                this.aborted = 1;

                try { // #214, #257
                    if (io.contentWindow.document.execCommand) {
                        io.contentWindow.document.execCommand('Stop');
                    }
                }
                catch(ignore) {}

                $io.attr('src', s.iframeSrc); // abort op in progress
                xhr.error = e;
                if (s.error) {
                    s.error.call(s.context, xhr, e, status);
                }
                if (g) {
                    $.event.trigger("ajaxError", [xhr, s, e]);
                }
                if (s.complete) {
                    s.complete.call(s.context, xhr, e);
                }
            }
        };

        g = s.global;
        // trigger ajax global events so that activity/block indicators work like normal
        if (g && 0 === $.active++) {
            $.event.trigger("ajaxStart");
        }
        if (g) {
            $.event.trigger("ajaxSend", [xhr, s]);
        }

        if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
            if (s.global) {
                $.active--;
            }
            deferred.reject();
            return deferred;
        }
        if (xhr.aborted) {
            deferred.reject();
            return deferred;
        }

        // add submitting element to data if we know it
        sub = form.clk;
        if (sub) {
            n = sub.name;
            if (n && !sub.disabled) {
                s.extraData = s.extraData || {};
                s.extraData[n] = sub.value;
                if (sub.type == "image") {
                    s.extraData[n+'.x'] = form.clk_x;
                    s.extraData[n+'.y'] = form.clk_y;
                }
            }
        }

        var CLIENT_TIMEOUT_ABORT = 1;
        var SERVER_ABORT = 2;
                
        function getDoc(frame) {
            /* it looks like contentWindow or contentDocument do not
             * carry the protocol property in ie8, when running under ssl
             * frame.document is the only valid response document, since
             * the protocol is know but not on the other two objects. strange?
             * "Same origin policy" http://en.wikipedia.org/wiki/Same_origin_policy
             */
            
            var doc = null;
            
            // IE8 cascading access check
            try {
                if (frame.contentWindow) {
                    doc = frame.contentWindow.document;
                }
            } catch(err) {
                // IE8 access denied under ssl & missing protocol
                log('cannot get iframe.contentWindow document: ' + err);
            }

            if (doc) { // successful getting content
                return doc;
            }

            try { // simply checking may throw in ie8 under ssl or mismatched protocol
                doc = frame.contentDocument ? frame.contentDocument : frame.document;
            } catch(err) {
                // last attempt
                log('cannot get iframe.contentDocument: ' + err);
                doc = frame.document;
            }
            return doc;
        }

        // Rails CSRF hack (thanks to Yvan Barthelemy)
        var csrf_token = $('meta[name=csrf-token]').attr('content');
        var csrf_param = $('meta[name=csrf-param]').attr('content');
        if (csrf_param && csrf_token) {
            s.extraData = s.extraData || {};
            s.extraData[csrf_param] = csrf_token;
        }

        // take a breath so that pending repaints get some cpu time before the upload starts
        function doSubmit() {
            // make sure form attrs are set
            var t = $form.attr2('target'), 
                a = $form.attr2('action'), 
                mp = 'multipart/form-data',
                et = $form.attr('enctype') || $form.attr('encoding') || mp;

            // update form attrs in IE friendly way
            form.setAttribute('target',id);
            if (!method || /post/i.test(method) ) {
                form.setAttribute('method', 'POST');
            }
            if (a != s.url) {
                form.setAttribute('action', s.url);
            }

            // ie borks in some cases when setting encoding
            if (! s.skipEncodingOverride && (!method || /post/i.test(method))) {
                $form.attr({
                    encoding: 'multipart/form-data',
                    enctype:  'multipart/form-data'
                });
            }

            // support timout
            if (s.timeout) {
                timeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);
            }

            // look for server aborts
            function checkState() {
                try {
                    var state = getDoc(io).readyState;
                    log('state = ' + state);
                    if (state && state.toLowerCase() == 'uninitialized') {
                        setTimeout(checkState,50);
                    }
                }
                catch(e) {
                    log('Server abort: ' , e, ' (', e.name, ')');
                    cb(SERVER_ABORT);
                    if (timeoutHandle) {
                        clearTimeout(timeoutHandle);
                    }
                    timeoutHandle = undefined;
                }
            }

            // add "extra" data to form if provided in options
            var extraInputs = [];
            try {
                if (s.extraData) {
                    for (var n in s.extraData) {
                        if (s.extraData.hasOwnProperty(n)) {
                           // if using the $.param format that allows for multiple values with the same name
                           if($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {
                               extraInputs.push(
                               $('<input type="hidden" name="'+s.extraData[n].name+'">').val(s.extraData[n].value)
                                   .appendTo(form)[0]);
                           } else {
                               extraInputs.push(
                               $('<input type="hidden" name="'+n+'">').val(s.extraData[n])
                                   .appendTo(form)[0]);
                           }
                        }
                    }
                }

                if (!s.iframeTarget) {
                    // add iframe to doc and submit the form
                    $io.appendTo('body');
                }
                if (io.attachEvent) {
                    io.attachEvent('onload', cb);
                }
                else {
                    io.addEventListener('load', cb, false);
                }
                setTimeout(checkState,15);

                try {
                    form.submit();
                } catch(err) {
                    // just in case form has element with name/id of 'submit'
                    var submitFn = document.createElement('form').submit;
                    submitFn.apply(form);
                }
            }
            finally {
                // reset attrs and remove "extra" input elements
                form.setAttribute('action',a);
                form.setAttribute('enctype', et); // #380
                if(t) {
                    form.setAttribute('target', t);
                } else {
                    $form.removeAttr('target');
                }
                $(extraInputs).remove();
            }
        }

        if (s.forceSync) {
            doSubmit();
        }
        else {
            setTimeout(doSubmit, 10); // this lets dom updates render
        }

        var data, doc, domCheckCount = 50, callbackProcessed;

        function cb(e) {
            if (xhr.aborted || callbackProcessed) {
                return;
            }
            
            doc = getDoc(io);
            if(!doc) {
                log('cannot access response document');
                e = SERVER_ABORT;
            }
            if (e === CLIENT_TIMEOUT_ABORT && xhr) {
                xhr.abort('timeout');
                deferred.reject(xhr, 'timeout');
                return;
            }
            else if (e == SERVER_ABORT && xhr) {
                xhr.abort('server abort');
                deferred.reject(xhr, 'error', 'server abort');
                return;
            }

            if (!doc || doc.location.href == s.iframeSrc) {
                // response not received yet
                if (!timedOut) {
                    return;
                }
            }
            if (io.detachEvent) {
                io.detachEvent('onload', cb);
            }
            else {
                io.removeEventListener('load', cb, false);
            }

            var status = 'success', errMsg;
            try {
                if (timedOut) {
                    throw 'timeout';
                }

                var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
                log('isXml='+isXml);
                if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {
                    if (--domCheckCount) {
                        // in some browsers (Opera) the iframe DOM is not always traversable when
                        // the onload callback fires, so we loop a bit to accommodate
                        log('requeing onLoad callback, DOM not available');
                        setTimeout(cb, 250);
                        return;
                    }
                    // let this fall through because server response could be an empty document
                    //log('Could not access iframe DOM after mutiple tries.');
                    //throw 'DOMException: not available';
                }

                //log('response detected');
                var docRoot = doc.body ? doc.body : doc.documentElement;
                xhr.responseText = docRoot ? docRoot.innerHTML : null;
                xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
                if (isXml) {
                    s.dataType = 'xml';
                }
                xhr.getResponseHeader = function(header){
                    var headers = {'content-type': s.dataType};
                    return headers[header.toLowerCase()];
                };
                // support for XHR 'status' & 'statusText' emulation :
                if (docRoot) {
                    xhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;
                    xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;
                }

                var dt = (s.dataType || '').toLowerCase();
                var scr = /(json|script|text)/.test(dt);
                if (scr || s.textarea) {
                    // see if user embedded response in textarea
                    var ta = doc.getElementsByTagName('textarea')[0];
                    if (ta) {
                        xhr.responseText = ta.value;
                        // support for XHR 'status' & 'statusText' emulation :
                        xhr.status = Number( ta.getAttribute('status') ) || xhr.status;
                        xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;
                    }
                    else if (scr) {
                        // account for browsers injecting pre around json response
                        var pre = doc.getElementsByTagName('pre')[0];
                        var b = doc.getElementsByTagName('body')[0];
                        if (pre) {
                            xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;
                        }
                        else if (b) {
                            xhr.responseText = b.textContent ? b.textContent : b.innerText;
                        }
                    }
                }
                else if (dt == 'xml' && !xhr.responseXML && xhr.responseText) {
                    xhr.responseXML = toXml(xhr.responseText);
                }

                try {
                    data = httpData(xhr, dt, s);
                }
                catch (err) {
                    status = 'parsererror';
                    xhr.error = errMsg = (err || status);
                }
            }
            catch (err) {
                log('error caught: ',err);
                status = 'error';
                xhr.error = errMsg = (err || status);
            }

            if (xhr.aborted) {
                log('upload aborted');
                status = null;
            }

            if (xhr.status) { // we've set xhr.status
                status = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';
            }

            // ordering of these callbacks/triggers is odd, but that's how $.ajax does it
            if (status === 'success') {
                if (s.success) {
                    s.success.call(s.context, data, 'success', xhr);
                }
                deferred.resolve(xhr.responseText, 'success', xhr);
                if (g) {
                    $.event.trigger("ajaxSuccess", [xhr, s]);
                }
            }
            else if (status) {
                if (errMsg === undefined) {
                    errMsg = xhr.statusText;
                }
                if (s.error) {
                    s.error.call(s.context, xhr, status, errMsg);
                }
                deferred.reject(xhr, 'error', errMsg);
                if (g) {
                    $.event.trigger("ajaxError", [xhr, s, errMsg]);
                }
            }

            if (g) {
                $.event.trigger("ajaxComplete", [xhr, s]);
            }

            if (g && ! --$.active) {
                $.event.trigger("ajaxStop");
            }

            if (s.complete) {
                s.complete.call(s.context, xhr, status);
            }

            callbackProcessed = true;
            if (s.timeout) {
                clearTimeout(timeoutHandle);
            }

            // clean up
            setTimeout(function() {
                if (!s.iframeTarget) {
                    $io.remove();
                }
                else { //adding else to clean up existing iframe response.
                    $io.attr('src', s.iframeSrc);
                }
                xhr.responseXML = null;
            }, 100);
        }

        var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
            if (window.ActiveXObject) {
                doc = new ActiveXObject('Microsoft.XMLDOM');
                doc.async = 'false';
                doc.loadXML(s);
            }
            else {
                doc = (new DOMParser()).parseFromString(s, 'text/xml');
            }
            return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
        };
        var parseJSON = $.parseJSON || function(s) {
            /*jslint evil:true */
            return window['eval']('(' + s + ')');
        };

        var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4

            var ct = xhr.getResponseHeader('content-type') || '',
                xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
                data = xml ? xhr.responseXML : xhr.responseText;

            if (xml && data.documentElement.nodeName === 'parsererror') {
                if ($.error) {
                    $.error('parsererror');
                }
            }
            if (s && s.dataFilter) {
                data = s.dataFilter(data, type);
            }
            if (typeof data === 'string') {
                if (type === 'json' || !type && ct.indexOf('json') >= 0) {
                    data = parseJSON(data);
                } else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
                    $.globalEval(data);
                }
            }
            return data;
        };

        return deferred;
    }
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *    is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *    used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
    options = options || {};
    options.delegation = options.delegation && $.isFunction($.fn.on);

    // in jQuery 1.3+ we can fix mistakes with the ready state
    if (!options.delegation && this.length === 0) {
        var o = { s: this.selector, c: this.context };
        if (!$.isReady && o.s) {
            log('DOM not ready, queuing ajaxForm');
            $(function() {
                $(o.s,o.c).ajaxForm(options);
            });
            return this;
        }
        // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
        log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
        return this;
    }

    if ( options.delegation ) {
        $(document)
            .off('submit.form-plugin', this.selector, doAjaxSubmit)
            .off('click.form-plugin', this.selector, captureSubmittingElement)
            .on('submit.form-plugin', this.selector, options, doAjaxSubmit)
            .on('click.form-plugin', this.selector, options, captureSubmittingElement);
        return this;
    }

    return this.ajaxFormUnbind()
        .bind('submit.form-plugin', options, doAjaxSubmit)
        .bind('click.form-plugin', options, captureSubmittingElement);
};

// private event handlers
function doAjaxSubmit(e) {
    /*jshint validthis:true */
    var options = e.data;
    if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
        e.preventDefault();
        $(e.target).ajaxSubmit(options); // #365
    }
}

function captureSubmittingElement(e) {
    /*jshint validthis:true */
    var target = e.target;
    var $el = $(target);
    if (!($el.is("[type=submit],[type=image]"))) {
        // is this a child element of the submit el?  (ex: a span within a button)
        var t = $el.closest('[type=submit]');
        if (t.length === 0) {
            return;
        }
        target = t[0];
    }
    var form = this;
    form.clk = target;
    if (target.type == 'image') {
        if (e.offsetX !== undefined) {
            form.clk_x = e.offsetX;
            form.clk_y = e.offsetY;
        } else if (typeof $.fn.offset == 'function') {
            var offset = $el.offset();
            form.clk_x = e.pageX - offset.left;
            form.clk_y = e.pageY - offset.top;
        } else {
            form.clk_x = e.pageX - target.offsetLeft;
            form.clk_y = e.pageY - target.offsetTop;
        }
    }
    // clear form vars
    setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
}


// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
    return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic, elements) {
    var a = [];
    if (this.length === 0) {
        return a;
    }

    var form = this[0];
    var formId = this.attr('id');
    var els = semantic ? form.getElementsByTagName('*') : form.elements;
    var els2;

    if ( els ) {
        els = $(els).get();  // convert to standard array
    }

    // #386; account for inputs outside the form which use the 'form' attribute
    if ( formId ) {
        els2 = $(':input[form=' + formId + ']').get();
        if ( els2.length ) {
            els = (els || []).concat(els2);
        }
    }

    if (!els || !els.length) {
        return a;
    }

    var i,j,n,v,el,max,jmax;
    for(i=0, max=els.length; i < max; i++) {
        el = els[i];
        n = el.name;
        if (!n || el.disabled) {
            continue;
        }

        if (semantic && form.clk && el.type == "image") {
            // handle image inputs on the fly when semantic == true
            if(form.clk == el) {
                a.push({name: n, value: $(el).val(), type: el.type });
                a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
            }
            continue;
        }

        v = $.fieldValue(el, true);
        if (v && v.constructor == Array) {
            if (elements) {
                elements.push(el);
            }
            for(j=0, jmax=v.length; j < jmax; j++) {
                a.push({name: n, value: v[j]});
            }
        }
        else if (feature.fileapi && el.type == 'file') {
            if (elements) {
                elements.push(el);
            }
            var files = el.files;
            if (files.length) {
                for (j=0; j < files.length; j++) {
                    a.push({name: n, value: files[j], type: el.type});
                }
            }
            else {
                // #180
                a.push({ name: n, value: '', type: el.type });
            }
        }
        else if (v !== null && typeof v != 'undefined') {
            if (elements) {
                elements.push(el);
            }
            a.push({name: n, value: v, type: el.type, required: el.required});
        }
    }

    if (!semantic && form.clk) {
        // input type=='image' are not found in elements array! handle it here
        var $input = $(form.clk), input = $input[0];
        n = input.name;
        if (n && !input.disabled && input.type == 'image') {
            a.push({name: n, value: $input.val()});
            a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
        }
    }
    return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
    //hand off to jQuery.param for proper encoding
    return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
    var a = [];
    this.each(function() {
        var n = this.name;
        if (!n) {
            return;
        }
        var v = $.fieldValue(this, successful);
        if (v && v.constructor == Array) {
            for (var i=0,max=v.length; i < max; i++) {
                a.push({name: n, value: v[i]});
            }
        }
        else if (v !== null && typeof v != 'undefined') {
            a.push({name: this.name, value: v});
        }
    });
    //hand off to jQuery.param for proper encoding
    return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *      <input name="A" type="text" />
 *      <input name="A" type="text" />
 *      <input name="B" type="checkbox" value="B1" />
 *      <input name="B" type="checkbox" value="B2"/>
 *      <input name="C" type="radio" value="C1" />
 *      <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $('input[type=text]').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $('input[type=checkbox]').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $('input[type=radio]').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *    array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
    for (var val=[], i=0, max=this.length; i < max; i++) {
        var el = this[i];
        var v = $.fieldValue(el, successful);
        if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
            continue;
        }
        if (v.constructor == Array) {
            $.merge(val, v);
        }
        else {
            val.push(v);
        }
    }
    return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
    var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
    if (successful === undefined) {
        successful = true;
    }

    if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
        (t == 'checkbox' || t == 'radio') && !el.checked ||
        (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
        tag == 'select' && el.selectedIndex == -1)) {
            return null;
    }

    if (tag == 'select') {
        var index = el.selectedIndex;
        if (index < 0) {
            return null;
        }
        var a = [], ops = el.options;
        var one = (t == 'select-one');
        var max = (one ? index+1 : ops.length);
        for(var i=(one ? index : 0); i < max; i++) {
            var op = ops[i];
            if (op.selected) {
                var v = op.value;
                if (!v) { // extra pain for IE...
                    v = (op.attributes && op.attributes.value && !(op.attributes.value.specified)) ? op.text : op.value;
                }
                if (one) {
                    return v;
                }
                a.push(v);
            }
        }
        return a;
    }
    return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function(includeHidden) {
    return this.each(function() {
        $('input,select,textarea', this).clearFields(includeHidden);
    });
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {
    var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list
    return this.each(function() {
        var t = this.type, tag = this.tagName.toLowerCase();
        if (re.test(t) || tag == 'textarea') {
            this.value = '';
        }
        else if (t == 'checkbox' || t == 'radio') {
            this.checked = false;
        }
        else if (tag == 'select') {
            this.selectedIndex = -1;
        }
		else if (t == "file") {
			if (/MSIE/.test(navigator.userAgent)) {
				$(this).replaceWith($(this).clone(true));
			} else {
				$(this).val('');
			}
		}
        else if (includeHidden) {
            // includeHidden can be the value true, or it can be a selector string
            // indicating a special test; for example:
            //  $('#myForm').clearForm('.special:hidden')
            // the above would clean hidden inputs that have the class of 'special'
            if ( (includeHidden === true && /hidden/.test(t)) ||
                 (typeof includeHidden == 'string' && $(this).is(includeHidden)) ) {
                this.value = '';
            }
        }
    });
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
    return this.each(function() {
        // guard against an input with the name of 'reset'
        // note that IE reports the reset function as an 'object'
        if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
            this.reset();
        }
    });
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
    if (b === undefined) {
        b = true;
    }
    return this.each(function() {
        this.disabled = !b;
    });
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
    if (select === undefined) {
        select = true;
    }
    return this.each(function() {
        var t = this.type;
        if (t == 'checkbox' || t == 'radio') {
            this.checked = select;
        }
        else if (this.tagName.toLowerCase() == 'option') {
            var $sel = $(this).parent('select');
            if (select && $sel[0] && $sel[0].type == 'select-one') {
                // deselect all other options
                $sel.find('option').selected(false);
            }
            this.selected = select;
        }
    });
};

// expose debug var
$.fn.ajaxSubmit.debug = false;

// helper fn for console logging
function log() {
    if (!$.fn.ajaxSubmit.debug) {
        return;
    }
    var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
    if (window.console && window.console.log) {
        window.console.log(msg);
    }
    else if (window.opera && window.opera.postError) {
        window.opera.postError(msg);
    }
}

}));


/**
 * jQuery.timers - Timer abstractions for jQuery
 * Written by Blair Mitchelmore (blair DOT mitchelmore AT gmail DOT com)
 * Licensed under the WTFPL (http://sam.zoy.org/wtfpl/).
 * Date: 2009/10/16
 *
 * @author Blair Mitchelmore
 * @version 1.2
 *
 **/

jQuery.fn.extend({
    everyTime: function(interval, label, fn, times) {
        return this.each(function() {
            jQuery.timer.add(this, interval, label, fn, times);
        });
    },
    oneTime: function(interval, label, fn) {
        return this.each(function() {
            jQuery.timer.add(this, interval, label, fn, 1);
        });
    },
    stopTime: function(label, fn) {
        return this.each(function() {
            jQuery.timer.remove(this, label, fn);
        });
    }
});

jQuery.extend({
    timer: {
        global: [],
        guid: 1,
        dataKey: "jQuery.timer",
        regex: /^([0-9]+(?:\.[0-9]*)?)\s*(.*s)?$/,
        powers: {
            // Yeah this is major overkill...
            'ms': 1,
            'cs': 10,
            'ds': 100,
            's': 1000,
            'das': 10000,
            'hs': 100000,
            'ks': 1000000
        },
        timeParse: function(value) {
            if (value == undefined || value == null)
                return null;
            var result = this.regex.exec(jQuery.trim(value.toString()));
            if (result[2]) {
                var num = parseFloat(result[1]);
                var mult = this.powers[result[2]] || 1;
                return num * mult;
            } else {
                return value;
            }
        },
        add: function(element, interval, label, fn, times) {
            var counter = 0;

            if (jQuery.isFunction(label)) {
                if (!times)
                    times = fn;
                fn = label;
                label = interval;
            }

            interval = jQuery.timer.timeParse(interval);

            if (typeof interval != 'number' || isNaN(interval) || interval < 0)
                return;

            if (typeof times != 'number' || isNaN(times) || times < 0)
                times = 0;

            times = times || 0;

            var timers = jQuery.data(element, this.dataKey) || jQuery.data(element, this.dataKey, {});

            if (!timers[label])
                timers[label] = {};

            fn.timerID = fn.timerID || this.guid++;

            var handler = function() {
                if ((++counter > times && times !== 0) || fn.call(element, counter) === false)
                    jQuery.timer.remove(element, label, fn);
            };

            handler.timerID = fn.timerID;

            if (!timers[label][fn.timerID])
                timers[label][fn.timerID] = window.setInterval(handler,interval);

            this.global.push( element );

        },
        remove: function(element, label, fn) {
            var timers = jQuery.data(element, this.dataKey), ret;

            if ( timers ) {

                if (!label) {
                    for ( label in timers )
                        this.remove(element, label, fn);
                } else if ( timers[label] ) {
                    if ( fn ) {
                        if ( fn.timerID ) {
                            window.clearInterval(timers[label][fn.timerID]);
                            delete timers[label][fn.timerID];
                        }
                    } else {
                        for ( var fn in timers[label] ) {
                            window.clearInterval(timers[label][fn]);
                            delete timers[label][fn];
                        }
                    }

                    for ( ret in timers[label] ) break;
                    if ( !ret ) {
                        ret = null;
                        delete timers[label];
                    }
                }

                for ( ret in timers ) break;
                if ( !ret )
                    jQuery.removeData(element, this.dataKey);
            }
        }
    }
});

jQuery(window).bind("unload", function() {
    jQuery.each(jQuery.timer.global, function(index, item) {
        jQuery.timer.remove(item);
    });
});

/*! http://mths.be/placeholder v2.0.7 by @mathias */
;(function(window, document, $) {

    var isInputSupported = 'placeholder' in document.createElement('input'),
        isTextareaSupported = 'placeholder' in document.createElement('textarea'),
        prototype = $.fn,
        valHooks = $.valHooks,
        hooks,
        placeholder;

    if (isInputSupported && isTextareaSupported) {

        placeholder = prototype.placeholder = function() {
            return this;
        };

        placeholder.input = placeholder.textarea = true;

    } else {

        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this
                .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
                .not('.placeholder')
                .bind({
                    'focus.placeholder': clearPlaceholder,
                    'blur.placeholder': setPlaceholder
                })
                .data('placeholder-enabled', true)
                .trigger('blur.placeholder');
            return $this;
        };

        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;

        hooks = {
            'get': function(element) {
                var $element = $(element);
                return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
            },
            'set': function(element, value) {
                var $element = $(element);
                if (!$element.data('placeholder-enabled')) {
                    return element.value = value;
                }
                if (value == '') {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != document.activeElement) {
                        // We can't use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass('placeholder')) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };

        isInputSupported || (valHooks.input = hooks);
        isTextareaSupported || (valHooks.textarea = hooks);

        $(function() {
            // Look for forms
            $(document).delegate('form', 'submit.placeholder', function() {
                // Clear the placeholder values so they don't get submitted
                var $inputs = $('.placeholder', this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });

        // Clear placeholder values upon page reload
        $(window).bind('beforeunload.placeholder', function() {
            $('.placeholder').each(function() {
                this.value = '';
            });
        });

    }

    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {},
            rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }

    function clearPlaceholder(event, value) {
        var input = this,
            $input = $(input);
        if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
            if ($input.data('placeholder-password')) {
                $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = '';
                $input.removeClass('placeholder');
                input == document.activeElement && input.select();
            }
        }
    }

    function setPlaceholder() {
        var $replacement,
            input = this,
            $input = $(input),
            $origInput = $input,
            id = this.id;
        if (input.value == '') {
            if (input.type == 'password') {
                if (!$input.data('placeholder-textinput')) {
                    try {
                        $replacement = $input.clone().attr({ 'type': 'text' });
                    } catch(e) {
                        $replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
                    }
                    $replacement
                        .removeAttr('name')
                        .data({
                            'placeholder-password': true,
                            'placeholder-id': id
                        })
                        .bind('focus.placeholder', clearPlaceholder);
                    $input
                        .data({
                            'placeholder-textinput': $replacement,
                            'placeholder-id': id
                        })
                        .before($replacement);
                }
                $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
                // Note: `$input[0] != input` now!
            }
            $input.addClass('placeholder');
            $input[0].value = $input.attr('placeholder');
        } else {
            $input.removeClass('placeholder');
        }
    }

}(this, document, jQuery));
$.fn.selectRange = function(start, end) {
    return this.each(function() {
        if (this.setSelectionRange) {
            this.focus();
            this.setSelectionRange(start, end);
        } else if (this.createTextRange) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveEnd('character', end);
            range.moveStart('character', start);
            range.select();
        }
    });
};

// License: PD

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
        
            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);
                
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }
                
                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);
            
            return output;
        },
        
        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;
            
            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            
            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));
                
                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;
                
                output = output + String.fromCharCode(chr1);
                
                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);
            
            return output;
        }
    };

    return obj;
})();
/*

Jappix - An open social platform
This is the JSJaC library for Jappix (from trunk)

-------------------------------------------------

Licenses: Mozilla Public License version 1.1, GNU GPL, AGPL
Authors: Stefan Strigler, Val√©rian Saliou, Zash, Maranda

*/

/**
 * @fileoverview Magic dependency loading. Taken from script.aculo.us
 * and modified to break it.
 * @author Stefan Strigler steve@zeank.in-berlin.de 
 * @version $Revision$
 */

var JSJaC = {
  Version: '$Rev$',
  bind: function(fn, obj, optArg) {
    return function(arg) {
      return fn.apply(obj, [arg, optArg]);
    };
  }
};

if (typeof JSJaCConnection == 'undefined')
  JSJaC.load();



/* Copyright 2006 Erik Arvidsson
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 */

/**
 * @fileoverview Wrapper to make working with XmlHttpRequest and the
 * DOM more convenient (cross browser compliance).
 * this code is taken from
 * http://webfx.eae.net/dhtml/xmlextras/xmlextras.html
 * @author Stefan Strigler steve@zeank.in-berlin.de
 * @version $Revision$
 */

/**
 * XmlHttp factory
 * @private
 */
function XmlHttp() {}

/**
 * creates a cross browser compliant XmlHttpRequest object
 */
XmlHttp.create = function () {
  try {
    // Are we cross-domain?
    if(!BOSH_SAME_ORIGIN) {
      // Able to use CORS?
      if (window.XMLHttpRequest) {
        var req = new XMLHttpRequest();
        
        if (req.withCredentials !== undefined)
          return req;
      }
      
      // Fallback on JSONP
      return new jXHR();
    }
    // Might be local-domain?
    if (window.XMLHttpRequest) {
      var req = new XMLHttpRequest();
      
      // some versions of Moz do not support the readyState property
      // and the onreadystate event so we patch it!
      if (req.readyState == null) {
  req.readyState = 1;
  req.addEventListener("load", function () {
             req.readyState = 4;
             if (typeof req.onreadystatechange == "function")
         req.onreadystatechange();
           }, false);
      }
      
      return req;
    }
    if (window.ActiveXObject) {
      return new ActiveXObject(XmlHttp.getPrefix() + ".XmlHttp");
    }
  }
  catch (ex) {}
  // fell through
  throw new Error("Your browser does not support XmlHttp objects");
};

/**
 * used to find the Automation server name
 * @private
 */
XmlHttp.getPrefix = function() {
  if (XmlHttp.prefix) // I know what you did last summer
    return XmlHttp.prefix;
 
  var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
  var o;
  for (var i = 0; i < prefixes.length; i++) {
    try {
      // try to create the objects
      o = new ActiveXObject(prefixes[i] + ".XmlHttp");
      return XmlHttp.prefix = prefixes[i];
    }
    catch (ex) {};
  }
 
  throw new Error("Could not find an installed XML parser");
};


/**
 * XmlDocument factory
 * @private
 */
function XmlDocument() {}

XmlDocument.create = function (name,ns) {
  name = name || 'foo';
  ns = ns || '';

  try {
    var doc;
    // DOM2
    if (document.implementation && document.implementation.createDocument) {
      doc = document.implementation.createDocument(ns, name, null);
      // some versions of Moz do not support the readyState property
      // and the onreadystate event so we patch it!
      if (doc.readyState == null) {
        doc.readyState = 1;
        doc.addEventListener("load", function () {
             doc.readyState = 4;
             if (typeof doc.onreadystatechange == "function")
               doc.onreadystatechange();
        }, false);
      }
    } else if (window.ActiveXObject) {
      doc = new ActiveXObject(XmlDocument.getPrefix() + ".DomDocument");
    }
   
    if (!doc.documentElement || doc.documentElement.tagName != name ||
        (doc.documentElement.namespaceURI &&
         doc.documentElement.namespaceURI != ns)) {
          try {
            if (ns != '')
              doc.appendChild(doc.createElement(name)).
                setAttribute('xmlns',ns);
            else
              doc.appendChild(doc.createElement(name));
          } catch (dex) {
            doc = document.implementation.createDocument(ns,name,null);
           
            if (doc.documentElement == null)
              doc.appendChild(doc.createElement(name));

             // fix buggy opera 8.5x
            if (ns != '' &&
                doc.documentElement.getAttribute('xmlns') != ns) {
              doc.documentElement.setAttribute('xmlns',ns);
            }
          }
        }
   
    return doc;
  }
  catch (ex) { }
  throw new Error("Your browser does not support XmlDocument objects");
};

/**
 * used to find the Automation server name
 * @private
 */
XmlDocument.getPrefix = function() {
  if (XmlDocument.prefix)
    return XmlDocument.prefix;

  var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
  var o;
  for (var i = 0; i < prefixes.length; i++) {
    try {
      // try to create the objects
      o = new ActiveXObject(prefixes[i] + ".DomDocument");
      return XmlDocument.prefix = prefixes[i];
    }
    catch (ex) {};
  }
 
  throw new Error("Could not find an installed XML parser");
};


// Create the loadXML method
if (typeof(Document) != 'undefined' && window.DOMParser) {

  /**
   * XMLDocument did not extend the Document interface in some
   * versions of Mozilla.
   * @private
   */
  Document.prototype.loadXML = function (s) {
  
    // parse the string to a new doc
    var doc2 = (new DOMParser()).parseFromString(s, "text/xml");
  
    // remove all initial children
    while (this.hasChildNodes())
      this.removeChild(this.lastChild);
    
    // insert and import nodes
    for (var i = 0; i < doc2.childNodes.length; i++) {
      this.appendChild(this.importNode(doc2.childNodes[i], true));
    }
  };
 }

// Create xml getter for Mozilla
if (window.XMLSerializer &&
    window.Node && Node.prototype && Node.prototype.__defineGetter__) {

  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  // XMLDocument did not extend the Document interface in some versions
  // of Mozilla. Extend both!
  XMLDocument.prototype.__defineGetter__("xml", function () {
                                           return (new XMLSerializer()).serializeToString(this);
                                         });
  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  Document.prototype.__defineGetter__("xml", function () {
                                        return (new XMLSerializer()).serializeToString(this);
                                      });

  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  Node.prototype.__defineGetter__("xml", function () {
                                    return (new XMLSerializer()).serializeToString(this);
                                  });
 }


/**
 * @fileoverview Collection of functions to make live easier
 * @author Stefan Strigler
 * @version $Revision$
 */

/**
 * Convert special chars to HTML entities
 * @addon
 * @return The string with chars encoded for HTML
 * @type String
 */
String.prototype.htmlEnc = function() {
  if(!this)
    return this;

  return this.replace(/&(?!(amp|apos|gt|lt|quot);)/g,"&amp;")
             .replace(/</g,"&lt;")
             .replace(/>/g,"&gt;")
             .replace(/\'/g,"&apos;")
             .replace(/\"/g,"&quot;")
             .replace(/\n/g,"<br />");
};

/**
 * Convert HTML entities to special chars
 * @addon
 * @return The normal string
 * @type String
 */
String.prototype.revertHtmlEnc = function() {
  if(!this)
    return this;

  var str = this.replace(/&amp;/gi,'&');
  str = str.replace(/&lt;/gi,'<');
  str = str.replace(/&gt;/gi,'>');
  str = str.replace(/&apos;/gi,'\'');
  str = str.replace(/&quot;/gi,'\"');
  str = str.replace(/<br( )?(\/)?>/gi,'\n');
  return str;
};

/**
 * Converts from jabber timestamps to JavaScript Date objects
 * @addon
 * @param {String} ts A string representing a jabber datetime timestamp as
 * defined by {@link http://www.xmpp.org/extensions/xep-0082.html XEP-0082}
 * @return A javascript Date object corresponding to the jabber DateTime given
 * @type Date
 */
Date.jab2date = function(ts) {
  // Timestamp
  if(!isNaN(ts))
    return new Date(ts * 1000);
  
  // Get the UTC date
  var date = new Date(Date.UTC(ts.substr(0,4),ts.substr(5,2)-1,ts.substr(8,2),ts.substr(11,2),ts.substr(14,2),ts.substr(17,2)));
  
  if (ts.substr(ts.length-6,1) != 'Z') { // there's an offset
    var date_offset = date.getTimezoneOffset() * 60 * 1000;
    var offset = new Date();
    offset.setTime(0);
    offset.setUTCHours(ts.substr(ts.length-5,2));
    offset.setUTCMinutes(ts.substr(ts.length-2,2));
    if (ts.substr(ts.length-6,1) == '+')
      date.setTime(date.getTime() + offset.getTime() + date_offset);
    else if (ts.substr(ts.length-6,1) == '-')
      date.setTime(date.getTime() - offset.getTime() + date_offset);
  }
  return date;
};

/**
 * Takes a timestamp in the form of 2004-08-13T12:07:04+02:00 as argument
 * and converts it to some sort of humane readable format
 * @addon
 */
Date.hrTime = function(ts) {
  return Date.jab2date(ts).toLocaleString();
};


 /**
  * Current timestamp.
  * @return Seconds since 1.1.1970.
  * @type int
  */
 if (!Date.now) {
     Date.now = function() { return new Date().getTime(); }
 }
 
 /**
 * somewhat opposit to {@link #hrTime}
 * expects a javascript Date object as parameter and returns a jabber
 * date string conforming to
 * {@link http://www.xmpp.org/extensions/xep-0082.html XEP-0082}
 * @see #hrTime
 * @return The corresponding jabber DateTime string
 * @type String
 */
Date.prototype.jabberDate = function() {
  var padZero = function(i) {
    if (i < 10) return "0" + i;
    return i;
  };

  var jDate = this.getUTCFullYear() + "-";
  jDate += padZero(this.getUTCMonth()+1) + "-";
  jDate += padZero(this.getUTCDate()) + "T";
  jDate += padZero(this.getUTCHours()) + ":";
  jDate += padZero(this.getUTCMinutes()) + ":";
  jDate += padZero(this.getUTCSeconds()) + "Z";

  return jDate;
};

/**
 * Determines the maximum of two given numbers
 * @addon
 * @param {Number} A a number
 * @param {Number} B another number
 * @return the maximum of A and B
 * @type Number
 */
Number.max = function(A, B) {
  return (A > B)? A : B;
};

Number.min = function(A, B) {
  return (A < B)? A : B;
};


/* Copyright (c) 1998 - 2007, Paul Johnston & Contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following
 * disclaimer. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/**
 * @fileoverview Collection of MD5 and SHA1 hashing and encoding
 * methods.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */


/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = new Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  var i, j, t, olda, oldb, oldc, oldd, olde;
  for (i = 0; i < x.length; i += 16)
  {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    olde = e;

    for (j = 0; j < 80; j++)
    {
      if (j < 16) { w[j] = x[i + j]; }
      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }
      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return [a, b, c, d, e];
}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if (t < 20) { return (b & c) | ((~b) & d); }
  if (t < 40) { return b ^ c ^ d; }
  if (t < 60) { return (b & c) | (b & d) | (c & d); }
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * chrsz); }

  var ipad = new Array(16), opad = new Array(16);
  for (var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = [];
  var mask = (1 << chrsz) - 1;
  for (var i = 0; i < str.length * chrsz; i += chrsz)
  {
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  }
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for (var i = 0; i < bin.length * 32; i += chrsz)
  {
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for (var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  var triplet, j;
  for (var i = 0; i < binarray.length * 4; i += 3)
  {
    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |
              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |
               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for (j = 0; j < 4; j++)
    {
      if (i * 8 + j * 6 > binarray.length * 32) { str += b64pad; }
      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
    }
  }
  return str;
}


/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


/* #############################################################################
   UTF-8 Decoder and Encoder
   base64 Encoder and Decoder
   written by Tobias Kieslich, justdreams
   Contact: tobias@justdreams.de        http://www.justdreams.de/
   ############################################################################# */

// returns an array of byterepresenting dezimal numbers which represent the
// plaintext in an UTF-8 encoded version. Expects a string.
// This function includes an exception management for those nasty browsers like
// NN401, which returns negative decimal numbers for chars>128. I hate it!!
// This handling is unfortunately limited to the user's charset. Anyway, it works
// in most of the cases! Special signs with an unicode>256 return numbers, which
// can not be converted to the actual unicode and so not to the valid utf-8
// representation. Anyway, this function does always return values which can not
// misinterpretd by RC4 or base64 en- or decoding, because every value is >0 and
// <255!!
// Arrays are faster and easier to handle in b64 encoding or encrypting....
function utf8t2d(t)
{
  t = t.replace(/\r\n/g,"\n");
  var d=new Array; var test=String.fromCharCode(237);
  if (test.charCodeAt(0) < 0)
    for(var n=0; n<t.length; n++)
      {
        var c=t.charCodeAt(n);
        if (c>0)
          d[d.length]= c;
        else {
          d[d.length]= (((256+c)>>6)|192);
          d[d.length]= (((256+c)&63)|128);}
      }
  else
    for(var n=0; n<t.length; n++)
      {
        var c=t.charCodeAt(n);
        // all the signs of asci => 1byte
        if (c<128)
          d[d.length]= c;
        // all the signs between 127 and 2047 => 2byte
        else if((c>127) && (c<2048)) {
          d[d.length]= ((c>>6)|192);
          d[d.length]= ((c&63)|128);}
        // all the signs between 2048 and 66536 => 3byte
        else {
          d[d.length]= ((c>>12)|224);
          d[d.length]= (((c>>6)&63)|128);
          d[d.length]= ((c&63)|128);}
      }
  return d;
}
  
// returns plaintext from an array of bytesrepresenting dezimal numbers, which
// represent an UTF-8 encoded text; browser which does not understand unicode
// like NN401 will show "?"-signs instead
// expects an array of byterepresenting decimals; returns a string
function utf8d2t(d)
{
  var r=new Array; var i=0;
  while(i<d.length)
    {
      if (d[i]<128) {
        r[r.length]= String.fromCharCode(d[i]); i++;}
      else if((d[i]>191) && (d[i]<224)) {
        r[r.length]= String.fromCharCode(((d[i]&31)<<6) | (d[i+1]&63)); i+=2;}
      else {
        r[r.length]= String.fromCharCode(((d[i]&15)<<12) | ((d[i+1]&63)<<6) | (d[i+2]&63)); i+=3;}
    }
  return r.join("");
}

// included in <body onload="b64arrays"> it creates two arrays which makes base64
// en- and decoding faster
// this speed is noticeable especially when coding larger texts (>5k or so)
function b64arrays() {
  var b64s='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  b64 = new Array();f64 =new Array();
  for (var i=0; i<b64s.length ;i++) {
    b64[i] = b64s.charAt(i);
    f64[b64s.charAt(i)] = i;
  }
}

// creates a base64 encoded text out of an array of byerepresenting dezimals
// it is really base64 :) this makes serversided handling easier
// expects an array; returns a string
function b64d2t(d) {
  var r=new Array; var i=0; var dl=d.length;
  // this is for the padding
  if ((dl%3) == 1) {
    d[d.length] = 0; d[d.length] = 0;}
  if ((dl%3) == 2)
    d[d.length] = 0;
  // from here conversion
  while (i<d.length)
    {
      r[r.length] = b64[d[i]>>2];
      r[r.length] = b64[((d[i]&3)<<4) | (d[i+1]>>4)];
      r[r.length] = b64[((d[i+1]&15)<<2) | (d[i+2]>>6)];
      r[r.length] = b64[d[i+2]&63];
      i+=3;
    }
  // this is again for the padding
  if ((dl%3) == 1)
    r[r.length-1] = r[r.length-2] = "=";
  if ((dl%3) == 2)
    r[r.length-1] = "=";
  // we join the array to return a textstring
  var t=r.join("");
  return t;
}

// returns array of byterepresenting numbers created of an base64 encoded text
// it is still the slowest function in this modul; I hope I can make it faster
// expects string; returns an array
function b64t2d(t) {
  var d=new Array; var i=0;
  // here we fix this CRLF sequenz created by MS-OS; arrrgh!!!
  t=t.replace(/\n|\r/g,""); t=t.replace(/=/g,"");
  while (i<t.length)
    {
      d[d.length] = (f64[t.charAt(i)]<<2) | (f64[t.charAt(i+1)]>>4);
      d[d.length] = (((f64[t.charAt(i+1)]&15)<<4) | (f64[t.charAt(i+2)]>>2));
      d[d.length] = (((f64[t.charAt(i+2)]&3)<<6) | (f64[t.charAt(i+3)]));
      i+=4;
    }
  if (t.length%4 == 2)
    d = d.slice(0, d.length-2);
  if (t.length%4 == 3)
    d = d.slice(0, d.length-1);
  return d;
}

if (typeof(atob) == 'undefined' || typeof(btoa) == 'undefined')
  b64arrays();

if (typeof(atob) == 'undefined') {
  b64decode = function(s) {
    return utf8d2t(b64t2d(s));
  }
} else {
  b64decode = function(s) {
    return decodeURIComponent(escape(atob(s)));
  }
}

if (typeof(btoa) == 'undefined') {
  b64encode = function(s) {
    return b64d2t(utf8t2d(s));
  }
} else {
  b64encode = function(s) {
    return btoa(unescape(encodeURIComponent(s)));
  }
}

function cnonce(size) {
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  var cnonce = '';
  for (var i=0; i<size; i++) {
    cnonce += tab.charAt(Math.round(Math.random(new Date().getTime())*(tab.length-1)));
  }
  return cnonce;
}


JSJAC_HAVEKEYS = true;          // whether to use keys
JSJAC_NKEYS    = 16;            // number of keys to generate

JSJAC_INACTIVITY = 300;         // qnd hack to make suspend/resume 
                                    // work more smoothly with polling
JSJAC_ERR_COUNT = 10;           // number of retries in case of connection
                                    // errors

JSJAC_ALLOW_PLAIN = true;       // whether to allow plaintext logins

JSJAC_CHECKQUEUEINTERVAL = 100;   // msecs to poll send queue
JSJAC_CHECKINQUEUEINTERVAL = 100; // msecs to poll incoming queue
JSJAC_TIMERVAL = 2000;          // default polling interval

JSJAC_ALLOW_PLAIN = true;       // whether to allow plaintext logins
JSJAC_ALLOW_SCRAM = false;      // allow usage of SCRAM-SHA-1 authentication; please note that it is quite slow so it is disable by default

JSJAC_RETRYDELAY = 5000;        // msecs to wait before trying next
                                // request after error

JSJAC_REGID_TIMEOUT = 20000;    // time in msec until registered
                                // callbacks for ids timeout

/* Options specific to HTTP Binding (BOSH) */
JSJACHBC_MAX_HOLD = 1;          // default for number of connctions
                                // held by connection manager

JSJACHBC_MAX_WAIT = 300;        // default 'wait' param - how long an
                                // idle connection should be held by
                                // connection manager

JSJACHBC_BOSH_VERSION  = "1.6";
JSJACHBC_USE_BOSH_VER  = true;

JSJACHBC_MAXPAUSE = 20;        // how long a suspend/resume cycle may take

/*** END CONFIG ***/


/* Copyright (c) 2005-2007 Sam Stephenson
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
  json.js
  taken from prototype.js, made static
*/
function JSJaCJSON() {}
JSJaCJSON.toString = function (obj) {
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  },
  s = {
    array: function (x) {
      var a = ['['], b, f, i, l = x.length, v;
      for (i = 0; i < l; i += 1) {
        v = x[i];
        f = s[typeof v];
        if (f) {
    try {
            v = f(v);
            if (typeof v == 'string') {
              if (b) {
                a[a.length] = ',';
              }
              a[a.length] = v;
              b = true;
            }
    } catch(e) { 
    }
        }
      }
      a[a.length] = ']';
      return a.join('');
    },
    'boolean': function (x) {
      return String(x);
    },
    'null': function (x) {
      return "null";
    },
    number: function (x) {
      return isFinite(x) ? String(x) : 'null';
    },
    object: function (x) {
      if (x) {
        if (x instanceof Array) {
          return s.array(x);
        }
        var a = ['{'], b, f, i, v;
        for (i in x) {
          if (x.hasOwnProperty(i)) {
            v = x[i];
            f = s[typeof v];
            if (f) {
        try {
                v = f(v);
                if (typeof v == 'string') {
                  if (b) {
                    a[a.length] = ',';
                  }
                  a.push(s.string(i), ':', v);
                  b = true;
                }
        } catch(e) {
        }
            }
          }
        }
         
        a[a.length] = '}';
        return a.join('');
      }
      return 'null';
    },
    string: function (x) {
      if (/["\\\x00-\x1f]/.test(x)) {
                    x = x.replace(/([\x00-\x1f\\"])/g, function(a, b) {
          var c = m[b];
          if (c) {
            return c;
          }
          c = b.charCodeAt();
          return '\\u00' +
          Math.floor(c / 16).toString(16) +
          (c % 16).toString(16);
        });
  }
  return '"' + x + '"';
}
  };

switch (typeof(obj)) {
 case 'object':
   return s.object(obj);
 case 'array':
   return s.array(obj);
   
 }
};

JSJaCJSON.parse = function (str) {
  try {
    return !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(
                                                       str.replace(/"(\\.|[^"\\])*"/g, ''))) &&
            eval('(' + str + ')');
    } catch (e) {
        return false;
    }
};


/**
 * @fileoverview This file contains all things that make life easier when
 * dealing with JIDs
 * @author Stefan Strigler
 * @version $Revision$
 */

/**
 * list of forbidden chars for nodenames
 * @private
 */
var JSJACJID_FORBIDDEN = ['"',' ','&','\'','/',':','<','>','@'];

/**
 * Creates a new JSJaCJID object
 * @class JSJaCJID models xmpp jid objects
 * @constructor
 * @param {Object} jid jid may be either of type String or a JID represented
 * by JSON with fields 'node', 'domain' and 'resource'
 * @throws JSJaCJIDInvalidException Thrown if jid is not valid
 * @return a new JSJaCJID object
 */
function JSJaCJID(jid) {
  /**
   *@private
   */
  this._node = '';
  /**
   *@private
   */
  this._domain = '';
  /**
   *@private
   */
  this._resource = '';

  if (typeof(jid) == 'string') {
    if (jid.indexOf('@') != -1) {
        this.setNode(jid.substring(0,jid.indexOf('@')));
        jid = jid.substring(jid.indexOf('@')+1);
    }
    if (jid.indexOf('/') != -1) {
      this.setResource(jid.substring(jid.indexOf('/')+1));
      jid = jid.substring(0,jid.indexOf('/'));
    }
    this.setDomain(jid);
  } else {
    this.setNode(jid.node);
    this.setDomain(jid.domain);
    this.setResource(jid.resource);
  }
}


/**
 * Gets the node part of the jid
 * @return A string representing the node name
 * @type String
 */
JSJaCJID.prototype.getNode = function() { return this._node; };

/**
 * Gets the domain part of the jid
 * @return A string representing the domain name
 * @type String
 */
JSJaCJID.prototype.getDomain = function() { return this._domain; };

/**
 * Gets the resource part of the jid
 * @return A string representing the resource
 * @type String
 */
JSJaCJID.prototype.getResource = function() { return this._resource; };


/**
 * Sets the node part of the jid
 * @param {String} node Name of the node
 * @throws JSJaCJIDInvalidException Thrown if node name contains invalid chars
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setNode = function(node) {
  JSJaCJID._checkNodeName(node);
  this._node = node || '';
  return this;
};

/**
 * Sets the domain part of the jid
 * @param {String} domain Name of the domain
 * @throws JSJaCJIDInvalidException Thrown if domain name contains invalid
 * chars or is empty
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setDomain = function(domain) {
  if (!domain || domain == '')
    throw new JSJaCJIDInvalidException("domain name missing");
  // chars forbidden for a node are not allowed in domain names
  // anyway, so let's check
  JSJaCJID._checkNodeName(domain);
  this._domain = domain;
  return this;
};

/**
 * Sets the resource part of the jid
 * @param {String} resource Name of the resource
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setResource = function(resource) {
  this._resource = resource || '';
  return this;
};

/**
 * The string representation of the full jid
 * @return A string representing the jid
 * @type String
 */
JSJaCJID.prototype.toString = function() {
  var jid = '';
  if (this.getNode() && this.getNode() != '')
    jid = this.getNode() + '@';
  jid += this.getDomain(); // we always have a domain
  if (this.getResource() && this.getResource() != "")
    jid += '/' + this.getResource();
  return jid;
};

/**
 * Removes the resource part of the jid
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.removeResource = function() {
  return this.setResource();
};

/**
 * creates a copy of this JSJaCJID object
 * @return A copy of this
 * @type JSJaCJID
 */
JSJaCJID.prototype.clone = function() {
  return new JSJaCJID(this.toString());
};

/**
 * Compares two jids if they belong to the same entity (i.e. w/o resource)
 * @param {String} jid a jid as string or JSJaCJID object
 * @return 'true' if jid is same entity as this
 * @type Boolean
 */
JSJaCJID.prototype.isEntity = function(jid) {
  if (typeof jid == 'string')
    jid = (new JSJaCJID(jid));
  jid.removeResource();
  return (this.clone().removeResource().toString() === jid.toString());
};

/**
 * Check if node name is valid
 * @private
 * @param {String} node A name for a node
 * @throws JSJaCJIDInvalidException Thrown if name for node is not allowed
 */
JSJaCJID._checkNodeName = function(nodeprep) {
    if (!nodeprep || nodeprep == '')
      return;
    for (var i=0; i< JSJACJID_FORBIDDEN.length; i++) {
      if (nodeprep.indexOf(JSJACJID_FORBIDDEN[i]) != -1) {
        throw new JSJaCJIDInvalidException("forbidden char in nodename: "+JSJACJID_FORBIDDEN[i]);
      }
    }
};

/**
 * Creates a new Exception of type JSJaCJIDInvalidException
 * @class Exception to indicate invalid values for a jid
 * @constructor
 * @param {String} message The message associated with this Exception
 */
function JSJaCJIDInvalidException(message) {
  /**
   * The exceptions associated message
   * @type String
   */
  this.message = message;
  /**
   * The name of the exception
   * @type String
   */
  this.name = "JSJaCJIDInvalidException";
}


/* Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * @private
 * This code is taken from {@link
 * http://wiki.script.aculo.us/scriptaculous/show/Builder
 * script.aculo.us' Dom Builder} and has been modified to suit our
 * needs.<br/>
 * The original parts of the code do have the following
 * copyright and license notice:<br/>
 * Copyright (c) 2005, 2006 Thomas Fuchs (http://script.aculo.us,
 * http://mir.acu lo.us) <br/>
 * script.aculo.us is freely distributable under the terms of an
 * MIT-style license.<br>
 * For details, see the script.aculo.us web site:
 * http://script.aculo.us/<br>
 */
var JSJaCBuilder = {
  /**
   * @private
   */
  buildNode: function(doc, elementName) {

    var element, ns = arguments[4];

    // attributes (or text)
    if(arguments[2])
      if(JSJaCBuilder._isStringOrNumber(arguments[2]) ||
         (arguments[2] instanceof Array)) {
        element = this._createElement(doc, elementName, ns);
        JSJaCBuilder._children(doc, element, arguments[2]);
      } else {
        ns = arguments[2]['xmlns'] || ns;
        element = this._createElement(doc, elementName, ns);
        for(attr in arguments[2]) {
          if (arguments[2].hasOwnProperty(attr) && attr != 'xmlns')
            element.setAttribute(attr, arguments[2][attr]);
        }
      }
    else
      element = this._createElement(doc, elementName, ns);
    // text, or array of children
    if(arguments[3])
      JSJaCBuilder._children(doc, element, arguments[3], ns);

    return element;
  },

  _createElement: function(doc, elementName, ns) {
    try {
      if (ns)
        return doc.createElementNS(ns, elementName);
    } catch (ex) { }

    var el = doc.createElement(elementName);

    if (ns)
      el.setAttribute("xmlns", ns);

    return el;
  },

  /**
   * @private
   */
  _text: function(doc, text) {
    return doc.createTextNode(text);
  },

  /**
   * @private
   */
  _children: function(doc, element, children, ns) {
    if(typeof children=='object') { // array can hold nodes and text
      for (var i in children) {
        if (children.hasOwnProperty(i)) {
          var e = children[i];
          if (typeof e=='object') {
            if (e instanceof Array) {
              var node = JSJaCBuilder.buildNode(doc, e[0], e[1], e[2], ns);
              element.appendChild(node);
            } else {
              element.appendChild(e);
            }
          } else {
            if(JSJaCBuilder._isStringOrNumber(e)) {
              element.appendChild(JSJaCBuilder._text(doc, e));
            }
          }
        }
      }
    } else {
      if(JSJaCBuilder._isStringOrNumber(children)) {
        element.appendChild(JSJaCBuilder._text(doc, children));
      }
    }
  },

  _attributes: function(attributes) {
    var attrs = [];
    for(attribute in attributes)
      if (attributes.hasOwnProperty(attribute))
        attrs.push(attribute +
          '="' + attributes[attribute].toString().htmlEnc() + '"');
    return attrs.join(" ");
  },

  _isStringOrNumber: function(param) {
    return(typeof param=='string' || typeof param=='number');
  }
};


/**
 * @fileoverview Contains all Jabber/XMPP packet related classes.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 * @version $Revision$
 */

var JSJACPACKET_USE_XMLNS = true;

/**
 * Creates a new packet with given root tag name (for internal use)
 * @class Somewhat abstract base class for all kinds of specialised packets
 * @param {String} name The root tag name of the packet
 * (i.e. one of 'message', 'iq' or 'presence')
 */
function JSJaCPacket(name) {
  /**
   * @private
   */
  this.name = name;

  if (typeof(JSJACPACKET_USE_XMLNS) != 'undefined' && JSJACPACKET_USE_XMLNS)
    /**
     * @private
     */
    this.doc = XmlDocument.create(name,'jabber:client');
  else
    /**
     * @private
     */
    this.doc = XmlDocument.create(name,'');
}

/**
 * Gets the type (name of root element) of this packet, i.e. one of
 * 'presence', 'message' or 'iq'
 * @return the top level tag name
 * @type String
 */
JSJaCPacket.prototype.pType = function() { return this.name; };

/**
 * Gets the associated Document for this packet.
 * @type {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#i-Document Document}
 */
JSJaCPacket.prototype.getDoc = function() {
  return this.doc;
};
/**
 * Gets the root node of this packet
 * @type {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node}
 */
JSJaCPacket.prototype.getNode = function() {
  if (this.getDoc() && this.getDoc().documentElement)
    return this.getDoc().documentElement;
  else
    return null;
};

/**
 * Sets the 'to' attribute of the root node of this packet
 * @param {String} to
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.setTo = function(to) {
  if (!to || to == '')
    this.getNode().removeAttribute('to');
  else if (typeof(to) == 'string')
    this.getNode().setAttribute('to',to);
  else
    this.getNode().setAttribute('to',to.toString());
  return this;
};
/**
 * Sets the 'from' attribute of the root node of this
 * packet. Usually this is not needed as the server will take care
 * of this automatically.
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.setFrom = function(from) {
  if (!from || from == '')
    this.getNode().removeAttribute('from');
  else if (typeof(from) == 'string')
    this.getNode().setAttribute('from',from);
  else
    this.getNode().setAttribute('from',from.toString());
  return this;
};
/**
 * Sets 'id' attribute of the root node of this packet.
 * @param {String} id The id of the packet.
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.setID = function(id) {
  if (!id || id == '')
    this.getNode().removeAttribute('id');
  else
    this.getNode().setAttribute('id',id);
  return this;
};
/**
 * Sets the 'type' attribute of the root node of this packet.
 * @param {String} type The type of the packet.
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.setType = function(type) {
  if (!type || type == '')
    this.getNode().removeAttribute('type');
  else
    this.getNode().setAttribute('type',type);
  return this;
};
/**
 * Sets 'xml:lang' for this packet
 * @param {String} xmllang The xml:lang of the packet.
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.setXMLLang = function(xmllang) {
  // Fix IE bug with xml:lang attribute

  // Also due to issues with both BD and jQuery being used, employ a simple regexp since the detection
  // here is very limited.
  if (navigator.appVersion.match(/^.*MSIE (\d)/) || navigator.userAgent.match(/Trident\/(\d+)((\.)(\d+))?/))
    return this;
  if (!xmllang || xmllang == '')
    this.getNode().removeAttribute('xml:lang');
  else
    this.getNode().setAttribute('xml:lang',xmllang);
  return this;
};

/**
 * Gets the 'to' attribute of this packet
 * @type String
 */
JSJaCPacket.prototype.getTo = function() {
  return this.getNode().getAttribute('to');
};
/**
 * Gets the 'from' attribute of this packet.
 * @type String
 */
JSJaCPacket.prototype.getFrom = function() {
  return this.getNode().getAttribute('from');
};
/**
 * Gets the 'to' attribute of this packet as a JSJaCJID object
 * @type JSJaCJID
 */
JSJaCPacket.prototype.getToJID = function() {
  return new JSJaCJID(this.getTo());
};
/**
 * Gets the 'from' attribute of this packet as a JSJaCJID object
 * @type JSJaCJID
 */
JSJaCPacket.prototype.getFromJID = function() {
  return new JSJaCJID(this.getFrom());
};
/**
 * Gets the 'id' of this packet
 * @type String
 */
JSJaCPacket.prototype.getID = function() {
  return this.getNode().getAttribute('id');
};
/**
 * Gets the 'type' of this packet
 * @type String
 */
JSJaCPacket.prototype.getType = function() {
  return this.getNode().getAttribute('type');
};
/**
 * Gets the 'xml:lang' of this packet
 * @type String
 */
JSJaCPacket.prototype.getXMLLang = function() {
  return this.getNode().getAttribute('xml:lang');
};
/**
 * Gets the 'xmlns' (xml namespace) of the root node of this packet
 * @type String
 */
JSJaCPacket.prototype.getXMLNS = function() {
  return this.getNode().namespaceURI || this.getNode().getAttribute('xmlns');
};

/**
 * Gets a child element of this packet. If no params given returns first child.
 * @param {String} name Tagname of child to retrieve. Use '*' to match any tag. [optional]
 * @param {String} ns   Namespace of child. Use '*' to match any ns.[optional]
 * @return The child node, null if none found
 * @type {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node}
 */
JSJaCPacket.prototype.getChild = function(name, ns) {
  if (!this.getNode()) {
    return null;
  }

  name = name || '*';
  ns = ns || '*';

  if (this.getNode().getElementsByTagNameNS) {
    return this.getNode().getElementsByTagNameNS(ns, name).item(0);
  }

  // fallback
  var nodes = this.getNode().getElementsByTagName(name);
  if (ns != '*') {
    for (var i=0; i<nodes.length; i++) {
      if (nodes.item(i).namespaceURI == ns || nodes.item(i).getAttribute('xmlns') == ns) {
        return nodes.item(i);
      }
    }
  } else {
    return nodes.item(0);
  }
  return null; // nothing found
};

/**
 * Gets the node value of a child element of this packet.
 * @param {String} name Tagname of child to retrieve.
 * @param {String} ns   Namespace of child
 * @return The value of the child node, empty string if none found
 * @type String
 */
JSJaCPacket.prototype.getChildVal = function(name, ns) {
  var node = this.getChild(name, ns);
  var ret = '';
  if (node && node.hasChildNodes()) {
    // concatenate all values from childNodes
    for (var i=0; i<node.childNodes.length; i++)
      if (node.childNodes.item(i).nodeValue)
        ret += node.childNodes.item(i).nodeValue;
  }
  return ret;
};

/**
 * Returns a copy of this node
 * @return a copy of this node
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.clone = function() {
  return JSJaCPacket.wrapNode(this.getNode());
};

/**
 * Checks if packet is of type 'error'
 * @return 'true' if this packet is of type 'error', 'false' otherwise
 * @type boolean
 */
JSJaCPacket.prototype.isError = function() {
  return (this.getType() == 'error');
};

/**
 * Returns an error condition reply according to {@link http://www.xmpp.org/extensions/xep-0086.html XEP-0086}. Creates a clone of the calling packet with senders and recipient exchanged and error stanza appended.
 * @param {STANZA_ERROR} stanza_error an error stanza containing error cody, type and condition of the error to be indicated
 * @return an error reply packet
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.errorReply = function(stanza_error) {
  var rPacket = this.clone();
  rPacket.setTo(this.getFrom());
  rPacket.setFrom();
  rPacket.setType('error');

  rPacket.appendNode('error',
                     {code: stanza_error.code, type: stanza_error.type},
                     [[stanza_error.cond]]);

  return rPacket;
};

/**
 * Returns a string representation of the raw xml content of this packet.
 * @type String
 */
JSJaCPacket.prototype.xml = typeof XMLSerializer != 'undefined' ?
function() {
  var r = (new XMLSerializer()).serializeToString(this.getNode());
  if (typeof(r) == 'undefined')
    r = (new XMLSerializer()).serializeToString(this.doc); // oldschool
  return r
} :
function() {// IE
  return this.getDoc().xml
};


// PRIVATE METHODS DOWN HERE

/**
 * Gets an attribute of the root element
 * @private
 */
JSJaCPacket.prototype._getAttribute = function(attr) {
  return this.getNode().getAttribute(attr);
};


if (document.ELEMENT_NODE == null) {
  document.ELEMENT_NODE = 1;
  document.ATTRIBUTE_NODE = 2;
  document.TEXT_NODE = 3;
  document.CDATA_SECTION_NODE = 4;
  document.ENTITY_REFERENCE_NODE = 5;
  document.ENTITY_NODE = 6;
  document.PROCESSING_INSTRUCTION_NODE = 7;
  document.COMMENT_NODE = 8;
  document.DOCUMENT_NODE = 9;
  document.DOCUMENT_TYPE_NODE = 10;
  document.DOCUMENT_FRAGMENT_NODE = 11;
  document.NOTATION_NODE = 12;
}

/**
 * import node into this packets document
 * @private
 */
JSJaCPacket.prototype._importNode = function(node, allChildren) {
  switch (node.nodeType) {
  case document.ELEMENT_NODE:

  if (this.getDoc().createElementNS) {
    var newNode = this.getDoc().createElementNS(node.namespaceURI, node.nodeName);
  } else {
    var newNode = this.getDoc().createElement(node.nodeName);
  }

  /* does the node have any attributes to add? */
  if (node.attributes && node.attributes.length > 0)
    for (var i = 0, il = node.attributes.length;i < il; i++) {
      var attr = node.attributes.item(i);
      if (attr.nodeName == 'xmlns' && newNode.getAttribute('xmlns') != null ) continue;
      if (newNode.setAttributeNS && attr.namespaceURI) {
        newNode.setAttributeNS(attr.namespaceURI,
                               attr.nodeName,
                               attr.nodeValue);
      } else {
        newNode.setAttribute(attr.nodeName,
                             attr.nodeValue);
      }
    }
  /* are we going after children too, and does the node have any? */
  if (allChildren && node.childNodes && node.childNodes.length > 0) {
    for (var i = 0, il = node.childNodes.length; i < il; i++) {
      newNode.appendChild(this._importNode(node.childNodes.item(i), allChildren));
    }
  }
  return newNode;
  break;
  case document.TEXT_NODE:
  case document.CDATA_SECTION_NODE:
  case document.COMMENT_NODE:
  return this.getDoc().createTextNode(node.nodeValue);
  break;
  }
};

/**
 * Set node value of a child node
 * @private
 */
JSJaCPacket.prototype._setChildNode = function(nodeName, nodeValue) {
  var aNode = this.getChild(nodeName);
  var tNode = this.getDoc().createTextNode(nodeValue);
  if (aNode)
    try {
      aNode.replaceChild(tNode,aNode.firstChild);
    } catch (e) { }
  else {
    try {
      aNode = this.getDoc().createElementNS(this.getNode().namespaceURI,
                                            nodeName);
    } catch (ex) {
      aNode = this.getDoc().createElement(nodeName)
    }
    this.getNode().appendChild(aNode);
    aNode.appendChild(tNode);
  }
  return aNode;
};

/**
 * Builds a node using {@link
 * http://wiki.script.aculo.us/scriptaculous/show/Builder
 * script.aculo.us' Dom Builder} notation.
 * This code is taken from {@link
 * http://wiki.script.aculo.us/scriptaculous/show/Builder
 * script.aculo.us' Dom Builder} and has been modified to suit our
 * needs.<br/>
 * The original parts of the code do have the following copyright
 * and license notice:<br/>
 * Copyright (c) 2005, 2006 Thomas Fuchs (http://script.aculo.us,
 * http://mir.acu lo.us) <br/>
 * script.aculo.us is freely distributable under the terms of an
 * MIT-style licen se.  // For details, see the script.aculo.us web
 * site: http://script.aculo.us/<br>
 * @author Thomas Fuchs
 * @author Stefan Strigler
 * @return The newly created node
 * @type {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node}
 */
JSJaCPacket.prototype.buildNode = function(elementName) {
  return JSJaCBuilder.buildNode(this.getDoc(),
                                elementName,
                                arguments[1],
                                arguments[2]);
};

/**
 * Appends node created by buildNode to this packets parent node.
 * @param {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node} element The node to append or
 * @param {String} element A name plus an object hash with attributes (optional) plus an array of childnodes (optional)
 * @see #buildNode
 * @return This packet
 * @type JSJaCPacket
 */
JSJaCPacket.prototype.appendNode = function(element) {
  if (typeof element=='object') { // seems to be a prebuilt node
    return this.getNode().appendChild(element)
  } else { // build node
    return this.getNode().appendChild(this.buildNode(element,
                                                     arguments[1],
                                                     arguments[2],
                                                     null,
                                                     this.getNode().namespaceURI));
  }
};


/**
 * A jabber/XMPP presence packet
 * @class Models the XMPP notion of a 'presence' packet
 * @extends JSJaCPacket
 */
function JSJaCPresence() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('presence');
}
JSJaCPresence.prototype = new JSJaCPacket;

/**
 * Sets the status message for current status. Usually this is set
 * to some human readable string indicating what the user is
 * doing/feel like currently.
 * @param {String} status A status message
 * @return this
 * @type JSJaCPacket
 */
JSJaCPresence.prototype.setStatus = function(status) {
  this._setChildNode("status", status);
  return this;
};
/**
 * Sets the online status for this presence packet.
 * @param {String} show An XMPP complient status indicator. Must
 * be one of 'chat', 'away', 'xa', 'dnd'
 * @return this
 * @type JSJaCPacket
 */
JSJaCPresence.prototype.setShow = function(show) {
  if (show == 'chat' || show == 'away' || show == 'xa' || show == 'dnd')
    this._setChildNode("show",show);
  return this;
};
/**
 * Sets the priority of the resource bind to with this connection
 * @param {int} prio The priority to set this resource to
 * @return this
 * @type JSJaCPacket
 */
JSJaCPresence.prototype.setPriority = function(prio) {
  this._setChildNode("priority", prio);
  return this;
};
/**
 * Some combined method that allowes for setting show, status and
 * priority at once
 * @param {String} show A status message
 * @param {String} status A status indicator as defined by XMPP
 * @param {int} prio A priority for this resource
 * @return this
 * @type JSJaCPacket
 */
JSJaCPresence.prototype.setPresence = function(show,status,prio) {
  if (show)
    this.setShow(show);
  if (status)
    this.setStatus(status);
  if (prio)
    this.setPriority(prio);
  return this;
};

/**
 * Gets the status message of this presence
 * @return The (human readable) status message
 * @type String
 */
JSJaCPresence.prototype.getStatus = function() {
  return this.getChildVal('status');
};
/**
 * Gets the status of this presence.
 * Either one of 'chat', 'away', 'xa' or 'dnd' or null.
 * @return The status indicator as defined by XMPP
 * @type String
 */
JSJaCPresence.prototype.getShow = function() {
  return this.getChildVal('show');
};
/**
 * Gets the priority of this status message
 * @return A resource priority
 * @type int
 */
JSJaCPresence.prototype.getPriority = function() {
  return this.getChildVal('priority');
};


/**
 * A jabber/XMPP iq packet
 * @class Models the XMPP notion of an 'iq' packet
 * @extends JSJaCPacket
 */
function JSJaCIQ() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('iq');
}
JSJaCIQ.prototype = new JSJaCPacket;

/**
 * Some combined method to set 'to', 'type' and 'id' at once
 * @param {String} to the recepients JID
 * @param {String} type A XMPP compliant iq type (one of 'set', 'get', 'result' and 'error'
 * @param {String} id A packet ID
 * @return this
 * @type JSJaCIQ
 */
JSJaCIQ.prototype.setIQ = function(to,type,id) {
  if (to)
    this.setTo(to);
  if (type)
    this.setType(type);
  if (id)
    this.setID(id);
  return this;
};
/**
 * Creates a 'query' child node with given XMLNS
 * @param {String} xmlns The namespace for the 'query' node
 * @return The query node
 * @type {@link  http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node}
 */
JSJaCIQ.prototype.setQuery = function(xmlns) {
  var query;
  try {
    query = this.getDoc().createElementNS(xmlns,'query');
  } catch (e) {
    query = this.getDoc().createElement('query');
  query.setAttribute('xmlns',xmlns);
  }
  this.getNode().appendChild(query);
  return query;
};

/**
 * Gets the 'query' node of this packet
 * @return The query node
 * @type {@link  http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 Node}
 */
JSJaCIQ.prototype.getQuery = function() {
  return this.getNode().getElementsByTagName('query').item(0);
};
/**
 * Gets the XMLNS of the query node contained within this packet
 * @return The namespace of the query node
 * @type String
 */
JSJaCIQ.prototype.getQueryXMLNS = function() {
  if (this.getQuery()) {
    return this.getQuery().namespaceURI || this.getQuery().getAttribute('xmlns');
  } else {
    return null;
  }
};

/**
 * Creates an IQ reply with type set to 'result'. If given appends payload to first child if IQ. Payload maybe XML as string or a DOM element (or an array of such elements as well).
 * @param {Element} payload A payload to be appended [optional]
 * @return An IQ reply packet
 * @type JSJaCIQ
 */
JSJaCIQ.prototype.reply = function(payload) {
  var rIQ = this.clone();
  rIQ.setTo(this.getFrom());
  rIQ.setFrom();
  rIQ.setType('result');
  if (payload) {
    if (typeof payload == 'string')
      rIQ.getChild().appendChild(rIQ.getDoc().loadXML(payload));
    else if (payload.constructor == Array) {
      var node = rIQ.getChild();
      for (var i=0; i<payload.length; i++)
        if(typeof payload[i] == 'string')
          node.appendChild(rIQ.getDoc().loadXML(payload[i]));
        else if (typeof payload[i] == 'object')
          node.appendChild(payload[i]);
    }
    else if (typeof payload == 'object')
      rIQ.getChild().appendChild(payload);
  }
  return rIQ;
};

/**
 * A jabber/XMPP message packet
 * @class Models the XMPP notion of an 'message' packet
 * @extends JSJaCPacket
 */
function JSJaCMessage() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('message');
}
JSJaCMessage.prototype = new JSJaCPacket;

/**
 * Sets the body of the message
 * @param {String} body Your message to be sent along
 * @return this message
 * @type JSJaCMessage
 */
JSJaCMessage.prototype.setBody = function(body) {
  this._setChildNode("body",body);
  return this;
};
/**
 * Sets the subject of the message
 * @param {String} subject Your subject to be sent along
 * @return this message
 * @type JSJaCMessage
 */
JSJaCMessage.prototype.setSubject = function(subject) {
  this._setChildNode("subject",subject);
  return this;
};
/**
 * Sets the 'tread' attribute for this message. This is used to identify
 * threads in chat conversations
 * @param {String} thread Usually a somewhat random hash.
 * @return this message
 * @type JSJaCMessage
 */
JSJaCMessage.prototype.setThread = function(thread) {
  this._setChildNode("thread", thread);
  return this;
};
/**
 * Sets the 'nick' attribute for this message.
 * This is sometime sused to detect the sender nickname when he's not in the roster
 * @param {String} nickname
 * @return this message
 * @type JSJaCMessage
 */
JSJaCMessage.prototype.setNick = function(nick) {
  var aNode = this.getChild("nick");
  var tNode = this.getDoc().createTextNode(nick);
  if (aNode)
    try {
      aNode.replaceChild(tNode,aNode.firstChild);
    } catch (e) { }
  else {
    try {
      aNode = this.getDoc().createElementNS('http://jabber.org/protocol/nick',
                                            "nick");
    } catch (ex) {
      aNode = this.getDoc().createElement("nick")
    }
    this.getNode().appendChild(aNode);
    aNode.appendChild(tNode);
  }
  return this;
};
/**
 * Gets the 'thread' identifier for this message
 * @return A thread identifier
 * @type String
 */
JSJaCMessage.prototype.getThread = function() {
  return this.getChildVal('thread');
};
/**
 * Gets the body of this message
 * @return The body of this message
 * @type String
 */
JSJaCMessage.prototype.getBody = function() {
  return this.getChildVal('body');
};
/**
 * Gets the subject of this message
 * @return The subject of this message
 * @type String
 */
JSJaCMessage.prototype.getSubject = function() {
  return this.getChildVal('subject')
};
/**
 * Gets the nickname of this message
 * @return The nickname of this message
 * @type String
 */
JSJaCMessage.prototype.getNick = function() {
  return this.getChildVal('nick');
};


/**
 * Tries to transform a w3c DOM node to JSJaC's internal representation
 * (JSJaCPacket type, one of JSJaCPresence, JSJaCMessage, JSJaCIQ)
 * @param: {Node
 * http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247}
 * node The node to be transformed
 * @return A JSJaCPacket representing the given node. If node's root
 * elemenent is not one of 'message', 'presence' or 'iq',
 * <code>null</code> is being returned.
 * @type JSJaCPacket
 */
JSJaCPacket.wrapNode = function(node) {
  var oPacket = null;

  switch (node.nodeName.toLowerCase()) {
  case 'presence':
      oPacket = new JSJaCPresence();
      break;
  case 'message':
      oPacket = new JSJaCMessage();
      break;
  case 'iq':
      oPacket = new JSJaCIQ();
      break;
  }

  if (oPacket) {
    oPacket.getDoc().replaceChild(oPacket._importNode(node, true),
                                  oPacket.getNode());
  }

  return oPacket;
};



/**
 * an error packet for internal use
 * @private
 * @constructor
 */
function JSJaCError(code,type,condition) {
  var xmldoc = XmlDocument.create("error","jsjac");

  xmldoc.documentElement.setAttribute('code',code);
  xmldoc.documentElement.setAttribute('type',type);
  if (condition)
    xmldoc.documentElement.appendChild(xmldoc.createElement(condition)).
      setAttribute('xmlns','urn:ietf:params:xml:ns:xmpp-stanzas');
  return xmldoc.documentElement;
}



/**
 * Creates a new set of hash keys
 * @class Reflects a set of sha1/md5 hash keys for securing sessions
 * @constructor
 * @param {Function} func The hash function to be used for creating the keys
 * @param {Debugger} oDbg Reference to debugger implementation [optional]
 */                  
function JSJaCKeys(func,oDbg) {
  var seed = Math.random();

  /**
   * @private
   */
  this._k = new Array();
  this._k[0] = seed.toString();
  if (oDbg)
    /**
     * Reference to Debugger
     * @type Debugger
     */
    this.oDbg = oDbg;
  else {
    this.oDbg = {};
    this.oDbg.log = function() {};
  }

  if (func) {
    for (var i=1; i<JSJAC_NKEYS; i++) {
      this._k[i] = func(this._k[i-1]);
      oDbg.log(i+": "+this._k[i],4);
    }
  }

  /**
   * @private
   */
  this._indexAt = JSJAC_NKEYS-1;
  /**
   * Gets next key from stack
   * @return New hash key
   * @type String
   */
  this.getKey = function() {
    return this._k[this._indexAt--];
  };
  /**
   * Indicates whether there's only one key left
   * @return <code>true</code> if there's only one key left, false otherwise
   * @type boolean
   */
  this.lastKey = function() { return (this._indexAt == 0); };
  /**
   * Returns number of overall/initial stack size
   * @return Number of keys created
   * @type int
   */
  this.size = function() { return this._k.length; };

  /**
   * @private
   */
  this._getSuspendVars = function() {
    return ('_k,_indexAt').split(',');
  }
}


/**
 * @fileoverview Contains all things in common for all subtypes of connections
 * supported.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 * @version $Revision$
 */

/**
 * Creates a new Jabber connection (a connection to a jabber server)
 * @class Somewhat abstract base class for jabber connections. Contains all
 * of the code in common for all jabber connections
 * @constructor
 * @param {JSON http://www.json.org/index} oArg JSON with properties: <br>
 * * <code>httpbase</code> the http base address of the service to be used for
 * connecting to jabber<br>
 * * <code>oDbg</code> (optional) a reference to a debugger interface
 */
function JSJaCConnection(oArg) {

  if (oArg && oArg.oDbg && oArg.oDbg.log) {
      /**
       * Reference to debugger interface
       * (needs to implement method <code>log</code>)
       * @type Debugger
       */
    this.oDbg = oArg.oDbg;
  } else {
    this.oDbg = new Object(); // always initialise a debugger
    this.oDbg.log = function() { };
  }

  if (oArg && oArg.timerval)
    this.setPollInterval(oArg.timerval);
  else
    this.setPollInterval(JSJAC_TIMERVAL);

  if (oArg && oArg.httpbase)
      /**
       * @private
       */
    this._httpbase = oArg.httpbase;

  if (oArg &&oArg.allow_plain)
      /**
       * @private
       */
    this.allow_plain = oArg.allow_plain;
  else
    this.allow_plain = JSJAC_ALLOW_PLAIN;

  if (oArg && oArg.cookie_prefix)
      /**
       * @private
       */
    this._cookie_prefix = oArg.cookie_prefix;
  else
    this._cookie_prefix = "";

  /**
   * @private
   */
  this._connected = false;
  /**
   * @private
   */
  this._events = new Array();
  /**
   * @private
   */
  this._keys = null;
  /**
   * @private
   */
  this._ID = 0;
  /**
   * @private
   */
  this._inQ = new Array();
  /**
   * @private
   */
  this._pQueue = new Array();
  /**
   * @private
   */
  this._regIDs = new Array();
  /**
   * @private
   */
  this._req = new Array();
  /**
   * @private
   */
  this._status = 'intialized';
  /**
   * @private
   */
  this._errcnt = 0;
  /**
   * @private
   */
  this._inactivity = JSJAC_INACTIVITY;
  /**
   * @private
   */
  this._sendRawCallbacks = new Array();
}

// Generates an ID
var STANZA_ID = 1;

function genID() {
  return STANZA_ID++;
}

JSJaCConnection.prototype.connect = function(oArg) {
    this._setStatus('connecting');

    this.domain = oArg.domain || 'localhost';
    this.username = oArg.username;
    this.resource = oArg.resource;
    this.pass = oArg.pass;
    this.register = oArg.register;

    this.authhost = oArg.authhost || this.domain;
    this.authtype = oArg.authtype || 'sasl';

    if (oArg.xmllang && oArg.xmllang != '')
        this._xmllang = oArg.xmllang;
    else
        this._xmllang = 'en';

    this.host = oArg.host || this.domain;
    this.port = oArg.port || 5222;
    if (oArg.secure)
        this.secure = 'true';
    else
        this.secure = 'false';

    if (oArg.wait)
        this._wait = oArg.wait;

    this.jid = this.username + '@' + this.domain;
    this.fulljid = this.jid + '/' + this.resource;

    this._rid  = Math.round( 100000.5 + ( ( (900000.49999) - (100000.5) ) * Math.random() ) );

    // setupRequest must be done after rid is created but before first use in reqstr
    var slot = this._getFreeSlot();
    this._req[slot] = this._setupRequest(true);

    var reqstr = this._getInitialRequestString();

    this.oDbg.log(reqstr,4);

    this._req[slot].r.onreadystatechange =
        JSJaC.bind(function() {
            var r = this._req[slot].r;
            if (r.readyState == 4) {
                this.oDbg.log("async recv: "+r.responseText,4);
                this._handleInitialResponse(r); // handle response
            }
        }, this);

    if (typeof(this._req[slot].r.onerror) != 'undefined') {
        this._req[slot].r.onerror =
            JSJaC.bind(function(e) {
                this.oDbg.log('XmlHttpRequest error',1);
                return false;
            }, this);
    }

    this._req[slot].r.send(reqstr);
};

/**
 * Tells whether this connection is connected
 * @return <code>true</code> if this connections is connected,
 * <code>false</code> otherwise
 * @type boolean
 */
JSJaCConnection.prototype.connected = function() { return this._connected; };

/**
 * Disconnects from jabber server and terminates session (if applicable)
 */
JSJaCConnection.prototype.disconnect = function() {
  this._setStatus('disconnecting');
 
  if (!this.connected())
    return;
  this._connected = false;
 
  clearInterval(this._interval);
  clearInterval(this._inQto);
 
  if (this._timeout)
    clearTimeout(this._timeout); // remove timer
 
  var slot = this._getFreeSlot();
  // Intentionally synchronous
  this._req[slot] = this._setupRequest(false);
 
  request = this._getRequestString(false, true);
 
  this.oDbg.log("Disconnecting: " + request,4);
  this._req[slot].r.send(request);
 
  try {
    DataStore.removeDB(MINI_HASH, 'jsjac', 'state');
  } catch (e) {}
 
  this.oDbg.log("Disconnected: "+this._req[slot].r.responseText,2);
  this._handleEvent('ondisconnect');
};

/**
 * Gets current value of polling interval
 * @return Polling interval in milliseconds
 * @type int
 */
JSJaCConnection.prototype.getPollInterval = function() {
  return this._timerval;
};

/**
 * Registers an event handler (callback) for this connection.

 * <p>Note: All of the packet handlers for specific packets (like
 * message_in, presence_in and iq_in) fire only if there's no
 * callback associated with the id.<br>

 * <p>Example:<br/>
 * <code>con.registerHandler('iq', 'query', 'jabber:iq:version', handleIqVersion);</code>


 * @param {String} event One of

 * <ul>
 * <li>onConnect - connection has been established and authenticated</li>
 * <li>onDisconnect - connection has been disconnected</li>
 * <li>onResume - connection has been resumed</li>

 * <li>onStatusChanged - connection status has changed, current
 * status as being passed argument to handler. See {@link #status}.</li>

 * <li>onError - an error has occured, error node is supplied as
 * argument, like this:<br><code>&lt;error code='404' type='cancel'&gt;<br>
 * &lt;item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;<br>
 * &lt;/error&gt;</code></li>

 * <li>packet_in - a packet has been received (argument: the
 * packet)</li>

 * <li>packet_out - a packet is to be sent(argument: the
 * packet)</li>

 * <li>message_in | message - a message has been received (argument:
 * the packet)</li>

 * <li>message_out - a message packet is to be sent (argument: the
 * packet)</li>

 * <li>presence_in | presence - a presence has been received
 * (argument: the packet)</li>

 * <li>presence_out - a presence packet is to be sent (argument: the
 * packet)</li>

 * <li>iq_in | iq - an iq has been received (argument: the packet)</li>
 * <li>iq_out - an iq is to be sent (argument: the packet)</li>
 * </ul>

 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet [optional]

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given) [optional]

 * @param {String} type The type of the packet to handle (works only if childName and chidNS are given (both may be set to '*' in order to get skipped) [optional]

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerHandler = function(event) {
  event = event.toLowerCase(); // don't be case-sensitive here
  var eArg = {handler: arguments[arguments.length-1],
              childName: '*',
              childNS: '*',
              type: '*'};
  if (arguments.length > 2)
    eArg.childName = arguments[1];
  if (arguments.length > 3)
    eArg.childNS = arguments[2];
  if (arguments.length > 4)
    eArg.type = arguments[3];
  if (!this._events[event])
    this._events[event] = new Array(eArg);
  else
    this._events[event] = this._events[event].concat(eArg);

  // sort events in order how specific they match criterias thus using
  // wildcard patterns puts them back in queue when it comes to
  // bubbling the event
  this._events[event] =
  this._events[event].sort(function(a,b) {
    var aRank = 0;
    var bRank = 0;
    with (a) {
      if (type == '*')
        aRank++;
      if (childNS == '*')
        aRank++;
      if (childName == '*')
        aRank++;
    }
    with (b) {
      if (type == '*')
        bRank++;
      if (childNS == '*')
        bRank++;
      if (childName == '*')
        bRank++;
    }
    if (aRank > bRank)
      return 1;
    if (aRank < bRank)
      return -1;
    return 0;
  });
  this.oDbg.log("registered handler for event '"+event+"'",2);
};

JSJaCConnection.prototype.unregisterHandler = function(event,handler) {
  event = event.toLowerCase(); // don't be case-sensitive here

  if (!this._events[event])
    return;

  var arr = this._events[event], res = new Array();
  for (var i=0; i<arr.length; i++)
    if (arr[i].handler != handler)
      res.push(arr[i]);

  if (arr.length != res.length) {
    this._events[event] = res;
    this.oDbg.log("unregistered handler for event '"+event+"'",2);
  }
};

/**
 * Register for iq packets of type 'get'.
 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given)

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerIQGet = function(childName, childNS, handler) {
  this.registerHandler('iq', childName, childNS, 'get', handler);
};

/**
 * Register for iq packets of type 'set'.
 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given)

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerIQSet = function(childName, childNS, handler) {
  this.registerHandler('iq', childName, childNS, 'set', handler);
};

/**
 * Resumes this connection from saved state (cookie)
 * @return Whether resume was successful
 * @type boolean
 */
JSJaCConnection.prototype.resume = function() {
  try {
    var json = DataStore.getDB(MINI_HASH, 'jsjac', 'state');
    this.oDbg.log('read cookie: '+json,2);
    DataStore.removeDB(MINI_HASH, 'jsjac', 'state');

    return this.resumeFromData(JSJaCJSON.parse(json));
  } catch (e) {}
  return false; // sth went wrong
};

/**
 * Resumes BOSH connection from data
 * @param {Object} serialized jsjac state information
 * @return Whether resume was successful
 * @type boolean
 */
JSJaCConnection.prototype.resumeFromData = function(data) {
  try {
    this._setStatus('resuming');

    for (var i in data)
      if (data.hasOwnProperty(i))
        this[i] = data[i];

    // copy keys - not being very generic here :-/
    if (this._keys) {
      this._keys2 = new JSJaCKeys();
      var u = this._keys2._getSuspendVars();
      for (var i=0; i<u.length; i++)
        this._keys2[u[i]] = this._keys[u[i]];
      this._keys = this._keys2;
    }

    if (this._connected) {
      // don't poll too fast!
      this._handleEvent('onresume');
      setTimeout(JSJaC.bind(this._resume, this),this.getPollInterval());
      this._interval = setInterval(JSJaC.bind(this._checkQueue, this),
           JSJAC_CHECKQUEUEINTERVAL);
      this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
        JSJAC_CHECKINQUEUEINTERVAL);
    }

    return (this._connected === true);
  } catch (e) {
    if (e.message)
      this.oDbg.log("Resume failed: "+e.message, 1);
    else
      this.oDbg.log("Resume failed: "+e, 1);
    return false;
  }
};

/**
 * Sends a JSJaCPacket
 * @param {JSJaCPacket} packet  The packet to send
 * @param {Function}    cb      The callback to be called if there's a reply
 * to this packet (identified by id) [optional]
 * @param {Object}      arg     Arguments passed to the callback
 * (additionally to the packet received) [optional]
 * @return 'true' if sending was successfull, 'false' otherwise
 * @type boolean
 */
JSJaCConnection.prototype.send = function(packet,cb,arg) {
  if (!packet || !packet.pType) {
    this.oDbg.log("no packet: "+packet, 1);
    return false;
  }

  if (!this.connected())
    return false;

  // generate an ID for the packet
  if (!packet.getID())
    packet.setID(genID());

  // packet xml:lang
  if (!packet.getXMLLang())
    packet.setXMLLang(XML_LANG);

  // remember id for response if callback present
  if (cb)
    this._registerPID(packet, cb, arg);

  try {
    this._handleEvent(packet.pType()+'_out', packet);
    this._handleEvent("packet_out", packet);
    this._pQueue = this._pQueue.concat(packet.xml());
  } catch (e) {
    this.oDbg.log(e.toString(),1);
    return false;
  }

  return true;
};

/**
 * Sends an IQ packet. Has default handlers for each reply type.
 * Those maybe overriden by passing an appropriate handler.
 * @param {JSJaCIQPacket} iq - the iq packet to send
 * @param {Object} handlers - object with properties 'error_handler',
 *                            'result_handler' and 'default_handler'
 *                            with appropriate functions
 * @param {Object} arg - argument to handlers
 * @return 'true' if sending was successfull, 'false' otherwise
 * @type boolean
 */
JSJaCConnection.prototype.sendIQ = function(iq, handlers, arg) {
  if (!iq || iq.pType() != 'iq') {
    return false;
  }

  handlers = handlers || {};
    var error_handler = handlers.error_handler || JSJaC.bind(function(aIq) {
        this.oDbg.log(aIq.xml(), 1);
    }, this);

    var result_handler = handlers.result_handler ||  JSJaC.bind(function(aIq) {
        this.oDbg.log(aIq.xml(), 2);
    }, this);

  var iqHandler = function(aIq, arg) {
    switch (aIq.getType()) {
      case 'error':
      error_handler(aIq);
      break;
      case 'result':
      result_handler(aIq, arg);
      break;
    }
  };
  return this.send(iq, iqHandler, arg);
};

/**
 * Sets polling interval for this connection
 * @param {int} timerval Milliseconds to set timer to
 * @return effective interval this connection has been set to
 * @type int
 */
JSJaCConnection.prototype.setPollInterval = function(timerval) {
  if (timerval && !isNaN(timerval))
    this._timerval = timerval;
  return this._timerval;
};

/**
 * Returns current status of this connection
 * @return String to denote current state. One of
 * <ul>
 * <li>'initializing' ... well
 * <li>'connecting' if connect() was called
 * <li>'resuming' if resume() was called
 * <li>'processing' if it's about to operate as normal
 * <li>'onerror_fallback' if there was an error with the request object
 * <li>'protoerror_fallback' if there was an error at the http binding protocol flow (most likely that's where you interested in)
 * <li>'internal_server_error' in case of an internal server error
 * <li>'suspending' if suspend() is being called
 * <li>'aborted' if abort() was called
 * <li>'disconnecting' if disconnect() has been called
 * </ul>
 * @type String
 */
JSJaCConnection.prototype.status = function() { return this._status; };

/**
 * Suspends this connection (saving state for later resume)
 * Saves state to cookie
 * @return Whether suspend (saving to cookie) was successful
 * @type boolean
 */
JSJaCConnection.prototype.suspend = function(has_pause) {
  var data = this.suspendToData(has_pause);
  
  try {
    var c = DataStore.setDB(MINI_HASH, 'jsjac', 'state', JSJaCJSON.toString(data));
    return c;
  } catch (e) {
    this.oDbg.log("Failed creating cookie '"+this._cookie_prefix+
                  "JSJaC_State': "+e.message,1);
  }
  return false;
};

/**
 * Suspend connection and return serialized JSJaC connection state
 * @return JSJaC connection state object
 * @type Object
 */
JSJaCConnection.prototype.suspendToData = function(has_pause) {
  
  // remove timers
  if(has_pause) {
    clearTimeout(this._timeout);
    clearInterval(this._interval);
    clearInterval(this._inQto);

    this._suspend();
  }
  
  var u = ('_connected,_keys,_ID,_inQ,_pQueue,_regIDs,_errcnt,_inactivity,domain,username,resource,jid,fulljid,_sid,_httpbase,_timerval,_is_polling').split(',');
  u = u.concat(this._getSuspendVars());
  var s = new Object();

  for (var i=0; i<u.length; i++) {
    if (!this[u[i]]) continue; // hu? skip these!
    if (this[u[i]]._getSuspendVars) {
      var uo = this[u[i]]._getSuspendVars();
      var o = new Object();
      for (var j=0; j<uo.length; j++)
        o[uo[j]] = this[u[i]][uo[j]];
    } else
      var o = this[u[i]];

    s[u[i]] = o;
  }
  
  if(has_pause) {
    this._connected = false;
    this._setStatus('suspending');
  }
  
  return s;
};

/**
 * @private
 */
JSJaCConnection.prototype._abort = function() {
  clearTimeout(this._timeout); // remove timer

  clearInterval(this._inQto);
  clearInterval(this._interval);

  this._connected = false;

  this._setStatus('aborted');

  this.oDbg.log("Disconnected.",1);
  this._handleEvent('ondisconnect');
  this._handleEvent('onerror',
                    JSJaCError('500','cancel','service-unavailable'));
};

/**
 * @private
 */
JSJaCConnection.prototype._checkInQ = function() {
  for (var i=0; i<this._inQ.length && i<10; i++) {
    var item = this._inQ[0];
    this._inQ = this._inQ.slice(1,this._inQ.length);
    var packet = JSJaCPacket.wrapNode(item);

    if (!packet)
      return;

    this._handleEvent("packet_in", packet);

    if (packet.pType && !this._handlePID(packet)) {
      this._handleEvent(packet.pType()+'_in',packet);
      this._handleEvent(packet.pType(),packet);
    }
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._checkQueue = function() {
  if (this._pQueue.length != 0)
    this._process();
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doAuth = function() {
  if (this.has_sasl && this.authtype == 'nonsasl')
    this.oDbg.log("Warning: SASL present but not used", 1);

  if (!this._doSASLAuth() &&
      !this._doLegacyAuth()) {
    this.oDbg.log("Auth failed for authtype "+this.authtype,1);
    this.disconnect();
    return false;
  }
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doInBandReg = function() {
  if (this.authtype == 'saslanon' || this.authtype == 'anonymous')
    return; // bullshit - no need to register if anonymous

  /* ***
   * In-Band Registration see JEP-0077
   */

  var iq = new JSJaCIQ();
  iq.setType('set');
  iq.setID('reg1');
  iq.appendNode("query", {xmlns: "jabber:iq:register"},
                [["username", this.username],
                 ["password", this.pass]]);

  this.send(iq,this._doInBandRegDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doInBandRegDone = function(iq) {
  if (iq && iq.getType() == 'error') { // we failed to register
    this.oDbg.log("registration failed for "+this.username,0);
    this._handleEvent('onerror',iq.getChild('error'));
    return;
  }

  this.oDbg.log(this.username + " registered succesfully",0);

  this._doAuth();
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuth = function() {
  if (this.authtype != 'nonsasl' && this.authtype != 'anonymous')
    return false;

  /* ***
   * Non-SASL Authentication as described in JEP-0078
   */
  var iq = new JSJaCIQ();
  iq.setIQ(null,'get','auth1');
  iq.appendNode('query', {xmlns: 'jabber:iq:auth'},
                [['username', this.username]]);

  this.send(iq,this._doLegacyAuth2);
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuth2 = function(iq) {
  if (!iq || iq.getType() != 'result') {
    if (iq && iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    this.disconnect();
    return;
  }

  var use_digest = (iq.getChild('digest') != null);

  /* ***
   * Send authentication
   */
  var iq = new JSJaCIQ();
  iq.setIQ(null,'set','auth2');

  query = iq.appendNode('query', {xmlns: 'jabber:iq:auth'},
                        [['username', this.username],
                         ['resource', this.resource]]);

  if (use_digest) { // digest login
    query.appendChild(iq.buildNode('digest', {xmlns: 'jabber:iq:auth'},
                                   hex_sha1(this.streamid + this.pass)));
  } else if (this.allow_plain) { // use plaintext auth
    query.appendChild(iq.buildNode('password', {xmlns: 'jabber:iq:auth'},
                                   this.pass));
  } else {
    this.oDbg.log("no valid login mechanism found",1);
    this.disconnect();
    return false;
  }

  this.send(iq,this._doLegacyAuthDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuthDone = function(iq) {
  if (iq.getType() != 'result') { // auth' failed
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    this.disconnect();
  } else
    this._handleEvent('onconnect');
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuth = function() {
  if (this.authtype == 'nonsasl' || this.authtype == 'anonymous')
    return false;

  if (this.authtype == 'saslanon') {
    if (this.mechs['ANONYMOUS']) {
      this.oDbg.log("SASL using mechanism 'ANONYMOUS'",2);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='ANONYMOUS'/>",
                           this._doSASLAuthDone);
    }
    this.oDbg.log("SASL ANONYMOUS requested but not supported",1);
  } else {
    if (this.mechs['DIGEST-MD5']) {
      this.oDbg.log("SASL using mechanism 'DIGEST-MD5'",2);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>",
                           this._doSASLAuthDigestMd5S1);
    } else if (this.allow_plain && this.mechs['PLAIN']) {
      this.oDbg.log("SASL using mechanism 'PLAIN'",2);
      var authStr = this.username+'@'+
      this.domain+String.fromCharCode(0)+
      this.username+String.fromCharCode(0)+
      this.pass;
      this.oDbg.log("authenticating with '"+authStr+"'",2);
      authStr = b64encode(authStr);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='PLAIN'>"+authStr+"</auth>",
                           this._doSASLAuthDone);
    }
    this.oDbg.log("No SASL mechanism applied",1);
    this.authtype = 'nonsasl'; // fallback
  }
  return false;
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDigestMd5S1 = function(el) {
  if (el.nodeName != "challenge") {
    this.oDbg.log("challenge missing",1);
    this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
    this.disconnect();
  } else {
    var challenge = b64decode(el.firstChild.nodeValue);
    this.oDbg.log("got challenge: "+challenge,2);
    this._nonce = challenge.substring(challenge.indexOf("nonce=")+7);
    this._nonce = this._nonce.substring(0,this._nonce.indexOf("\""));
    this.oDbg.log("nonce: "+this._nonce,2);
    if (this._nonce == '' || this._nonce.indexOf('\"') != -1) {
      this.oDbg.log("nonce not valid, aborting",1);
      this.disconnect();
      return;
    }

    this._digest_uri = "xmpp/";
    //     if (typeof(this.host) != 'undefined' && this.host != '') {
    //       this._digest-uri += this.host;
    //       if (typeof(this.port) != 'undefined' && this.port)
    //         this._digest-uri += ":" + this.port;
    //       this._digest-uri += '/';
    //     }
    this._digest_uri += this.domain;

    this._cnonce = cnonce(14);

    this._nc = '00000001';

    var X = this.username+':'+this.domain+':'+this.pass;
    var Y = rstr_md5(str2rstr_utf8(X));

    var A1 = Y+':'+this._nonce+':'+this._cnonce;
    var HA1 = rstr2hex(rstr_md5(A1));

    var A2 = 'AUTHENTICATE:'+this._digest_uri;
    var HA2 = hex_md5(A2);

    var response = hex_md5(HA1+':'+this._nonce+':'+this._nc+':'+
                           this._cnonce+':auth:'+HA2);

    var rPlain = 'username="'+this.username+'",realm="'+this.domain+
    '",nonce="'+this._nonce+'",cnonce="'+this._cnonce+'",nc="'+this._nc+
    '",qop=auth,digest-uri="'+this._digest_uri+'",response="'+response+
    '",charset="utf-8"';

    this.oDbg.log("response: "+rPlain,2);

    this._sendRaw("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>"+
                  b64encode(rPlain)+"</response>",
                  this._doSASLAuthDigestMd5S2);
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDigestMd5S2 = function(el) {
  if (el.nodeName == 'failure') {
    if (el.xml)
      this.oDbg.log("auth error: "+el.xml,1);
    else
      this.oDbg.log("auth error",1);
    this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
    this.disconnect();
    return;
  }

  var response = b64decode(el.firstChild.nodeValue);
  this.oDbg.log("response: "+response,2);

  var rspauth = response.substring(response.indexOf("rspauth=")+8);
  this.oDbg.log("rspauth: "+rspauth,2);

  var X = this.username+':'+this.domain+':'+this.pass;
  var Y = rstr_md5(str2rstr_utf8(X));

  var A1 = Y+':'+this._nonce+':'+this._cnonce;
  var HA1 = rstr2hex(rstr_md5(A1));

  var A2 = ':'+this._digest_uri;
  var HA2 = hex_md5(A2);

  var rsptest = hex_md5(HA1+':'+this._nonce+':'+this._nc+':'+
                        this._cnonce+':auth:'+HA2);
  this.oDbg.log("rsptest: "+rsptest,2);

  if (rsptest != rspauth) {
    this.oDbg.log("SASL Digest-MD5: server repsonse with wrong rspauth",1);
    this.disconnect();
    return;
  }

    if (el.nodeName == 'success') {
        this._reInitStream(JSJaC.bind(this._doStreamBind, this));
    } else { // some extra turn
        this._sendRaw("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>",
                      this._doSASLAuthDone);
    }
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDone = function (el) {
    if (el.nodeName != 'success') {
        this.oDbg.log("auth failed",1);
        this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
        this.disconnect();
    } else {
        this._reInitStream(JSJaC.bind(this._doStreamBind, this));
    }
};

/**
 * @private
 */
JSJaCConnection.prototype._doStreamBind = function() {
  var iq = new JSJaCIQ();
  iq.setIQ(null,'set','bind_1');
  iq.appendNode("bind", {xmlns: "urn:ietf:params:xml:ns:xmpp-bind"},
                [["resource", this.resource]]);
  this.oDbg.log(iq.xml());
  this.send(iq,this._doXMPPSess);
};

/**
 * @private
 */
JSJaCConnection.prototype._doXMPPSess = function(iq) {
  if (iq.getType() != 'result' || iq.getType() == 'error') { // failed
    this.disconnect();
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    return;
  }

  this.fulljid = iq.getChildVal("jid");
  this.jid = this.fulljid.substring(0,this.fulljid.lastIndexOf('/'));

  if (!this.legacy_sessions) {
    this._handleEvent('onconnect');
    return;
  }

  iq = new JSJaCIQ();
  iq.setIQ(null,'set','sess_1');
  iq.appendNode("session", {xmlns: "urn:ietf:params:xml:ns:xmpp-session"},
                []);
  this.oDbg.log(iq.xml());
  this.send(iq,this._doXMPPSessDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doXMPPSessDone = function(iq) {
  if (iq.getType() != 'result' || iq.getType() == 'error') { // failed
    this.disconnect();
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    return;
  } else
    this._handleEvent('onconnect');
};

/**
 * @private
 */
JSJaCConnection.prototype._handleEvent = function(event,arg) {
  event = event.toLowerCase(); // don't be case-sensitive here
  this.oDbg.log("incoming event '"+event+"'",3);
  if (!this._events[event])
    return;
  this.oDbg.log("handling event '"+event+"'",2);
  for (var i=0;i<this._events[event].length; i++) {
    var aEvent = this._events[event][i];
    if (typeof aEvent.handler == 'function') {
      try {
        if (arg) {
          if (arg.pType) { // it's a packet
            if ((!arg.getNode().hasChildNodes() && aEvent.childName != '*') ||
        (arg.getNode().hasChildNodes() &&
         !arg.getChild(aEvent.childName, aEvent.childNS)))
              continue;
            if (aEvent.type != '*' &&
                arg.getType() != aEvent.type)
              continue;
            this.oDbg.log(aEvent.childName+"/"+aEvent.childNS+"/"+aEvent.type+" => match for handler "+aEvent.handler,3);
          }
          if (aEvent.handler(arg)) {
            // handled!
            break;
          }
        }
        else
          if (aEvent.handler()) {
            // handled!
            break;
          }
      } catch (e) {

        if (e.fileName&&e.lineNumber) {
            this.oDbg.log(aEvent.handler+"\n>>>"+e.name+": "+ e.message+' in '+e.fileName+' line '+e.lineNumber,1);
        } else {
            this.oDbg.log(aEvent.handler+"\n>>>"+e.name+": "+ e.message,1);
        }

      }
    }
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._handlePID = function(packet) {
  if (!packet.getID())
    return false;

  if (packet.pType() != 'iq' ||
         (packet.getType() != 'error' && packet.getType() != 'result'))
    return false; 

  var jid = packet.getFrom() || this.jid;

  if (packet.getFrom() == this.domain)
    jid = this.jid;

  var id = packet.getID();
  if (this._regIDs[jid] && this._regIDs[jid][id]) {
    try {
      this.oDbg.log("handling id "+id,3);
      var reg = this._regIDs[jid][id];
      if (reg.cb.call(this, packet, reg.arg) === false) {
        // don't unregister
        return false;
      } else {
        delete this._regIDs[jid][id];
        return true;
      }
    } catch (e) {
      // broken handler?
      this.oDbg.log(e.name+": "+ e.message, 1);
      delete this._regIDs[jid][id];
      return true;
    }
  } else {
    this.oDbg.log("not handling id '"+id+"' from jid "+jid, 1);
  }
  return false;
};

/**
 * @private
 */
JSJaCConnection.prototype._handleResponse = function(req) {
  var rootEl = this._parseResponse(req);

  if (!rootEl)
    return;

  for (var i=0; i<rootEl.childNodes.length; i++) {
    if (this._sendRawCallbacks.length) {
      var cb = this._sendRawCallbacks[0];
      this._sendRawCallbacks = this._sendRawCallbacks.slice(1, this._sendRawCallbacks.length);
      cb.fn.call(this, rootEl.childNodes.item(i), cb.arg);
      continue;
    }
    this._inQ = this._inQ.concat(rootEl.childNodes.item(i));
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._parseStreamFeatures = function(doc) {
    if (!doc) {
        this.oDbg.log("nothing to parse ... aborting",1);
        return false;
    }

    var errorTag;
    if (doc.getElementsByTagNameNS) {
        errorTag = doc.getElementsByTagNameNS("http://etherx.jabber.org/streams", "error").item(0);
    } else {
        var errors = doc.getElementsByTagName("error");
        for (var i=0; i<errors.length; i++)
            if (errors.item(i).namespaceURI == "http://etherx.jabber.org/streams" ||
                errors.item(i).getAttribute('xmlns') == "http://etherx.jabber.org/streams") {
                errorTag = errors.item(i);
                break;
            }
    }

    if (errorTag) {
        this._setStatus("internal_server_error");
        clearTimeout(this._timeout); // remove timer
        clearInterval(this._interval);
        clearInterval(this._inQto);
        this._handleEvent('onerror',JSJaCError('503','cancel','session-terminate'));
        this._connected = false;
        this.oDbg.log("Disconnected.",1);
        this._handleEvent('ondisconnect');
        return false;
    }
    
    this.mechs = new Object();
    var lMec1 = doc.getElementsByTagName("mechanisms");
    this.has_sasl = false;
    for (var i=0; i<lMec1.length; i++)
        if (lMec1.item(i).getAttribute("xmlns") ==
            "urn:ietf:params:xml:ns:xmpp-sasl") {
            this.has_sasl=true;
            var lMec2 = lMec1.item(i).getElementsByTagName("mechanism");
            for (var j=0; j<lMec2.length; j++)
                this.mechs[lMec2.item(j).firstChild.nodeValue] = true;
            break;
        }
    if (this.has_sasl)
        this.oDbg.log("SASL detected",2);
    else {
        this.oDbg.log("No support for SASL detected",2);
        return false;
    }
    
    // Get the server CAPS (if available)
    this.server_caps=null;
    var sCaps = doc.getElementsByTagName("c");
    for (var i=0; i<sCaps.length; i++) {
      var c_sCaps=sCaps.item(i);
      var x_sCaps=c_sCaps.getAttribute("xmlns");
      var v_sCaps=c_sCaps.getAttribute("ver");
      
      if ((x_sCaps == NS_CAPS) && v_sCaps) {
        this.server_caps=v_sCaps;
        break;
      }
    }

    // Get legacy session capability if available
    this.legacy_sessions=null;
    if (doc.getElementsByTagName("session")[0]) {
	this.legacy_sessions=true;
    }
    
    return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._process = function(timerval) {
  if (!this.connected()) {
    this.oDbg.log("Connection lost ...",1);
    if (this._interval)
      clearInterval(this._interval);
    return;
  }

  this.setPollInterval(timerval);

  if (this._timeout)
    clearTimeout(this._timeout);

  var slot = this._getFreeSlot();

  if (slot < 0)
    return;

  if (typeof(this._req[slot]) != 'undefined' &&
      typeof(this._req[slot].r) != 'undefined' &&
      this._req[slot].r.readyState != 4) {
    this.oDbg.log("Slot "+slot+" is not ready");
    return;
  }

  if (!this.isPolling() && this._pQueue.length == 0 &&
      this._req[(slot+1)%2] && this._req[(slot+1)%2].r.readyState != 4) {
    this.oDbg.log("all slots busy, standby ...", 2);
    return;
  }

  if (!this.isPolling())
    this.oDbg.log("Found working slot at "+slot,2);

  this._req[slot] = this._setupRequest(true);

  /* setup onload handler for async send */
  this._req[slot].r.onreadystatechange =
  JSJaC.bind(function() {
               if (this._req[slot].r.readyState == 4) {
                 this._setStatus('processing');
                 this.oDbg.log("async recv: "+this._req[slot].r.responseText,4);
                 this._handleResponse(this._req[slot]);

                 if (!this.connected())
                   return;

                 // schedule next tick
                 if (this._pQueue.length) {
                   this._timeout = setTimeout(JSJaC.bind(this._process, this),100);
                 } else {
                   this.oDbg.log("scheduling next poll in "+this.getPollInterval()+
                                 " msec", 4);
                   this._timeout = setTimeout(JSJaC.bind(this._process, this),this.getPollInterval());
                 }
               }
             }, this);

  try {
    this._req[slot].r.onerror =
      JSJaC.bind(function() {
                   if (!this.connected())
                     return;
                   this._errcnt++;
                   this.oDbg.log('XmlHttpRequest error ('+this._errcnt+')',1);
                   if (this._errcnt > JSJAC_ERR_COUNT) {
                     // abort
                     this._abort();
                     return false;
                   }

                   this._setStatus('onerror_fallback');

                   // schedule next tick
                   setTimeout(JSJaC.bind(this._resume, this),this.getPollInterval());
                   return false;
                 }, this);
  } catch(e) { } // well ... no onerror property available, maybe we
  // can catch the error somewhere else ...

  var reqstr = this._getRequestString();

  if (typeof(this._rid) != 'undefined') // remember request id if any
    this._req[slot].rid = this._rid;

  this.oDbg.log("sending: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};

/**
 * @private
   @param {JSJaCPacket} packet The packet to be sent.
   @param {function} cb The callback to be called when response is received.
   @param {any} arg Optional arguments to be passed to 'cb' when executing it.
   @return Whether registering an ID was successful
   @type boolean
 */
JSJaCConnection.prototype._registerPID = function(packet, cb, arg) {
  this.oDbg.log("registering id for packet "+packet.xml(), 3);
  var id = packet.getID();
  if (!id) {
    this.oDbg.log("id missing", 1);
    return false;
  }

  if (typeof cb != 'function') {
    this.oDbg.log("callback is not a function", 1);
    return false;
  }

  var jid = packet.getTo() || this.jid;

  if (packet.getTo() == this.domain)
    jid = this.jid;

  if (!this._regIDs[jid]) {
    this._regIDs[jid] = {};
  }

  if (this._regIDs[jid][id] != null) {
    this.oDbg.log("id already registered: " + id, 1);
    return false;
  }
  this._regIDs[jid][id] = {
      cb:  cb,
      arg: arg,
      ts:  Date.now()
  };
  this.oDbg.log("registered id "+id,3);
  this._cleanupRegisteredPIDs();
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._cleanupRegisteredPIDs = function() {
  var now = Date.now();
  for (var jid in this._regIDs) {
    if (this._regIDs.hasOwnProperty(jid)) {
      for (var id in this._regIDs[jid]) {
        if (this._regIDs[jid].hasOwnProperty(id)) {
          if (this._regIDs[jid][id].ts + JSJAC_REGID_TIMEOUT < now) {
            this.oDbg.log("deleting registered id '"+id+ "' due to timeout", 1);
            delete this._regIDs[jid][id];
          }
        }
      }
    }
  }
};

/**
 * Partial function binding sendEmpty to callback
 * @private
 */
JSJaCConnection.prototype._prepSendEmpty = function(cb, ctx) {
    return function() {
        ctx._sendEmpty(JSJaC.bind(cb, ctx));
    };
};

/**
 * send empty request
 * waiting for stream id to be able to proceed with authentication
 * @private
 */
JSJaCConnection.prototype._sendEmpty = function(cb) {
  var slot = this._getFreeSlot();
  this._req[slot] = this._setupRequest(true);

  this._req[slot].r.onreadystatechange =
  JSJaC.bind(function() {
               if (this._req[slot].r.readyState == 4) {
                 this.oDbg.log("async recv: "+this._req[slot].r.responseText,4);
                   cb(this._req[slot].r); // handle response
               }
             },this);

  if (typeof(this._req[slot].r.onerror) != 'undefined') {
    this._req[slot].r.onerror =
      JSJaC.bind(function(e) {
                   this.oDbg.log('XmlHttpRequest error',1);
                   return false;
                 }, this);
  }

  var reqstr = this._getRequestString();
  this.oDbg.log("sending: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};

/**
 * @private
 */
JSJaCConnection.prototype._sendRaw = function(xml,cb,arg) {
  if (cb)
    this._sendRawCallbacks.push({fn: cb, arg: arg});

  this._pQueue.push(xml);
  this._process();

  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._setStatus = function(status) {
  if (!status || status == '')
    return;
  if (status != this._status) { // status changed!
    this._status = status;
    this._handleEvent('onstatuschanged', status);
    this._handleEvent('status_changed', status);
  }
};


/**
 * @fileoverview All stuff related to HTTP Binding
 * @author Stefan Strigler steve@zeank.in-berlin.de
 * @version $Revision$
 */

/**
 * Instantiates an HTTP Binding session
 * @class Implementation of {@link
 * http://www.xmpp.org/extensions/xep-0206.html XMPP Over BOSH}
 * formerly known as HTTP Binding.
 * @extends JSJaCConnection
 * @constructor
 */
function JSJaCHttpBindingConnection(oArg) {
  /**
   * @ignore
   */
  this.base = JSJaCConnection;
  this.base(oArg);

  // member vars
  /**
   * @private
   */
  this._hold = JSJACHBC_MAX_HOLD;
  /**
   * @private
   */
  this._inactivity = 0;
  /**
   * @private
   */
  this._last_requests = new Object(); // 'hash' storing hold+1 last requests
  /**
   * @private
   */
  this._last_rid = 0;                 // I know what you did last summer
  /**
   * @private
   */
  this._min_polling = 0;

  /**
   * @private
   */
  this._pause = 0;
  /**
   * @private
   */
  this._wait = JSJACHBC_MAX_WAIT;
}
JSJaCHttpBindingConnection.prototype = new JSJaCConnection();

/**
 * Inherit an instantiated HTTP Binding session
 */
JSJaCHttpBindingConnection.prototype.inherit = function(oArg) {
  if (oArg.jid) {
    var oJid = new JSJaCJID(oArg.jid);
    this.domain = oJid.getDomain();
    this.username = oJid.getNode();
    this.resource = oJid.getResource();
  } else {
    this.domain = oArg.domain || 'localhost';
    this.username = oArg.username;
    this.resource = oArg.resource;
  }
  this._sid = oArg.sid;
  this._rid = oArg.rid;
  this._min_polling = oArg.polling;
  this._inactivity = oArg.inactivity;
  this._setHold(oArg.requests-1);
  this.setPollInterval(this._timerval);
  if (oArg.wait)
    this._wait = oArg.wait; // for whatever reason

  this._connected = true;

  this._handleEvent('onconnect');

  this._interval= setInterval(JSJaC.bind(this._checkQueue, this),
                              JSJAC_CHECKQUEUEINTERVAL);
  this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
                            JSJAC_CHECKINQUEUEINTERVAL);
  this._timeout = setTimeout(JSJaC.bind(this._process, this),
                             this.getPollInterval());
};

/**
 * Sets poll interval
 * @param {int} timerval the interval in seconds
 */
JSJaCHttpBindingConnection.prototype.setPollInterval = function(timerval) {
  if (timerval && !isNaN(timerval)) {
    if (!this.isPolling())
      this._timerval = 100;
    else if (this._min_polling && timerval < this._min_polling*1000)
      this._timerval = this._min_polling*1000;
    else if (this._inactivity && timerval > this._inactivity*1000)
      this._timerval = this._inactivity*1000;
    else
      this._timerval = timerval;
  }
  return this._timerval;
};

/**
 * whether this session is in polling mode
 * @type boolean
 */
JSJaCHttpBindingConnection.prototype.isPolling = function() { return (this._hold == 0) };

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getFreeSlot = function() {
  for (var i=0; i<this._hold+1; i++)
    if (typeof(this._req[i]) == 'undefined' || typeof(this._req[i].r) == 'undefined' || this._req[i].r.readyState == 4)
      return i;
  return -1; // nothing found
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getHold = function() { return this._hold; };

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getRequestString = function(raw, last) {
  raw = raw || '';
  var reqstr = '';

  // check if we're repeating a request

  if (this._rid <= this._last_rid && typeof(this._last_requests[this._rid]) != 'undefined') // repeat!
    reqstr = this._last_requests[this._rid].xml;
  else { // grab from queue
    var xml = '';
    while (this._pQueue.length) {
      var curNode = this._pQueue[0];
      xml += curNode;
      this._pQueue = this._pQueue.slice(1,this._pQueue.length);
    }

    reqstr = "<body xml:lang='"+XML_LANG+"' rid='"+this._rid+"' sid='"+this._sid+"' xmlns='http://jabber.org/protocol/httpbind' ";
    if (JSJAC_HAVEKEYS) {
      reqstr += "key='"+this._keys.getKey()+"' ";
      if (this._keys.lastKey()) {
        this._keys = new JSJaCKeys(hex_sha1,this.oDbg);
        reqstr += "newkey='"+this._keys.getKey()+"' ";
      }
    }
    if (last)
      reqstr += "type='terminate'";
    else if (this._reinit) {
      if (JSJACHBC_USE_BOSH_VER)
        reqstr += "xmpp:restart='true' xmlns:xmpp='urn:xmpp:xbosh' to='"+this.domain+"'";
      this._reinit = false;
    }

    if (xml != '' || raw != '') {
      reqstr += ">" + raw + xml + "</body>";
    } else {
      reqstr += "/>";
    }

    this._last_requests[this._rid] = new Object();
    this._last_requests[this._rid].xml = reqstr;
    this._last_rid = this._rid;

    for (var i in this._last_requests)
      if (this._last_requests.hasOwnProperty(i) &&
          i < this._rid-this._hold)
        delete(this._last_requests[i]); // truncate
  }

  return reqstr;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getInitialRequestString = function() {
  var reqstr = "<body xml:lang='"+XML_LANG+"' content='text/xml; charset=utf-8' hold='"+this._hold+"' xmlns='http://jabber.org/protocol/httpbind' to='"+this.authhost+"' wait='"+this._wait+"' rid='"+this._rid+"'";
  if (this.secure)
    reqstr += " secure='"+this.secure+"'";
  if (JSJAC_HAVEKEYS) {
    this._keys = new JSJaCKeys(hex_sha1,this.oDbg); // generate first set of keys
    key = this._keys.getKey();
    reqstr += " newkey='"+key+"'";
  }

  if (JSJACHBC_USE_BOSH_VER) {
    reqstr += " ver='" + JSJACHBC_BOSH_VERSION + "'";
    reqstr += " xmlns:xmpp='urn:xmpp:xbosh'";
    if (this.authtype == 'sasl' || this.authtype == 'saslanon')
      reqstr += " xmpp:version='1.0'";
  }
  reqstr += "/>";
  return reqstr;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getStreamID = function(req) {

  this.oDbg.log(req.responseText,4);

  if (!req.responseXML || !req.responseXML.documentElement) {
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }
  var body = req.responseXML.documentElement;
  
  // any session error?
  if(body.getAttribute('type') == 'terminate') {
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }
  
  // extract stream id used for non-SASL authentication
  if (body.getAttribute('authid')) {
    this.streamid = body.getAttribute('authid');
    this.oDbg.log("got streamid: "+this.streamid,2);
  }

  if (!this._parseStreamFeatures(body)) {
      this._sendEmpty(JSJaC.bind(this._getStreamID, this));
      return;
  }

  this._timeout = setTimeout(JSJaC.bind(this._process, this),
                             this.getPollInterval());

  if (this.register)
    this._doInBandReg();
  else
    this._doAuth();
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getSuspendVars = function() {
  return ('host,port,secure,_rid,_last_rid,_wait,_min_polling,_inactivity,_hold,_last_requests,_pause').split(',');
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._handleInitialResponse = function(req) {
  try {
    // This will throw an error on Mozilla when the connection was refused
    this.oDbg.log(req.getAllResponseHeaders(),4);
    this.oDbg.log(req.responseText,4);
  } catch(ex) {
    this.oDbg.log("No response",4);
  }

  if (req.status != 200 || !req.responseXML) {
    this.oDbg.log("initial response broken (status: "+req.status+")",1);
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }
  var body = req.responseXML.documentElement;

  if (!body || body.tagName != 'body' || body.namespaceURI != 'http://jabber.org/protocol/httpbind') {
    this.oDbg.log("no body element or incorrect body in initial response",1);
    this._handleEvent("onerror",JSJaCError("500","wait","internal-service-error"));
    return;
  }

  // Check for errors from the server
  if (body.getAttribute("type") == "terminate") {
    this.oDbg.log("invalid response:\n" + req.responseText,1);
    clearTimeout(this._timeout); // remove timer
    this._connected = false;
    this.oDbg.log("Disconnected.",1);
    this._handleEvent('ondisconnect');
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }

  // get session ID
  this._sid = body.getAttribute('sid');
  this.oDbg.log("got sid: "+this._sid,2);

  // get attributes from response body
  if (body.getAttribute('polling'))
    this._min_polling = body.getAttribute('polling');

  if (body.getAttribute('inactivity'))
    this._inactivity = body.getAttribute('inactivity');

  if (body.getAttribute('requests'))
    this._setHold(body.getAttribute('requests')-1);
  this.oDbg.log("set hold to " + this._getHold(),2);

  if (body.getAttribute('ver'))
    this._bosh_version = body.getAttribute('ver');

  if (body.getAttribute('maxpause'))
    this._pause = Number.min(body.getAttribute('maxpause'), JSJACHBC_MAXPAUSE);

  // must be done after response attributes have been collected
  this.setPollInterval(this._timerval);

  /* start sending from queue for not polling connections */
  this._connected = true;

  this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
                            JSJAC_CHECKINQUEUEINTERVAL);
  this._interval= setInterval(JSJaC.bind(this._checkQueue, this),
                              JSJAC_CHECKQUEUEINTERVAL);

  /* wait for initial stream response to extract streamid needed
   * for digest auth
   */
  this._getStreamID(req);
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._parseResponse = function(req) {
  if (!this.connected() || !req)
    return null;

  var r = req.r; // the XmlHttpRequest

  try {
    if (r.status == 404 || r.status == 403) {
      // connection manager killed session
      this._abort();
      return null;
    }

    if (r.status != 200 || !r.responseXML) {
      this._errcnt++;
      var errmsg = "invalid response ("+r.status+"):\n" + r.getAllResponseHeaders()+"\n"+r.responseText;
      if (!r.responseXML)
        errmsg += "\nResponse failed to parse!";
      this.oDbg.log(errmsg,1);
      if (this._errcnt > JSJAC_ERR_COUNT) {
        // abort
        this._abort();
        return null;
      }

      if (this.connected()) {
        this.oDbg.log("repeating ("+this._errcnt+")",1);
        this._setStatus('proto_error_fallback');

        // schedule next tick
        setTimeout(JSJaC.bind(this._resume, this),
                   this.getPollInterval());
      }

      return null;
    }
  } catch (e) {
    this.oDbg.log("XMLHttpRequest error: status not available", 1);
    this._errcnt++;
    if (this._errcnt > JSJAC_ERR_COUNT) {
      // abort
      this._abort();
    } else {
      if (this.connected()) {
        this.oDbg.log("repeating ("+this._errcnt+")",1);

        this._setStatus('proto_error_fallback');

        // schedule next tick
        setTimeout(JSJaC.bind(this._resume, this),
                   this.getPollInterval());
      }
    }
    return null;
  }

  var body = r.responseXML.documentElement;
  if (!body || body.tagName != 'body' ||
    body.namespaceURI != 'http://jabber.org/protocol/httpbind') {
    this.oDbg.log("invalid response:\n" + r.responseText,1);

    clearTimeout(this._timeout); // remove timer
    clearInterval(this._interval);
    clearInterval(this._inQto);

    this._connected = false;
    this.oDbg.log("Disconnected.",1);
    this._handleEvent('ondisconnect');

    this._setStatus('internal_server_error');
    this._handleEvent('onerror',
          JSJaCError('500','wait','internal-server-error'));

    return null;
  }

  if (typeof(req.rid) != 'undefined' && this._last_requests[req.rid]) {
    if (this._last_requests[req.rid].handled) {
      this.oDbg.log("already handled "+req.rid,2);
      return null;
    } else
      this._last_requests[req.rid].handled = true;
  }


  // Check for errors from the server
  if (body.getAttribute("type") == "terminate") {
    // read condition
    var condition = body.getAttribute('condition');

    if (condition != "item-not-found") {
      this.oDbg.log("session terminated:\n" + r.responseText,1);

      clearTimeout(this._timeout); // remove timer
      clearInterval(this._interval);
      clearInterval(this._inQto);

      try {
        DataStore.removeDB(MINI_HASH, 'jsjac', 'state');
      } catch (e) {}

      this._connected = false;

      if (condition == "remote-stream-error")
        if (body.getElementsByTagName("conflict").length > 0)
          this._setStatus("session-terminate-conflict");
      if (condition == null)
        condition = 'session-terminate';
      this._handleEvent('onerror',JSJaCError('503','cancel',condition));

      this.oDbg.log("Aborting remaining connections",4);

      for (var i=0; i<this._hold+1; i++) {
        try {
          this._req[i].r.abort();
        } catch(e) { this.oDbg.log(e, 1); }
      }

      this.oDbg.log("parseResponse done with terminating", 3);

      this.oDbg.log("Disconnected.",1);
      this._handleEvent('ondisconnect');
    } else {
      this._errcnt++;
      if (this._errcnt > JSJAC_ERR_COUNT)
        this._abort();
    }
    return null;
  }

  // no error
  this._errcnt = 0;
  return r.responseXML.documentElement;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._reInitStream = function(cb) {
    // tell http binding to reinit stream with/before next request
    this._reinit = true;

    this._sendEmpty(this._prepReInitStreamWait(cb));
};


JSJaCHttpBindingConnection.prototype._prepReInitStreamWait = function(cb) {
    return JSJaC.bind(function(req) {
        this._reInitStreamWait(req, cb);
    }, this);
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._reInitStreamWait = function(req, cb) {
    this.oDbg.log("checking for stream features");
    var doc = req.responseXML.documentElement;
    this.oDbg.log(doc);
    if (doc.getElementsByTagNameNS) {
        this.oDbg.log("checking with namespace");
        var features = doc.getElementsByTagNameNS('http://etherx.jabber.org/streams',
                                                'features').item(0);
        if (features) {
            var bind = features.getElementsByTagNameNS('urn:ietf:params:xml:ns:xmpp-bind',
                                                       'bind').item(0);
        }
    } else {
        var featuresNL = doc.getElementsByTagName('stream:features');
        for (var i=0, l=featuresNL.length; i<l; i++) {
            if (featuresNL.item(i).namespaceURI == 'http://etherx.jabber.org/streams' ||
                featuresNL.item(i).getAttribute('xmlns') == 
                'http://etherx.jabber.org/streams') {
                var features = featuresNL.item(i);
                break;
            }
        }
        if (features) {
            var bind = features.getElementsByTagName('bind');
            for (var i=0, l=bind.length; i<l; i++) {
                if (bind.item(i).namespaceURI == 'urn:ietf:params:xml:ns:xmpp-bind' ||
                    bind.item(i).getAttribute('xmlns') == 
                    'urn:ietf:params:xml:ns:xmpp-bind') {
                    bind = bind.item(i);
                    break;
                }
            }
        }
    }
    this.oDbg.log(features);
    this.oDbg.log(bind);
    
    if (features) {
        if (bind) {
            cb();
        } else {
            this.oDbg.log("no bind feature - giving up",1);
            this._handleEvent('onerror',JSJaCError('503','cancel',"service-unavailable"));
            this._connected = false;
            this.oDbg.log("Disconnected.",1);
            this._handleEvent('ondisconnect');
        }
    } else {
        // wait
        this._sendEmpty(this._prepReInitStreamWait(cb));
    }
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._resume = function() {
  /* make sure to repeat last request as we can be sure that
   * it had failed (only if we're not using the 'pause' attribute
   */
  if (this._pause == 0 && this._rid >= this._last_rid)
    this._rid = this._last_rid-1;

  this._process();
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._setHold = function(hold)  {
  if (!hold || isNaN(hold) || hold < 0)
    hold = 0;
  else if (hold > JSJACHBC_MAX_HOLD)
    hold = JSJACHBC_MAX_HOLD;
  this._hold = hold;
  return this._hold;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._setupRequest = function(async) {
  var req = new Object();
  var r = XmlHttp.create();
  try {
    r.open("POST",this._httpbase,async);
    r.setRequestHeader('Content-Type','text/xml; charset=utf-8');
  } catch(e) { this.oDbg.log(e,1); }
  req.r = r;
  this._rid++;
  req.rid = this._rid;
  return req;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._suspend = function() {
  if (this._pause == 0)
    return; // got nothing to do

  var slot = this._getFreeSlot();
  // Intentionally synchronous
  this._req[slot] = this._setupRequest(false);

  var reqstr = "<body xml:lang='"+XML_LANG+"' pause='"+this._pause+"' xmlns='http://jabber.org/protocol/httpbind' sid='"+this._sid+"' rid='"+this._rid+"'";
  if (JSJAC_HAVEKEYS) {
    reqstr += " key='"+this._keys.getKey()+"'";
    if (this._keys.lastKey()) {
      this._keys = new JSJaCKeys(hex_sha1,this.oDbg);
      reqstr += " newkey='"+this._keys.getKey()+"'";
    }

  }
  reqstr += ">";

  while (this._pQueue.length) {
    var curNode = this._pQueue[0];
    reqstr += curNode;
    this._pQueue = this._pQueue.slice(1,this._pQueue.length);
  }

  //reqstr += "<presence type='unavailable' xmlns='jabber:client'/>";
  reqstr += "</body>";

  this.oDbg.log("Disconnecting: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};

/**
 * @author Janusz Dziemidowicz rraptorr@nails.eu.org
 * @fileoverview All stuff related to WebSocket
 * <pre>
 * The WebSocket protocol is a bit of a mess. Various, incompatible,
 * protocol drafts were implemented in browsers. Fortunately, recently
 * a finished protocol was released in RFC6455. Further description
 * assumes RFC6455 WebSocket protocol version.
 *
 * WebSocket browser support. Current (November 2012) browser status:
 * - Chrome 16+ - works properly and supports RFC6455
 * - Firefox 16+ - works properly and support RFC6455 (ealier versions
 *   have problems with proxies)
 * - Opera 12.10 - supports RFC6455, but does not work at all if a
 *   proxy is configured (earlier versions do not support RFC6455)
 * - Internet Explorer 10+ - works properly and supports RFC6455
 *
 * Due to the above status, this code is currently recommended on
 * Chrome 16+, Firefox 16+ and Internet Explorer 10+. Using it on
 * other browsers is discouraged.
 *
 * Please also note that some users are only able to connect to ports
 * 80 and 443. Port 80 is sometimes intercepted by transparent HTTP
 * proxies, which mostly does not support WebSocket, so port 443 is
 * the best choice currently (it does not have to be
 * encrypted). WebSocket also usually does not work well with reverse
 * proxies, be sure to make extensive tests if you use one.
 *
 * There is no standard for XMPP over WebSocket. However, there is a
 * draft (http://tools.ietf.org/html/draft-ietf-xmpp-websocket-00) and
 * this implementation follows it.
 *
 * Tested servers:
 *
 * - node-xmpp-bosh (https://github.com/dhruvbird/node-xmpp-bosh) -
 *   supports RFC6455 and works with no problems since 0.6.1, it also
 *   transparently uses STARTTLS if necessary
 * - wxg (https://github.com/Gordin/wxg) - supports RFC6455 and works
 *   with no problems, but cannot connect to servers requiring
 *   STARTTLS (original wxg at https://github.com/hocken/wxg has some
 *   issues, that were fixed by Gordin).
 * - ejabberd-websockets
 *   (https://github.com/superfeedr/ejabberd-websockets) - does not
 *   support RFC6455 hence it does not work, adapting it to support
 *   RFC6455 should be quite easy for anyone knowing Erlang (some work
 *   in progress can be found on github)
 * - Openfire (http://www.igniterealtime.org/projects/openfire/) -
 *   unofficial plugin is available, but it lacks support
 *   for RFC6455 hence it does not work
 * - Apache Vysper (http://mina.apache.org/vysper/) - does
 *   not support RFC6455 hence does not work
 * - Tigase (http://www.tigase.org/) - works fine since 5.2.0.
 * - MongooseIM (https://github.com/esl/ejabberd) - a fork of ejabberd
 *   with support for XMPP over Websockets.
 * </pre>
 */

/*exported JSJaCWebSocketConnection */

/**
 * Instantiates a WebSocket session.
 * @class Implementation of {@link http://tools.ietf.org/html/draft-ietf-xmpp-websocket-00 | An XMPP Sub-protocol for WebSocket}.
 * @extends JSJaCConnection
 * @constructor
 * @param {Object} oArg connection properties.
 * @param {string} oArg.httpbase WebSocket connection endpoint (i.e. ws://localhost:5280)
 * @param {JSJaCDebugger} [oArg.oDbg] A reference to a debugger implementing the JSJaCDebugger interface.
 */
function JSJaCWebSocketConnection(oArg) {
  this.base = JSJaCConnection;
  this.base(oArg);

  this._ws = null;

  this.registerHandler('onerror', JSJaC.bind(this._cleanupWebSocket, this));
}

JSJaCWebSocketConnection.prototype = new JSJaCConnection();

JSJaCWebSocketConnection.prototype._cleanupWebSocket = function() {
  if (this._ws !== null) {
    this._ws.onclose = null;
    this._ws.onerror = null;
    this._ws.onopen = null;
    this._ws.onmessage = null;

    this._ws.close();
    this._ws = null;
  }
};

/**
 * Connect to a jabber/XMPP server.
 * @param {Object} oArg The configuration to be used for connecting.
 * @param {string} oArg.domain The domain name of the XMPP service.
 * @param {string} oArg.username The username (nodename) to be logged in with.
 * @param {string} oArg.resource The resource to identify the login with.
 * @param {string} oArg.password The user's password.
 * @param {string} [oArg.authzid] Authorization identity. Used to act as another user, in most cases not needed and rarely supported by servers. If present should be a bare JID (user@example.net).
 * @param {boolean} [oArg.allow_plain] Whether to allow plain text logins.
 * @param {boolean} [oArg.allow_scram] Whether to allow SCRAM-SHA-1 authentication. Please note that it is quite slow, do some testing on all required browsers before enabling.
 * @param {boolean} [oArg.register] Whether to register a new account.
 * @param {string} [oArg.authhost] The host that handles the actualy authorization. There are cases where this is different from the settings above, e.g. if there's a service that provides anonymous logins at 'anon.example.org'.
 * @param {string} [oArg.authtype] Must be one of 'sasl' (default), 'nonsasl', 'saslanon', or 'anonymous'.
 * @param {string} [oArg.xmllang] The requested language for this login. Typically XMPP server try to respond with error messages and the like in this language if available.
 */
JSJaCWebSocketConnection.prototype.connect = function(oArg) {
  this._setStatus('connecting');

  this.domain = oArg.domain || 'localhost';
  this.username = oArg.username;
  this.resource = oArg.resource;
  this.pass = oArg.password || oArg.pass;
  this.authzid = oArg.authzid || '';
  this.register = oArg.register;

  this.authhost = oArg.authhost || this.domain;
  this.authtype = oArg.authtype || 'sasl';

  this.jid = this.username + '@' + this.domain;
  this.fulljid = this.jid + '/' + this.resource;

  if (oArg.allow_plain) {
    this._allow_plain = oArg.allow_plain;
  } else {
    this._allow_plain = JSJAC_ALLOW_PLAIN;
  }

  if (oArg.allow_scram) {
    this._allow_scram = oArg.allow_scram;
  } else {
    this._allow_scram = JSJAC_ALLOW_SCRAM;
  }

  if (oArg.xmllang && oArg.xmllang !== '') {
    this._xmllang = oArg.xmllang;
  } else {
    this._xmllang = 'en';
  }

  if (typeof WebSocket === 'undefined') {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  this._ws = new WebSocket(this._httpbase, 'xmpp');
  this._ws.onclose = JSJaC.bind(this._onclose, this);
  this._ws.onerror = JSJaC.bind(this._onerror, this);
  this._ws.onopen = JSJaC.bind(this._onopen, this);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onopen = function() {
  var reqstr = this._getInitialRequestString();

  this.oDbg.log(reqstr, 4);

  this._ws.onmessage = JSJaC.bind(this._handleOpenStream, this);
  this._ws.send(reqstr);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._handleOpenStream = function(event) {
  var open, stream;

  this.oDbg.log(event.data, 4);

  open = event.data;
  // skip XML prolog if any
  open = open.substr(open.indexOf('<stream:stream'));
  if (open.substr(-2) !== '/>' && open.substr(-16) !== '</stream:stream>') {
    // some servers send closed opening tag, some not
    open += '</stream:stream>';
  }
  stream = this._parseXml(open);
  if(!stream) {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  // extract stream id used for non-SASL authentication
  this.streamid = stream.getAttribute('id');

  this.oDbg.log('got streamid: ' + this.streamid, 2);
  this._ws.onmessage = JSJaC.bind(this._handleInitialResponse, this);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._handleInitialResponse = function(event) {
  var doc = this._parseXml(event.data);
  if (!this._parseStreamFeatures(doc)) {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  this._connected = true;

  if (this.register) {
    this._doInBandReg();
  } else {
    this._doAuth();
  }
};

/**
 * Disconnect from XMPP service
 *
 * When called upon leaving a page needs to use 'onbeforeunload' event
 * as Websocket would be closed already otherwise prior to this call.
 */
JSJaCWebSocketConnection.prototype.disconnect = function() {
  this._setStatus('disconnecting');

  if (!this.connected()) {
    return;
  }
  this._connected = false;

  this.oDbg.log('Disconnecting', 4);
  this._sendRaw('</stream:stream>', JSJaC.bind(this._cleanupWebSocket, this));

  this.oDbg.log('Disconnected', 2);
  this._handleEvent('ondisconnect');
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onclose = function() {
  this.oDbg.log('websocket closed', 2);
  if (this._status !== 'disconnecting') {
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
  }
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onerror = function() {
  this.oDbg.log('websocket error', 1);
  this._connected = false;
  this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onmessage = function(event) {
  var stanza, node, packet;

  stanza = event.data;
  this._setStatus('processing');
  if (!stanza || stanza === '') {
    return;
  }

  // WebSocket works only on modern browsers, so it is safe to assume
  // that namespaceURI and getElementsByTagNameNS are available.
  node = this._parseXml(stanza);
  if (node.namespaceURI === NS_STREAM && node.localName === 'error') {
    if (node.getElementsByTagNameNS(NS_STREAMS, 'conflict').length > 0) {
      this._setStatus('session-terminate-conflict');
    }
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'remote-stream-error'));
    return;
  }

  packet = JSJaCPacket.wrapNode(node);
  if (!packet) {
    return;
  }

  this.oDbg.log('async recv: ' + event.data, 4);
  this._handleEvent('packet_in', packet);

  if (packet.pType && !this._handlePID(packet)) {
    this._handleEvent(packet.pType() + '_in', packet);
    this._handleEvent(packet.pType(), packet);
  }
};

/**
 * Parse single XML stanza. As proposed in XMPP Sub-protocol for
 * WebSocket draft, it assumes that every stanza is sent in a separate
 * WebSocket frame, which greatly simplifies parsing.
 * @private
 */
JSJaCWebSocketConnection.prototype._parseXml = function(s) {
  var doc;

  this.oDbg.log('Parsing: ' + s, 4);
  try {
    doc = XmlDocument.create('stream', NS_STREAM);
    if(s.indexOf('<stream:stream') === -1) {
      // Wrap every stanza into stream element, so that XML namespaces work properly.
      doc.loadXML("<stream:stream xmlns:stream='" + NS_STREAM + "' xmlns='jabber:client'>" + s + "</stream:stream>");
      return doc.documentElement.firstChild;
    } else {
      doc.loadXML(s);
      return doc.documentElement;
    }
  } catch (e) {
    this.oDbg.log('Error: ' + e);
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('500', 'wait', 'internal-service-error'));
  }

  return null;
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._getInitialRequestString = function() {
  var streamto, reqstr;

  streamto = this.domain;
  if (this.authhost) {
    streamto = this.authhost;
  }

  reqstr = '<stream:stream to="' + streamto + '" xmlns="jabber:client" xmlns:stream="' + NS_STREAM + '"';
  if (this.authtype === 'sasl' || this.authtype === 'saslanon') {
    reqstr += ' version="1.0"';
  }
  reqstr += '>';
  return reqstr;
};

JSJaCWebSocketConnection.prototype.send = function(packet, cb, arg) {
  this._ws.onmessage = JSJaC.bind(this._onmessage, this);
  if (!packet || !packet.pType) {
    this.oDbg.log('no packet: ' + packet, 1);
    return false;
  }

  if (!this.connected()) {
    return false;
  }

  // remember id for response if callback present
  if (cb) {
    if (!packet.getID()) {
      packet.setID('JSJaCID_' + this._ID++); // generate an ID
    }

    // register callback with id
    this._registerPID(packet, cb, arg);
  }

  try {
    this._handleEvent(packet.pType() + '_out', packet);
    this._handleEvent('packet_out', packet);
    this._ws.send(packet.xml());
  } catch (e) {
    this.oDbg.log(e.toString(), 1);
    return false;
  }

  return true;
};

/**
 * Resuming connections is not supported by WebSocket.
 */
JSJaCWebSocketConnection.prototype.resume = function() {
  return false; // not supported for websockets
};

/**
 * Suspending connections is not supported by WebSocket.
 */
JSJaCWebSocketConnection.prototype.suspend = function() {
  return false; // not supported for websockets
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthScramSha1S1 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthScramSha1S1, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthScramSha1S2 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthScramSha1S2, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDigestMd5S1 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDigestMd5S1, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDigestMd5S2 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDigestMd5S2, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDone = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDone, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._reInitStream = function(cb) {
  var reqstr, streamto = this.domain;
  if (this.authhost) {
    streamto = this.authhost;
  }

  reqstr = '<stream:stream xmlns:stream="' + NS_STREAM + '" xmlns="jabber:client" to="' + streamto + '" version="1.0">';
  this._sendRaw(reqstr, cb);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._sendRaw = function(xml, cb, arg) {
  if (!this._ws) {
    // Socket might have been closed already because of an 'onerror'
    // event. In this case we'd try to send a closing stream element
    // 'ondisconnect' which won't work.
    return false;
  }
  if (cb) {
    this._ws.onmessage = JSJaC.bind(cb, this, arg);
  }
  this._ws.send(xml);
  return true;
};


/**
 * @fileoverview JSJaC Jingle library, implementation of XEP-0166.
 * Written originally for Uno.im service requirements
 *
 * @version v0.7 (dev)
 * @url https://github.com/valeriansaliou/jsjac-jingle
 * @depends https://github.com/sstrigler/JSJaC
 * @author Val√©rian Saliou http://valeriansaliou.name/
 * @license Mozilla Public License v2.0 (MPL v2.0)
 */


/**
 * Implements:
 *
 * See the PROTOCOL.md file for a list of supported protocol extensions
 *
 *
 * Workflow:
 *
 * This negotiation example associates JSJaCJingle.js methods to a real workflow
 * We assume in this workflow example remote user accepts the call he gets
 *
 * 1.cmt Local user wants to start a WebRTC session with remote user
 * 1.snd Local user sends a session-initiate type='set'
 * 1.hdl Remote user sends back a type='result' to '1.snd' stanza (ack)
 *
 * 2.cmt Local user waits silently for remote user to send a session-accept
 * 2.hdl Remote user sends a session-accept type='set'
 * 2.snd Local user sends back a type='result' to '2.hdl' stanza (ack)
 *
 * 3.cmt WebRTC session starts
 * 3.cmt Users chat, and chat, and chat. Happy Jabbering to them!
 *
 * 4.cmt Local user wants to stop WebRTC session with remote user
 * 4.snd Local user sends a session-terminate type='set'
 * 4.hdl Remote user sends back a type='result' to '4.snd' stanza (ack)
 */


/**
 * JINGLE WEBRTC
 */

var WEBRTC_GET_MEDIA           = ( navigator.webkitGetUserMedia     ||
                                   navigator.mozGetUserMedia        ||
                                   navigator.msGetUserMedia         ||
                                   navigator.getUserMedia           );

var WEBRTC_PEER_CONNECTION     = ( window.webkitRTCPeerConnection   ||
                                   window.mozRTCPeerConnection      ||
                                   window.RTCPeerConnection         );

var WEBRTC_SESSION_DESCRIPTION = ( window.mozRTCSessionDescription  ||
                                   window.RTCSessionDescription     );

var WEBRTC_ICE_CANDIDATE       = ( window.mozRTCIceCandidate        ||
                                   window.RTCIceCandidate           );

var WEBRTC_CONFIGURATION = {
  peer_connection : {
    config        : {
      iceServers : [{
        url: 'stun:stun.jappix.com'
      }]
    },

    constraints   : {
      optional : [{
        'DtlsSrtpKeyAgreement': true
      }]
    }
  },

  create_offer    : {
    mandatory: {
      'OfferToReceiveAudio' : true,
      'OfferToReceiveVideo' : true
    }
  },

  create_answer   : {
    mandatory: {
      'OfferToReceiveAudio' : true,
      'OfferToReceiveVideo' : true
    }
  }
};

var WEBRTC_SDP_LINE_BREAK      = '\r\n';
var WEBRTC_SDP_TYPE_OFFER      = 'offer';
var WEBRTC_SDP_TYPE_ANSWER     = 'answer';

var R_WEBRTC_SDP_ICE_CANDIDATE = /^a=candidate:(\w{1,32}) (\d{1,5}) (udp|tcp) (\d{1,10}) ([a-zA-Z0-9:\.]{1,45}) (\d{1,5}) (typ) (host|srflx|prflx|relay)( (raddr) ([a-zA-Z0-9:\.]{1,45}) (rport) (\d{1,5}))?( (generation) (\d))?/i;

var R_WEBRTC_SDP_ICE_PAYLOAD   = {
  rtpmap          : /^a=rtpmap:(\d+) (([^\s\/]+)\/(\d+)(\/([^\s\/]+))?)?/i,
  fmtp            : /^a=fmtp:(\d+) (.+)/i,
  group           : /^a=group:(\S+) (.+)/,
  rtcp_fb         : /^a=rtcp-fb:(\S+) (\S+)( (\S+))?/i,
  rtcp_fb_trr_int : /^a=rtcp-fb:(\d+) trr-int (\d+)/i,
  pwd             : /^a=ice-pwd:(\S+)/i,
  ufrag           : /^a=ice-ufrag:(\S+)/i,
  ptime           : /^a=ptime:(\d+)/i,
  maxptime        : /^a=maxptime:(\d+)/i,
  ssrc            : /^a=ssrc:(\d+) (\w+)(:(\S+))?( (\S+))?/i,
  rtcp_mux        : /^a=rtcp-mux/i,
  crypto          : /^a=crypto:(\d{1,9}) (\S+) (\S+)( (\S+))?/i,
  zrtp_hash       : /^a=zrtp-hash:(\S+) (\S+)/i,
  fingerprint     : /^a=fingerprint:(\S+) (\S+)/i,
  setup           : /^a=setup:(\S+)/i,
  extmap          : /^a=extmap:([^\s\/]+)(\/([^\s\/]+))? (\S+)/i,
  bandwidth       : /^b=(\w+):(\d+)/i,
  media           : /^m=(audio|video|application|data) /i
};



/**
 * JINGLE NAMESPACES
 */

var NS_JINGLE                                       = 'urn:xmpp:jingle:1';
var NS_JINGLE_ERRORS                                = 'urn:xmpp:jingle:errors:1';

var NS_JINGLE_APPS_RTP                              = 'urn:xmpp:jingle:apps:rtp:1';
var NS_JINGLE_APPS_RTP_INFO                         = 'urn:xmpp:jingle:apps:rtp:info:1';
var NS_JINGLE_APPS_RTP_AUDIO                        = 'urn:xmpp:jingle:apps:rtp:audio';
var NS_JINGLE_APPS_RTP_VIDEO                        = 'urn:xmpp:jingle:apps:rtp:video';
var NS_JINGLE_APPS_RTP_RTP_HDREXT                   = 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0';
var NS_JINGLE_APPS_RTP_RTCP_FB                      = 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0';
var NS_JINGLE_APPS_RTP_ZRTP                         = 'urn:xmpp:jingle:apps:rtp:zrtp:1';
var NS_JINGLE_APPS_RTP_SSMA                         = 'urn:xmpp:jingle:apps:rtp:ssma:0';
var NS_JINGLE_APPS_STUB                             = 'urn:xmpp:jingle:apps:stub:0';
var NS_JINGLE_APPS_DTLS                             = 'urn:xmpp:tmp:jingle:apps:dtls:0';
var NS_JINGLE_APPS_GROUPING                         = 'urn:xmpp:jingle:apps:grouping:0';

var NS_JINGLE_TRANSPORTS_ICEUDP                     = 'urn:xmpp:jingle:transports:ice-udp:1';
var NS_JINGLE_TRANSPORTS_STUB                       = 'urn:xmpp:jingle:transports:stub:0';

var NS_JINGLE_SECURITY_STUB                         = 'urn:xmpp:jingle:security:stub:0';

var NS_EXTDISCO                                     = 'urn:xmpp:extdisco:1';

var NS_IETF_RFC_3264                                = 'urn:ietf:rfc:3264';
var NS_IETF_RFC_5576                                = 'urn:ietf:rfc:5576';
var NS_IETF_RFC_5888                                = 'urn:ietf:rfc:5888';

var R_NS_JINGLE_APP                                 = /^urn:xmpp:jingle:app:(\w+)(:(\w+))?(:(\d+))?$/;
var R_NS_JINGLE_TRANSPORT                           = /^urn:xmpp:jingle:transport:(\w+)$/;

var MAP_DISCO_JINGLE                                = [
  /* http://xmpp.org/extensions/xep-0166.html#support */
  /* http://xmpp.org/extensions/xep-0167.html#support */
  NS_JINGLE,
  NS_JINGLE_APPS_RTP,
  NS_JINGLE_APPS_RTP_AUDIO,
  NS_JINGLE_APPS_RTP_VIDEO,

  /* http://xmpp.org/extensions/xep-0176.html#support */
  NS_JINGLE_TRANSPORTS_ICEUDP,
  NS_IETF_RFC_3264,

  /* http://xmpp.org/extensions/xep-0339.html#disco */
  NS_IETF_RFC_5576,

  /* http://xmpp.org/extensions/xep-0338.html#disco */
  NS_IETF_RFC_5888,

  /* http://xmpp.org/extensions/xep-0293.html#determining-support */
  NS_JINGLE_APPS_RTP_RTCP_FB,

  /* http://xmpp.org/extensions/xep-0294.html#determining-support */
  NS_JINGLE_APPS_RTP_RTP_HDREXT,

  /* http://xmpp.org/extensions/xep-0320.html#disco */
  NS_JINGLE_APPS_DTLS,

  /* http://xmpp.org/extensions/xep-0262.html */
  NS_JINGLE_APPS_RTP_ZRTP,

  /* http://xmpp.org/extensions/xep-0215.html */
  NS_EXTDISCO
];



/**
 * JSJAC JINGLE CONSTANTS
 */

var JSJAC_JINGLE_AVAILABLE                           = WEBRTC_GET_MEDIA ? true : false;

var JSJAC_JINGLE_PEER_TIMEOUT_DEFAULT                = 15;
var JSJAC_JINGLE_PEER_TIMEOUT_DISCONNECT             = 5;
var JSJAC_JINGLE_STANZA_TIMEOUT                      = 10;
var JSJAC_JINGLE_STANZA_ID_PRE                       = 'jj';

var JSJAC_JINGLE_NETWORK                             = '0';
var JSJAC_JINGLE_GENERATION                          = '0';

var JSJAC_JINGLE_BROWSER_FIREFOX                     = 'Firefox';
var JSJAC_JINGLE_BROWSER_CHROME                      = 'Chrome';
var JSJAC_JINGLE_BROWSER_SAFARI                      = 'Safari';
var JSJAC_JINGLE_BROWSER_OPERA                       = 'Opera';
var JSJAC_JINGLE_BROWSER_IE                          = 'IE';

var JSJAC_JINGLE_SENDERS_BOTH                        = { jingle: 'both',      sdp: 'sendrecv' };
var JSJAC_JINGLE_SENDERS_INITIATOR                   = { jingle: 'initiator', sdp: 'sendonly' };
var JSJAC_JINGLE_SENDERS_NONE                        = { jingle: 'none',      sdp: 'inactive' };
var JSJAC_JINGLE_SENDERS_RESPONDER                   = { jingle: 'responder', sdp: 'recvonly' };

var JSJAC_JINGLE_CREATOR_INITIATOR                   = 'initiator';
var JSJAC_JINGLE_CREATOR_RESPONDER                   = 'responder';

var JSJAC_JINGLE_STATUS_INACTIVE                     = 'inactive';
var JSJAC_JINGLE_STATUS_INITIATING                   = 'initiating';
var JSJAC_JINGLE_STATUS_INITIATED                    = 'initiated';
var JSJAC_JINGLE_STATUS_ACCEPTING                    = 'accepting';
var JSJAC_JINGLE_STATUS_ACCEPTED                     = 'accepted';
var JSJAC_JINGLE_STATUS_TERMINATING                  = 'terminating';
var JSJAC_JINGLE_STATUS_TERMINATED                   = 'terminated';

var JSJAC_JINGLE_ACTION_CONTENT_ACCEPT               = 'content-accept';
var JSJAC_JINGLE_ACTION_CONTENT_ADD                  = 'content-add';
var JSJAC_JINGLE_ACTION_CONTENT_MODIFY               = 'content-modify';
var JSJAC_JINGLE_ACTION_CONTENT_REJECT               = 'content-reject';
var JSJAC_JINGLE_ACTION_CONTENT_REMOVE               = 'content-remove';
var JSJAC_JINGLE_ACTION_DESCRIPTION_INFO             = 'description-info';
var JSJAC_JINGLE_ACTION_SECURITY_INFO                = 'security-info';
var JSJAC_JINGLE_ACTION_SESSION_ACCEPT               = 'session-accept';
var JSJAC_JINGLE_ACTION_SESSION_INFO                 = 'session-info';
var JSJAC_JINGLE_ACTION_SESSION_INITIATE             = 'session-initiate';
var JSJAC_JINGLE_ACTION_SESSION_TERMINATE            = 'session-terminate';
var JSJAC_JINGLE_ACTION_TRANSPORT_ACCEPT             = 'transport-accept';
var JSJAC_JINGLE_ACTION_TRANSPORT_INFO               = 'transport-info';
var JSJAC_JINGLE_ACTION_TRANSPORT_REJECT             = 'transport-reject';
var JSJAC_JINGLE_ACTION_TRANSPORT_REPLACE            = 'transport-replace';

var JSJAC_JINGLE_ERROR_OUT_OF_ORDER                  = { jingle: 'out-of-order',           xmpp: 'unexpected-request',         type: 'wait'   };
var JSJAC_JINGLE_ERROR_TIE_BREAK                     = { jingle: 'tie-break',              xmpp: 'conflict',                   type: 'cancel' };
var JSJAC_JINGLE_ERROR_UNKNOWN_SESSION               = { jingle: 'unknown-session',        xmpp: 'item-not-found',             type: 'cancel' };
var JSJAC_JINGLE_ERROR_UNSUPPORTED_INFO              = { jingle: 'unsupported-info',       xmpp: 'feature-not-implemented',    type: 'modify' };
var JSJAC_JINGLE_ERROR_SECURITY_REQUIRED             = { jingle: 'security-required',      xmpp: 'not-acceptable',             type: 'cancel' };

var XMPP_ERROR_UNEXPECTED_REQUEST                    = { xmpp: 'unexpected-request',       type: 'wait' };
var XMPP_ERROR_CONFLICT                              = { xmpp: 'conflict',                 type: 'cancel' };
var XMPP_ERROR_ITEM_NOT_FOUND                        = { xmpp: 'item-not-found',           type: 'cancel' };
var XMPP_ERROR_NOT_ACCEPTABLE                        = { xmpp: 'not-acceptable',           type: 'modify' };
var XMPP_ERROR_FEATURE_NOT_IMPLEMENTED               = { xmpp: 'feature-not-implemented',  type: 'cancel' };
var XMPP_ERROR_SERVICE_UNAVAILABLE                   = { xmpp: 'service-unavailable',      type: 'cancel' };
var XMPP_ERROR_REDIRECT                              = { xmpp: 'redirect',                 type: 'modify' };
var XMPP_ERROR_RESOURCE_CONSTRAINT                   = { xmpp: 'resource-constraint',      type: 'wait'   };
var XMPP_ERROR_BAD_REQUEST                           = { xmpp: 'bad-request',              type: 'cancel' };

var JSJAC_JINGLE_REASON_ALTERNATIVE_SESSION          = 'alternative-session';
var JSJAC_JINGLE_REASON_BUSY                         = 'busy';
var JSJAC_JINGLE_REASON_CANCEL                       = 'cancel';
var JSJAC_JINGLE_REASON_CONNECTIVITY_ERROR           = 'connectivity-error';
var JSJAC_JINGLE_REASON_DECLINE                      = 'decline';
var JSJAC_JINGLE_REASON_EXPIRED                      = 'expired';
var JSJAC_JINGLE_REASON_FAILED_APPLICATION           = 'failed-application';
var JSJAC_JINGLE_REASON_FAILED_TRANSPORT             = 'failed-transport';
var JSJAC_JINGLE_REASON_GENERAL_ERROR                = 'general-error';
var JSJAC_JINGLE_REASON_GONE                         = 'gone';
var JSJAC_JINGLE_REASON_INCOMPATIBLE_PARAMETERS      = 'incompatible-parameters';
var JSJAC_JINGLE_REASON_MEDIA_ERROR                  = 'media-error';
var JSJAC_JINGLE_REASON_SECURITY_ERROR               = 'security-error';
var JSJAC_JINGLE_REASON_SUCCESS                      = 'success';
var JSJAC_JINGLE_REASON_TIMEOUT                      = 'timeout';
var JSJAC_JINGLE_REASON_UNSUPPORTED_APPLICATIONS     = 'unsupported-applications';
var JSJAC_JINGLE_REASON_UNSUPPORTED_TRANSPORTS       = 'unsupported-transports';

var JSJAC_JINGLE_SESSION_INFO_ACTIVE                 = 'active';
var JSJAC_JINGLE_SESSION_INFO_HOLD                   = 'hold';
var JSJAC_JINGLE_SESSION_INFO_MUTE                   = 'mute';
var JSJAC_JINGLE_SESSION_INFO_RINGING                = 'ringing';
var JSJAC_JINGLE_SESSION_INFO_UNHOLD                 = 'unhold';
var JSJAC_JINGLE_SESSION_INFO_UNMUTE                 = 'unmute';

var JSJAC_JINGLE_MEDIA_AUDIO                         = 'audio';
var JSJAC_JINGLE_MEDIA_VIDEO                         = 'video';

var JSJAC_JINGLE_VIDEO_SOURCE_CAMERA                 = 'camera';
var JSJAC_JINGLE_VIDEO_SOURCE_SCREEN                 = 'screen';

var JSJAC_JINGLE_STANZA_TYPE_ALL                     = 'all';
var JSJAC_JINGLE_STANZA_TYPE_RESULT                  = 'result';
var JSJAC_JINGLE_STANZA_TYPE_SET                     = 'set';
var JSJAC_JINGLE_STANZA_TYPE_GET                     = 'get';



/**
 * JSJSAC JINGLE CONSTANTS MAPPING
 */

var JSJAC_JINGLE_BROWSERS                           = {};
JSJAC_JINGLE_BROWSERS[JSJAC_JINGLE_BROWSER_FIREFOX] = 1;
JSJAC_JINGLE_BROWSERS[JSJAC_JINGLE_BROWSER_CHROME]  = 1;
JSJAC_JINGLE_BROWSERS[JSJAC_JINGLE_BROWSER_SAFARI]  = 1;
JSJAC_JINGLE_BROWSERS[JSJAC_JINGLE_BROWSER_OPERA]   = 1;
JSJAC_JINGLE_BROWSERS[JSJAC_JINGLE_BROWSER_IE]      = 1;

var JSJAC_JINGLE_SENDERS            = {};
JSJAC_JINGLE_SENDERS[JSJAC_JINGLE_SENDERS_BOTH.jingle]                = JSJAC_JINGLE_SENDERS_BOTH.sdp;
JSJAC_JINGLE_SENDERS[JSJAC_JINGLE_SENDERS_INITIATOR.jingle]           = JSJAC_JINGLE_SENDERS_INITIATOR.sdp;
JSJAC_JINGLE_SENDERS[JSJAC_JINGLE_SENDERS_NONE.jingle]                = JSJAC_JINGLE_SENDERS_NONE.sdp;
JSJAC_JINGLE_SENDERS[JSJAC_JINGLE_SENDERS_RESPONDER.jingle]           = JSJAC_JINGLE_SENDERS_RESPONDER.sdp;

var JSJAC_JINGLE_CREATORS           = {};
JSJAC_JINGLE_CREATORS[JSJAC_JINGLE_CREATOR_INITIATOR]                 = 1;
JSJAC_JINGLE_CREATORS[JSJAC_JINGLE_CREATOR_RESPONDER]                 = 1;

var JSJAC_JINGLE_STATUSES           = {};
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_INACTIVE]                   = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_INITIATING]                 = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_INITIATED]                  = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_ACCEPTING]                  = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_ACCEPTED]                   = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_TERMINATING]                = 1;
JSJAC_JINGLE_STATUSES[JSJAC_JINGLE_STATUS_TERMINATED]                 = 1;

var JSJAC_JINGLE_ACTIONS            = {};
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_CONTENT_ACCEPT]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_CONTENT_ADD]                 = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_CONTENT_MODIFY]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_CONTENT_REJECT]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_CONTENT_REMOVE]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_DESCRIPTION_INFO]            = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_SECURITY_INFO]               = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_SESSION_ACCEPT]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_SESSION_INFO]                = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_SESSION_INITIATE]            = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_SESSION_TERMINATE]           = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_TRANSPORT_ACCEPT]            = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_TRANSPORT_INFO]              = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_TRANSPORT_REJECT]            = 1;
JSJAC_JINGLE_ACTIONS[JSJAC_JINGLE_ACTION_TRANSPORT_REPLACE]           = 1;

var JSJAC_JINGLE_ERRORS             = {};
JSJAC_JINGLE_ERRORS[JSJAC_JINGLE_ERROR_OUT_OF_ORDER.jingle]           = 1;
JSJAC_JINGLE_ERRORS[JSJAC_JINGLE_ERROR_TIE_BREAK.jingle]              = 1;
JSJAC_JINGLE_ERRORS[JSJAC_JINGLE_ERROR_UNKNOWN_SESSION.jingle]        = 1;
JSJAC_JINGLE_ERRORS[JSJAC_JINGLE_ERROR_UNSUPPORTED_INFO.jingle]       = 1;
JSJAC_JINGLE_ERRORS[JSJAC_JINGLE_ERROR_SECURITY_REQUIRED.jingle]      = 1;

var XMPP_ERRORS                     = {};
XMPP_ERRORS[XMPP_ERROR_UNEXPECTED_REQUEST.xmpp]                       = 1;
XMPP_ERRORS[XMPP_ERROR_CONFLICT.xmpp]                                 = 1;
XMPP_ERRORS[XMPP_ERROR_ITEM_NOT_FOUND.xmpp]                           = 1;
XMPP_ERRORS[XMPP_ERROR_NOT_ACCEPTABLE.xmpp]                           = 1;
XMPP_ERRORS[XMPP_ERROR_FEATURE_NOT_IMPLEMENTED.xmpp]                  = 1;
XMPP_ERRORS[XMPP_ERROR_SERVICE_UNAVAILABLE.xmpp]                      = 1;
XMPP_ERRORS[XMPP_ERROR_REDIRECT.xmpp]                                 = 1;
XMPP_ERRORS[XMPP_ERROR_RESOURCE_CONSTRAINT.xmpp]                      = 1;
XMPP_ERRORS[XMPP_ERROR_BAD_REQUEST.xmpp]                              = 1;

var JSJAC_JINGLE_REASONS            = {};
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_ALTERNATIVE_SESSION]         = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_BUSY]                        = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_CANCEL]                      = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_CONNECTIVITY_ERROR]          = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_DECLINE]                     = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_EXPIRED]                     = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_FAILED_APPLICATION]          = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_FAILED_TRANSPORT]            = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_GENERAL_ERROR]               = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_GONE]                        = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_INCOMPATIBLE_PARAMETERS]     = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_MEDIA_ERROR]                 = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_SECURITY_ERROR]              = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_SUCCESS]                     = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_TIMEOUT]                     = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_UNSUPPORTED_APPLICATIONS]    = 1;
JSJAC_JINGLE_REASONS[JSJAC_JINGLE_REASON_UNSUPPORTED_TRANSPORTS]      = 1;

var JSJAC_JINGLE_SESSION_INFOS      = {};
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_ACTIVE]          = 1;
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_HOLD]            = 1;
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_MUTE]            = 1;
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_RINGING]         = 1;
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_UNHOLD]          = 1;
JSJAC_JINGLE_SESSION_INFOS[JSJAC_JINGLE_SESSION_INFO_UNMUTE]          = 1;

var JSJAC_JINGLE_MEDIAS             = {};
JSJAC_JINGLE_MEDIAS[JSJAC_JINGLE_MEDIA_AUDIO]                         = { label: '0' };
JSJAC_JINGLE_MEDIAS[JSJAC_JINGLE_MEDIA_VIDEO]                         = { label: '1' };

var JSJAC_JINGLE_VIDEO_SOURCES      = {};
JSJAC_JINGLE_VIDEO_SOURCES[JSJAC_JINGLE_VIDEO_SOURCE_CAMERA]          = 1;
JSJAC_JINGLE_VIDEO_SOURCES[JSJAC_JINGLE_VIDEO_SOURCE_SCREEN]          = 1;

var JSJAC_JINGLE_STANZAS            = {};
JSJAC_JINGLE_STANZAS[JSJAC_JINGLE_STANZA_TYPE_ALL]                    = 1;
JSJAC_JINGLE_STANZAS[JSJAC_JINGLE_STANZA_TYPE_RESULT]                 = 1;
JSJAC_JINGLE_STANZAS[JSJAC_JINGLE_STANZA_TYPE_SET]                    = 1;
JSJAC_JINGLE_STANZAS[JSJAC_JINGLE_STANZA_TYPE_GET]                    = 1;



/**
 * JSJAC JINGLE STORAGE
 */

var JSJAC_JINGLE_STORE_CONNECTION = null;
var JSJAC_JINGLE_STORE_SESSIONS   = {};
var JSJAC_JINGLE_STORE_INITIATE   = function(stanza) {};

var JSJAC_JINGLE_STORE_DEBUG      = {
  log : function() {}
};

var JSJAC_JINGLE_STORE_EXTDISCO   = {
  stun : {},
  turn : {}
};

var JSJAC_JINGLE_STORE_FALLBACK   = {
  stun : {},
  turn : {}
};

var JSJAC_JINGLE_STORE_DEFER      = {
  deferred : false,
  count    : 0,
  fn       : []
};

var R_JSJAC_JINGLE_SERVICE_URI    = /^(\w+):([^:\?]+)(?::(\d+))?(?:\?transport=(\w+))?/i;



/**
 * JSJSAC JINGLE METHODS
 */

/**
 * Creates a new XMPP Jingle session.
 * @class Somewhat abstract base class for XMPP Jingle sessions. Contains all
 * of the code in common for all Jingle sessions
 * @constructor
 * @param {Object} args Jingle session arguments.
 * @param {function} args.session_initiate_pending The initiate pending custom handler.
 * @param {function} args.session_initiate_success The initiate success custom handler.
 * @param {function} args.session_initiate_error The initiate error custom handler.
 * @param {function} args.session_initiate_request The initiate request custom handler.
 * @param {function} args.session_accept_pending The accept pending custom handler.
 * @param {function} args.session_accept_success The accept success custom handler.
 * @param {function} args.session_accept_error The accept error custom handler.
 * @param {function} args.session_accept_request The accept request custom handler.
 * @param {function} args.session_info_success The info success custom handler.
 * @param {function} args.session_info_error The info error custom handler.
 * @param {function} args.session_info_request The info request custom handler.
 * @param {function} args.session_terminate_pending The terminate pending custom handler.
 * @param {function} args.session_terminate_success The terminate success custom handler.
 * @param {function} args.session_terminate_error The terminate error custom handler.
 * @param {function} args.session_terminate_request The terminate request custom handler.
 * @param {DOM} args.local_view The path to the local stream view element.
 * @param {DOM} args.remote_view The path to the remote stream view element.
 * @param {string} args.to The full JID to start the Jingle session with.
 * @param {string} args.media The media type to be used in the Jingle session.
 * @param {string} args.resolution The resolution to be used for video in the Jingle session.
 * @param {string} args.bandwidth The bandwidth to be limited for video in the Jingle session.
 * @param {string} args.fps The framerate to be used for video in the Jingle session.
 * @param {object} args.stun A list of STUN servers to use (override the default one)
 * @param {object} args.turn A list of TURN servers to use
 * @param {object} args.sdp_trace Log SDP trace in console (requires a debug interface)
 * @param {JSJaCDebugger} args.debug A reference to a debugger implementing the JSJaCDebugger interface.
 */
function JSJaCJingle(args) {
  var self = this;

  if(args && args.session_initiate_pending)
    /**
     * @private
     */
    self._session_initiate_pending = args.session_initiate_pending;

  if(args && args.session_initiate_success)
    /**
     * @private
     */
    self._session_initiate_success = args.session_initiate_success;

  if(args && args.session_initiate_error)
    /**
     * @private
     */
    self._session_initiate_error = args.session_initiate_error;

  if(args && args.session_initiate_request)
    /**
     * @private
     */
    self._session_initiate_request = args.session_initiate_request;

  if(args && args.session_accept_pending)
    /**
     * @private
     */
    self._session_accept_pending = args.session_accept_pending;

  if(args && args.session_accept_success)
    /**
     * @private
     */
    self._session_accept_success = args.session_accept_success;

  if(args && args.session_accept_error)
    /**
     * @private
     */
    self._session_accept_error = args.session_accept_error;

  if(args && args.session_accept_request)
    /**
     * @private
     */
    self._session_accept_request = args.session_accept_request;

  if(args && args.session_info_success)
    /**
     * @private
     */
    self._session_info_success = args.session_info_success;

  if(args && args.session_info_error)
    /**
     * @private
     */
    self._session_info_error = args.session_info_error;

  if(args && args.session_info_request)
    /**
     * @private
     */
    self._session_info_request = args.session_info_request;

  if(args && args.session_terminate_pending)
    /**
     * @private
     */
    self._session_terminate_pending = args.session_terminate_pending;

  if(args && args.session_terminate_success)
    /**
     * @private
     */
    self._session_terminate_success = args.session_terminate_success;

  if(args && args.session_terminate_error)
    /**
     * @private
     */
    self._session_terminate_error = args.session_terminate_error;

  if(args && args.session_terminate_request)
    /**
     * @private
     */
    self._session_terminate_request = args.session_terminate_request;

  if(args && args.to)
    /**
     * @private
     */
    self._to = args.to;

  if(args && args.media)
    /**
     * @private
     */
    self._media = args.media;

  if(args && args.video_source)
    /**
     * @private
     */
    self._video_source = args.video_source;

  if(args && args.resolution)
    /**
     * @private
     */
    self._resolution = args.resolution;

  if(args && args.bandwidth)
    /**
     * @private
     */
    self._bandwidth = args.bandwidth;

  if(args && args.fps)
    /**
     * @private
     */
    self._fps = args.fps;

  if(args && args.local_view)
    /**
     * @private
     */
    self._local_view = [args.local_view];

  if(args && args.remote_view)
    /**
     * @private
     */
    self._remote_view = [args.remote_view];

  if(args && args.stun) {
    /**
     * @private
     */
    self._stun = args.stun;
  } else {
    self._stun = {};
  }

  if(args && args.turn) {
    /**
     * @private
     */
    self._turn = args.turn;
  } else {
    self._turn = {};
  }

  if(args && args.sdp_trace)
    /**
     * @private
     */
    self._sdp_trace = args.sdp_trace;

  if(args && args.debug && args.debug.log) {
      /**
       * Reference to debugger interface
       * (needs to implement method <code>log</code>)
       * @type JSJaCDebugger
       */
    self._debug = args.debug;
  } else {
    self._debug = JSJAC_JINGLE_STORE_DEBUG;
  }

  /**
   * @private
   */
  self._local_stream = null;

  /**
   * @private
   */
  self._remote_stream = null;

  /**
   * @private
   */
  self._content_local = {};

  /**
   * @private
   */
  self._content_remote = {};

  /**
   * @private
   */
  self._payloads_local = [];

  /**
   * @private
   */
  self._group_local = {};

  /**
   * @private
   */
  self._candidates_local = {};

  /**
   * @private
   */
  self._candidates_queue_local = {};

  /**
   * @private
   */
  self._payloads_remote = {};

  /**
   * @private
   */
  self._group_remote = {};

  /**
   * @private
   */
  self._candidates_remote = {};

  /**
   * @private
   */
  self._candidates_queue_remote = {};

  /**
   * @private
   */
  self._initiator = '';

  /**
   * @private
   */
  self._responder = '';

  /**
   * @private
   */
  self._mute = {};

  /**
   * @private
   */
  self._lock = false;

  /**
   * @private
   */
  self._media_busy = false;

  /**
   * @private
   */
  self._sid = '';

  /**
   * @private
   */
  self._name = {};

  /**
   * @private
   */
  self._senders = {};

  /**
   * @private
   */
  self._creator = {};

  /**
   * @private
   */
  self._status = JSJAC_JINGLE_STATUS_INACTIVE;

  /**
   * @private
   */
  self._reason = JSJAC_JINGLE_REASON_CANCEL;

  /**
   * @private
   */
  self._handlers = {};

  /**
   * @private
   */
  self._peer_connection = null;

  /**
   * @private
   */
  self._id = 0;

  /**
   * @private
   */
  self._sent_id = {};

  /**
   * @private
   */
  self._received_id = {};



  /**
   * Initiates a new Jingle session.
   */
  self.initiate = function() {
    self.get_debug().log('[JSJaCJingle] initiate', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] initiate > Cannot initiate, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.initiate(); })) {
        self.get_debug().log('[JSJaCJingle] initiate > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Slot unavailable?
      if(self.get_status() != JSJAC_JINGLE_STATUS_INACTIVE) {
        self.get_debug().log('[JSJaCJingle] initiate > Cannot initiate, resource not inactive (status: ' + self.get_status() + ').', 0);
        return;
      }

      self.get_debug().log('[JSJaCJingle] initiate > New Jingle session with media: ' + self.get_media(), 2);

      // Common vars
      var i, cur_name;

      // Trigger init pending custom callback
      (self._get_session_initiate_pending())(self);

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_INITIATING);

      // Set session values
      self._set_sid(self.util_generate_sid());
      self._set_initiator(self.util_connection_jid());
      self._set_responder(self.get_to());

      for(i in self.get_media_all()) {
        cur_name = self._util_name_generate(
          self.get_media_all()[i]
        );

        self._set_name(cur_name);

        self._set_senders(
          cur_name,
          JSJAC_JINGLE_SENDERS_BOTH.jingle
        );

        self._set_creator(
          cur_name,
          JSJAC_JINGLE_CREATOR_INITIATOR
        );
      }

      // Register session to common router
      JSJaCJingle_add(self.get_sid(), self);

      // Initialize WebRTC
      self._peer_get_user_media(function() {
        self._peer_connection_create(function() {
          self.get_debug().log('[JSJaCJingle] initiate > Ready to begin Jingle negotiation.', 2);

          self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_SESSION_INITIATE });
        });
      });
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] initiate > ' + e, 1);
    }
  };

  /**
   * Accepts the Jingle session.
   */
  self.accept = function() {
    self.get_debug().log('[JSJaCJingle] accept', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] accept > Cannot accept, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.accept(); })) {
        self.get_debug().log('[JSJaCJingle] accept > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Slot unavailable?
      if(self.get_status() != JSJAC_JINGLE_STATUS_INITIATED) {
        self.get_debug().log('[JSJaCJingle] accept > Cannot accept, resource not initiated (status: ' + self.get_status() + ').', 0);
        return;
      }

      self.get_debug().log('[JSJaCJingle] accept > New Jingle session with media: ' + self.get_media(), 2);

      // Trigger accept pending custom callback
      (self._get_session_accept_pending())(self);

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_ACCEPTING);

      // Initialize WebRTC
      self._peer_get_user_media(function() {
        self._peer_connection_create(function() {
          self.get_debug().log('[JSJaCJingle] accept > Ready to complete Jingle negotiation.', 2);

          // Process accept actions
          self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_SESSION_ACCEPT });
        });
      });
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] accept > ' + e, 1);
    }
  };

  /**
   * Sends a Jingle session info.
   */
  self.info = function(name, args) {
    self.get_debug().log('[JSJaCJingle] info', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] info > Cannot accept, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.info(name, args); })) {
        self.get_debug().log('[JSJaCJingle] info > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Slot unavailable?
      if(!(self.get_status() == JSJAC_JINGLE_STATUS_INITIATED || self.get_status() == JSJAC_JINGLE_STATUS_ACCEPTING || self.get_status() == JSJAC_JINGLE_STATUS_ACCEPTED)) {
        self.get_debug().log('[JSJaCJingle] info > Cannot send info, resource not active (status: ' + self.get_status() + ').', 0);
        return;
      }

      // Assert
      if(typeof args !== 'object') args = {};

      // Build final args parameter
      args.action = JSJAC_JINGLE_ACTION_SESSION_INFO;
      if(name) args.info = name;

      self.send(JSJAC_JINGLE_STANZA_TYPE_SET, args);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] info > ' + e, 1);
    }
  };

  /**
   * Terminates the Jingle session.
   */
  self.terminate = function(reason) {
    self.get_debug().log('[JSJaCJingle] terminate', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] terminate > Cannot terminate, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.terminate(reason); })) {
        self.get_debug().log('[JSJaCJingle] terminate > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Slot unavailable?
      if(self.get_status() == JSJAC_JINGLE_STATUS_TERMINATED) {
        self.get_debug().log('[JSJaCJingle] terminate > Cannot terminate, resource already terminated (status: ' + self.get_status() + ').', 0);
        return;
      }

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_TERMINATING);

      // Trigger terminate pending custom callback
      (self._get_session_terminate_pending())(self);

      // Process terminate actions
      self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_SESSION_TERMINATE, reason: reason });
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] terminate > ' + e, 1);
    }
  };

  /**
   * Sends a given Jingle stanza packet
   */
  self.send = function(type, args) {
    self.get_debug().log('[JSJaCJingle] send', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] send > Cannot send, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.send(type, args); })) {
        self.get_debug().log('[JSJaCJingle] send > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Assert
      if(typeof args !== 'object') args = {};

      // Build stanza
      var stanza = new JSJaCIQ();
      stanza.setTo(self.get_to());

      if(type) stanza.setType(type);

      if(!args.id) args.id = self._get_id_new();
      stanza.setID(args.id);

      if(type == JSJAC_JINGLE_STANZA_TYPE_SET) {
        if(!(args.action && args.action in JSJAC_JINGLE_ACTIONS)) {
          self.get_debug().log('[JSJaCJingle] send > Stanza action unknown: ' + (args.action || 'undefined'), 1);
          return;
        }

        self._set_sent_id(args.id);

        // Submit to registered handler
        switch(args.action) {
          case JSJAC_JINGLE_ACTION_CONTENT_ACCEPT:
            self.send_content_accept(stanza); break;

          case JSJAC_JINGLE_ACTION_CONTENT_ADD:
            self.send_content_add(stanza); break;

          case JSJAC_JINGLE_ACTION_CONTENT_MODIFY:
            self.send_content_modify(stanza); break;

          case JSJAC_JINGLE_ACTION_CONTENT_REJECT:
            self.send_content_reject(stanza); break;

          case JSJAC_JINGLE_ACTION_CONTENT_REMOVE:
            self.send_content_remove(stanza); break;

          case JSJAC_JINGLE_ACTION_DESCRIPTION_INFO:
            self.send_description_info(stanza); break;

          case JSJAC_JINGLE_ACTION_SECURITY_INFO:
            self.send_security_info(stanza); break;

          case JSJAC_JINGLE_ACTION_SESSION_ACCEPT:
            self.send_session_accept(stanza, args); break;

          case JSJAC_JINGLE_ACTION_SESSION_INFO:
            self.send_session_info(stanza, args); break;

          case JSJAC_JINGLE_ACTION_SESSION_INITIATE:
            self.send_session_initiate(stanza, args); break;

          case JSJAC_JINGLE_ACTION_SESSION_TERMINATE:
            self.send_session_terminate(stanza, args); break;

          case JSJAC_JINGLE_ACTION_TRANSPORT_ACCEPT:
            self.send_transport_accept(stanza); break;

          case JSJAC_JINGLE_ACTION_TRANSPORT_INFO:
            self.send_transport_info(stanza, args); break;

          case JSJAC_JINGLE_ACTION_TRANSPORT_REJECT:
            self.send_transport_reject(stanza); break;

          case JSJAC_JINGLE_ACTION_TRANSPORT_REPLACE:
            self.send_transport_replace(stanza); break;

          default:
            self.get_debug().log('[JSJaCJingle] send > Unexpected error.', 1);

            return false;
        }
      } else if(type != JSJAC_JINGLE_STANZA_TYPE_RESULT) {
        self.get_debug().log('[JSJaCJingle] send > Stanza type must either be set or result.', 1);

        return false;
      }

      JSJAC_JINGLE_STORE_CONNECTION.send(stanza);

      return true;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send > ' + e, 1);
    }

    return false;
  };

  /**
   * Handles a given Jingle stanza response
   */
  self.handle = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] handle > Cannot handle, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.handle(stanza); })) {
        self.get_debug().log('[JSJaCJingle] handle > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      var id   = stanza.getID();
      var type = stanza.getType();

      if(id && type == JSJAC_JINGLE_STANZA_TYPE_RESULT)  self._set_received_id(id);

      // Submit to custom handler
      if(typeof self._get_handlers(type, id) == 'function') {
        self.get_debug().log('[JSJaCJingle] handle > Submitted to custom handler.', 2);

        (self._get_handlers(type, id))(stanza);
        self.unregister_handler(type, id);

        return;
      }

      var jingle = self.util_stanza_jingle(stanza);

      // Don't handle non-Jingle stanzas there...
      if(!jingle) return;

      var action = self.util_stanza_get_attribute(jingle, 'action');

      // Don't handle action-less Jingle stanzas there...
      if(!action) return;

      // Submit to registered handler
      switch(action) {
        case JSJAC_JINGLE_ACTION_CONTENT_ACCEPT:
          self.handle_content_accept(stanza); break;

        case JSJAC_JINGLE_ACTION_CONTENT_ADD:
          self.handle_content_add(stanza); break;

        case JSJAC_JINGLE_ACTION_CONTENT_MODIFY:
          self.handle_content_modify(stanza); break;

        case JSJAC_JINGLE_ACTION_CONTENT_REJECT:
          self.handle_content_reject(stanza); break;

        case JSJAC_JINGLE_ACTION_CONTENT_REMOVE:
          self.handle_content_remove(stanza); break;

        case JSJAC_JINGLE_ACTION_DESCRIPTION_INFO:
          self.handle_description_info(stanza); break;

        case JSJAC_JINGLE_ACTION_SECURITY_INFO:
          self.handle_security_info(stanza); break;

        case JSJAC_JINGLE_ACTION_SESSION_ACCEPT:
          self.handle_session_accept(stanza); break;

        case JSJAC_JINGLE_ACTION_SESSION_INFO:
          self.handle_session_info(stanza); break;

        case JSJAC_JINGLE_ACTION_SESSION_INITIATE:
          self.handle_session_initiate(stanza); break;

        case JSJAC_JINGLE_ACTION_SESSION_TERMINATE:
          self.handle_session_terminate(stanza); break;

        case JSJAC_JINGLE_ACTION_TRANSPORT_ACCEPT:
          self.handle_transport_accept(stanza); break;

        case JSJAC_JINGLE_ACTION_TRANSPORT_INFO:
          self.handle_transport_info(stanza); break;

        case JSJAC_JINGLE_ACTION_TRANSPORT_REJECT:
          self.handle_transport_reject(stanza); break;

        case JSJAC_JINGLE_ACTION_TRANSPORT_REPLACE:
          self.handle_transport_replace(stanza); break;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle > ' + e, 1);
    }
  };

  /**
   * Mutes a Jingle session (local)
   */
  self.mute = function(name) {
    self.get_debug().log('[JSJaCJingle] mute', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] mute > Cannot mute, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.mute(name); })) {
        self.get_debug().log('[JSJaCJingle] mute > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Already muted?
      if(self.get_mute(name)) {
        self.get_debug().log('[JSJaCJingle] mute > Resource already muted.', 0);
        return;
      }

      self._peer_sound(false);
      self._set_mute(name, true);

      self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_SESSION_INFO, info: JSJAC_JINGLE_SESSION_INFO_MUTE, name: name });
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] mute > ' + e, 1);
    }
  };

  /**
   * Unmutes a Jingle session (local)
   */
  self.unmute = function(name) {
    self.get_debug().log('[JSJaCJingle] unmute', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] unmute > Cannot unmute, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.unmute(name); })) {
        self.get_debug().log('[JSJaCJingle] unmute > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Already unmute?
      if(!self.get_mute(name)) {
        self.get_debug().log('[JSJaCJingle] unmute > Resource already unmuted.', 0);
        return;
      }

      self._peer_sound(true);
      self._set_mute(name, false);

      self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_SESSION_INFO, info: JSJAC_JINGLE_SESSION_INFO_UNMUTE, name: name });
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] unmute > ' + e, 1);
    }
  };

  /**
   * Toggles media type in a Jingle session
   */
  self.media = function(media) {
    /* DEV: don't expect this to work as of now! */

    self.get_debug().log('[JSJaCJingle] media', 4);

    try {
      // Locked?
      if(self.get_lock()) {
        self.get_debug().log('[JSJaCJingle] media > Cannot change media, resource locked. Please open another session or check WebRTC support.', 0);
        return;
      }

      // Defer?
      if(JSJaCJingle_defer(function() { self.media(media); })) {
        self.get_debug().log('[JSJaCJingle] media > Deferred (waiting for the library components to be initiated).', 0);
        return;
      }

      // Toggle media?
      if(!media)
        media = (self.get_media() == JSJAC_JINGLE_MEDIA_VIDEO) ? JSJAC_JINGLE_MEDIA_AUDIO : JSJAC_JINGLE_MEDIA_VIDEO;

      // Media unknown?
      if(!(media in JSJAC_JINGLE_MEDIAS)) {
        self.get_debug().log('[JSJaCJingle] media > No media provided or media unsupported (media: ' + media + ').', 0);
        return;
      }

      // Already using provided media?
      if(self.get_media() == media) {
        self.get_debug().log('[JSJaCJingle] media > Resource already using this media (media: ' + media + ').', 0);
        return;
      }

      // Switch locked for now? (another one is being processed)
      if(self.get_media_busy()) {
        self.get_debug().log('[JSJaCJingle] media > Resource already busy switching media (busy: ' + self.get_media() + ', media: ' + media + ').', 0);
        return;
      }

      self.get_debug().log('[JSJaCJingle] media > Changing media to: ' + media + '...', 2);

      // Store new media
      self._set_media(media);
      self._set_media_busy(true);

      // Toggle video mode (add/remove)
      if(media == JSJAC_JINGLE_MEDIA_VIDEO) {
        // TODO: the flow is something like that...
        /*self._peer_get_user_media(function() {
          self._peer_connection_create(function() {
            self.get_debug().log('[JSJaCJingle] media > Ready to change media (to: ' + media + ').', 2);

            // 'content-add' >> video
            // TODO: restart video stream configuration

            // WARNING: only change get user media, DO NOT TOUCH THE STREAM THING (don't stop active stream as it's flowing!!)

            self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_CONTENT_ADD, name: JSJAC_JINGLE_MEDIA_VIDEO });
          })
        });*/
      } else {
        // TODO: the flow is something like that...
        /*self._peer_get_user_media(function() {
          self._peer_connection_create(function() {
            self.get_debug().log('[JSJaCJingle] media > Ready to change media (to: ' + media + ').', 2);

            // 'content-remove' >> video
            // TODO: remove video stream configuration

            // WARNING: only change get user media, DO NOT TOUCH THE STREAM THING (don't stop active stream as it's flowing!!)
            //          here, only stop the video stream, do not touch the audio stream

            self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_CONTENT_REMOVE, name: JSJAC_JINGLE_MEDIA_VIDEO });
          })
        });*/
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] media > ' + e, 1);
    }
  };

  /**
   * Registers a given handler on a given Jingle stanza
   */
  self.register_handler = function(type, id, fn) {
    self.get_debug().log('[JSJaCJingle] register_handler', 4);

    try {
      type = type || JSJAC_JINGLE_STANZA_TYPE_ALL;

      if(typeof fn !== 'function') {
        self.get_debug().log('[JSJaCJingle] register_handler > fn parameter not passed or not a function!', 1);
        return false;
      }

      if(id) {
        self._set_handlers(type, id, fn);

        self.get_debug().log('[JSJaCJingle] register_handler > Registered handler for id: ' + id + ' and type: ' + type, 3);
        return true;
      } else {
        self.get_debug().log('[JSJaCJingle] register_handler > Could not register handler (no ID).', 1);
        return false;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] register_handler > ' + e, 1);
    }

    return false;
  };

  /**
   * Unregisters the given handler on a given Jingle stanza
   */
  self.unregister_handler = function(type, id) {
    self.get_debug().log('[JSJaCJingle] unregister_handler', 4);

    try {
      type = type || JSJAC_JINGLE_STANZA_TYPE_ALL;

      if(type in self._handlers && id in self._handlers[type]) {
        delete self._handlers[type][id];

        self.get_debug().log('[JSJaCJingle] unregister_handler > Unregistered handler for id: ' + id + ' and type: ' + type, 3);
        return true;
      } else {
        self.get_debug().log('[JSJaCJingle] unregister_handler > Could not unregister handler with id: ' + id + ' and type: ' + type + ' (not found).', 2);
        return false;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] unregister_handler > ' + e, 1);
    }

    return false;
  };

  /**
   * Registers a view element
   */
  self.register_view = function(type, view) {
    self.get_debug().log('[JSJaCJingle] register_view', 4);

    try {
      // Get view functions
      var fn = self._util_map_register_view(type);

      if(fn.type == type) {
        var i;

        // Check view is not already registered
        for(i in (fn.view.get)()) {
          if((fn.view.get)()[i] == view) {
            self.get_debug().log('[JSJaCJingle] register_view > Could not register view of type: ' + type + ' (already registered).', 2);
            return true;
          }
        }

        // Proceeds registration
        (fn.view.set)(view);

        self._util_peer_stream_attach(
          [view],
          (fn.stream.get)(),
          fn.mute
        );

        self.get_debug().log('[JSJaCJingle] register_view > Registered view of type: ' + type, 3);

        return true;
      } else {
        self.get_debug().log('[JSJaCJingle] register_view > Could not register view of type: ' + type + ' (type unknown).', 1);
        return false;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] register_view > ' + e, 1);
    }

    return false;
  };

  /**
   * Unregisters a view element
   */
  self.unregister_view = function(type, view) {
    self.get_debug().log('[JSJaCJingle] unregister_view', 4);

    try {
      // Get view functions
      var fn = self._util_map_unregister_view(type);

      if(fn.type == type) {
        var i;

        // Check view is registered
        for(i in (fn.view.get)()) {
          if((fn.view.get)()[i] == view) {
            // Proceeds un-registration
            self._util_peer_stream_detach(
              [view]
            );

            self.util_array_remove_value(
              (fn.view.get)(),
              view
            );

            self.get_debug().log('[JSJaCJingle] unregister_view > Unregistered view of type: ' + type, 3);
            return true;
          }
        }

        self.get_debug().log('[JSJaCJingle] unregister_view > Could not unregister view of type: ' + type + ' (not found).', 2);
        return true;
      } else {
        self.get_debug().log('[JSJaCJingle] unregister_view > Could not unregister view of type: ' + type + ' (type unknown).', 1);
        return false;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] unregister_view > ' + e, 1);
    }

    return false;
  };



  /**
   * JSJSAC JINGLE SENDERS
   */

  /**
   * Sends the Jingle content accept
   */
  self.send_content_accept = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_content_accept', 4);

    try {
      // TODO: remove from remote 'content-add' queue
      // TODO: reprocess content_local/content_remote

      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_content_accept > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_content_accept > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle content add
   */
  self.send_content_add = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_content_add', 4);

    try {
      // TODO: push to local 'content-add' queue

      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_content_add > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_content_add > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle content modify
   */
  self.send_content_modify = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_content_modify', 4);

    try {
      // TODO: push to local 'content-modify' queue

      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_content_modify > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_content_modify > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle content reject
   */
  self.send_content_reject = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_content_reject', 4);

    try {
      // TODO: remove from remote 'content-add' queue

      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_content_reject > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_content_reject > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle content remove
   */
  self.send_content_remove = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_content_remove', 4);

    try {
      // TODO: add to local 'content-remove' queue

      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_content_remove > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_content_remove > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle description info
   */
  self.send_description_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_description_info', 4);

    try {
      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_description_info > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_description_info > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle security info
   */
  self.send_security_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_security_info', 4);

    try {
      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_security_info > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_security_info > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle session accept
   */
  self.send_session_accept = function(stanza, args) {
    self.get_debug().log('[JSJaCJingle] send_session_accept', 4);

    try {
      if(self.get_status() != JSJAC_JINGLE_STATUS_ACCEPTING) {
        self.get_debug().log('[JSJaCJingle] send_session_accept > Cannot send accept stanza, resource not accepting (status: ' + self.get_status() + ').', 0);
        self.send_error(stanza, JSJAC_JINGLE_ERROR_OUT_OF_ORDER);
        return;
      }

      if(!args) {
          self.get_debug().log('[JSJaCJingle] send_session_accept > Argument not provided.', 1);
          return;
      }

      // Build Jingle stanza
      var jingle = self._util_stanza_generate_jingle(stanza, {
        'action'    : JSJAC_JINGLE_ACTION_SESSION_ACCEPT,
        'responder' : self.get_responder()
      });

      self._util_stanza_generate_content_local(stanza, jingle);
      self._util_stanza_generate_group_local(stanza, jingle);

      // Schedule success
      self.register_handler(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, function(stanza) {
        (self._get_session_accept_success())(self, stanza);
        self.handle_session_accept_success(stanza);
      });

      // Schedule error timeout
      self.util_stanza_timeout(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, {
        external:   self._get_session_accept_error(),
        internal:   self.handle_session_accept_error
      });

      self.get_debug().log('[JSJaCJingle] send_session_accept > Sent.', 4);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_session_accept > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle session info
   */
  self.send_session_info = function(stanza, args) {
    self.get_debug().log('[JSJaCJingle] send_session_info', 4);

    try {
      if(!args) {
        self.get_debug().log('[JSJaCJingle] send_session_info > Argument not provided.', 1);
        return;
      }

      // Filter info
      args.info = args.info || JSJAC_JINGLE_SESSION_INFO_ACTIVE;

      // Build Jingle stanza
      var jingle = self._util_stanza_generate_jingle(stanza, {
        'action'    : JSJAC_JINGLE_ACTION_SESSION_INFO,
        'initiator' : self.get_initiator()
      });

      self._util_stanza_generate_session_info(stanza, jingle, args);

      // Schedule success
      self.register_handler(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, function(stanza) {
        (self._get_session_info_success())(self, stanza);
        self.handle_session_info_success(stanza);
      });

      // Schedule error timeout
      self.util_stanza_timeout(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, {
        external:   self._get_session_info_error(),
        internal:   self.handle_session_info_error
      });

      self.get_debug().log('[JSJaCJingle] send_session_info > Sent (name: ' + args.info + ').', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_session_info > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle session initiate
   */
  self.send_session_initiate = function(stanza, args) {
    self.get_debug().log('[JSJaCJingle] send_session_initiate', 4);

    try {
      if(self.get_status() != JSJAC_JINGLE_STATUS_INITIATING) {
        self.get_debug().log('[JSJaCJingle] send_session_initiate > Cannot send initiate stanza, resource not initiating (status: ' + self.get_status() + ').', 0);
        return;
      }

      if(!args) {
        self.get_debug().log('[JSJaCJingle] send_session_initiate > Argument not provided.', 1);
        return;
      }

      // Build Jingle stanza
      var jingle = self._util_stanza_generate_jingle(stanza, {
        'action'    : JSJAC_JINGLE_ACTION_SESSION_INITIATE,
        'initiator' : self.get_initiator()
      });

      self._util_stanza_generate_content_local(stanza, jingle);
      self._util_stanza_generate_group_local(stanza, jingle);

      // Schedule success
      self.register_handler(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, function(stanza) {
        (self._get_session_initiate_success())(self, stanza);
        self.handle_session_initiate_success(stanza);
      });

      // Schedule error timeout
      self.util_stanza_timeout(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, {
        external:   self._get_session_initiate_error(),
        internal:   self.handle_session_initiate_error
      });

      self.get_debug().log('[JSJaCJingle] send_session_initiate > Sent.', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_session_initiate > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle session terminate
   */
  self.send_session_terminate = function(stanza, args) {
    self.get_debug().log('[JSJaCJingle] send_session_terminate', 4);

    try {
      if(self.get_status() != JSJAC_JINGLE_STATUS_TERMINATING) {
        self.get_debug().log('[JSJaCJingle] send_session_terminate > Cannot send terminate stanza, resource not terminating (status: ' + self.get_status() + ').', 0);
        return;
      }

      if(!args) {
        self.get_debug().log('[JSJaCJingle] send_session_terminate > Argument not provided.', 1);
        return;
      }

      // Filter reason
      args.reason = args.reason || JSJAC_JINGLE_REASON_SUCCESS;

      // Store terminate reason
      self._set_reason(args.reason);

      // Build terminate stanza
      var jingle = self._util_stanza_generate_jingle(stanza, {
        'action': JSJAC_JINGLE_ACTION_SESSION_TERMINATE
      });

      var jingle_reason = jingle.appendChild(stanza.buildNode('reason', {'xmlns': NS_JINGLE}));
      jingle_reason.appendChild(stanza.buildNode(args.reason, {'xmlns': NS_JINGLE}));

      // Schedule success
      self.register_handler(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, function(stanza) {
        (self._get_session_terminate_success())(self, stanza);
        self.handle_session_terminate_success(stanza);
      });

      // Schedule error timeout
      self.util_stanza_timeout(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, {
        external:   self._get_session_terminate_error(),
        internal:   self.handle_session_terminate_error
      });

      self.get_debug().log('[JSJaCJingle] send_session_terminate > Sent (reason: ' + args.reason + ').', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_session_terminate > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle transport accept
   */
  self.send_transport_accept = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_transport_accept', 4);

    try {
      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_transport_accept > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_transport_accept > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle transport info
   */
  self.send_transport_info = function(stanza, args) {
    self.get_debug().log('[JSJaCJingle] send_transport_info', 4);

    try {
      if(self.get_status() != JSJAC_JINGLE_STATUS_INITIATED && self.get_status() != JSJAC_JINGLE_STATUS_ACCEPTING && self.get_status() != JSJAC_JINGLE_STATUS_ACCEPTED) {
        self.get_debug().log('[JSJaCJingle] send_transport_info > Cannot send transport info, resource not initiated, nor accepting, nor accepted (status: ' + self.get_status() + ').', 0);
        return;
      }

      if(!args) {
        self.get_debug().log('[JSJaCJingle] send_transport_info > Argument not provided.', 1);
        return;
      }

      if(self.util_object_length(self._get_candidates_queue_local()) === 0) {
        self.get_debug().log('[JSJaCJingle] send_transport_info > No local candidate in queue.', 1);
        return;
      }

      // Build Jingle stanza
      var jingle = self._util_stanza_generate_jingle(stanza, {
        'action'    : JSJAC_JINGLE_ACTION_TRANSPORT_INFO,
        'initiator' : self.get_initiator()
      });

      // Build queue content
      var cur_name;
      var content_queue_local = {};

      for(cur_name in self.get_name()) {
        content_queue_local[cur_name] = self._util_generate_content(
            self.get_creator(cur_name),
            cur_name,
            self.get_senders(cur_name),
            self._get_payloads_local(cur_name),
            self._get_candidates_queue_local(cur_name)
        );
      }

      self._util_stanza_generate_content_local(stanza, jingle, content_queue_local);
      self._util_stanza_generate_group_local(stanza, jingle);

      // Schedule success
      self.register_handler(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, function(stanza) {
        self.handle_transport_info_success(stanza);
      });

      // Schedule error timeout
      self.util_stanza_timeout(JSJAC_JINGLE_STANZA_TYPE_RESULT, args.id, {
        internal: self.handle_transport_info_error
      });

      self.get_debug().log('[JSJaCJingle] send_transport_info > Sent.', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_transport_info > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle transport reject
   */
  self.send_transport_reject = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_transport_reject', 4);

    try {
      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_transport_reject > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_transport_reject > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle transport replace
   */
  self.send_transport_replace = function(stanza) {
    self.get_debug().log('[JSJaCJingle] send_transport_replace', 4);

    try {
      // Not implemented for now
      self.get_debug().log('[JSJaCJingle] send_transport_replace > Feature not implemented!', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_transport_replace > ' + e, 1);
    }
  };

  /**
   * Sends the Jingle transport replace
   */
  self.send_error = function(stanza, error) {
    self.get_debug().log('[JSJaCJingle] send_error', 4);

    try {
      // Assert
      if(!('type' in error)) {
        self.get_debug().log('[JSJaCJingle] send_error > Type unknown.', 1);
        return;
      }

      if('jingle' in error && !(error.jingle in JSJAC_JINGLE_ERRORS)) {
        self.get_debug().log('[JSJaCJingle] send_error > Jingle condition unknown (' + error.jingle + ').', 1);
        return;
      }

      if('xmpp' in error && !(error.xmpp in XMPP_ERRORS)) {
        self.get_debug().log('[JSJaCJingle] send_error > XMPP condition unknown (' + error.xmpp + ').', 1);
        return;
      }

      var stanza_error = new JSJaCIQ();

      stanza_error.setType('error');
      stanza_error.setID(stanza.getID());
      stanza_error.setTo(self.get_to());

      var error_node = stanza_error.getNode().appendChild(stanza_error.buildNode('error', {'xmlns': NS_CLIENT, 'type': error.type}));

      if('xmpp'   in error) error_node.appendChild(stanza_error.buildNode(error.xmpp,   { 'xmlns': NS_STANZAS       }));
      if('jingle' in error) error_node.appendChild(stanza_error.buildNode(error.jingle, { 'xmlns': NS_JINGLE_ERRORS }));

      JSJAC_JINGLE_STORE_CONNECTION.send(stanza_error);

      self.get_debug().log('[JSJaCJingle] send_error > Sent: ' + (error.jingle || error.xmpp), 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] send_error > ' + e, 1);
    }
  };



  /**
   * JSJSAC JINGLE HANDLERS
   */

  /**
   * Handles the Jingle content accept
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_content_accept = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_content_accept', 4);

    try {
      // TODO: start to flow accepted stream
      // TODO: remove accepted content from local 'content-add' queue
      // TODO: reprocess content_local/content_remote

      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_accept > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle content add
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_content_add = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_content_add', 4);

    try {
      // TODO: request the user to start this content (need a custom handler)
      //       on accept: send content-accept
      // TODO: push to remote 'content-add' queue
      // TODO: reprocess content_local/content_remote

      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_add > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle content modify
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_content_modify = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_content_modify', 4);

    try {
      // TODO: change 'senders' value (direction of the stream)
      //       if(send:from_me): notify the user that media is requested
      //       if(unacceptable): terminate the session
      //       if(accepted):     change local/remote SDP
      // TODO: reprocess content_local/content_remote

      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_modify > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle content reject
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_content_reject = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_content_reject', 4);

    try {
      // TODO: remove rejected content from local 'content-add' queue

      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_reject > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle content remove
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_content_remove = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_content_remove', 4);

    try {
      // TODO: stop flowing removed stream
      // TODO: reprocess content_local/content_remote

      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_remove > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle description info
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_description_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_description_info', 4);

    try {
      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_description_info > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle security info
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_security_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_security_info', 4);

    try {
      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_security_info > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session accept
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_accept = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_accept', 4);

    try {
      // Security preconditions
      if(!self.util_stanza_safe(stanza)) {
        self.get_debug().log('[JSJaCJingle] handle_session_accept > Dropped unsafe stanza.', 0);

        self.send_error(stanza, JSJAC_JINGLE_ERROR_UNKNOWN_SESSION);
        return;
      }

      // Can now safely dispatch the stanza
      switch(stanza.getType()) {
        case JSJAC_JINGLE_STANZA_TYPE_RESULT:
          (self._get_session_accept_success())(self, stanza);
          self.handle_session_accept_success(stanza);

          break;

        case 'error':
          (self._get_session_accept_error())(self, stanza);
          self.handle_session_accept_error(stanza);

          break;

        case JSJAC_JINGLE_STANZA_TYPE_SET:
          // External handler must be set before internal one here...
          (self._get_session_accept_request())(self, stanza);
          self.handle_session_accept_request(stanza);

          break;

        default:
          self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_accept > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session accept success
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_accept_success = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_accept_success', 4);

    try {
      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_ACCEPTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_accept_success > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session accept error
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_accept_error = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_accept_error', 4);

    try {
      // Terminate the session (timeout)
      self.terminate(JSJAC_JINGLE_REASON_TIMEOUT);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_accept_error > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session accept request
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_accept_request = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_accept_request', 4);

    try {
      // Slot unavailable?
      if(self.get_status() != JSJAC_JINGLE_STATUS_INITIATED) {
        self.get_debug().log('[JSJaCJingle] handle_session_accept_request > Cannot handle, resource already accepted (status: ' + self.get_status() + ').', 0);
        self.send_error(stanza, JSJAC_JINGLE_ERROR_OUT_OF_ORDER);
        return;
      }

      // Common vars
      var i, cur_candidate_obj;

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_ACCEPTING);

      var rd_sid = self.util_stanza_sid(stanza);

      // Request is valid?
      if(rd_sid && self.is_initiator() && self._util_stanza_parse_content(stanza)) {
        // Handle additional data (optional)
        self._util_stanza_parse_group(stanza);

        // Generate and store content data
        self._util_build_content_remote();

        // Trigger accept success callback
        (self._get_session_accept_success())(self, stanza);
        self.handle_session_accept_success(stanza);

        var sdp_remote = self._util_sdp_generate(
          WEBRTC_SDP_TYPE_ANSWER,
          self._get_group_remote(),
          self._get_payloads_remote(),
          self._get_candidates_queue_remote()
        );

        if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (remote)' + '\n\n' + sdp_remote.description.sdp, 4);

        // Remote description
        self._get_peer_connection().setRemoteDescription(
          (new WEBRTC_SESSION_DESCRIPTION(sdp_remote.description)),

          function() {
            // Success (descriptions are compatible)
          },

          function(e) {
            if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (remote:error)' + '\n\n' + (e.message || e.name || 'Unknown error'), 4);

            // Error (descriptions are incompatible)
            self.terminate(JSJAC_JINGLE_REASON_INCOMPATIBLE_PARAMETERS);
          }
        );

        // ICE candidates
        for(i in sdp_remote.candidates) {
          cur_candidate_obj = sdp_remote.candidates[i];

          self._get_peer_connection().addIceCandidate(
            new WEBRTC_ICE_CANDIDATE({
              sdpMLineIndex : cur_candidate_obj.id,
              candidate     : cur_candidate_obj.candidate
            })
          );
        }

        // Empty the unapplied candidates queue
        self._set_candidates_queue_remote(null);

        // Success reply
        self.send(JSJAC_JINGLE_STANZA_TYPE_RESULT, { id: stanza.getID() });
      } else {
        // Trigger accept error callback
        (self._get_session_accept_error())(self, stanza);
        self.handle_session_accept_error(stanza);

        // Send error reply
        self.send_error(stanza, XMPP_ERROR_BAD_REQUEST);

        self.get_debug().log('[JSJaCJingle] handle_session_accept_request > Error.', 1);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_accept_request > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session info
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_info', 4);

    try {
      // Security preconditions
      if(!self.util_stanza_safe(stanza)) {
        self.get_debug().log('[JSJaCJingle] handle_session_info > Dropped unsafe stanza.', 0);

        self.send_error(stanza, JSJAC_JINGLE_ERROR_UNKNOWN_SESSION);
        return;
      }

      // Can now safely dispatch the stanza
      switch(stanza.getType()) {
        case JSJAC_JINGLE_STANZA_TYPE_RESULT:
          (self._get_session_info_success())(self, stanza);
          self.handle_session_info_success(stanza);

          break;

        case 'error':
          (self._get_session_info_error())(self, stanza);
          self.handle_session_info_error(stanza);

          break;

        case JSJAC_JINGLE_STANZA_TYPE_SET:
          (self._get_session_info_request())(self, stanza);
          self.handle_session_info_request(stanza);

          break;

        default:
          self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_info > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session info success
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_info_success = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_info_success', 4);
  };

  /**
   * Handles the Jingle session info error
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_info_error = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_info_error', 4);
  };

  /**
   * Handles the Jingle session info request
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_info_request = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_info_request', 4);

    try {
      // Parse stanza
      var info_name = self.util_stanza_session_info(stanza);
      var info_result = false;

      switch(info_name) {
        case JSJAC_JINGLE_SESSION_INFO_ACTIVE:
        case JSJAC_JINGLE_SESSION_INFO_RINGING:
        case JSJAC_JINGLE_SESSION_INFO_MUTE:
        case JSJAC_JINGLE_SESSION_INFO_UNMUTE:
          info_result = true; break;
      }

      if(info_result) {
        self.get_debug().log('[JSJaCJingle] handle_session_info_request > (name: ' + (info_name || 'undefined') + ').', 3);

        // Process info actions
        self.send(JSJAC_JINGLE_STANZA_TYPE_RESULT, { id: stanza.getID() });

        // Trigger info success custom callback
        (self._get_session_info_success())(self, stanza);
        self.handle_session_info_success(stanza);
      } else {
        self.get_debug().log('[JSJaCJingle] handle_session_info_request > Error (name: ' + (info_name || 'undefined') + ').', 1);

        // Send error reply
        self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);

        // Trigger info error custom callback
        (self._get_session_info_error())(self, stanza);
        self.handle_session_info_error(stanza);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_info_request > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session initiate
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_initiate = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_initiate', 4);

    try {
      switch(stanza.getType()) {
        case JSJAC_JINGLE_STANZA_TYPE_RESULT:
          (self._get_session_initiate_success())(self, stanza);
          self.handle_session_initiate_success(stanza);

          break;

        case 'error':
          (self._get_session_initiate_error())(self, stanza);
          self.handle_session_initiate_error(stanza);

          break;

        case JSJAC_JINGLE_STANZA_TYPE_SET:
          (self._get_session_initiate_request())(self, stanza);
          self.handle_session_initiate_request(stanza);

          break;

        default:
          self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_initiate > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session initiate success
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_initiate_success = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_initiate_success', 4);

    try {
      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_INITIATED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_initiate_success > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session initiate error
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_initiate_error = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_initiate_error', 4);

    try {
      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_INACTIVE);

      // Stop WebRTC
      self._peer_stop();

      // Lock session (cannot be used later)
      self._set_lock(true);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_initiate_error > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session initiate request
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_initiate_request = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_initiate_request', 4);

    try {
      // Slot unavailable?
      if(self.get_status() != JSJAC_JINGLE_STATUS_INACTIVE) {
        self.get_debug().log('[JSJaCJingle] handle_session_initiate_request > Cannot handle, resource already initiated (status: ' + self.get_status() + ').', 0);
        self.send_error(stanza, JSJAC_JINGLE_ERROR_OUT_OF_ORDER);
        return;
      }

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_INITIATING);

      // Common vars
      var rd_from = self.util_stanza_from(stanza);
      var rd_sid  = self.util_stanza_sid(stanza);

      // Request is valid?
      if(rd_sid && self._util_stanza_parse_content(stanza)) {
        // Handle additional data (optional)
        self._util_stanza_parse_group(stanza);

        // Set session values
        self._set_sid(rd_sid);
        self._set_to(rd_from);
        self._set_initiator(rd_from);
        self._set_responder(self.util_connection_jid());

        // Register session to common router
        JSJaCJingle_add(rd_sid, self);

        // Generate and store content data
        self._util_build_content_remote();

        // Video or audio-only session?
        if(JSJAC_JINGLE_MEDIA_VIDEO in self._get_content_remote()) {
          self._set_media(JSJAC_JINGLE_MEDIA_VIDEO);
        } else if(JSJAC_JINGLE_MEDIA_AUDIO in self._get_content_remote()) {
          self._set_media(JSJAC_JINGLE_MEDIA_AUDIO);
        } else {
          // Session initiation not done
          (self._get_session_initiate_error())(self, stanza);
          self.handle_session_initiate_error(stanza);

          // Error (no media is supported)
          self.terminate(JSJAC_JINGLE_REASON_UNSUPPORTED_APPLICATIONS);

          self.get_debug().log('[JSJaCJingle] handle_session_initiate_request > Error (unsupported media).', 1);
          return;
        }

        // Session initiate done
        (self._get_session_initiate_success())(self, stanza);
        self.handle_session_initiate_success(stanza);

        self.send(JSJAC_JINGLE_STANZA_TYPE_RESULT, { id: stanza.getID() });
      } else {
        // Session initiation not done
        (self._get_session_initiate_error())(self, stanza);
        self.handle_session_initiate_error(stanza);

        // Send error reply
        self.send_error(stanza, XMPP_ERROR_BAD_REQUEST);

        self.get_debug().log('[JSJaCJingle] handle_session_initiate_request > Error (bad request).', 1);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_initiate_request > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session terminate
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_terminate = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_terminate', 4);

    try {
      var type = stanza.getType();

      // Security preconditions
      if(!self.util_stanza_safe(stanza)) {
        self.get_debug().log('[JSJaCJingle] handle_session_terminate > Dropped unsafe stanza.', 0);

        self.send_error(stanza, JSJAC_JINGLE_ERROR_UNKNOWN_SESSION);
        return;
      }

      // Can now safely dispatch the stanza
      switch(stanza.getType()) {
        case JSJAC_JINGLE_STANZA_TYPE_RESULT:
          (self._get_session_terminate_success())(self, stanza);
          self.handle_session_terminate_success(stanza);

          break;

        case 'error':
          (self._get_session_terminate_error())(self, stanza);
          self.handle_session_terminate_error(stanza);

          break;

        case JSJAC_JINGLE_STANZA_TYPE_SET:
          (self._get_session_terminate_request())(self, stanza);
          self.handle_session_terminate_request(stanza);

          break;

        default:
          self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_terminate > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session terminate success
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_terminate_success = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_terminate_success', 4);

    try {
      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_TERMINATED);

      // Stop WebRTC
      self._peer_stop();
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_terminate_success > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session terminate error
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_terminate_error = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_terminate_error', 4);

    try {
      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_TERMINATED);

      // Stop WebRTC
      self._peer_stop();

      // Lock session (cannot be used later)
      self._set_lock(true);

      self.get_debug().log('[JSJaCJingle] handle_session_terminate_error > Forced session termination locally.', 0);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_terminate_error > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle session terminate request
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_session_terminate_request = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_session_terminate_request', 4);

    try {
      // Slot unavailable?
      if(self.get_status() == JSJAC_JINGLE_STATUS_INACTIVE || self.get_status() == JSJAC_JINGLE_STATUS_TERMINATED) {
        self.get_debug().log('[JSJaCJingle] handle_session_terminate_request > Cannot handle, resource not active (status: ' + self.get_status() + ').', 0);
        self.send_error(stanza, JSJAC_JINGLE_ERROR_OUT_OF_ORDER);
        return;
      }

      // Change session status
      self._set_status(JSJAC_JINGLE_STATUS_TERMINATING);

      // Store termination reason
      self._set_reason(self.util_stanza_terminate_reason(stanza));

      // Trigger terminate success callbacks
      (self._get_session_terminate_success())(self, stanza);
      self.handle_session_terminate_success(stanza);

      // Process terminate actions
      self.send(JSJAC_JINGLE_STANZA_TYPE_RESULT, { id: stanza.getID() });

      self.get_debug().log('[JSJaCJingle] handle_session_terminate_request > (reason: ' + self.get_reason() + ').', 3);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_session_terminate_request > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle transport accept
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_accept = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_accept', 4);

    try {
      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_content_accept > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle transport info
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_info = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_info', 4);

    try {
      // Slot unavailable?
      if(self.get_status() != JSJAC_JINGLE_STATUS_INITIATED && self.get_status() != JSJAC_JINGLE_STATUS_ACCEPTING && self.get_status() != JSJAC_JINGLE_STATUS_ACCEPTED) {
        self.get_debug().log('[JSJaCJingle] handle_transport_info > Cannot handle, resource not initiated, nor accepting, nor accepted (status: ' + self.get_status() + ').', 0);
        self.send_error(stanza, JSJAC_JINGLE_ERROR_OUT_OF_ORDER);
        return;
      }

      // Common vars
      var i, cur_candidate_obj;

      // Parse the incoming transport
      var rd_sid = self.util_stanza_sid(stanza);

      // Request is valid?
      if(rd_sid && self._util_stanza_parse_content(stanza)) {
        // Handle additional data (optional)
        // Still unsure if it is relevant to parse groups there... (are they allowed in such stanza?)
        //self._util_stanza_parse_group(stanza);

        // Re-generate and store new content data
        self._util_build_content_remote();

        var sdp_candidates_remote = self._util_sdp_generate_candidates(
          self._get_candidates_queue_remote()
        );

        // ICE candidates
        for(i in sdp_candidates_remote) {
          cur_candidate_obj = sdp_candidates_remote[i];

          self._get_peer_connection().addIceCandidate(
            new WEBRTC_ICE_CANDIDATE({
              sdpMLineIndex : cur_candidate_obj.id,
              candidate     : cur_candidate_obj.candidate
            })
          );
        }

        // Empty the unapplied candidates queue
        self._set_candidates_queue_remote(null);

        // Success reply
        self.send(JSJAC_JINGLE_STANZA_TYPE_RESULT, { id: stanza.getID() });
      } else {
        // Send error reply
        self.send_error(stanza, XMPP_ERROR_BAD_REQUEST);

        self.get_debug().log('[JSJaCJingle] handle_transport_info > Error.', 1);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_transport_info > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle transport info success
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_info_success = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_info_success', 4);
  };

  /**
   * Handles the Jingle transport info error
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_info_error = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_info_error', 4);
  };

  /**
   * Handles the Jingle transport reject
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_reject = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_reject', 4);

    try {
      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_transport_reject > ' + e, 1);
    }
  };

  /**
   * Handles the Jingle transport replace
   * @param {JSJaCPacket} stanza Jingle handled stanza
   */
  self.handle_transport_replace = function(stanza) {
    self.get_debug().log('[JSJaCJingle] handle_transport_replace', 4);

    try {
      // Not implemented for now
      self.send_error(stanza, XMPP_ERROR_FEATURE_NOT_IMPLEMENTED);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] handle_transport_replace > ' + e, 1);
    }
  };



  /**
   * JSJSAC JINGLE GETTERS
   */

  /**
   * @private
   */
  self._get_session_initiate_pending = function() {
    if(typeof self._session_initiate_pending == 'function')
      return self._session_initiate_pending;

    return function() {};
  };

  /**
   * @private
   */
  self._get_session_initiate_success = function() {
    if(typeof self._session_initiate_success == 'function')
      return self._session_initiate_success;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_initiate_error = function() {
    if(typeof self._session_initiate_error == 'function')
      return self._session_initiate_error;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_initiate_request = function() {
    if(typeof self._session_initiate_request == 'function')
      return self._session_initiate_request;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_accept_pending = function() {
    if(typeof self._session_accept_pending == 'function')
      return self._session_accept_pending;

    return function() {};
  };

  /**
   * @private
   */
  self._get_session_accept_success = function() {
    if(typeof self._session_accept_success == 'function')
      return self._session_accept_success;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_accept_error = function() {
    if(typeof self._session_accept_error == 'function')
      return self._session_accept_error;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_accept_request = function() {
    if(typeof self._session_accept_request == 'function')
      return self._session_accept_request;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_info_success = function() {
    if(typeof self._session_info_success == 'function')
      return self._session_info_success;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_info_error = function() {
    if(typeof self._session_info_error == 'function')
      return self._session_info_error;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_info_request = function() {
    if(typeof self._session_info_request == 'function')
      return self._session_info_request;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_terminate_pending = function() {
    if(typeof self._session_terminate_pending == 'function')
      return self._session_terminate_pending;

    return function() {};
  };

  /**
   * @private
   */
  self._get_session_terminate_success = function() {
    if(typeof self._session_terminate_success == 'function')
      return self._session_terminate_success;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_terminate_error = function() {
    if(typeof self._session_terminate_error == 'function')
      return self._session_terminate_error;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_session_terminate_request = function() {
    if(typeof self._session_terminate_request == 'function')
      return self._session_terminate_request;

    return function(stanza) {};
  };

  /**
   * @private
   */
  self._get_local_stream = function() {
    return self._local_stream;
  };

  /**
   * @private
   */
  self._get_remote_stream = function() {
    return self._remote_stream;
  };

  /**
   * @private
   */
  self._get_payloads_local = function(name) {
    if(name)
      return (name in self._payloads_local) ? self._payloads_local[name] : {};

    return self._payloads_local;
  };

  /**
   * @private
   */
  self._get_group_local = function(semantics) {
    if(semantics)
      return (semantics in self._group_local) ? self._group_local[semantics] : {};

    return self._group_local;
  };

  /**
   * @private
   */
  self._get_candidates_local = function(name) {
    if(name)
      return (name in self._candidates_local) ? self._candidates_local[name] : {};

    return self._candidates_local;
  };

  /**
   * @private
   */
  self._get_candidates_queue_local = function(name) {
    if(name)
      return (name in self._candidates_queue_local) ? self._candidates_queue_local[name] : {};

    return self._candidates_queue_local;
  };

  /**
   * @private
   */
  self._get_payloads_remote = function(name) {
    if(name)
      return (name in self._payloads_remote) ? self._payloads_remote[name] : {};

    return self._payloads_remote;
  };

  /**
   * @private
   */
  self._get_group_remote = function(semantics) {
    if(semantics)
      return (semantics in self._group_remote) ? self._group_remote[semantics] : {};

    return self._group_remote;
  };

  /**
   * @private
   */
  self._get_candidates_remote = function(name) {
    if(name)
      return (name in self._candidates_remote) ? self._candidates_remote[name] : [];

    return self._candidates_remote;
  };

  /**
   * @private
   */
  self._get_candidates_queue_remote = function(name) {
    if(name)
      return (name in self._candidates_queue_remote) ? self._candidates_queue_remote[name] : {};

    return self._candidates_queue_remote;
  };

  /**
   * @private
   */
  self._get_content_local = function(name) {
    if(name)
      return (name in self._content_local) ? self._content_local[name] : {};

    return self._content_local;
  };

  /**
   * @private
   */
  self._get_content_remote = function(name) {
    if(name)
      return (name in self._content_remote) ? self._content_remote[name] : {};

    return self._content_remote;
  };

  /**
   * @private
   */
  self._get_handlers = function(type, id) {
    type = type || JSJAC_JINGLE_STANZA_TYPE_ALL;

    if(id) {
      if(type != JSJAC_JINGLE_STANZA_TYPE_ALL && type in self._handlers && typeof self._handlers[type][id] == 'function')
        return self._handlers[type][id];

      if(JSJAC_JINGLE_STANZA_TYPE_ALL in self._handlers && typeof self._handlers[JSJAC_JINGLE_STANZA_TYPE_ALL][id] == 'function')
        return self._handlers[type][id];
    }

    return null;
  };

  /**
   * @private
   */
  self._get_peer_connection = function() {
    return self._peer_connection;
  };

  /**
   * @private
   */
  self._get_id = function() {
    return self._id;
  };

  /**
   * @private
   */
  self._get_id_pre = function() {
    return JSJAC_JINGLE_STANZA_ID_PRE + '_' + (self.get_sid() || '0') + '_';
  };

  /**
   * @private
   */
  self._get_id_new = function() {
    var trans_id = self._get_id() + 1;
    self._set_id(trans_id);

    return self._get_id_pre() + trans_id;
  };

  /**
   * @private
   */
  self._get_sent_id = function() {
    return self._sent_id;
  };

  /**
   * @private
   */
  self._get_received_id = function() {
    return self._received_id;
  };

  /**
   * Gets the mute state
   * @return mute value
   * @type boolean
   */
  self.get_mute = function(name) {
    if(!name) name = '*';

    return (name in self._mute) ? self._mute[name] : false;
  };

  /**
   * Gets the lock value
   * @return lock value
   * @type boolean
   */
  self.get_lock = function() {
    return self._lock || !JSJAC_JINGLE_AVAILABLE;
  };

  /**
   * Gets the media busy value
   * @return media busy value
   * @type boolean
   */
  self.get_media_busy = function() {
    return self._media_busy;
  };

  /**
   * Gets the sid value
   * @return sid value
   * @type string
   */
  self.get_sid = function() {
    return self._sid;
  };

  /**
   * Gets the status value
   * @return status value
   * @type string
   */
  self.get_status = function() {
    return self._status;
  };

  /**
   * Gets the reason value
   * @return reason value
   * @type string
   */
  self.get_reason = function() {
    return self._reason;
  };

  /**
   * Gets the to value
   * @return to value
   * @type string
   */
  self.get_to = function() {
    return self._to;
  };

  /**
   * Gets the media value
   * @return media value
   * @type string
   */
  self.get_media = function() {
    return (self._media && self._media in JSJAC_JINGLE_MEDIAS) ? self._media : JSJAC_JINGLE_MEDIA_VIDEO;
  };

  /**
   * Gets a list of medias in use
   * @return media list
   * @type object
   */
  self.get_media_all = function() {
    if(self.get_media() == JSJAC_JINGLE_MEDIA_AUDIO)
      return [JSJAC_JINGLE_MEDIA_AUDIO];

    return [JSJAC_JINGLE_MEDIA_AUDIO, JSJAC_JINGLE_MEDIA_VIDEO];
  };

  /**
   * Gets the video source value
   * @return video source value
   * @type string
   */
  self.get_video_source = function() {
    return (self._video_source && self._video_source in JSJAC_JINGLE_VIDEO_SOURCES) ? self._video_source : JSJAC_JINGLE_VIDEO_SOURCE_CAMERA;
  };

  /**
   * Gets the resolution value
   * @return resolution value
   * @type string
   */
  self.get_resolution = function() {
    return self._resolution ? (self._resolution).toString() : null;
  };

  /**
   * Gets the bandwidth value
   * @return bandwidth value
   * @type string
   */
  self.get_bandwidth = function() {
    return self._bandwidth ? (self._bandwidth).toString() : null;
  };

  /**
   * Gets the fps value
   * @return fps value
   * @type string
   */
  self.get_fps = function() {
    return self._fps ? (self._fps).toString() : null;
  };

  /**
   * Gets the name value
   * @return name value
   * @type string
   */
  self.get_name = function(name) {
    if(name)
      return name in self._name;

    return self._name;
  };

  /**
   * Gets the senders value
   * @return senders value
   * @type string
   */
  self.get_senders = function(name) {
    if(name)
      return (name in self._senders) ? self._senders[name] : null;

    return self._senders;
  };

  /**
   * Gets the creator value
   * @return creator value
   * @type string
   */
  self.get_creator = function(name) {
    if(name)
      return (name in self._creator) ? self._creator[name] : null;

    return self._creator;
  };

  /**
   * Gets the creator value (for this)
   * @return creator value
   * @type string
   */
  self.get_creator_this = function(name) {
    return self.get_responder() == self.get_to() ? JSJAC_JINGLE_CREATOR_INITIATOR : JSJAC_JINGLE_CREATOR_RESPONDER;
  };

  /**
   * Gets the initiator value
   * @return initiator value
   * @type string
   */
  self.get_initiator = function() {
    return self._initiator;
  };

  /**
   * Gets the response value
   * @return response value
   * @type string
   */
  self.get_responder = function() {
    return self._responder;
  };

  /**
   * Gets the local_view value
   * @return local_view value
   * @type DOM
   */
  self.get_local_view = function() {
    return (typeof self._local_view == 'object') ? self._local_view : [];
  };

  /**
   * Gets the remote_view value
   * @return remote_view value
   * @type DOM
   */
  self.get_remote_view = function() {
    return (typeof self._remote_view == 'object') ? self._remote_view : [];
  };

  /**
   * Gets the STUN servers
   * @return STUN servers
   * @type object
   */
  self.get_stun = function() {
    return (typeof self._stun == 'object') ? self._stun : {};
  };

  /**
   * Gets the TURN servers
   * @return TURN servers
   * @type object
   */
  self.get_turn = function() {
    return (typeof self._turn == 'object') ? self._turn : {};
  };

  /**
   * Gets the SDP trace value
   * @return SDP trace value
   * @type JSJaCsdp_traceger
   */
  self.get_sdp_trace = function() {
    return (self._sdp_trace === true);
  };

  /**
   * Gets the debug value
   * @return debug value
   * @type JSJaCDebugger
   */
  self.get_debug = function() {
    return self._debug;
  };



  /**
   * JSJSAC JINGLE SETTERS
   */

  /**
   * @private
   */
  self._set_session_initiate_pending = function(session_initiate_pending) {
    self._session_initiate_pending = session_initiate_pending;
  };

  /**
   * @private
   */
  self._set_initiate_success = function(initiate_success) {
    self._session_initiate_success = initiate_success;
  };

  /**
   * @private
   */
  self._set_initiate_error = function(initiate_error) {
    self._session_initiate_error = initiate_error;
  };

  /**
   * @private
   */
  self._set_initiate_request = function(initiate_request) {
    self._session_initiate_request = initiate_request;
  };

  /**
   * @private
   */
  self._set_accept_pending = function(accept_pending) {
    self._session_accept_pending = accept_pending;
  };

  /**
   * @private
   */
  self._set_accept_success = function(accept_success) {
    self._session_accept_success = accept_success;
  };

  /**
   * @private
   */
  self._set_accept_error = function(accept_error) {
    self._session_accept_error = accept_error;
  };

  /**
   * @private
   */
  self._set_accept_request = function(accept_request) {
    self._session_accept_request = accept_request;
  };

  /**
   * @private
   */
  self._set_info_success = function(info_success) {
    self._session_info_success = info_success;
  };

  /**
   * @private
   */
  self._set_info_error = function(info_error) {
    self._session_info_error = info_error;
  };

  /**
   * @private
   */
  self._set_info_request = function(info_request) {
    self._session_info_request = info_request;
  };

  /**
   * @private
   */
  self._set_terminate_pending = function(terminate_pending) {
    self._session_terminate_pending = terminate_pending;
  };

  /**
   * @private
   */
  self._set_terminate_success = function(terminate_success) {
    self._session_terminate_success = terminate_success;
  };

  /**
   * @private
   */
  self._set_terminate_error = function(terminate_error) {
    self._session_terminate_error = terminate_error;
  };

  /**
   * @private
   */
  self._set_terminate_request = function(terminate_request) {
    self._session_terminate_request = terminate_request;
  };

  /**
   * @private
   */
  self._set_local_stream = function(local_stream) {
    try {
      if(!local_stream && self._local_stream) {
        (self._local_stream).stop();

        self._util_peer_stream_detach(
          self.get_local_view()
        );
      }

      self._local_stream = local_stream;

      if(local_stream) {
        self._util_peer_stream_attach(
          self.get_local_view(),
          self._get_local_stream(),
          true
        );
      } else {
        self._util_peer_stream_detach(
          self.get_local_view()
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _set_local_stream > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._set_remote_stream = function(remote_stream) {
    try {
      if(!remote_stream && self._remote_stream) {
        self._util_peer_stream_detach(
          self.get_remote_view()
        );
      }

      self._remote_stream = remote_stream;

      if(remote_stream) {
        self._util_peer_stream_attach(
          self.get_remote_view(),
          self._get_remote_stream(),
          false
        );
      } else {
        self._util_peer_stream_detach(
          self.get_remote_view()
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _set_remote_stream > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._set_local_view = function(local_view) {
    if(typeof self._local_view !== 'object')
      self._local_view = [];

    self._local_view.push(local_view);
  };

  /**
   * @private
   */
  self._set_remote_view = function(remote_view) {
    if(typeof self._remote_view !== 'object')
      self._remote_view = [];

    self._remote_view.push(remote_view);
  };

  /**
   * @private
   */
  self._set_payloads_local = function(name, payload_data) {
    self._payloads_local[name] = payload_data;
  };

  /**
   * @private
   */
  self._set_group_local = function(semantics, group_data) {
    self._group_local[semantics] = group_data;
  };

  /**
   * @private
   */
  self._set_candidates_local = function(name, candidate_data) {
    if(!(name in self._candidates_local))  self._candidates_local[name] = [];

    (self._candidates_local[name]).push(candidate_data);
  };

  /**
   * @private
   */
  self._set_candidates_queue_local = function(name, candidate_data) {
    try {
      if(name === null) {
        self._candidates_queue_local = {};
      } else {
        if(!(name in self._candidates_queue_local))  self._candidates_queue_local[name] = [];

        (self._candidates_queue_local[name]).push(candidate_data);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _set_candidates_queue_local > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._set_payloads_remote = function(name, payload_data) {
    self._payloads_remote[name] = payload_data;
  };

  /**
   * @private
   */
  self._set_payloads_remote_add = function(name, payload_data) {
    try {
      if(!(name in self._payloads_remote)) {
        self._set_payloads_remote(name, payload_data);
      } else {
        var key;
        var payloads_store = self._payloads_remote[name].descriptions.payload;
        var payloads_add   = payload_data.descriptions.payload;

        for(key in payloads_add) {
          if(!(key in payloads_store))
            payloads_store[key] = payloads_add[key];
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _set_payloads_remote_add > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._set_group_remote = function(semantics, group_data) {
    self._group_remote[semantics] = group_data;
  };

  /**
   * @private
   */
  self._set_candidates_remote = function(name, candidate_data) {
    self._candidates_remote[name] = candidate_data;
  };

  /**
   * @private
   */
  self._set_candidates_queue_remote = function(name, candidate_data) {
    if(name === null)
      self._candidates_queue_remote = {};
    else
      self._candidates_queue_remote[name] = (candidate_data);
  };

  /**
   * @private
   */
  self._set_candidates_remote_add = function(name, candidate_data) {
    try {
      if(!name) return;

      if(!(name in self._candidates_remote))
        self._set_candidates_remote(name, []);
   
      var c, i;
      var candidate_ids = [];

      for(c in self._get_candidates_remote(name))
        candidate_ids.push(self._get_candidates_remote(name)[c].id);

      for(i in candidate_data) {
        if((candidate_data[i].id).indexOf(candidate_ids) !== -1)
          self._get_candidates_remote(name).push(candidate_data[i]);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _set_candidates_remote_add > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._set_content_local = function(name, content_local) {
    self._content_local[name] = content_local;
  };

  /**
   * @private
   */
  self._set_content_remote = function(name, content_remote) {
    self._content_remote[name] = content_remote;
  };

  /**
   * @private
   */
  self._set_handlers = function(type, id, handler) {
    if(!(type in self._handlers))  self._handlers[type] = {};

    self._handlers[type][id] = handler;
  };

  /**
   * @private
   */
  self._set_peer_connection = function(peer_connection) {
    self._peer_connection = peer_connection;
  };

  /**
   * @private
   */
  self._set_id = function(id) {
    self._id = id;
  };

  /**
   * @private
   */
  self._set_sent_id = function(sent_id) {
    self._sent_id[sent_id] = 1;
  };

  /**
   * @private
   */
  self._set_received_id = function(received_id) {
    self._received_id[received_id] = 1;
  };

  /**
   * @private
   */
  self._set_mute = function(name, mute) {
    if(!name || name == '*') {
      self._mute = {};
      name = '*';
    }

    self._mute[name] = mute;
  };

  /**
   * @private
   */
  self._set_lock = function(lock) {
    self._lock = lock;
  };

  /**
   * Gets the media busy value
   * @return media busy value
   * @type boolean
   */
  self._set_media_busy = function(busy) {
    self._media_busy = busy;
  };

  /**
   * @private
   */
  self._set_sid = function(sid) {
    self._sid = sid;
  };

  /**
   * @private
   */
  self._set_status = function(status) {
    self._status = status;
  };

  /**
   * @private
   */
  self._set_reason = function(reason) {
    self._reason = reason || JSJAC_JINGLE_REASON_CANCEL;
  };

  /**
   * @private
   */
  self._set_to = function(to) {
    self._to = to;
  };

  /**
   * @private
   */
  self._set_media = function(media) {
    self._media = media;
  };

  /**
   * @private
   */
  self._set_video_source = function() {
    self._video_source = video_source;
  };

  /**
   * @private
   */
  self._set_resolution = function(resolution) {
    self._resolution = resolution;
  };

  /**
   * @private
   */
  self._set_bandwidth = function(bandwidth) {
    self._bandwidth = bandwidth;
  };

  /**
   * @private
   */
  self._set_fps = function(fps) {
    self._fps = fps;
  };

  /**
   * @private
   */
  self._set_name = function(name) {
    self._name[name] = 1;
  };

  /**
   * @private
   */
  self._set_senders = function(name, senders) {
    if(!(senders in JSJAC_JINGLE_SENDERS)) senders = JSJAC_JINGLE_SENDERS_BOTH.jingle;

    self._senders[name] = senders;
  };

  /**
   * @private
   */
  self._set_creator = function(name, creator) {
    if(!(creator in JSJAC_JINGLE_CREATORS)) creator = JSJAC_JINGLE_CREATOR_INITIATOR;

    self._creator[name] = creator;
  };

  /**
   * @private
   */
  self._set_initiator = function(initiator) {
    self._initiator = initiator;
  };

  /**
   * @private
   */
  self._set_responder = function(responder) {
    self._responder = responder;
  };

  /**
   * @private
   */
  self._set_stun = function(stun_host, stun_data) {
    self._stun[stun_server] = stun_data;
  };

  /**
   * @private
   */
  self._set_turn = function(turn_host, turn_data) {
    self._turn[turn_server] = turn_data;
  };

  /**
   * @private
   */
  self._set_sdp_trace = function(sdp_trace) {
    self._sdp_trace = sdp_trace;
  };

  /**
   * @private
   */
  self._set_debug = function(debug) {
    self._debug = debug;
  };



  /**
   * JSJSAC JINGLE SHORTCUTS
   */

  /**
   * Am I responder?
   * @return Receiver state
   * @type boolean
   */
  self.is_responder = function() {
    return self.util_negotiation_status() == JSJAC_JINGLE_SENDERS_RESPONDER.jingle;
  };

  /**
   * Am I initiator?
   * @return Initiator state
   * @type boolean
   */
  self.is_initiator = function() {
    return self.util_negotiation_status() == JSJAC_JINGLE_SENDERS_INITIATOR.jingle;
  };



  /**
   * JSJSAC JINGLE UTILITIES
   */

  /**
   * Removes a given array value
   * @return new array
   * @type object
   */
  self.util_array_remove_value = function(array, value) {
    try {
      var i;

      for(i = 0; i < array.length; i++) {
        if(array[i] === value) {
          array.splice(i, 1); i--;
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_array_remove_value > ' + e, 1);
    }

    return array;
  };

  /**
   * Returns whether an object is empty or not
   * @return Empty value
   * @type boolean
   */
  self.util_object_length = function(object) {
    var key;
    var l = 0;

    try {
      for(key in object) {
        if(object.hasOwnProperty(key))  l++;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_object_length > ' + e, 1);
    }

    return l;
  };

  /**
   * Collects given objects
   * @return Empty value
   * @type object
   */
  self.util_object_collect = function() {
    var i, p;

    var collect_obj = {};
    var len = arguments.length;

    for(i = 0; i < len; i++) {
      for(p in arguments[i]) {
        if(arguments[i].hasOwnProperty(p))
          collect_obj[p] = arguments[i][p];
      }
    }

    return collect_obj;
  };

  /**
   * Clones a given object
   * @return Cloned object
   * @type object
   */
  self.util_object_clone = function(object) {
    try {
      var copy, i, attr;

      // Assert
      if(object === null || typeof object !== 'object') return object;

      // Handle Date
      if(object instanceof Date) {
          copy = new Date();
          copy.setTime(object.getTime());

          return copy;
      }

      // Handle Array
      if(object instanceof Array) {
          copy = [];

          for(i = 0, len = object.length; i < len; i++)
            copy[i] = self.util_object_clone(object[i]);

          return copy;
      }

      // Handle Object
      if(object instanceof Object) {
          copy = {};

          for(attr in object) {
              if(object.hasOwnProperty(attr))
                copy[attr] = self.util_object_clone(object[attr]);
          }

          return copy;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_object_clone > ' + e, 1);
    }

    self.get_debug().log('[JSJaCJingle] util_object_clone > Cannot clone this object.', 1);
  };

  /**
   * Gets the browser info
   * @return browser info
   * @type object
   */
  self._util_browser = function() {
    var browser_info = {
      name    : 'Generic'
    };

    try {
      var user_agent, detect_arr, cur_browser;

      detect_arr = {
        'firefox' : JSJAC_JINGLE_BROWSER_FIREFOX,
        'chrome'  : JSJAC_JINGLE_BROWSER_CHROME,
        'safari'  : JSJAC_JINGLE_BROWSER_SAFARI,
        'opera'   : JSJAC_JINGLE_BROWSER_OPERA,
        'msie'    : JSJAC_JINGLE_BROWSER_IE
      };

      user_agent = navigator.userAgent.toLowerCase();

      for(cur_browser in detect_arr) {
        if(user_agent.indexOf(cur_browser) > -1) {
          browser_info.name = detect_arr[cur_browser];
          break;
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_browser > ' + e, 1);
    }

    return browser_info;
  };

  /**
   * Gets the ICE config
   * @return ICE config
   * @type object
   */
  self._util_config_ice = function() {
    try {
      // Collect data (user + server)
      var stun_config = self.util_object_collect(
        self.get_stun(),
        JSJAC_JINGLE_STORE_EXTDISCO.stun,
        JSJAC_JINGLE_STORE_FALLBACK.stun
      );

      var turn_config = self.util_object_collect(
        self.get_turn(),
        JSJAC_JINGLE_STORE_EXTDISCO.turn,
        JSJAC_JINGLE_STORE_FALLBACK.turn
      );

      // Can proceed?
      if(stun_config && self.util_object_length(stun_config)  || 
         turn_config && self.util_object_length(turn_config)  ) {
        var config = {
          iceServers : []
        };

        // STUN servers
        var cur_stun_host, cur_stun_obj, cur_stun_config;

        for(cur_stun_host in stun_config) {
          if(cur_stun_host) {
            cur_stun_obj = stun_config[cur_stun_host];

            cur_stun_config = {};
            cur_stun_config.url = 'stun:' + cur_stun_host;

            if(cur_stun_obj.port)
              cur_stun_config.url += ':' + cur_stun_obj.port;

            if(cur_stun_obj.transport && self._util_browser().name != JSJAC_JINGLE_BROWSER_FIREFOX)
              cur_stun_config.url += '?transport=' + cur_stun_obj.transport;

            (config.iceServers).push(cur_stun_config);
          }
        }

        // TURN servers
        var cur_turn_host, cur_turn_obj, cur_turn_config;

        for(cur_turn_host in turn_config) {
          if(cur_turn_host) {
            cur_turn_obj = turn_config[cur_turn_host];

            cur_turn_config = {};
            cur_turn_config.url = 'turn:' + cur_turn_host;

            if(cur_turn_obj.port)
              cur_turn_config.url += ':' + cur_turn_obj.port;

            if(cur_turn_obj.transport)
              cur_turn_config.url += '?transport=' + cur_turn_obj.transport;

            if(cur_turn_obj.username)
              cur_turn_config.username = cur_turn_obj.username;

            if(cur_turn_obj.password)
              cur_turn_config.password = cur_turn_obj.password;

            (config.iceServers).push(cur_turn_config);
          }
        }

        // Check we have at least a STUN server (if user can traverse NAT)
        var i;
        var has_stun = false;

        for(i in config.iceServers) {
          if((config.iceServers[i].url).match(/^stun:/i)) {
            has_stun = true; break;
          }
        }

        if(!has_stun) {
          (config.iceServers).push({
            url: (WEBRTC_CONFIGURATION.peer_connection.config.iceServers)[0].url
          });
        }

        return config;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_config_ice > ' + e, 1);
    }

    return WEBRTC_CONFIGURATION.peer_connection.config;
  };

  /**
   * Gets the node value from a stanza element
   * @return Node value
   * @type string
   */
  self.util_stanza_get_value = function(stanza) {
    try {
      return stanza.firstChild.nodeValue || null;
    } catch(e) {
      try {
        return (stanza[0]).firstChild.nodeValue || null;
      } catch(_e) {
        self.get_debug().log('[JSJaCJingle] util_stanza_get_value > ' + _e, 1);
      }
    }

    return null;
  };

  /**
   * Gets the attribute value from a stanza element
   * @return Attribute value
   * @type string
   */
  self.util_stanza_get_attribute = function(stanza, name) {
    if(!name) return null;

    try {
      return stanza.getAttribute(name) || null;
    } catch(e) {
      try {
        return (stanza[0]).getAttribute(name) || null;
      } catch(_e) {
        self.get_debug().log('[JSJaCJingle] util_stanza_get_attribute > ' + _e, 1);
      }
    }

    return null;
  };

  /**
   * Sets the attribute value to a stanza element
   */
  self.util_stanza_set_attribute = function(stanza, name, value) {
    if(!(name && value && stanza)) return;

    try {
      stanza.setAttribute(name, value);
    } catch(e) {
      try {
        (stanza[0]).setAttribute(name, value);
      } catch(_e) {
        self.get_debug().log('[JSJaCJingle] util_stanza_set_attribute > ' + _e, 1);
      }
    }
  };

  /**
   * Gets the Jingle node from a stanza
   * @return Jingle node
   * @type DOM
   */
  self.util_stanza_get_element = function(stanza, name, ns) {
    // Assert
    if(!stanza)        return [];
    if(stanza.length)  stanza = stanza[0];

    try {
      // Get only in lower level (not all sub-levels)
      var matches = stanza.getElementsByTagNameNS(ns, name);

      if(matches[0] && matches[0].parentNode == stanza)  return matches;

      return [];
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_get_element > ' + e, 1);
    }

    return [];
  };

  /**
   * Gets the Jingle node from a stanza
   * @return Jingle node
   * @type DOM
   */
  self.util_stanza_jingle = function(stanza) {
    try {
      return stanza.getChild('jingle', NS_JINGLE);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_jingle > ' + e, 1);
    }

    return null;
  };

  /**
   * Gets the from value from a stanza
   * @return from value
   * @type string
   */
  self.util_stanza_from = function(stanza) {
    try {
      return stanza.getFrom() || null;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_from > ' + e, 1);
    }

    return null;
  };

  /**
   * Gets the SID value from a stanza
   * @return SID value
   * @type string
   */
  self.util_stanza_sid = function(stanza) {
    try {
      return self.util_stanza_get_attribute(
        self.util_stanza_jingle(stanza),
        'sid'
      );
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_sid > ' + e, 1);
    }
  };

  /**
   * Checks if a stanza is safe (known SID + sender)
   * @return safety state
   * @type boolean
   */
  self.util_stanza_safe = function(stanza) {
    try {
      return !((stanza.getType() == JSJAC_JINGLE_STANZA_TYPE_SET && self.util_stanza_sid(stanza) != self.get_sid()) || self.util_stanza_from(stanza) != self.get_to());
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_safe > ' + e, 1);
    }

    return false;
  };

  /**
   * Gets a stanza terminate reason
   * @return reason code
   * @type string
   */
  self.util_stanza_terminate_reason = function(stanza) {
    try {
      var jingle = self.util_stanza_jingle(stanza);

      if(jingle) {
        var reason = self.util_stanza_get_element(jingle, 'reason', NS_JINGLE);

        if(reason.length) {
          var cur_reason;

          for(cur_reason in JSJAC_JINGLE_REASONS) {
            if(self.util_stanza_get_element(reason[0], cur_reason, NS_JINGLE).length)
              return cur_reason;
          }
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_terminate_reason > ' + e, 1);
    }

    return null;
  };

  /**
   * Gets a stanza session info
   * @return info code
   * @type string
   */
  self.util_stanza_session_info = function(stanza) {
    try {
      var jingle = self.util_stanza_jingle(stanza);

      if(jingle) {
        var cur_info;

        for(cur_info in JSJAC_JINGLE_SESSION_INFOS) {
          if(self.util_stanza_get_element(jingle, cur_info, NS_JINGLE_APPS_RTP_INFO).length)
            return cur_info;
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_session_info > ' + e, 1);
    }

    return null;
  };

  /**
   * Set a timeout limit to a stanza
   */
  self.util_stanza_timeout = function(t_type, t_id, handlers) {
    try {
      t_type = t_type || JSJAC_JINGLE_STANZA_TYPE_ALL;

      var t_sid = self.get_sid();
      var t_status = self.get_status();

      self.get_debug().log('[JSJaCJingle] util_stanza_timeout > Registered (id: ' + t_id + ', status: ' + t_status + ').', 4);

      setTimeout(function() {
        self.get_debug().log('[JSJaCJingle] util_stanza_timeout > Cheking (id: ' + t_id + ', status: ' + t_status + '-' + self.get_status() + ').', 4);

        // State did not change?
        if(self.get_sid() == t_sid && self.get_status() == t_status && !(t_id in self._get_received_id())) {
          self.get_debug().log('[JSJaCJingle] util_stanza_timeout > Stanza timeout.', 2);

          self.unregister_handler(t_type, t_id);

          if(handlers.external)  (handlers.external)(self);
          if(handlers.internal)  (handlers.internal)();
        } else {
          self.get_debug().log('[JSJaCJingle] util_stanza_timeout > Stanza successful.', 4);
        }
      }, (JSJAC_JINGLE_STANZA_TIMEOUT * 1000));
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_stanza_timeout > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_stanza_parse_node = function(parent, name, ns, obj, attrs, value) {
    try {
      var i, j,
          error, child, child_arr;
      var children = self.util_stanza_get_element(parent, name, ns);

      if(children.length) {
        for(i = 0; i < children.length; i++) {
          // Initialize
          error = 0;
          child = children[i];
          child_arr = {};

          // Parse attributes
          for(j in attrs) {
            child_arr[attrs[j].n] = self.util_stanza_get_attribute(child, attrs[j].n);

            if(attrs[j].r && !child_arr[attrs[j].n]) {
              error++; break;
            }
          }

          // Parse value
          if(value) {
            child_arr[value.n] = self.util_stanza_get_value(child);
            if(value.r && !child_arr[value.n])  error++;
          }

          if(error !== 0) continue;

          // Push current children
          obj.push(child_arr);
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_parse_node > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_stanza_parse_content = function(stanza) {
    try {
      var i,
          jingle, content, cur_content,
          content_creator, content_name, content_senders,
          cur_candidates;

      // Parse initiate stanza
      jingle = self.util_stanza_jingle(stanza);

      if(jingle) {
        // Childs
        content = self.util_stanza_get_element(jingle, 'content', NS_JINGLE);

        if(content && content.length) {
          for(i = 0; i < content.length; i++) {
            cur_content = content[i];

            // Attrs (avoids senders & creators to be changed later in the flow)
            content_name    = self.util_stanza_get_attribute(cur_content, 'name');
            content_senders = self.get_senders(content_name) || self.util_stanza_get_attribute(cur_content, 'senders');
            content_creator = self.get_creator(content_name) || self.util_stanza_get_attribute(cur_content, 'creator');

            self._set_name(content_name);
            self._set_senders(content_name, content_senders);
            self._set_creator(content_name, content_creator);

            // Payloads (non-destructive setters / cumulative)
            self._set_payloads_remote_add(
              content_name,
              self._util_stanza_parse_payload(cur_content)
            );

            // Candidates (enqueue them for ICE processing, too)
            cur_candidate = self._util_stanza_parse_candidate(cur_content);

            self._set_candidates_remote_add(
              content_name,
              cur_candidate
            );

            self._set_candidates_queue_remote(
              content_name,
              cur_candidate
            );
          }

          return true;
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_parse_content > ' + e, 1);
    }

    return false;
  };

  /**
   * @private
   */
  self._util_stanza_parse_group = function(stanza) {
    try {
      var i, j,
          jingle,
          group, cur_group,
          content, cur_content, group_content_names;

      // Parse initiate stanza
      jingle = self.util_stanza_jingle(stanza);

      if(jingle) {
        // Childs
        group = self.util_stanza_get_element(jingle, 'group', NS_JINGLE_APPS_GROUPING);

        if(group && group.length) {
          for(i = 0; i < group.length; i++) {
            cur_group = group[i];
            group_content_names = [];

            // Attrs
            group_semantics = self.util_stanza_get_attribute(cur_group, 'semantics');

            // Contents
            content = self.util_stanza_get_element(cur_group, 'content', NS_JINGLE_APPS_GROUPING);

            for(j = 0; j < content.length; j++) {
              cur_content = content[j];

              // Content attrs
              group_content_names.push(
                self.util_stanza_get_attribute(cur_content, 'name')
              );
            }

            // Payloads (non-destructive setters / cumulative)
            self._set_group_remote(
              group_semantics,
              group_content_names
            );
          }
        }
      }

      return true;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_parse_group > ' + e, 1);
    }

    return false;
  };

  /**
   * @private
   */
  self._util_stanza_parse_payload = function(stanza_content) {
    var payload_obj = {
      descriptions : {},
      transports   : {}
    };

    try {
      // Common vars
      var j, error,
          cur_payload, cur_payload_arr, cur_payload_id;

      // Common functions
      var init_content = function() {
        var ic_key;
        var ic_arr = {
          'attrs'      : {},
          'rtcp-fb'    : [],
          'bandwidth'  : [],
          'payload'    : {},
          'rtp-hdrext' : [],
          'rtcp-mux'   : 0,

          'encryption' : {
            'attrs'     : {},
            'crypto'    : [],
            'zrtp-hash' : []
          }
        };

        for(ic_key in ic_arr)
          if(!(ic_key in payload_obj.descriptions))  payload_obj.descriptions[ic_key] = ic_arr[ic_key];
      };

      var init_payload = function(id) {
        var ip_key;
        var ip_arr = {
          'attrs'           : {},
          'parameter'       : [],
          'rtcp-fb'         : [],
          'rtcp-fb-trr-int' : []
        };

        if(!(id in payload_obj.descriptions.payload))  payload_obj.descriptions.payload[id] = {};

        for(ip_key in ip_arr)
          if(!(ip_key in payload_obj.descriptions.payload[id]))  payload_obj.descriptions.payload[id][ip_key] = ip_arr[ip_key];
      };

      // Parse session description
      var description = self.util_stanza_get_element(stanza_content, 'description', NS_JINGLE_APPS_RTP);

      if(description.length) {
        description = description[0];

        var cd_media = self.util_stanza_get_attribute(description, 'media');
        var cd_ssrc  = self.util_stanza_get_attribute(description, 'ssrc');

        if(!cd_media)
          self.get_debug().log('[JSJaCJingle] util_stanza_parse_payload > No media attribute to ' + cc_name + ' stanza.', 1);

        // Initialize current description
        init_content();

        payload_obj.descriptions.attrs.media = cd_media;
        payload_obj.descriptions.attrs.ssrc  = cd_ssrc;

        // Loop on multiple payloads
        var payload = self.util_stanza_get_element(description, 'payload-type', NS_JINGLE_APPS_RTP);

        if(payload.length) {
          for(j = 0; j < payload.length; j++) {
            error           = 0;
            cur_payload     = payload[j];
            cur_payload_arr = {};

            cur_payload_arr.channels  = self.util_stanza_get_attribute(cur_payload, 'channels');
            cur_payload_arr.clockrate = self.util_stanza_get_attribute(cur_payload, 'clockrate');
            cur_payload_arr.id        = self.util_stanza_get_attribute(cur_payload, 'id') || error++;
            cur_payload_arr.name      = self.util_stanza_get_attribute(cur_payload, 'name');

            payload_obj.descriptions.attrs.ptime     = self.util_stanza_get_attribute(cur_payload, 'ptime');
            payload_obj.descriptions.attrs.maxptime  = self.util_stanza_get_attribute(cur_payload, 'maxptime');

            if(error !== 0) continue;

            // Initialize current payload
            cur_payload_id = cur_payload_arr.id;
            init_payload(cur_payload_id);

            // Push current payload
            payload_obj.descriptions.payload[cur_payload_id].attrs = cur_payload_arr;

            // Loop on multiple parameters
            self._util_stanza_parse_node(
              cur_payload,
              'parameter',
              NS_JINGLE_APPS_RTP,
              payload_obj.descriptions.payload[cur_payload_id].parameter,
              [ { n: 'name', r: 1 }, { n: 'value', r: 0 } ]
            );

            // Loop on multiple RTCP-FB
            self._util_stanza_parse_node(
              cur_payload,
              'rtcp-fb',
              NS_JINGLE_APPS_RTP_RTCP_FB,
              payload_obj.descriptions.payload[cur_payload_id]['rtcp-fb'],
              [ { n: 'type', r: 1 }, { n: 'subtype', r: 0 } ]
            );

            // Loop on multiple RTCP-FB-TRR-INT
            self._util_stanza_parse_node(
              cur_payload,
              'rtcp-fb-trr-int',
              NS_JINGLE_APPS_RTP_RTCP_FB,
              payload_obj.descriptions.payload[cur_payload_id]['rtcp-fb-trr-int'],
              [ { n: 'value', r: 1 } ]
            );
          }
        }

        // Parse the encryption element
        var encryption = self.util_stanza_get_element(description, 'encryption', NS_JINGLE_APPS_RTP);

        if(encryption.length) {
          encryption = encryption[0];

          payload_obj.descriptions.encryption.attrs.required = self.util_stanza_get_attribute(encryption, 'required') || '0';

          // Loop on multiple cryptos
          self._util_stanza_parse_node(
            encryption,
            'crypto',
            NS_JINGLE_APPS_RTP,
            payload_obj.descriptions.encryption.crypto,
            [ { n: 'crypto-suite', r: 1 }, { n: 'key-params', r: 1 }, { n: 'session-params', r: 0 }, { n: 'tag', r: 1 } ]
          );

          // Loop on multiple zrtp-hash
          self._util_stanza_parse_node(
            encryption,
            'zrtp-hash',
            NS_JINGLE_APPS_RTP_ZRTP,
            payload_obj.descriptions.encryption['zrtp-hash'],
            [ { n: 'version', r: 1 } ],
            { n: 'value', r: 1 }
          );
        }

        // Loop on common RTCP-FB
        self._util_stanza_parse_node(
          description,
          'rtcp-fb',
          NS_JINGLE_APPS_RTP_RTCP_FB,
          payload_obj.descriptions['rtcp-fb'],
          [ { n: 'type', r: 1 }, { n: 'subtype', r: 0 } ]
        );

        // Loop on bandwidth
        self._util_stanza_parse_node(
          description,
          'bandwidth',
          NS_JINGLE_APPS_RTP,
          payload_obj.descriptions.bandwidth,
          [ { n: 'type', r: 1 } ],
          { n: 'value', r: 1 }
        );

        // Parse the RTP-HDREXT element
        self._util_stanza_parse_node(
          description,
          'rtp-hdrext',
          NS_JINGLE_APPS_RTP_RTP_HDREXT,
          payload_obj.descriptions['rtp-hdrext'],
          [ { n: 'id', r: 1 }, { n: 'uri', r: 1 }, { n: 'senders', r: 0 } ]
        );

        // Parse the RTCP-MUX element
        var rtcp_mux = self.util_stanza_get_element(description, 'rtcp-mux', NS_JINGLE_APPS_RTP);

        if(rtcp_mux.length) {
          payload_obj.descriptions['rtcp-mux'] = 1;
        }
      }

      // Parse transport (need to get 'ufrag' and 'pwd' there)
      var transport = self.util_stanza_get_element(stanza_content, 'transport', NS_JINGLE_TRANSPORTS_ICEUDP);

      if(transport.length) {
        payload_obj.transports.pwd          = self.util_stanza_get_attribute(transport, 'pwd');
        payload_obj.transports.ufrag        = self.util_stanza_get_attribute(transport, 'ufrag');

        var fingerprint = self.util_stanza_get_element(transport, 'fingerprint', NS_JINGLE_APPS_DTLS);

        if(fingerprint.length) {
          payload_obj.transports.fingerprint          = {};
          payload_obj.transports.fingerprint.setup = self.util_stanza_get_attribute(fingerprint, 'setup');
          payload_obj.transports.fingerprint.hash  = self.util_stanza_get_attribute(fingerprint, 'hash');
          payload_obj.transports.fingerprint.value = self.util_stanza_get_value(fingerprint);
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_parse_payload > ' + e, 1);
    }

    return payload_obj;
  };

  /**
   * @private
   */
  self._util_stanza_parse_candidate = function(stanza_content) {
    var candidate_arr = [];

    try {
      // Common vars
      var i,
          transport, candidate,
          cur_candidate, cur_candidate_obj;

      // Parse transport candidates
      transport = self.util_stanza_get_element(stanza_content, 'transport', NS_JINGLE_TRANSPORTS_ICEUDP);
      
      if(transport.length) {
        self._util_stanza_parse_node(
          transport,
          'candidate',
          NS_JINGLE_TRANSPORTS_ICEUDP,
          candidate_arr,

          [
            { n: 'component',  r: 1 },
            { n: 'foundation', r: 1 },
            { n: 'generation', r: 1 },
            { n: 'id',         r: 1 },
            { n: 'ip',         r: 1 },
            { n: 'network',    r: 1 },
            { n: 'port',       r: 1 },
            { n: 'priority',   r: 1 },
            { n: 'protocol',   r: 1 },
            { n: 'rel-addr',   r: 0 },
            { n: 'rel-port',   r: 0 },
            { n: 'type',       r: 1 }
          ]
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_parse_candidate > ' + e, 1);
    }

    return candidate_arr;
  };

  /*
   * @private
   */
  self._util_stanza_build_node = function(doc, parent, children, name, ns, value) {
    var node = null;

    try {
      var i, child, attr;

      if(children && children.length) {
        for(i in children) {
          child = children[i];

          if(!child) continue;

          node = parent.appendChild(doc.buildNode(
            name,
            { 'xmlns': ns },
            (value && child[value]) ? child[value] : null
          ));

          for(attr in child)
            if(attr != value)  self.util_stanza_set_attribute(node, attr, child[attr]);
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_build_node > name: ' + name + ' > ' + e, 1);
    }

    return node;
  };

  /**
   * @private
   */
  self._util_stanza_generate_jingle = function(stanza, attrs) {
    var jingle = null;

    try {
      var cur_attr;

      jingle = stanza.getNode().appendChild(stanza.buildNode('jingle', { 'xmlns': NS_JINGLE }));

      if(!attrs.sid) attrs.sid = self.get_sid();

      for(cur_attr in attrs) self.util_stanza_set_attribute(jingle, cur_attr, attrs[cur_attr]);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_generate_jingle > ' + e, 1);
    }

    return jingle;
  };

  /**
   * @private
   */
  self._util_stanza_generate_session_info = function(stanza, jingle, args) {
    try {
      var info = jingle.appendChild(stanza.buildNode(args.info, { 'xmlns': NS_JINGLE_APPS_RTP_INFO }));

      // Info attributes
      switch(args.info) {
        case JSJAC_JINGLE_SESSION_INFO_MUTE:
        case JSJAC_JINGLE_SESSION_INFO_UNMUTE:
          self.util_stanza_set_attribute(info, 'creator', self.get_creator_this());
          self.util_stanza_set_attribute(info, 'name',    args.name);

          break;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_generate_session_info > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_stanza_generate_content_local = function(stanza, jingle, override_content) {
    try {
      var cur_media;
      var content_local = override_content ? override_content : self._get_content_local();

      for(cur_media in content_local) {
        var cur_content = content_local[cur_media];

        var content = jingle.appendChild(stanza.buildNode('content', { 'xmlns': NS_JINGLE }));

        self.util_stanza_set_attribute(content, 'creator', cur_content.creator);
        self.util_stanza_set_attribute(content, 'name',    cur_content.name);
        self.util_stanza_set_attribute(content, 'senders', cur_content.senders);

        // Build description (if action type allows that element)
        if(self.util_stanza_get_attribute(jingle, 'action') != JSJAC_JINGLE_ACTION_TRANSPORT_INFO) {
          var cs_description  = cur_content.description;
          var cs_d_attrs      = cs_description.attrs;
          var cs_d_rtcp_fb    = cs_description['rtcp-fb'];
          var cs_d_bandwidth  = cs_description.bandwidth;
          var cs_d_payload    = cs_description.payload;
          var cs_d_encryption = cs_description.encryption;
          var cs_d_rtp_hdrext = cs_description['rtp-hdrext'];
          var cs_d_rtcp_mux   = cs_description['rtcp-mux'];

          var description = self._util_stanza_build_node(
                              stanza, content,
                              [cs_d_attrs],
                              'description',
                              NS_JINGLE_APPS_RTP
                            );

          // Payload-type
          if(cs_d_payload) {
            var i, cs_d_p, payload_type;

            for(i in cs_d_payload) {
              cs_d_p = cs_d_payload[i];

              payload_type = self._util_stanza_build_node(
                               stanza,
                               description,
                               [cs_d_p.attrs],
                               'payload-type',
                               NS_JINGLE_APPS_RTP
                             );

              // Parameter
              self._util_stanza_build_node(
                stanza,
                payload_type,
                cs_d_p.parameter,
                'parameter',
                NS_JINGLE_APPS_RTP
              );

              // RTCP-FB (sub)
              self._util_stanza_build_node(
                stanza,
                payload_type,
                cs_d_p['rtcp-fb'],
                'rtcp-fb',
                NS_JINGLE_APPS_RTP_RTCP_FB
              );

              // RTCP-FB-TRR-INT
              self._util_stanza_build_node(
                stanza,
                payload_type,
                cs_d_p['rtcp-fb-trr-int'],
                'rtcp-fb-trr-int',
                NS_JINGLE_APPS_RTP_RTCP_FB
              );
            }

            // Encryption
            if(cs_d_encryption && 
               (cs_d_encryption.crypto && cs_d_encryption.crypto.length || 
                cs_d_encryption['zrtp-hash'] && cs_d_encryption['zrtp-hash'].length)) {
              var encryption = description.appendChild(stanza.buildNode('encryption', { 'xmlns': NS_JINGLE_APPS_RTP }));

              self.util_stanza_set_attribute(encryption, 'required', (cs_d_encryption.attrs.required || '0'));

              // Crypto
              self._util_stanza_build_node(
                stanza,
                encryption,
                cs_d_encryption.crypto,
                'crypto',
                NS_JINGLE_APPS_RTP
              );

              // ZRTP-HASH
              self._util_stanza_build_node(
                stanza,
                encryption,
                cs_d_encryption['zrtp-hash'],
                'zrtp-hash',
                NS_JINGLE_APPS_RTP_ZRTP,
                'value'
              );
            }

            // RTCP-FB (common)
            self._util_stanza_build_node(
              stanza,
              description,
              cs_d_rtcp_fb,
              'rtcp-fb',
              NS_JINGLE_APPS_RTP_RTCP_FB
            );

            // Bandwidth
            self._util_stanza_build_node(
              stanza,
              description,
              cs_d_bandwidth,
              'bandwidth',
              NS_JINGLE_APPS_RTP,
              'value'
            );

            // RTP-HDREXT
            self._util_stanza_build_node(
              stanza,
              description,
              cs_d_rtp_hdrext,
              'rtp-hdrext',
              NS_JINGLE_APPS_RTP_RTP_HDREXT
            );

            // RTCP-MUX
            if(cs_d_rtcp_mux)
              description.appendChild(stanza.buildNode('rtcp-mux', { 'xmlns': NS_JINGLE_APPS_RTP }));
          }
        }

        // Build transport
        var cs_transport = cur_content.transport;

        var transport = self._util_stanza_build_node(
                          stanza,
                          content,
                          [cs_transport.attrs],
                          'transport',
                          NS_JINGLE_TRANSPORTS_ICEUDP
                        );

        // Fingerprint
        self._util_stanza_build_node(
          stanza,
          transport,
          [cs_transport.fingerprint],
          'fingerprint',
          NS_JINGLE_APPS_DTLS,
          'value'
        );

        // Candidates
        self._util_stanza_build_node(
          stanza,
          transport,
          cs_transport.candidate,
          'candidate',
          NS_JINGLE_TRANSPORTS_ICEUDP
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_generate_content_local > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_stanza_generate_group_local = function(stanza, jingle) {
    try {
      var i,
          cur_semantics, cur_group, cur_group_name,
          group;

      var group_local = self._get_group_local();

      for(cur_semantics in group_local) {
        cur_group = group_local[cur_semantics];

        group = jingle.appendChild(stanza.buildNode('group', {
          'xmlns': NS_JINGLE_APPS_GROUPING,
          'semantics': cur_semantics
        }));

        for(i in cur_group) {
          cur_group_name = cur_group[i];

          group.appendChild(stanza.buildNode('content', {
            'xmlns': NS_JINGLE_APPS_GROUPING,
            'name': cur_group_name
          }));
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_stanza_generate_group_local > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_generate_content = function(creator, name, senders, payloads, transports) {
    var content_obj = {};

    try {
      // Generation process
      content_obj.creator     = creator;
      content_obj.name        = name;
      content_obj.senders     = senders;
      content_obj.description = {};
      content_obj.transport   = {};

      // Generate description
      var i;
      var description_cpy      = self.util_object_clone(payloads.descriptions);
      var description_ptime    = description_cpy.attrs.ptime;
      var description_maxptime = description_cpy.attrs.maxptime;

      if(description_ptime)     delete description_cpy.attrs.ptime;
      if(description_maxptime)  delete description_cpy.attrs.maxptime;

      for(i in description_cpy.payload) {
        if(!('attrs' in description_cpy.payload[i]))
          description_cpy.payload[i].attrs           = {};

        description_cpy.payload[i].attrs.ptime    = description_ptime;
        description_cpy.payload[i].attrs.maxptime = description_maxptime;
      }

      content_obj.description = description_cpy;

      // Generate transport
      content_obj.transport.candidate      = transports;
      content_obj.transport.attrs          = {};
      content_obj.transport.attrs.pwd   = payloads.transports ? payloads.transports.pwd   : null;
      content_obj.transport.attrs.ufrag = payloads.transports ? payloads.transports.ufrag : null;

      if(payloads.transports && payloads.transports.fingerprint)
        content_obj.transport.fingerprint  = payloads.transports.fingerprint;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_generate_content > ' + e, 1);
    }

    return content_obj;
  };

  /**
   * @private
   */
  self._util_build_content_local = function() {
    try {
      var cur_name;

      for(cur_name in self.get_name()) {
        self._set_content_local(
          cur_name,

          self._util_generate_content(
            JSJAC_JINGLE_SENDERS_INITIATOR.jingle,
            cur_name,
            self.get_senders(cur_name),
            self._get_payloads_local(cur_name),
            self._get_candidates_local(cur_name)
          )
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_build_content_local > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_build_content_remote = function() {
    try {
      var cur_name;

      for(cur_name in self.get_name()) {
        self._set_content_remote(
          cur_name,

          self._util_generate_content(
            self.get_creator(cur_name),
            cur_name,
            self.get_senders(cur_name),
            self._get_payloads_remote(cur_name),
            self._get_candidates_remote(cur_name)
          )
        );
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_build_content_remote > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_name_generate = function(media) {
    var name = null;

    try {
      var i, cur_name;

      var content_all = [
        self._get_content_remote(),
        self._get_content_local()
      ];

      for(i in content_all) {
        for(cur_name in content_all[i]) {
          try {
            if(content_all[i][cur_name].description.attrs.media == media) {
              name = cur_name; break;
            }
          } catch(e) {}
        }

        if(name) break;
      }

      if(!name) name = media;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_name_generate > ' + e, 1);
    }

    return name;
  };

  /**
   * @private
   */
  self._util_media_generate = function(name) {
    var cur_media;
    var media = null;

    try {
      if(typeof name == 'number') {
        for(cur_media in JSJAC_JINGLE_MEDIAS) {
          if(name == parseInt(JSJAC_JINGLE_MEDIAS[cur_media].label, 10)) {
            media = cur_media; break;
          }
        }
      } else {
        for(cur_media in JSJAC_JINGLE_MEDIAS) {
          if(name == self._util_name_generate(cur_media)) {
            media = cur_media; break;
          }
        }
      }

      if(!media)  media = name;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_media_generate > ' + e, 1);
    }

    return media;
  };

  /**
   * @private
   */
  self._util_sdp_generate = function(type, group, payloads, candidates) {
    try {
      var sdp_obj = {};

      sdp_obj.candidates  = self._util_sdp_generate_candidates(candidates);
      sdp_obj.description = self._util_sdp_generate_description(type, group, payloads, sdp_obj.candidates);

      return sdp_obj;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_generate > ' + e, 1);
    }

    return {};
  };

  /**
   * @private
   */
  self._util_sdp_generate_candidates = function(candidates) {
    var candidates_arr = [];

    try {
      // Parse candidates
      var i,
          cur_media, cur_name, cur_c_name, cur_candidate, cur_label, cur_id, cur_candidate_str;

      for(cur_name in candidates) {
        cur_c_name = candidates[cur_name];
        cur_media   = self._util_media_generate(cur_name);

        for(i in cur_c_name) {
          cur_candidate = cur_c_name[i];

          cur_label         = JSJAC_JINGLE_MEDIAS[cur_media].label;
          cur_id            = cur_label;
          cur_candidate_str = '';

          cur_candidate_str += 'a=candidate:';
          cur_candidate_str += cur_candidate.foundation;
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.component;
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.protocol;
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.priority;
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.ip;
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.port;
          cur_candidate_str += ' ';
          cur_candidate_str += 'typ';
          cur_candidate_str += ' ';
          cur_candidate_str += cur_candidate.type;

          if(cur_candidate['rel-addr'] && cur_candidate['rel-port']) {
            cur_candidate_str += ' ';
            cur_candidate_str += 'raddr';
            cur_candidate_str += ' ';
            cur_candidate_str += cur_candidate['rel-addr'];
            cur_candidate_str += ' ';
            cur_candidate_str += 'rport';
            cur_candidate_str += ' ';
            cur_candidate_str += cur_candidate['rel-port'];
          }

          if(cur_candidate.generation) {
            cur_candidate_str += ' ';
            cur_candidate_str += 'generation';
            cur_candidate_str += ' ';
            cur_candidate_str += cur_candidate.generation;
          }

          cur_candidate_str   += WEBRTC_SDP_LINE_BREAK;

          candidates_arr.push({
            label     : cur_label,
            id        : cur_id,
            candidate : cur_candidate_str
          });
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_generate_candidates > ' + e, 1);
    }

    return candidates_arr;
  };

  /**
   * @private
   */
  self._util_sdp_generate_description = function(type, group, payloads, sdp_candidates) {
    var payloads_obj = {};

    try {
      var payloads_str = '';

      // Common vars
      var i, c, j, k, l, m, n, o, p, q, r, s, t,
          cur_name, cur_name_obj,
          cur_media, cur_senders,
          cur_group_semantics, cur_group_names, cur_group_name,
          cur_transports_obj, cur_description_obj,
          cur_d_pwd, cur_d_ufrag, cur_d_fingerprint,
          cur_d_attrs, cur_d_rtcp_fb, cur_d_bandwidth, cur_d_encryption, cur_d_ssrc,
          cur_d_ssrc_obj, cur_d_rtcp_fb_obj,
          cur_d_payload, cur_d_payload_obj, cur_d_payload_obj_attrs, cur_d_payload_obj_id,
          cur_d_payload_obj_parameter, cur_d_payload_obj_parameter_obj, cur_d_payload_obj_parameter_str,
          cur_d_payload_obj_rtcp_fb, cur_d_payload_obj_rtcp_fb_obj,
          cur_d_payload_obj_rtcp_fb_ttr_int, cur_d_payload_obj_rtcp_fb_ttr_int_obj,
          cur_d_crypto_obj, cur_d_zrtp_hash_obj,
          cur_d_rtp_hdrext, cur_d_rtp_hdrext_obj,
          cur_d_rtcp_mux;

      // Payloads headers
      payloads_str += self._util_sdp_generate_protocol_version();
      payloads_str += WEBRTC_SDP_LINE_BREAK;
      payloads_str += self._util_sdp_generate_origin();
      payloads_str += WEBRTC_SDP_LINE_BREAK;
      payloads_str += self._util_sdp_generate_session_name();
      payloads_str += WEBRTC_SDP_LINE_BREAK;
      payloads_str += self._util_sdp_generate_timing();
      payloads_str += WEBRTC_SDP_LINE_BREAK;

      // Add groups
      for(cur_group_semantics in group) {
        cur_group_names = group[cur_group_semantics];

        payloads_str += 'a=group:' + cur_group_semantics;

        for(t in cur_group_names) {
          cur_group_name = cur_group_names[t];
          payloads_str += ' ' + cur_group_name;
        }

        payloads_str += WEBRTC_SDP_LINE_BREAK;
      }

      // Add media groups
      for(cur_name in payloads) {
        cur_name_obj          = payloads[cur_name];
        cur_senders           = self.get_senders(cur_name);
        cur_media             = self.get_name(cur_name) ? self._util_media_generate(cur_name) : null;

        // No media?
        if(!cur_media) continue;

        // Transports
        cur_transports_obj    = cur_name_obj.transports || {};
        cur_d_pwd             = cur_transports_obj.pwd;
        cur_d_ufrag           = cur_transports_obj.ufrag;
        cur_d_fingerprint     = cur_transports_obj.fingerprint;

        // Descriptions
        cur_description_obj   = cur_name_obj.descriptions;
        cur_d_attrs           = cur_description_obj.attrs;
        cur_d_rtcp_fb         = cur_description_obj['rtcp-fb'];
        cur_d_bandwidth       = cur_description_obj.bandwidth;
        cur_d_payload         = cur_description_obj.payload;
        cur_d_encryption      = cur_description_obj.encryption;
        cur_d_ssrc            = cur_description_obj.ssrc;
        cur_d_rtp_hdrext      = cur_description_obj['rtp-hdrext'];
        cur_d_rtcp_mux        = cur_description_obj['rtcp-mux'];

        // Current media
        payloads_str += self._util_sdp_generate_description_media(cur_media, cur_d_encryption, cur_d_fingerprint, cur_d_payload);
        payloads_str += WEBRTC_SDP_LINE_BREAK;

        payloads_str += 'c=IN IP4 0.0.0.0';
        payloads_str += WEBRTC_SDP_LINE_BREAK;
        payloads_str += 'a=rtcp:1 IN IP4 0.0.0.0';
        payloads_str += WEBRTC_SDP_LINE_BREAK;

        if(cur_d_ufrag)  payloads_str += 'a=ice-ufrag:' + cur_d_ufrag + WEBRTC_SDP_LINE_BREAK;
        if(cur_d_pwd)    payloads_str += 'a=ice-pwd:' + cur_d_pwd + WEBRTC_SDP_LINE_BREAK;

        // Fingerprint
        if(cur_d_fingerprint) {
          if(cur_d_fingerprint.hash && cur_d_fingerprint.value) {
            payloads_str += 'a=fingerprint:' + cur_d_fingerprint.hash + ' ' + cur_d_fingerprint.value;
            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }

          if(cur_d_fingerprint.setup) {
            payloads_str += 'a=setup:' + cur_d_fingerprint.setup;
            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }
        }

        // RTP-HDREXT
        if(cur_d_rtp_hdrext && cur_d_rtp_hdrext.length) {
          for(i in cur_d_rtp_hdrext) {
            cur_d_rtp_hdrext_obj = cur_d_rtp_hdrext[i];

            payloads_str += 'a=extmap:' + cur_d_rtp_hdrext_obj.id;

            if(cur_d_rtp_hdrext_obj.senders)
              payloads_str += '/' + cur_d_rtp_hdrext_obj.senders;

            payloads_str += ' ' + cur_d_rtp_hdrext_obj.uri;
            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }
        }

        // Senders
        if(cur_senders) {
          payloads_str += 'a=' + JSJAC_JINGLE_SENDERS[cur_senders];
          payloads_str += WEBRTC_SDP_LINE_BREAK;
        }

        // Name
        if(cur_media && JSJAC_JINGLE_MEDIAS[cur_media]) {
          payloads_str += 'a=mid:' + (JSJAC_JINGLE_MEDIAS[cur_media]).label;
          payloads_str += WEBRTC_SDP_LINE_BREAK;
        }

        // RTCP-MUX
        // WARNING: no spec!
        // See: http://code.google.com/p/libjingle/issues/detail?id=309
        //      http://mail.jabber.org/pipermail/jingle/2011-December/001761.html
        if(cur_d_rtcp_mux) {
          payloads_str += 'a=rtcp-mux';
          payloads_str += WEBRTC_SDP_LINE_BREAK;
        }

        // 'encryption'
        if(cur_d_encryption) {
          // 'crypto'
          for(j in cur_d_encryption.crypto) {
            cur_d_crypto_obj = cur_d_encryption.crypto[j];

            payloads_str += 'a=crypto:'                       + 
                            cur_d_crypto_obj.tag           + ' ' + 
                            cur_d_crypto_obj['crypto-suite']  + ' ' + 
                            cur_d_crypto_obj['key-params']    + 
                            (cur_d_crypto_obj['session-params'] ? (' ' + cur_d_crypto_obj['session-params']) : '');

            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }

          // 'zrtp-hash'
          for(p in cur_d_encryption['zrtp-hash']) {
            cur_d_zrtp_hash_obj = cur_d_encryption['zrtp-hash'][p];

            payloads_str += 'a=zrtp-hash:'                  + 
                            cur_d_zrtp_hash_obj.version  + ' ' + 
                            cur_d_zrtp_hash_obj.value;

            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }
        }

        // 'rtcp-fb' (common)
        for(n in cur_d_rtcp_fb) {
          cur_d_rtcp_fb_obj = cur_d_rtcp_fb[n];

          payloads_str += 'a=rtcp-fb:*';
          payloads_str += ' ' + cur_d_rtcp_fb_obj.type;

          if(cur_d_rtcp_fb_obj.subtype)
            payloads_str += ' ' + cur_d_rtcp_fb_obj.subtype;

          payloads_str += WEBRTC_SDP_LINE_BREAK;
        }

        // 'bandwidth' (common)
        for(q in cur_d_bandwidth) {
          cur_d_bandwidth_obj = cur_d_bandwidth[q];

          payloads_str += 'b=' + cur_d_bandwidth_obj.type;
          payloads_str += ':'  + cur_d_bandwidth_obj.value;
          payloads_str += WEBRTC_SDP_LINE_BREAK;
        }

        // 'payload-type'
        for(k in cur_d_payload) {
          cur_d_payload_obj                 = cur_d_payload[k];
          cur_d_payload_obj_attrs           = cur_d_payload_obj.attrs;
          cur_d_payload_obj_parameter       = cur_d_payload_obj.parameter;
          cur_d_payload_obj_rtcp_fb         = cur_d_payload_obj['rtcp-fb'];
          cur_d_payload_obj_rtcp_fb_ttr_int = cur_d_payload_obj['rtcp-fb-trr-int'];

          cur_d_payload_obj_id              = cur_d_payload_obj_attrs.id;

          payloads_str += 'a=rtpmap:' + cur_d_payload_obj_id;

          // 'rtpmap'
          if(cur_d_payload_obj_attrs.name) {
            payloads_str += ' ' + cur_d_payload_obj_attrs.name;

            if(cur_d_payload_obj_attrs.clockrate) {
              payloads_str += '/' + cur_d_payload_obj_attrs.clockrate;

              if(cur_d_payload_obj_attrs.channels)
                payloads_str += '/' + cur_d_payload_obj_attrs.channels;
            }
          }

          payloads_str += WEBRTC_SDP_LINE_BREAK;

          // 'parameter'
          if(cur_d_payload_obj_parameter.length) {
            payloads_str += 'a=fmtp:' + cur_d_payload_obj_id + ' ';
            cur_d_payload_obj_parameter_str = '';

            for(o in cur_d_payload_obj_parameter) {
              cur_d_payload_obj_parameter_obj = cur_d_payload_obj_parameter[o];

              if(cur_d_payload_obj_parameter_str)  cur_d_payload_obj_parameter_str += ';';

              cur_d_payload_obj_parameter_str += cur_d_payload_obj_parameter_obj.name;

              if(cur_d_payload_obj_parameter_obj.value !== null) {
                cur_d_payload_obj_parameter_str += '=';
                cur_d_payload_obj_parameter_str += cur_d_payload_obj_parameter_obj.value;
              }
            }

            payloads_str += cur_d_payload_obj_parameter_str;
            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }

          // 'rtcp-fb' (sub)
          for(l in cur_d_payload_obj_rtcp_fb) {
            cur_d_payload_obj_rtcp_fb_obj = cur_d_payload_obj_rtcp_fb[l];

            payloads_str += 'a=rtcp-fb:' + cur_d_payload_obj_id;
            payloads_str += ' ' + cur_d_payload_obj_rtcp_fb_obj.type;

            if(cur_d_payload_obj_rtcp_fb_obj.subtype)
              payloads_str += ' ' + cur_d_payload_obj_rtcp_fb_obj.subtype;

            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }

          // 'rtcp-fb-ttr-int'
          for(m in cur_d_payload_obj_rtcp_fb_ttr_int) {
            cur_d_payload_obj_rtcp_fb_ttr_int_obj = cur_d_payload_obj_rtcp_fb_ttr_int[m];

            payloads_str += 'a=rtcp-fb:' + cur_d_payload_obj_id;
            payloads_str += ' ' + 'trr-int';
            payloads_str += ' ' + cur_d_payload_obj_rtcp_fb_ttr_int_obj.value;
            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }
        }

        if(cur_d_attrs.ptime)     payloads_str += 'a=ptime:'    + cur_d_attrs.ptime + WEBRTC_SDP_LINE_BREAK;
        if(cur_d_attrs.maxptime)  payloads_str += 'a=maxptime:' + cur_d_attrs.maxptime + WEBRTC_SDP_LINE_BREAK;

        // 'ssrc' (not used in Jingle ATM)
        for(r in cur_d_ssrc) {
          for(s in cur_d_ssrc[r]) {
            cur_d_ssrc_obj = cur_d_ssrc[r][s];

            payloads_str += 'a=ssrc';
            payloads_str += ':' + cur_d_ssrc_obj.id;
            payloads_str += ' ' + cur_d_ssrc_obj.attribute;

            if(cur_d_ssrc_obj.value)
              payloads_str += ':' + cur_d_ssrc_obj.value;

            if(cur_d_ssrc_obj.data)
              payloads_str += ' ' + cur_d_ssrc_obj.data;

            payloads_str += WEBRTC_SDP_LINE_BREAK;
          }
        }

        // Candidates (some browsers require them there, too)
        if(typeof sdp_candidates == 'object') {
          for(c in sdp_candidates) {
            if((sdp_candidates[c]).label == JSJAC_JINGLE_MEDIAS[cur_media].label)
              payloads_str += (sdp_candidates[c]).candidate;
          }
        }
      }

      // Push to object
      payloads_obj.type = type;
      payloads_obj.sdp  = payloads_str;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_generate_description > ' + e, 1);
    }

    return payloads_obj;
  };

  /**
   * @private
   */
  self._util_sdp_generate_protocol_version = function() {
    return 'v=0';
  };

  /**
   * @private
   */
  self._util_sdp_generate_origin = function() {
    var sdp_origin = '';

    try {
      // Values
      var jid = new JSJaCJID(self.get_initiator());

      var username        = jid.getNode()   ? jid.getNode()   : '-';
      var session_id      = '1';
      var session_version = '1';
      var nettype         = 'IN';
      var addrtype        = 'IP4';
      var unicast_address = jid.getDomain() ? jid.getDomain() : '127.0.0.1';

      // Line content
      sdp_origin += 'o=';
      sdp_origin += username + ' ';
      sdp_origin += session_id + ' ';
      sdp_origin += session_version + ' ';
      sdp_origin += nettype + ' ';
      sdp_origin += addrtype + ' ';
      sdp_origin += unicast_address;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_generate_origin > ' + e, 1);
    }

    return sdp_origin;
  };

  /**
   * @private
   */
  self._util_sdp_generate_session_name = function() {
    return 's=' + (self.get_sid() || '-');
  };

  /**
   * @private
   */
  self._util_sdp_generate_timing = function() {
    return 't=0 0';
  };

  /**
   * @private
   */
  self._util_sdp_generate_description_media = function(media, crypto, fingerprint, payload) {
    var sdp_media = '';

    try {
      var i;
      var type_ids = [];

      sdp_media += 'm=' + media + ' 1 ';

      // Protocol
      if((crypto && crypto.length) || (fingerprint && fingerprint.hash && fingerprint.value))
        sdp_media += 'RTP/SAVPF';
      else
        sdp_media += 'RTP/AVPF';

      // Payload type IDs
      for(i in payload)  type_ids.push(payload[i].attrs.id);

      sdp_media += ' ' + type_ids.join(' ');
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_generate_description_media > ' + e, 1);
    }

    return sdp_media;
  };

  /**
   * Generates a random SID value
   * @return SID value
   * @type string
   */
  self.util_generate_sid = function() {
    return cnonce(16);
  };

  /**
   * Generates a random ID value
   * @return ID value
   * @type string
   */
  self.util_generate_id = function() {
    return cnonce(10);
  };

  /**
   * Generates the constraints object
   * @return constraints object
   * @type object
   */
  self.util_generate_constraints = function() {
    var constraints = {
      audio : false,
      video : false
    };

    try {
      // Medias?
      constraints.audio = true;
      constraints.video = (self.get_media() == JSJAC_JINGLE_MEDIA_VIDEO);

      // Video configuration
      if(constraints.video === true) {
        // Resolution?
        switch(self.get_resolution()) {
          // 16:9
          case '720':
          case 'hd':
            constraints.video = {
              mandatory : {
                minWidth       : 1280,
                minHeight      : 720,
                minAspectRatio : 1.77
              }
            };
            break;

          case '360':
          case 'md':
            constraints.video = {
              mandatory : {
                minWidth       : 640,
                minHeight      : 360,
                minAspectRatio : 1.77
              }
            };
            break;

          case '180':
          case 'sd':
            constraints.video = {
              mandatory : {
                minWidth       : 320,
                minHeight      : 180,
                minAspectRatio : 1.77
              }
            };
            break;

          // 4:3
          case '960':
            constraints.video = {
              mandatory : {
                minWidth  : 960,
                minHeight : 720
              }
            };
            break;

          case '640':
          case 'vga':
            constraints.video = {
              mandatory : {
                maxWidth  : 640,
                maxHeight : 480
              }
            };
            break;

          case '320':
            constraints.video = {
              mandatory : {
                maxWidth  : 320,
                maxHeight : 240
              }
            };
            break;
        }

        // Bandwidth?
        if(self.get_bandwidth())
          constraints.video.optional = [{ bandwidth: self.get_bandwidth() }];

        // FPS?
        if(self.get_fps())
          constraints.video.mandatory.minFrameRate = self.get_fps();

        // Custom video source? (screenshare)
        if(self.get_media()        == JSJAC_JINGLE_MEDIA_VIDEO         && 
           self.get_video_source() != JSJAC_JINGLE_VIDEO_SOURCE_CAMERA ) {
          if(document.location.protocol !== 'https:')
            self.get_debug().log('[JSJaCJingle] util_generate_constraints > HTTPS might be required to share screen, otherwise you may get a permission denied error.', 0);

          // Unsupported browser? (for that feature)
          if(self._util_browser().name != JSJAC_JINGLE_BROWSER_CHROME) {
            self.get_debug().log('[JSJaCJingle] util_generate_constraints > Video source not supported by ' + self._util_browser().name + ' (source: ' + self.get_video_source() + ').', 1);
            
            self.terminate(JSJAC_JINGLE_REASON_MEDIA_ERROR);
            return;
          }

          constraints.audio           = false;
          constraints.video.mandatory = {
            'chromeMediaSource': self.get_video_source()
          };
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] util_generate_constraints > ' + e, 1);
    }

    return constraints;
  };

  /**
   * Returns our negotiation status
   * @return Negotiation status
   * @type string
   */
  self.util_negotiation_status = function() {
    return (self.get_initiator() == self.util_connection_jid()) ? JSJAC_JINGLE_SENDERS_INITIATOR.jingle : JSJAC_JINGLE_SENDERS_RESPONDER.jingle;
  };

  /**
   * Get my connection JID
   * @return JID value
   * @type string
   */
  self.util_connection_jid = function() {
    return JSJAC_JINGLE_STORE_CONNECTION.username + '@' + 
           JSJAC_JINGLE_STORE_CONNECTION.domain   + '/' + 
           JSJAC_JINGLE_STORE_CONNECTION.resource;
  };

  /**
   * @private
   */
  self._util_map_register_view = function(type) {
    var fn = {
      type   : null,
      mute   : false,

      view   : {
        get : null,
        set : null
      },

      stream : {
        get : null,
        set : null
      }
    };

    try {
      switch(type) {
        case 'local':
          fn.type       = type;
          fn.mute       = true;
          fn.view.get   = self.get_local_view;
          fn.view.set   = self._set_local_view;
          fn.stream.get = self._get_local_stream;
          fn.stream.set = self._set_local_stream;
          break;

        case 'remote':
          fn.type       = type;
          fn.view.get   = self.get_remote_view;
          fn.view.set   = self._set_remote_view;
          fn.stream.get = self._get_remote_stream;
          fn.stream.set = self._set_remote_stream;
          break;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_map_register_view > ' + e, 1);
    }

    return fn;
  };

  /**
   * @private
   */
  self._util_map_unregister_view = function(type) {
    return self._util_map_register_view(type);
  };

  /**
   * @private
   */
  self._util_peer_stream_attach = function(element, stream, mute) {
    try {
      var i;
      var stream_src = stream ? URL.createObjectURL(stream) : '';

      for(i in element) {
        element[i].src = stream_src;

        if(navigator.mozGetUserMedia)
          element[i].play();
        else
          element[i].autoplay = true;

        if(typeof mute == 'boolean') element[i].muted = mute;
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_peer_stream_attach > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_peer_stream_detach = function(element) {
    try {
      var i;

      for(i in element) {
        element[i].pause();
        element[i].src = '';
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_peer_stream_detach > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._util_sdp_parse_payload = function(sdp_payload) {
    var payload = {};

    try {
      if(!sdp_payload || sdp_payload.indexOf('\n') == -1)  return payload;

      // Common vars
      var lines     = sdp_payload.split('\n');
      var cur_name  = null;
      var cur_media = null;

      var common_transports = {
        'fingerprint' : {},
        'pwd'         : null,
        'ufrag'       : null
      };

      var error, i, j,
          cur_line,
          cur_fmtp, cur_fmtp_id, cur_fmtp_values, cur_fmtp_attrs, cur_fmtp_key, cur_fmtp_value,
          cur_rtpmap, cur_rtcp_fb, cur_rtcp_fb_trr_int,
          cur_crypto, cur_zrtp_hash, cur_fingerprint, cur_ssrc, cur_extmap,
          cur_rtpmap_id, cur_rtcp_fb_id, cur_bandwidth,
          m_rtpmap, m_fmtp, m_rtcp_fb, m_rtcp_fb_trr_int, m_crypto, m_zrtp_hash,
          m_fingerprint, m_pwd, m_ufrag, m_ptime, m_maxptime, m_bandwidth, m_media, m_candidate,
          cur_check_name, cur_transport_sub;

      // Common functions
      var init_content = function(name) {
        if(!(name in payload))  payload[name] = {};
      };

      var init_descriptions = function(name, sub, sub_default) {
        init_content(name);

        if(!('descriptions' in payload[name]))        payload[name].descriptions      = {};
        if(!(sub  in payload[name].descriptions))  payload[name].descriptions[sub] = sub_default;
      };

      var init_transports = function(name, sub, sub_default) {
        init_content(name);

        if(!('transports' in payload[name]))        payload[name].transports      = {};
        if(!(sub  in payload[name].transports))  payload[name].transports[sub] = sub_default;
      };

      var init_ssrc = function(name, id) {
        init_descriptions(name, 'ssrc', {});

        if(!(id in payload[name].descriptions.ssrc))
          payload[name].descriptions.ssrc[id] = [];
      };

      var init_payload = function(name, id) {
        init_descriptions(name, 'payload', {});

        if(!(id in payload[name].descriptions.payload)) {
          payload[name].descriptions.payload[id] = {
            'attrs'           : {},
            'parameter'       : [],
            'rtcp-fb'         : [],
            'rtcp-fb-trr-int' : []
          };
        }
      };

      var init_encryption = function(name) {
        init_descriptions(name, 'encryption', {
          'attrs'     : {
            'required' : '1'
          },

          'crypto'    : [],
          'zrtp-hash' : []
        });
      };

      for(i in lines) {
        cur_line = lines[i];

        m_media = (R_WEBRTC_SDP_ICE_PAYLOAD.media).exec(cur_line);

        // 'audio/video' line?
        if(m_media) {
          cur_media = m_media[1];
          cur_name  = self._util_name_generate(cur_media);

          // Push it to parent array
          init_descriptions(cur_name, 'attrs', {});
          payload[cur_name].descriptions.attrs.media = cur_media;

          continue;
        }

        m_bandwidth = (R_WEBRTC_SDP_ICE_PAYLOAD.bandwidth).exec(cur_line);

        // 'bandwidth' line?
        if(m_bandwidth) {
          // Populate current object
          error = 0;
          cur_bandwidth = {};

          cur_bandwidth.type  = m_bandwidth[1]  || error++;
          cur_bandwidth.value = m_bandwidth[2]  || error++;

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array
          init_descriptions(cur_name, 'bandwidth', []);
          payload[cur_name].descriptions.bandwidth.push(cur_bandwidth);

          continue;
        }

        m_rtpmap = (R_WEBRTC_SDP_ICE_PAYLOAD.rtpmap).exec(cur_line);

        // 'rtpmap' line?
        if(m_rtpmap) {
          // Populate current object
          error = 0;
          cur_rtpmap = {};

          cur_rtpmap.channels  = m_rtpmap[6];
          cur_rtpmap.clockrate = m_rtpmap[4];
          cur_rtpmap.id        = m_rtpmap[1] || error++;
          cur_rtpmap.name      = m_rtpmap[3];

          // Incomplete?
          if(error !== 0) continue;

          cur_rtpmap_id = cur_rtpmap.id;

          // Push it to parent array
          init_payload(cur_name, cur_rtpmap_id);
          payload[cur_name].descriptions.payload[cur_rtpmap_id].attrs = cur_rtpmap;

          continue;
        }

        m_fmtp = (R_WEBRTC_SDP_ICE_PAYLOAD.fmtp).exec(cur_line);

        // 'fmtp' line?
        if(m_fmtp) {
          cur_fmtp_id = m_fmtp[1];

          if(cur_fmtp_id) {
            cur_fmtp_values = m_fmtp[2] ? (m_fmtp[2]).split(';') : [];

            for(j in cur_fmtp_values) {
              // Parse current attribute
              if(cur_fmtp_values[j].indexOf('=') !== -1) {
                cur_fmtp_attrs = cur_fmtp_values[j].split('=');
                cur_fmtp_key   = cur_fmtp_attrs[0];
                cur_fmtp_value = cur_fmtp_attrs[1];

                while(cur_fmtp_key.length && !cur_fmtp_key[0])
                  cur_fmtp_key = cur_fmtp_key.substring(1);
              } else {
                cur_fmtp_key = cur_fmtp_values[j];
                cur_fmtp_value = null;
              }

              // Populate current object
              error = 0;
              cur_fmtp = {};

              cur_fmtp.name  = cur_fmtp_key    || error++;
              cur_fmtp.value = cur_fmtp_value;

              // Incomplete?
              if(error !== 0) continue;

              // Push it to parent array
              init_payload(cur_name, cur_fmtp_id);
              payload[cur_name].descriptions.payload[cur_fmtp_id].parameter.push(cur_fmtp);
            }
          }

          continue;
        }

        m_rtcp_fb = (R_WEBRTC_SDP_ICE_PAYLOAD.rtcp_fb).exec(cur_line);

        // 'rtcp-fb' line?
        if(m_rtcp_fb) {
          // Populate current object
          error = 0;
          cur_rtcp_fb = {};

          cur_rtcp_fb.id      = m_rtcp_fb[1] || error++;
          cur_rtcp_fb.type    = m_rtcp_fb[2];
          cur_rtcp_fb.subtype = m_rtcp_fb[4];

          // Incomplete?
          if(error !== 0) continue;

          cur_rtcp_fb_id = cur_rtcp_fb.id;

          // Push it to parent array
          if(cur_rtcp_fb_id == '*') {
            init_descriptions(cur_name, 'rtcp-fb', []);
            (payload[cur_name].descriptions['rtcp-fb']).push(cur_rtcp_fb);
          } else {
            init_payload(cur_name, cur_rtcp_fb_id);
            (payload[cur_name].descriptions.payload[cur_rtcp_fb_id]['rtcp-fb']).push(cur_rtcp_fb);
          }

          continue;
        }

        m_rtcp_fb_trr_int = (R_WEBRTC_SDP_ICE_PAYLOAD.rtcp_fb_trr_int).exec(cur_line);

        // 'rtcp-fb-trr-int' line?
        if(m_rtcp_fb_trr_int) {
          // Populate current object
          error = 0;
          cur_rtcp_fb_trr_int = {};

          cur_rtcp_fb_trr_int.id      = m_rtcp_fb_trr_int[1] || error++;
          cur_rtcp_fb_trr_int.value   = m_rtcp_fb_trr_int[2] || error++;

          // Incomplete?
          if(error !== 0) continue;

          cur_rtcp_fb_trr_int_id = cur_rtcp_fb_trr_int.id;

          // Push it to parent array
          init_payload(cur_name, cur_rtcp_fb_trr_int_id);
          (payload[cur_name].descriptions.payload[cur_rtcp_fb_trr_int_id]['rtcp-fb-trr-int']).push(cur_rtcp_fb_trr_int);

          continue;
        }

        m_crypto = (R_WEBRTC_SDP_ICE_PAYLOAD.crypto).exec(cur_line);

        // 'crypto' line?
        if(m_crypto) {
          // Populate current object
          error = 0;
          cur_crypto = {};

          cur_crypto['crypto-suite']   = m_crypto[2]  || error++;
          cur_crypto['key-params']     = m_crypto[3]  || error++;
          cur_crypto['session-params'] = m_crypto[5];
          cur_crypto.tag            = m_crypto[1]  || error++;

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array
          init_encryption(cur_name);
          (payload[cur_name].descriptions.encryption.crypto).push(cur_crypto);

          continue;
        }

        m_zrtp_hash = (R_WEBRTC_SDP_ICE_PAYLOAD.zrtp_hash).exec(cur_line);

        // 'zrtp-hash' line?
        if(m_zrtp_hash) {
          // Populate current object
          error = 0;
          cur_zrtp_hash = {};

          cur_zrtp_hash.version = m_zrtp_hash[1]  || error++;
          cur_zrtp_hash.value   = m_zrtp_hash[2]  || error++;

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array
          init_encryption(cur_name);
          (payload[cur_name].descriptions.encryption['zrtp-hash']).push(cur_zrtp_hash);

          continue;
        }

        m_ptime = (R_WEBRTC_SDP_ICE_PAYLOAD.ptime).exec(cur_line);

        // 'ptime' line?
        if(m_ptime) {
          // Push it to parent array
          init_descriptions(cur_name, 'attrs', {});
          payload[cur_name].descriptions.attrs.ptime = m_ptime[1];

          continue;
        }

        m_maxptime = (R_WEBRTC_SDP_ICE_PAYLOAD.maxptime).exec(cur_line);

        // 'maxptime' line?
        if(m_maxptime) {
          // Push it to parent array
          init_descriptions(cur_name, 'attrs', {});
          payload[cur_name].descriptions.attrs.maxptime = m_maxptime[1];

          continue;
        }

        m_ssrc = (R_WEBRTC_SDP_ICE_PAYLOAD.ssrc).exec(cur_line);

        // 'ssrc' line?
        if(m_ssrc) {
          // Populate current object
          error = 0;
          cur_ssrc = {};

          cur_ssrc.id        = m_ssrc[1]  || error++;
          cur_ssrc.attribute = m_ssrc[2]  || error++;
          cur_ssrc.value     = m_ssrc[4];
          cur_ssrc.data      = m_ssrc[6];

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array (not used in Jingle ATM)
          init_ssrc(cur_name, cur_ssrc.id);
          (payload[cur_name].descriptions.ssrc[cur_ssrc.id]).push(cur_ssrc);

          // Push it to parent array (common attr required for Jingle)
          init_descriptions(cur_name, 'attrs', {});
          payload[cur_name].descriptions.attrs.ssrc = m_ssrc[1];

          continue;
        }

        m_rtcp_mux = (R_WEBRTC_SDP_ICE_PAYLOAD.rtcp_mux).exec(cur_line);

        // 'rtcp-mux' line?
        if(m_rtcp_mux) {
          // Push it to parent array
          init_descriptions(cur_name, 'rtcp-mux', 1);

          continue;
        }

        m_extmap = (R_WEBRTC_SDP_ICE_PAYLOAD.extmap).exec(cur_line);

        // 'extmap' line?
        if(m_extmap) {
          // Populate current object
          error = 0;
          cur_extmap = {};

          cur_extmap.id      = m_extmap[1]  || error++;
          cur_extmap.uri     = m_extmap[4]  || error++;
          cur_extmap.senders = m_extmap[3];

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array
          init_descriptions(cur_name, 'rtp-hdrext', []);
          (payload[cur_name].descriptions['rtp-hdrext']).push(cur_extmap);

          continue;
        }

        m_fingerprint = (R_WEBRTC_SDP_ICE_PAYLOAD.fingerprint).exec(cur_line);

        // 'fingerprint' line?
        if(m_fingerprint) {
          // Populate current object
          error = 0;
          cur_fingerprint = common_transports.fingerprint || {};

          cur_fingerprint.hash  = m_fingerprint[1]  || error++;
          cur_fingerprint.value = m_fingerprint[2]  || error++;

          // Incomplete?
          if(error !== 0) continue;

          // Push it to parent array
          init_transports(cur_name, 'fingerprint', cur_fingerprint);
          common_transports.fingerprint = cur_fingerprint;

          continue;
        }

        m_setup = (R_WEBRTC_SDP_ICE_PAYLOAD.setup).exec(cur_line);

        // 'setup' line?
        if(m_setup) {
          // Populate current object
          cur_fingerprint = common_transports.fingerprint || {};
          cur_fingerprint.setup = m_setup[1];

          // Push it to parent array
          if(cur_fingerprint.setup) {
            // Map it to fingerprint as XML-wise it is related
            init_transports(cur_name, 'fingerprint', cur_fingerprint);
            common_transports.fingerprint = cur_fingerprint;
          }

          continue;
        }

        m_pwd = (R_WEBRTC_SDP_ICE_PAYLOAD.pwd).exec(cur_line);

        // 'pwd' line?
        if(m_pwd) {
          init_transports(cur_name, 'pwd', m_pwd[1]);

          if(!common_transports.pwd)
            common_transports.pwd = m_pwd[1];

          continue;
        }

        m_ufrag = (R_WEBRTC_SDP_ICE_PAYLOAD.ufrag).exec(cur_line);

        // 'ufrag' line?
        if(m_ufrag) {
          init_transports(cur_name, 'ufrag', m_ufrag[1]);

          if(!common_transports.ufrag)
            common_transports.ufrag = m_ufrag[1];

          continue;
        }

        // 'candidate' line? (shouldn't be there)
        m_candidate = R_WEBRTC_SDP_ICE_CANDIDATE.exec(cur_line);

        if(m_candidate) {
          self._util_sdp_parse_candidate_store({
            media     : cur_media,
            candidate : cur_line
          });

          continue;
        }
      }

      // Filter medias
      for(cur_check_name in payload) {
        // Undesired media?
        if(!self.get_name()[cur_check_name]) {
          delete payload[cur_check_name]; continue;
        }

        // Validate transports
        if(typeof payload[cur_check_name].transports !== 'object')
          payload[cur_check_name].transports = {};

        for(cur_transport_sub in common_transports) {
          if(!payload[cur_check_name].transports[cur_transport_sub])
            payload[cur_check_name].transports[cur_transport_sub] = common_transports[cur_transport_sub];
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_parse_payload > ' + e, 1);
    }

    return payload;
  };

  /**
   * @private
   */
  self._util_sdp_parse_group = function(sdp_payload) {
    var group = {};

    try {
      if(!sdp_payload || sdp_payload.indexOf('\n') == -1)  return group;

      // Common vars
      var lines = sdp_payload.split('\n');
      var i, cur_line,
          m_group;

      var init_group = function(semantics) {
        if(!(semantics in group))  group[semantics] = [];
      };

      for(i in lines) {
        cur_line = lines[i];

        // 'group' line?
        m_group = (R_WEBRTC_SDP_ICE_PAYLOAD.group).exec(cur_line);

        if(m_group) {
          if(m_group[1] && m_group[2]) {
            init_group(m_group[1]);

            group[m_group[1]] = (m_group[2].indexOf(' ') === -1 ? [m_group[2]] : m_group[2].split(' '));
          }

          continue;
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_parse_group > ' + e, 1);
    }

    return group;
  };

  /**
   * @private
   */
  self._util_sdp_resolution_payload = function(payload) {
    try {
      if(!payload || typeof payload !== 'object') return {};

      // No video?
      if(self.get_media_all().indexOf(JSJAC_JINGLE_MEDIA_VIDEO) === -1) return payload;

      var i, j, k, cur_media;
      var cur_payload, res_arr, constraints;
      var res_height = null;
      var res_width  = null;

      // Try local view? (more reliable)
      for(i in self.get_local_view()) {
        if(typeof self.get_local_view()[i].videoWidth  == 'number'  &&
           typeof self.get_local_view()[i].videoHeight == 'number'  ) {
          res_height = self.get_local_view()[i].videoHeight;
          res_width  = self.get_local_view()[i].videoWidth;

          if(res_height && res_width)  break;
        }
      }

      // Try media constraints? (less reliable)
      if(!res_height || !res_width) {
        self.get_debug().log('[JSJaCJingle] _util_sdp_resolution_payload > Could not get local video resolution, falling back on constraints (local video may not be ready).', 0);

        constraints = self.util_generate_constraints();

        // Still nothing?!
        if(typeof constraints.video                     !== 'object'  || 
           typeof constraints.video.mandatory           !== 'object'  || 
           typeof constraints.video.mandatory.minWidth  !== 'number'  || 
           typeof constraints.video.mandatory.minHeight !== 'number'  ) {
          self.get_debug().log('[JSJaCJingle] _util_sdp_resolution_payload > Could not get local video resolution (not sending it).', 1);
          return payload;
        }

        res_height = constraints.video.mandatory.minHeight;
        res_width  = constraints.video.mandatory.minWidth;
      }

      // Constraints to be used
      res_arr = [
        {
          name  : 'height',
          value : res_height
        },

        {
          name  : 'width',
          value : res_width
        }
      ];

      for(cur_media in payload) {
        if(cur_media != JSJAC_JINGLE_MEDIA_VIDEO) continue;

        cur_payload = payload[cur_media].descriptions.payload;

        for(j in cur_payload) {
          if(typeof cur_payload[j].parameter !== 'object')  cur_payload[j].parameter = [];

          for(k in res_arr)
            (cur_payload[j].parameter).push(res_arr[k]);
        }
      }

      self.get_debug().log('[JSJaCJingle] _util_sdp_resolution_payload > Got local video resolution (' + res_width + 'x' + res_height + ').', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_resolution_payload > ' + e, 1);
    }

    return payload;
  };

  /**
   * @private
   */
  self._util_sdp_parse_candidate = function(sdp_candidate) {
    var candidate = {};

    try {
      if(!sdp_candidate)  return candidate;

      var error     = 0;
      var matches   = R_WEBRTC_SDP_ICE_CANDIDATE.exec(sdp_candidate);

      // Matches!
      if(matches) {
        candidate.component  = matches[2]  || error++;
        candidate.foundation = matches[1]  || error++;
        candidate.generation = matches[16] || JSJAC_JINGLE_GENERATION;
        candidate.id         = self.util_generate_id();
        candidate.ip         = matches[5]  || error++;
        candidate.network    = JSJAC_JINGLE_NETWORK;
        candidate.port       = matches[6]  || error++;
        candidate.priority   = matches[4]  || error++;
        candidate.protocol   = matches[3]  || error++;
        candidate['rel-addr']   = matches[11];
        candidate['rel-port']   = matches[13];
        candidate.type       = matches[8]  || error++;
      }

      // Incomplete?
      if(error !== 0) return {};
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _util_sdp_parse_candidate > ' + e, 1);
    }

    return candidate;
  };

  /**
   * @private
   */
  self._util_sdp_parse_candidate_store = function(sdp_candidate) {
    // Store received candidate
    var candidate_media = sdp_candidate.media;
    var candidate_data  = sdp_candidate.candidate;

    // Convert SDP raw data to an object
    var candidate_obj   = self._util_sdp_parse_candidate(candidate_data);

    self._set_candidates_local(
      self._util_name_generate(
        candidate_media
      ),

      candidate_obj
    );

    // Enqueue candidate
    self._set_candidates_queue_local(
      self._util_name_generate(
        candidate_media
      ),

      candidate_obj
    );
  };



  /**
   * JSJSAC JINGLE PEER API
   */

  /**
   * @private
   */
  self._peer_connection_create = function(sdp_message_callback) {
    self.get_debug().log('[JSJaCJingle] _peer_connection_create', 4);

    try {
      // Log STUN servers in use
      var i;
      var ice_config = self._util_config_ice();

      if(typeof ice_config.iceServers == 'object') {
        for(i = 0; i < (ice_config.iceServers).length; i++)
          self.get_debug().log('[JSJaCJingle] _peer_connection_create > Using ICE server at: ' + ice_config.iceServers[i].url + ' (' + (i + 1) + ').', 2);
      } else {
        self.get_debug().log('[JSJaCJingle] _peer_connection_create > No ICE server configured. Network may not work properly.', 0);
      }

      // Create the RTCPeerConnection object
      self._set_peer_connection(
        new WEBRTC_PEER_CONNECTION(
          ice_config,
          WEBRTC_CONFIGURATION.peer_connection.constraints
        )
      );

      // Event: onicecandidate
      self._get_peer_connection().onicecandidate = function(e) {
        if(e.candidate) {
          self._util_sdp_parse_candidate_store({
            media     : (isNaN(e.candidate.sdpMid) ? e.candidate.sdpMid : self._util_media_generate(parseInt(e.candidate.sdpMid, 10))),
            candidate : e.candidate.candidate
          });
        } else {
          // Build or re-build content (local)
          self._util_build_content_local();

          // In which action stanza should candidates be sent?
          if((self.is_initiator() && self.get_status() == JSJAC_JINGLE_STATUS_INITIATING)  ||
             (self.is_responder() && self.get_status() == JSJAC_JINGLE_STATUS_ACCEPTING)) {
            self.get_debug().log('[JSJaCJingle] _peer_connection_create > onicecandidate > Got initial candidates.', 2);

            // Execute what's next (initiate/accept session)
            sdp_message_callback();
          } else {
            self.get_debug().log('[JSJaCJingle] _peer_connection_create > onicecandidate > Got more candidates (on the go).', 2);

            // Send unsent candidates
            var candidates_queue_local = self._get_candidates_queue_local();

            if(self.util_object_length(candidates_queue_local) > 0)
              self.send(JSJAC_JINGLE_STANZA_TYPE_SET, { action: JSJAC_JINGLE_ACTION_TRANSPORT_INFO, candidates: candidates_queue_local });
          }

          // Empty the unsent candidates queue
          self._set_candidates_queue_local(null);
        }
      };

      // Event: oniceconnectionstatechange
      self._get_peer_connection().oniceconnectionstatechange = function(e) {
        self.get_debug().log('[JSJaCJingle] _peer_connection_create > oniceconnectionstatechange', 2);

        // Connection errors?
        switch(this.iceConnectionState) {
          case 'disconnected':
            self._peer_timeout(this.iceConnectionState, {
              timer  : JSJAC_JINGLE_PEER_TIMEOUT_DISCONNECT,
              reason : JSJAC_JINGLE_REASON_CONNECTIVITY_ERROR
            });
            break;

          case 'checking':
            self._peer_timeout(this.iceConnectionState); break;
        }

        self.get_debug().log('[JSJaCJingle] _peer_connection_create > oniceconnectionstatechange > (state: ' + this.iceConnectionState + ').', 2);
      };

      // Event: onaddstream
      self._get_peer_connection().onaddstream = function(e) {
        if (!e) return;

        self.get_debug().log('[JSJaCJingle] _peer_connection_create > onaddstream', 2);

        // Attach remote stream to DOM view
        self._set_remote_stream(e.stream);
      };

      // Event: onremovestream
      self._get_peer_connection().onremovestream = function(e) {
        self.get_debug().log('[JSJaCJingle] _peer_connection_create > onremovestream', 2);

        // Detach remote stream from DOM view
        self._set_remote_stream(null);
      };

      // Add local stream
      self._get_peer_connection().addStream(self._get_local_stream()); 

      // Create offer
      self.get_debug().log('[JSJaCJingle] _peer_connection_create > Getting local description...', 2);

      if(self.is_initiator()) {
        // Local description
        self._get_peer_connection().createOffer(self._peer_got_description, self._peer_fail_description, WEBRTC_CONFIGURATION.create_offer);

        // Then, wait for responder to send back its remote description
      } else {
        // Apply SDP data
        sdp_remote = self._util_sdp_generate(
          WEBRTC_SDP_TYPE_OFFER,
          self._get_group_remote(),
          self._get_payloads_remote(),
          self._get_candidates_queue_remote()
        );

        if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (remote)' + '\n\n' + sdp_remote.description.sdp, 4);

        // Remote description
        self._get_peer_connection().setRemoteDescription(
          (new WEBRTC_SESSION_DESCRIPTION(sdp_remote.description)),

          function() {
            // Success (descriptions are compatible)
          },

          function(e) {
            if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (remote:error)' + '\n\n' + (e.message || e.name || 'Unknown error'), 4);

            // Error (descriptions are incompatible)
            self.terminate(JSJAC_JINGLE_REASON_INCOMPATIBLE_PARAMETERS);
          }
        );

        // Local description
        self._get_peer_connection().createAnswer(self._peer_got_description, self._peer_fail_description, WEBRTC_CONFIGURATION.create_answer);

        // ICE candidates
        var c;
        var cur_candidate_obj;

        for(c in sdp_remote.candidates) {
          cur_candidate_obj = sdp_remote.candidates[c];

          self._get_peer_connection().addIceCandidate(
            new WEBRTC_ICE_CANDIDATE({
              sdpMLineIndex : cur_candidate_obj.id,
              candidate     : cur_candidate_obj.candidate
            })
          );
        }

        // Empty the unapplied candidates queue
        self._set_candidates_queue_remote(null);
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_connection_create > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_get_user_media = function(callback) {
    self.get_debug().log('[JSJaCJingle] _peer_get_user_media', 4);

    try {
      self.get_debug().log('[JSJaCJingle] _peer_get_user_media > Getting user media...', 2);

      (WEBRTC_GET_MEDIA.bind(navigator))(
        self.util_generate_constraints(),
        self._peer_got_user_media_success.bind(this, callback),
        self._peer_got_user_media_error.bind(this)
      );
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_get_user_media > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_got_user_media_success = function(callback, stream) {
    self.get_debug().log('[JSJaCJingle] _peer_got_user_media_success', 4);

    try {
      self.get_debug().log('[JSJaCJingle] _peer_got_user_media_success > Got user media.', 2);

      self._set_local_stream(stream);

      if(callback && typeof callback == 'function') {
        if((self.get_media() == JSJAC_JINGLE_MEDIA_VIDEO) && self.get_local_view().length) {
          self.get_debug().log('[JSJaCJingle] _peer_got_user_media_success > Waiting for local video to be loaded...', 2);

          var fn_loaded = function() {
            self.get_debug().log('[JSJaCJingle] _peer_got_user_media_success > Local video loaded.', 2);

            this.removeEventListener('loadeddata', fn_loaded, false);
            callback();
          };

          self.get_local_view()[0].addEventListener('loadeddata', fn_loaded, false);
        } else {
          callback();
        }
      }
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_got_user_media_success > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_got_user_media_error = function(error) {
    self.get_debug().log('[JSJaCJingle] _peer_got_user_media_error', 4);

    try {
      (self._get_session_initiate_error())(self);

      // Not needed in case we are the responder (breaks termination)
      if(self.is_initiator()) self.handle_session_initiate_error();

      // Not needed in case we are the initiator (no packet sent, ever)
      if(self.is_responder()) self.terminate(JSJAC_JINGLE_REASON_MEDIA_ERROR);

      self.get_debug().log('[JSJaCJingle] _peer_got_user_media_error > Failed (' + (error.PERMISSION_DENIED ? 'permission denied' : 'unknown' ) + ').', 1);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_got_user_media_error > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_got_description = function(sdp_local) {
    self.get_debug().log('[JSJaCJingle] _peer_got_description', 4);

    try {
      self.get_debug().log('[JSJaCJingle] _peer_got_description > Got local description.', 2);

      if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (local:raw)' + '\n\n' + sdp_local.sdp, 4);

      // Convert SDP raw data to an object
      var cur_name;
      var payload_parsed = self._util_sdp_parse_payload(sdp_local.sdp);
      self._util_sdp_resolution_payload(payload_parsed);

      for(cur_name in payload_parsed) {
        self._set_payloads_local(
          cur_name,
          payload_parsed[cur_name]
        );
      }

      var cur_semantics;
      var group_parsed = self._util_sdp_parse_group(sdp_local.sdp);

      for(cur_semantics in group_parsed) {
        self._set_group_local(
          cur_semantics,
          group_parsed[cur_semantics]
        );
      }

      // Filter our local description (remove unused medias)
      var sdp_local_desc = self._util_sdp_generate_description(
        sdp_local.type,
        self._get_group_local(),
        self._get_payloads_local(),

        self._util_sdp_generate_candidates(
          self._get_candidates_local()
        )
      );

      if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (local:gen)' + '\n\n' + sdp_local_desc.sdp, 4);

      self._get_peer_connection().setLocalDescription(
        (new WEBRTC_SESSION_DESCRIPTION(sdp_local_desc)),

        function() {
          // Success (descriptions are compatible)
        },

        function(e) {
          if(self.get_sdp_trace())  self.get_debug().log('[JSJaCJingle] SDP (local:error)' + '\n\n' + (e.message || e.name || 'Unknown error'), 4);

          // Error (descriptions are incompatible)
        }
      );

      self.get_debug().log('[JSJaCJingle] _peer_got_description > Waiting for local candidates...', 2);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_got_description > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_fail_description = function() {
    self.get_debug().log('[JSJaCJingle] _peer_fail_description', 4);

    try {
      self.get_debug().log('[JSJaCJingle] _peer_fail_description > Could not get local description!', 1);
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_fail_description > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_sound = function(enable) {
    self.get_debug().log('[JSJaCJingle] _peer_sound', 4);

    try {
      self.get_debug().log('[JSJaCJingle] _peer_sound > Enable: ' + enable + ' (current: ' + self.get_mute(JSJAC_JINGLE_MEDIA_AUDIO) + ').', 2);

      var i;
      var audio_tracks = self._get_local_stream().getAudioTracks();

      for(i = 0; i < audio_tracks.length; i++)
        audio_tracks[i].enabled = enable;
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_sound > ' + e, 1);
    }
  };

  /**
   * Set a timeout limit to peer connection
   */
  self._peer_timeout = function(state, args) {
    try {
      // Assert
      if(typeof args !== 'object') args = {};

      var t_sid = self.get_sid();
   
      setTimeout(function() {
        // State did not change?
        if(self.get_sid() == t_sid && self._get_peer_connection().iceConnectionState == state) {
          self.get_debug().log('[JSJaCJingle] util_stanza_timeout > Peer timeout.', 2);

          // Error (transports are incompatible)
          self.terminate(args.reason || JSJAC_JINGLE_REASON_FAILED_TRANSPORT);
        }
      }, ((args.timer || JSJAC_JINGLE_PEER_TIMEOUT_DEFAULT) * 1000));
    } catch(e) {
      self.get_debug().log('[JSJaCJingle] _peer_timeout > ' + e, 1);
    }
  };

  /**
   * @private
   */
  self._peer_stop = function() {
    self.get_debug().log('[JSJaCJingle] _peer_stop', 4);

    // Detach media streams from DOM view
    self._set_local_stream(null);
    self._set_remote_stream(null);

    // Close the media stream
    if(self._get_peer_connection())
      self._get_peer_connection().close();

    // Remove this session from router
    JSJaCJingle_remove(self.get_sid());
  };
}



/**
 * Listens for Jingle events
 */
function JSJaCJingle_listen(args) {
  try {
    if(args && args.connection)
      JSJAC_JINGLE_STORE_CONNECTION = args.connection;

    if(args && args.initiate)
      JSJAC_JINGLE_STORE_INITIATE = args.initiate;

    if(args && args.debug)
      JSJAC_JINGLE_STORE_DEBUG = args.debug;

    // Incoming IQs handler
    JSJAC_JINGLE_STORE_CONNECTION.registerHandler('iq', JSJaCJingle_route);

    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:listen > Listening.', 2);

    // Discover available network services
    if(!args || args.extdisco !== false)
      JSJaCJingle_extdisco();
    if(args.fallback && typeof args.fallback === 'string')
      JSJaCJingle_fallback(args.fallback);
  } catch(e) {
    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:listen > ' + e, 1);
  }
}

/**
 * Routes Jingle stanzas
 */
function JSJaCJingle_route(stanza) {
  try {
    var action = null;
    var sid    = null;

    // Route the incoming stanza
    var jingle = stanza.getChild('jingle', NS_JINGLE);

    if(jingle) {
      sid = jingle.getAttribute('sid');
      action = jingle.getAttribute('action');
    } else {
      var stanza_id = stanza.getID();

      if(stanza_id) {
        var is_jingle = stanza_id.indexOf(JSJAC_JINGLE_STANZA_ID_PRE + '_') !== -1;

        if(is_jingle) {
          var stanza_id_split = stanza_id.split('_');
          sid = stanza_id_split[1];
        }
      }
    }

    // WebRTC not available ATM?
    if(jingle && !JSJAC_JINGLE_AVAILABLE) {
      JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:route > Dropped Jingle packet (WebRTC not available).', 0);

      (new JSJaCJingle({ to: stanza.getFrom() })).send_error(stanza, XMPP_ERROR_SERVICE_UNAVAILABLE);
    } else {
      // New session? Or registered one?
      var session_route = JSJaCJingle_read(sid);

      if(action == JSJAC_JINGLE_ACTION_SESSION_INITIATE && session_route === null) {
        JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:route > New Jingle session (sid: ' + sid + ').', 2);

        JSJAC_JINGLE_STORE_INITIATE(stanza);
      } else if(sid) {
        if(session_route !== null) {
          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:route > Routed to Jingle session (sid: ' + sid + ').', 2);

          session_route.handle(stanza);
        } else if(stanza.getType() == JSJAC_JINGLE_STANZA_TYPE_SET && stanza.getFrom()) {
          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:route > Unknown Jingle session (sid: ' + sid + ').', 0);

          (new JSJaCJingle({ to: stanza.getFrom() })).send_error(stanza, JSJAC_JINGLE_ERROR_UNKNOWN_SESSION);
        }
      }
    }
  } catch(e) {
    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:route > ' + e, 1);
  }
}

/**
 * Adds a new Jingle session
 */
function JSJaCJingle_add(sid, obj) {
  JSJAC_JINGLE_STORE_SESSIONS[sid] = obj;
}

/**
 * Reads a new Jingle session
 * @return Session
 * @type object
 */
function JSJaCJingle_read(sid) {
  return (sid in JSJAC_JINGLE_STORE_SESSIONS) ? JSJAC_JINGLE_STORE_SESSIONS[sid] : null;
}

/**
 * Removes a new Jingle session
 */
function JSJaCJingle_remove(sid) {
  delete JSJAC_JINGLE_STORE_SESSIONS[sid];
}

/**
 * Defer given task/execute deferred tasks
 */
function JSJaCJingle_defer(arg) {
  try {
    if(typeof arg == 'function') {
      // Deferring?
      if(JSJAC_JINGLE_STORE_DEFER.deferred) {
        (JSJAC_JINGLE_STORE_DEFER.fn).push(arg);

        JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:defer > Registered a function to be executed once ready.', 2);
      }

      return JSJAC_JINGLE_STORE_DEFER.deferred;
    } else if(!arg || typeof arg == 'boolean') {
      JSJAC_JINGLE_STORE_DEFER.deferred = (arg === true);

      if(JSJAC_JINGLE_STORE_DEFER.deferred === false) {
        // Execute deferred tasks?
        if((--JSJAC_JINGLE_STORE_DEFER.count) <= 0) {
          JSJAC_JINGLE_STORE_DEFER.count = 0;

          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:defer > Executing ' + JSJAC_JINGLE_STORE_DEFER.fn.length + ' deferred functions...', 2);

          while(JSJAC_JINGLE_STORE_DEFER.fn.length)
            ((JSJAC_JINGLE_STORE_DEFER.fn).shift())();

          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:defer > Done executing deferred functions.', 2);
        }
      } else {
        ++JSJAC_JINGLE_STORE_DEFER.count;
      }
    }
  } catch(e) {
    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:defer > ' + e, 1);
  }
}

/**
 * Maps the Jingle disco features
 * @return Feature namespaces
 * @type array
 */
function JSJaCJingle_disco() {
  return JSJAC_JINGLE_AVAILABLE ? MAP_DISCO_JINGLE : [];
}

/**
 * Query the server for external services
 */
function JSJaCJingle_extdisco() {
  JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > Discovering available services...', 2);

  try {
    // Pending state (defer other requests)
    JSJaCJingle_defer(true);

    // Build request
    var request = new JSJaCIQ();

    request.setTo(JSJAC_JINGLE_STORE_CONNECTION.domain);
    request.setType(JSJAC_JINGLE_STANZA_TYPE_GET);

    request.getNode().appendChild(request.buildNode('services', { 'xmlns': NS_EXTDISCO }));

    JSJAC_JINGLE_STORE_CONNECTION.send(request, function(response) {
      try {
        // Parse response
        if(response.getType() == JSJAC_JINGLE_STANZA_TYPE_RESULT) {
          var i,
              service_arr, cur_service,
              cur_host, cur_password, cur_port, cur_transport, cur_type, cur_username;

          var services = response.getChild('services', NS_EXTDISCO);

          if(services) {
            service_arr = services.getElementsByTagNameNS(NS_EXTDISCO, 'service');

            for(i = 0; i < service_arr.length; i++) {
              cur_service = service_arr[i];

              cur_host      = cur_service.getAttribute('host')       || null;
              cur_port      = cur_service.getAttribute('port')       || null;
              cur_transport = cur_service.getAttribute('transport')  || null;
              cur_type      = cur_service.getAttribute('type')       || null;

              cur_username  = cur_service.getAttribute('username')   || null;
              cur_password  = cur_service.getAttribute('password')   || null;

              if(!cur_host || !cur_type)  continue;

              if(!(cur_type in JSJAC_JINGLE_STORE_EXTDISCO)) {
                JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > handle > Service skipped (type: ' + cur_type + ', host: ' + cur_host + ', port: ' + cur_port + ', transport: ' + cur_transport + ').', 4);
                continue;
              }

              JSJAC_JINGLE_STORE_EXTDISCO[cur_type][cur_host] = {
                'port'      : cur_port,
                'transport' : cur_transport,
                'type'      : cur_type
              };

              if(cur_type == 'turn') {
                JSJAC_JINGLE_STORE_EXTDISCO[cur_type][cur_host].username = cur_username;
                JSJAC_JINGLE_STORE_EXTDISCO[cur_type][cur_host].password = cur_password;
              }

              JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > handle > Service stored (type: ' + cur_type + ', host: ' + cur_host + ', port: ' + cur_port + ', transport: ' + cur_transport + ').', 4);
            }
          }

          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > handle > Discovered available services.', 2);
        } else {
          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > handle > Could not discover services (server might not support XEP-0215).', 0);
        }
      } catch(e) {
        JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > handle > ' + e, 1);
      }

      JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > Ready.', 2);

      // Execute deferred requests
      JSJaCJingle_defer(false);
    });
  } catch(e) {
    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:extdisco > ' + e, 1);
    
    // Execute deferred requests
    JSJaCJingle_defer(false);
  }
}

/**
 * Query some external APIs for fallback STUN/TURN (must be configured)
 */
function JSJaCJingle_fallback(fallback_url) {
  JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > Discovering fallback services...', 2);

  try {
    // Pending state (defer other requests)
    JSJaCJingle_defer(true);

    // Generate fallback API URL
    fallback_url += '?username=' + 
                    encodeURIComponent(JSJAC_JINGLE_STORE_CONNECTION.username + '@' + JSJAC_JINGLE_STORE_CONNECTION.domain);

    // Proceed request
    var xhr = new XMLHttpRequest();
    xhr.open('GET', fallback_url, true);

    xhr.onreadystatechange = function() {
      if(xhr.readyState === 4) {
        // Success?
        if(xhr.status === 200) {
          var data = JSON.parse(xhr.responseText);

          var cur_parse,
              i, cur_url,
              cur_type, cur_host, cur_port, cur_transport,
              cur_username, cur_password;

          if(data.uris && data.uris.length) {
            JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Parsing ' + data.uris.length + ' URIs...', 2);

            for(i in data.uris) {
              cur_url = data.uris[i];

              if(cur_url) {
                // Parse current URL
                cur_parse = R_JSJAC_JINGLE_SERVICE_URI.exec(cur_url);

                if(cur_parse) {
                  cur_type = cur_parse[1]        || null;
                  cur_host = cur_parse[2]        || null;
                  cur_port = cur_parse[3]        || null;
                  cur_transport = cur_parse[4]   || null;

                  cur_username  = data.username  || null;
                  cur_password  = data.password  || null;

                  if(!cur_host || !cur_type)  continue;

                  if(!(cur_type in JSJAC_JINGLE_STORE_FALLBACK)) {
                    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Service skipped (type: ' + cur_type + ', host: ' + cur_host + ', port: ' + cur_port + ', transport: ' + cur_transport + ').', 4);
                    continue;
                  }

                  JSJAC_JINGLE_STORE_FALLBACK[cur_type][cur_host] = {
                    'port'      : cur_port,
                    'transport' : cur_transport,
                    'type'      : cur_type
                  };

                  if(cur_type == 'turn') {
                    JSJAC_JINGLE_STORE_FALLBACK[cur_type][cur_host].username = cur_username;
                    JSJAC_JINGLE_STORE_FALLBACK[cur_type][cur_host].password = cur_password;
                  }

                  JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Fallback service stored (type: ' + cur_type + ', host: ' + cur_host + ', port: ' + cur_port + ', transport: ' + cur_transport + ').', 4);
                } else {
                  JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Fallback service not stored, weird URI (' + cur_url + ').', 0);
                }
              }
            }

            JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Finished parsing URIs.', 2);
          } else {
            JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > No URI to parse.', 2);
          }

          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Discovered fallback services.', 2);
        } else {
          JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > handle > Could not discover fallback services (API malfunction).', 0);
        }

        JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > Ready.', 2);

        // Execute deferred requests
        JSJaCJingle_defer(false);
      }
    };

    xhr.send();
  } catch(e) {
    JSJAC_JINGLE_STORE_DEBUG.log('[JSJaCJingle] lib:fallback > ' + e, 1);
  }
}

/*

Jappix - An open social platform
These are the system JS script for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Authors: Val√©rian Saliou, olivierm, regilero, Maranda

*/

// Bundle
var System = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Gets the current app location
     * @public
     * @return {string}
     */
    self.location = function() {

        try {
            var url = window.location.href;
            
            // If the URL has variables, remove them
            if(url.indexOf('?') != -1)
                url = url.split('?')[0];
            if(url.indexOf('#') != -1)
                url = url.split('#')[0];
            
            // No "/" at the end
            if(!url.match(/(.+)\/$/))
                url += '/';
            
            return url;
        } catch(e) {
            Console.error('System.location', e);
        }

    };


    /**
     * Checks if we are in developer mode
     * @public
     * @return {boolean}
     */
    self.isDeveloper = function() {

        try {
            return (DEVELOPER === 'on');
        } catch(e) {
            Console.error('System.isDeveloper', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixSystem = System;
/*

Jappix - An open social platform
These are the constants JS scripts for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Authors: Stefan Strigler, Val√©rian Saliou, Kloadut, Maranda

*/

// XMPP XMLNS attributes
var NS_PROTOCOL =     'http://jabber.org/protocol/';
var NS_FEATURES =     'http://jabber.org/features/';
var NS_CLIENT =       'jabber:client';
var NS_IQ =           'jabber:iq:';
var NS_X =            'jabber:x:';
var NS_IETF =         'urn:ietf:params:xml:ns:';
var NS_IETF_XMPP =    NS_IETF + 'xmpp-';
var NS_XMPP =         'urn:xmpp:';

var NS_STORAGE =      'storage:';
var NS_BOOKMARKS =    NS_STORAGE + 'bookmarks';
var NS_ROSTERNOTES =  NS_STORAGE + 'rosternotes';

var NS_JAPPIX =       'jappix:';
var NS_INBOX =        NS_JAPPIX + 'inbox';
var NS_OPTIONS =      NS_JAPPIX + 'options';

var NS_DISCO_ITEMS =  NS_PROTOCOL + 'disco#items';
var NS_DISCO_INFO =   NS_PROTOCOL + 'disco#info';
var NS_VCARD =        'vcard-temp';
var NS_VCARD_P =      NS_VCARD + ':x:update';
var NS_IETF_VCARD4 =  NS_IETF + 'vcard-4.0';
var NS_XMPP_VCARD4 =  NS_XMPP + 'vcard4';
var NS_URN_ADATA =    NS_XMPP + 'avatar:data';
var NS_URN_AMETA =    NS_XMPP + 'avatar:metadata';
var NS_AUTH =         NS_IQ + 'auth';
var NS_AUTH_ERROR =   NS_IQ + 'auth:error';
var NS_REGISTER =     NS_IQ + 'register';
var NS_SEARCH =       NS_IQ + 'search';
var NS_ROSTER =       NS_IQ + 'roster';
var NS_PRIVACY =      NS_IQ + 'privacy';
var NS_PRIVATE =      NS_IQ + 'private';
var NS_VERSION =      NS_IQ + 'version';
var NS_TIME =         NS_IQ + 'time';
var NS_LAST =         NS_IQ + 'last';
var NS_IQDATA =       NS_IQ + 'data';
var NS_XDATA =        NS_X + 'data';
var NS_IQOOB =        NS_IQ + 'oob';
var NS_XOOB =         NS_X + 'oob';
var NS_DELAY =        NS_X + 'delay';
var NS_EXPIRE =       NS_X + 'expire';
var NS_EVENT =        NS_X + 'event';
var NS_XCONFERENCE =  NS_X + 'conference';
var NS_STATS =        NS_PROTOCOL + 'stats';
var NS_MUC =          NS_PROTOCOL + 'muc';
var NS_MUC_USER =     NS_MUC + '#user';
var NS_MUC_ADMIN =    NS_MUC + '#admin';
var NS_MUC_OWNER =    NS_MUC + '#owner';
var NS_MUC_CONFIG =   NS_MUC + '#roomconfig';
var NS_PUBSUB =       NS_PROTOCOL + 'pubsub';
var NS_PUBSUB_EVENT = NS_PUBSUB + '#event';
var NS_PUBSUB_OWNER = NS_PUBSUB + '#owner';
var NS_PUBSUB_NMI =   NS_PUBSUB + '#node-meta-info';
var NS_PUBSUB_NC =    NS_PUBSUB + '#node_config';
var NS_PUBSUB_CN =    NS_PUBSUB + '#config-node';
var NS_PUBSUB_RI =    NS_PUBSUB + '#retrieve-items';
var NS_COMMANDS =     NS_PROTOCOL + 'commands';
var NS_BOSH =         NS_PROTOCOL + 'httpbind';
var NS_STREAM =       'http://etherx.jabber.org/streams';
var NS_URN_TIME =     NS_XMPP + 'time';
var NS_URN_PING =     NS_XMPP + 'ping';
var NS_URN_MBLOG =    NS_XMPP + 'microblog:0';
var NS_URN_INBOX =    NS_XMPP + 'inbox';
var NS_URN_FORWARD =  NS_XMPP + 'forward:0';
var NS_URN_MAM =      NS_XMPP + 'mam:tmp';
var NS_URN_DELAY =    NS_XMPP + 'delay';
var NS_URN_RECEIPTS = NS_XMPP + 'receipts';
var NS_URN_CARBONS =  NS_XMPP + 'carbons:2';
var NS_RSM =          NS_PROTOCOL + 'rsm';
var NS_IPV6 =         'ipv6';
var NS_XHTML =        'http://www.w3.org/1999/xhtml';
var NS_XHTML_IM =     NS_PROTOCOL + 'xhtml-im';
var NS_CHATSTATES =   NS_PROTOCOL + 'chatstates';
var NS_HTTP_AUTH =    NS_PROTOCOL + 'http-auth';
var NS_ROSTERX =      NS_PROTOCOL + 'rosterx';
var NS_MOOD =         NS_PROTOCOL + 'mood';
var NS_ACTIVITY =     NS_PROTOCOL + 'activity';
var NS_TUNE =         NS_PROTOCOL + 'tune';
var NS_GEOLOC =       NS_PROTOCOL + 'geoloc';
var NS_NICK =         NS_PROTOCOL + 'nick';
var NS_NOTIFY =       '+notify';
var NS_CAPS =         NS_PROTOCOL + 'caps';
var NS_ATOM =         'http://www.w3.org/2005/Atom';

var NS_STANZAS =      NS_IETF_XMPP + 'stanzas';
var NS_STREAMS =      NS_IETF_XMPP + 'streams';

var NS_TLS =          NS_IETF_XMPP + 'tls';
var NS_SASL =         NS_IETF_XMPP + 'sasl';
var NS_SESSION =      NS_IETF_XMPP + 'session';
var NS_BIND =         NS_IETF_XMPP + 'bind';

var NS_FEATURE_IQAUTH = NS_FEATURES + 'iq-auth';
var NS_FEATURE_IQREGISTER = NS_FEATURES + 'iq-register';
var NS_FEATURE_COMPRESS = NS_FEATURES + 'compress';

var NS_COMPRESS =     NS_PROTOCOL + 'compress';

var NS_METRONOME_MAM_PURGE = 'http://metronome.im/protocol/mam-purge';

// Available locales
var LOCALES_AVAILABLE_ID = [];
var LOCALES_AVAILABLE_NAMES = [];

// XML lang
var XML_LANG = null;

// Jappix parameters
var JAPPIX_STATIC = null;
var JAPPIX_VERSION = null;
var JAPPIX_MAX_FILE_SIZE = null;
var JAPPIX_MAX_UPLOAD = null;

// Jappix main configuration
var SERVICE_NAME = null;
var SERVICE_DESC = null;
var OWNER_NAME = null;
var OWNER_WEBSITE = null;
var LEGAL = null;
var JAPPIX_RESOURCE = null;
var LOCK_HOST = null;
var ANONYMOUS = null;
var HTTP_AUTH = null;
var REGISTRATION = null;
var BOSH_PROXY = null;
var MANAGER_LINK = null;
var GROUPCHATS_JOIN = null;
var GROUPCHATS_SUGGEST = null;
var ENCRYPTION = null;
var HTTPS_STORAGE = null;
var HTTPS_FORCE = null;
var COMPRESSION = null;
var ADS_ENABLE = null;
var GADS_CLIENT = null;
var GADS_SLOT = null;
var MULTI_FILES = null;
var DEVELOPER = null;
var REGISTER_API = null;

// Jappix hosts configuration
var HOST_MAIN = null;
var HOST_MUC = null;
var HOST_PUBSUB = null;
var HOST_VJUD = null;
var HOST_ANONYMOUS = null;
var HOST_STUN = null;
var HOST_TURN = null;
var HOST_TURN_USERNAME = null;
var HOST_TURN_PASSWORD = null;
var HOST_BOSH = null;
var HOST_BOSH_MAIN = null;
var HOST_BOSH_MINI = null;
var HOST_WEBSOCKET = null;
var HOST_STATIC = null;
var HOST_UPLOAD = null;

// Anonymous mode
var ANONYMOUS_ROOM = null;
var ANONYMOUS_NICK = null;

// Node parameters
var JAPPIX_LOCATION = JappixSystem.location();
var JAPPIX_MINI_CSS = null;
var BOSH_SAME_ORIGIN = false;

// XMPP error stanzas
function STANZA_ERROR(code, type, cond) {
    if(window == this) {
        return new STANZA_ERROR(code, type, cond);
    }
    
    this.code = code;
    this.type = type;
    this.cond = cond;
}

var ERR_BAD_REQUEST =
    STANZA_ERROR('400', 'modify', 'bad-request');
var ERR_CONFLICT =
    STANZA_ERROR('409', 'cancel', 'conflict');
var ERR_FEATURE_NOT_IMPLEMENTED =
    STANZA_ERROR('501', 'cancel', 'feature-not-implemented');
var ERR_FORBIDDEN =
    STANZA_ERROR('403', 'auth',   'forbidden');
var ERR_GONE =
    STANZA_ERROR('302', 'modify', 'gone');
var ERR_INTERNAL_SERVER_ERROR =
    STANZA_ERROR('500', 'wait',   'internal-server-error');
var ERR_ITEM_NOT_FOUND =
    STANZA_ERROR('404', 'cancel', 'item-not-found');
var ERR_JID_MALFORMED =
    STANZA_ERROR('400', 'modify', 'jid-malformed');
var ERR_NOT_ACCEPTABLE =
    STANZA_ERROR('406', 'modify', 'not-acceptable');
var ERR_NOT_ALLOWED =
    STANZA_ERROR('405', 'cancel', 'not-allowed');
var ERR_NOT_AUTHORIZED =
    STANZA_ERROR('401', 'auth',   'not-authorized');
var ERR_PAYMENT_REQUIRED =
    STANZA_ERROR('402', 'auth',   'payment-required');
var ERR_RECIPIENT_UNAVAILABLE =
    STANZA_ERROR('404', 'wait',   'recipient-unavailable');
var ERR_REDIRECT =
    STANZA_ERROR('302', 'modify', 'redirect');
var ERR_REGISTRATION_REQUIRED =
    STANZA_ERROR('407', 'auth',   'registration-required');
var ERR_REMOTE_SERVER_NOT_FOUND =
    STANZA_ERROR('404', 'cancel', 'remote-server-not-found');
var ERR_REMOTE_SERVER_TIMEOUT =
    STANZA_ERROR('504', 'wait',   'remote-server-timeout');
var ERR_RESOURCE_CONSTRAINT =
    STANZA_ERROR('500', 'wait',   'resource-constraint');
var ERR_SERVICE_UNAVAILABLE =
    STANZA_ERROR('503', 'cancel', 'service-unavailable');
var ERR_SUBSCRIPTION_REQUIRED =
    STANZA_ERROR('407', 'auth',   'subscription-required');
var ERR_UNEXPECTED_REQUEST =
    STANZA_ERROR('400', 'wait',   'unexpected-request');

/*

Jappix - An open social platform
These are the temporary/persistent data store functions

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var DataStore = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self._db_emulated = {};
    self._persistent_emulated = {};


    /**
     * Common: storage adapter
     * @public
     * @param {object} storage_native
     * @param {object} storage_emulated
     * @return {undefined}
     */
    self._adapter = function(storage_native, storage_emulated) {

        try {
            var legacy = !storage_native;

            this.key = function(key) {
                if(legacy) {
                    if(key >= this.length)
                        return null;

                    var c = 0;

                    for(var name in storage_emulated) {
                        if(c++ == key)  return name;
                    }

                    return null;
                }

                return storage_native.key(key);
            };

            this.getItem = function(key) {
                if(legacy) {
                    if(storage_emulated[key] !== undefined)
                        return storage_emulated[key];

                    return null;
                } else {
                    return storage_native.getItem(key);
                }
            };

            this.setItem = function(key, data) {
                if(legacy) {
                    if(!(key in storage_emulated))
                        this.length++;

                    storage_emulated[key] = (data + '');
                } else {
                    storage_native.setItem(key, data);
                    this.length = storage_native.length;
                }
            };

            this.removeItem = function(key) {
                if(legacy) {
                    if(key in storage_emulated) {
                        this.length--;
                        delete storage_emulated[key];
                    }
                } else {
                    storage_native.removeItem(key);
                    this.length = storage_native.length;
                }
            };

            this.clear = function() {
                if(legacy) {
                    this.length = 0;
                    storage_emulated = {};
                } else {
                    storage_native.clear();
                    this.length = storage_native.length;
                }
            };

            this.length = legacy ? 0 : storage_native.length;
        } catch(e) {
            Console.error('DataStore._adapter', e);
        }

    };


    /**
     * Temporary: sessionStorage class alias for direct access
     */
    self.storageDB = new self._adapter(
        (window.sessionStorage ? sessionStorage : null),
        self._db_emulated
    );


    /**
     * Persistent: localStorage class alias for direct access
     */
    self.storagePersistent = new self._adapter(
        (window.localStorage ? localStorage : null),
        self._persistent_emulated
    );


    /**
     * Temporary: returns whether it is available or not
     * @public
     * @return {boolean}
     */
    self.hasDB = function() {

        var has_db = false;

        try {
            self.storageDB.setItem('hasdb_check', 'ok');
            self.storageDB.removeItem('hasdb_check');

            has_db = true;
        } catch(e) {
            Console.error('DataStore.hasDB', e);
        } finally {
            return has_db;
        }

    };


    /**
     * Temporary: used to read a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {object}
     */
    self.getDB = function(dbID, type, id) {

        try {
            try {
                return self.storageDB.getItem(dbID + '_' + type + '_' + id);
            }
            
            catch(e) {
                Console.error('Error while getting a temporary database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
            }

            return null;
        } catch(e) {
            Console.error('DataStore.getDB', e);
        }

    };


    /**
     * Temporary: used to update a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @param {type} value
     * @return {boolean}
     */
    self.setDB = function(dbID, type, id, value) {

        try {
            try {
                self.storageDB.setItem(dbID + '_' + type + '_' + id, value);

                return true;
            }
            
            catch(e) {
                Console.error('Error while writing a temporary database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
            }

            return false;
        } catch(e) {
            Console.error('DataStore.setDB', e);
        }

    };


    /**
     * Temporary: used to remove a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {undefined}
     */
    self.removeDB = function(dbID, type, id) {

        try {
            try {
                self.storageDB.removeItem(dbID + '_' + type + '_' + id);
                
                return true;
            }
            
            catch(e) {
                Console.error('Error while removing a temporary database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
            }

            return false;
        } catch(e) {
            Console.error('DataStore.removeDB', e);
        }

    };


    /**
     * Temporary: used to check a database entry exists
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {boolean}
     */
    self.existDB = function(dbID, type, id) {

        try {
            return self.getDB(dbID, type, id) !== null;
        } catch(e) {
            Console.error('DataStore.existDB', e);
        }

    };


    /**
     * Temporary: used to clear all the database
     * @public
     * @return {boolean}
     */
    self.resetDB = function() {

        try {
            try {
                self.storageDB.clear();
                
                Console.info('Temporary database cleared.');
                
                return true;
            }
            
            catch(e) {
                Console.error('Error while clearing temporary database', e);
                
                return false;
            }
        } catch(e) {
            Console.error('DataStore.resetDB', e);
        }

    };


    /**
     * Persistent: returns whether it is available or not
     * @public
     * @return {boolean}
     */
    self.hasPersistent = function() {

        var has_persistent = false;

        try {
            // Try to write something
            self.storagePersistent.setItem('haspersistent_check', 'ok');
            self.storagePersistent.removeItem('haspersistent_check');
            
            has_persistent = true;
        } catch(e) {
            Console.error('DataStore.hasPersistent', e);
        } finally {
            return has_persistent;
        }

    };


    /**
     * Persistent: used to read a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {object}
     */
    self.getPersistent = function(dbID, type, id) {

        try {
            try {
                return self.storagePersistent.getItem(dbID + '_' + type + '_' + id);
            }
            
            catch(e) {
                Console.error('Error while getting a persistent database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
                
                return null;
            }
        } catch(e) {
            Console.error('DataStore.getPersistent', e);
        }

    };


    /**
     * Persistent: used to update a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @param {string} value
     * @return {boolean}
     */
    self.setPersistent = function(dbID, type, id, value) {

        try {
            try {
                self.storagePersistent.setItem(dbID + '_' + type + '_' + id, value);
                
                return true;
            }
            
            // Database might be full
            catch(e) {
                Console.warn('Retrying: could not write a persistent database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
                
                // Flush it!
                self.flushPersistent();
                
                // Set the item again
                try {
                    self.storagePersistent.setItem(dbID + ' -> ' + type + '_' + id, value);
                    
                    return true;
                }
                
                // New error!
                catch(_e) {
                    Console.error('Aborted: error while writing a persistent database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', _e);
                }
            }

            return false;
        } catch(e) {
            Console.error('DataStore.setPersistent', e);
        }

    };


    /**
     * Persistent: used to remove a database entry
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {boolean}
     */
    self.removePersistent = function(dbID, type, id) {

        try {
            try {
                self.storagePersistent.removeItem(dbID + '_' + type + '_' + id);

                return true;
            }
            
            catch(e) {
                Console.error('Error while removing a persistent database entry (' + dbID + ' -> ' + type + ' -> ' + id + ')', e);
            }

            return false;
        } catch(e) {
            Console.error('DataStore.removePersistent', e);
        }

    };


    /**
     * Persistent: used to check a database entry exists
     * @public
     * @param {string} dbID
     * @param {string} type
     * @param {string} id
     * @return {boolean}
     */
    self.existPersistent = function(dbID, type, id) {

        try {
            return self.getPersistent(dbID, type, id) !== null;
        } catch(e) {
            Console.error('DataStore.existPersistent', e);
        }

    };


    /**
     * Persistent: used to clear all the database
     * @public
     * @param {type} name
     * @return {boolean}
     */
    self.resetPersistent = function() {

        try {
            try {
                self.storagePersistent.clear();

                Console.info('Persistent database cleared.');
                
                return true;
            }
            
            catch(e) {
                Console.error('Error while clearing persistent database', e);
            }

            return false;
        } catch(e) {
            Console.error('DataStore.resetPersistent', e);
        }

    };


    /**
     * Persistent: used to flush the database
     * @public
     * @param {type} name
     * @return {boolean}
     */
    self.flushPersistent = function() {

        try {
            try {
                // Get the stored session entry
                var session = self.getPersistent('global', 'session', 1);
                
                // Reset the persistent database
                self.resetPersistent();
                
                // Restaure the stored session entry
                if(session)
                    self.setPersistent('global', 'session', 1, session);
                
                Console.info('Persistent database flushed.');
                
                return true;
            }
            
            catch(e) {
                Console.error('Error while flushing persistent database', e);
            }

            return false;
        } catch(e) {
            Console.error('DataStore.flushPersistent', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixDataStore = DataStore;
/* BROWSER DETECT
 * http://www.quirksmode.org/js/detect.html
 * License: dual-licensed under MPLv2 and the original license
 */

var BrowserDetect = {
    init: function () {
        this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
        this.version = this.searchVersion(navigator.userAgent)
            || this.searchVersion(navigator.appVersion)
            || "an unknown version";
        this.OS = this.searchString(this.dataOS) || "an unknown OS";
    },
    
    searchString: function (data) {
        for (var i=0;i<data.length;i++) {
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            this.versionSearchString = data[i].versionSearch || data[i].identity;
            if (dataString) {
                if (dataString.indexOf(data[i].subString) != -1)
                    return data[i].identity;
            }
            else if (dataProp)
                return data[i].identity;
        }
    },
    
    searchVersion: function (dataString) {
        var index = dataString.indexOf(this.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index+this.versionSearchString.length+1));
    },
    
    dataBrowser: [
        {
            string: navigator.userAgent,
            subString: "Chrome",
            identity: "Chrome"
        },
        {   string: navigator.userAgent,
            subString: "OmniWeb",
            versionSearch: "OmniWeb/",
            identity: "OmniWeb"
        },
        {
            string: navigator.vendor,
            subString: "Apple",
            identity: "Safari",
            versionSearch: "Version"
        },
        {
            prop: window.opera,
            identity: "Opera"
        },
        {
            string: navigator.vendor,
            subString: "iCab",
            identity: "iCab"
        },
        {
            string: navigator.vendor,
            subString: "KDE",
            identity: "Konqueror"
        },
        {
            string: navigator.userAgent,
            subString: "Firefox",
            identity: "Firefox"
        },
        {
            string: navigator.vendor,
            subString: "Camino",
            identity: "Camino"
        },
        {       // for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: "Netscape",
            identity: "Netscape"
        },
        {
            string: navigator.userAgent,
            subString: "MSIE",
            identity: "Explorer",
            versionSearch: "MSIE"
        },
        {
            string: navigator.userAgent,
            subString: "Gecko",
            identity: "Mozilla",
            versionSearch: "rv"
        },
        {       // for older Netscapes (4-)
            string: navigator.userAgent,
            subString: "Mozilla",
            identity: "Netscape",
            versionSearch: "Mozilla"
        }
    ],
    
    dataOS : [
        {
            string: navigator.platform,
            subString: "Win",
            identity: "Windows"
        },
        {
            string: navigator.platform,
            subString: "Mac",
            identity: "Mac"
        },
        {
               string: navigator.userAgent,
               subString: "iPhone",
               identity: "iPhone/iPod"
        },
        {
            string: navigator.platform,
            subString: "Linux",
            identity: "Linux"
        }
    ]
};

BrowserDetect.init();

/*

Jappix - An open social platform
These are the homepage JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, LinkMauve

*/

// Bundle
var Home = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Allows the user to switch the difference home page elements
     * @public
     * @param {string} div
     * @return {boolean}
     */
    self.change = function(div) {

        try {
            // Path to
            var home = '#home .';
            var right = home + 'right ';
            var current = right + '.homediv.' + div;
            
            // We switch the div
            $(right + '.homediv, ' + right + '.top').hide();
            $(right + '.' + div).show();
            
            // We reset the homedivs
            $(home + 'homediv:not(.default), ' + home + 'top:not(.default)').remove();
            
            // Get the HTML code to display
            var disable_form = '';
            var lock_host = '';
            var code = '';
            
            // Apply the previous link
            switch(div) {
                case 'loginer':
                case 'anonymouser':
                case 'registerer':
                    if(!Common.exists(right + '.top.sub')) {
                        // Append the HTML code for previous link
                        $(right + '.top.default').after('<h1 class="top sub loginer anonymouser registerer">&laquo; <a href="#" class="previous">' + Common._e("Previous") + '</a></h1>');
                        
                        // Click event on previous link
                        $(home + 'top.sub a.previous').click(function() {
                            return self.change('default');
                        });
                    }
                
                break;
            }
            
            // Apply the form
            switch(div) {
                // Login tool
                case 'loginer':
                    lock_host = Utils.disableInput(LOCK_HOST, 'on');
                    code = '<p>' + Common.printf(Common._e("Login to your existing XMPP account. You can also use the %s to join a groupchat."), '<a href="#" class="to-anonymous">' + Common._e("anonymous mode") + '</a>') + '</p>' + 
                        
                        '<form action="#" method="post">' + 
                            '<fieldset>' + 
                                '<legend>' + Common._e("Required") + '</legend>' + 
                                
                                '<label for="lnick">' + Common._e("Address") + '</label>' + 
                                '<input type="text" class="nick" id="lnick" pattern="[^@/]+" required="" /><span class="jid">@</span><input type="text" class="server" id="lserver" value="' + HOST_MAIN + '" ' + lock_host + ' pattern="[^@/]+" required="" />' + 
                                '<label for="lpassword">' + Common._e("Password") + '</label>' + 
                                '<input type="password" class="password" id="lpassword" required="" />' + 
                                '<label for="lremember">' + Common._e("Remember me") + '</label>' + 
                                '<input type="checkbox" class="remember" id="lremember" />' + 
                            '</fieldset>' + 
                            
                            '<a href="#" class="advanced home-images">' + Common._e("Advanced") + '</a>' + 
                            
                            '<fieldset class="advanced">' + 
                                '<legend>' + Common._e("Advanced") + '</legend>' + 
                                
                                '<label for="lresource">' + Common._e("Resource") + '</label>' + 
                                '<input type="text" class="resource" id="lresource" value="' + JAPPIX_RESOURCE + '" />' + 
                                '<label for="lpriority">' + Common._e("Priority") + '</label>' + 
                                '<select class="priority" id="lpriority">' + 
                                    '<option value="1">' + Common._e("Low") + '</option>' + 
                                    '<option value="10" selected="">' + Common._e("Medium") + '</option>' + 
                                    '<option value="100">' + Common._e("High") + '</option>' + 
                                '</select>' + 
                            '</fieldset>' + 
                            
                            '<div class="submit">' + 
                                '<input type="submit" value="' + Common._e("Here we go!") + '" />' + 

                                '<div class="clear"></div>' + 
                            '</div>' + 
                        '</form>';
                    
                    break;
                
                // Anonymous login tool
                case 'anonymouser':
                    disable_form = Utils.disableInput(ANONYMOUS, 'off');
                    code = '<p>' + Common.printf(Common._e("Enter the groupchat you want to join and the nick you want to have. You can also go back to the %s."), '<a href="#" class="to-home">' + Common._e("login page") + '</a>') + '</p>';
                    
                    if(LEGAL)
                        code += '<p>' + Common.printf(Common._e("By using our service, you accept %s."), '<b><a href="' + Common.encodeQuotes(LEGAL) + '" target="_blank">' + Common._e("our terms of use") + '</a></b>') + '</p>';
                    
                    code += '<form action="#" method="post">' + 
                            '<fieldset>' + 
                                '<legend>' + Common._e("Required") + '</legend>' + 
                                
                                '<label>' + Common._e("Room") + '</label>' + 
                                '<input type="text" class="room"' + disable_form + ' pattern="[^/]+" required="" />' + 
                                
                                '<label>' + Common._e("Nickname") + '</label>' + 
                                '<input type="text" class="nick"' + disable_form + ' required="" />' + 
                            '</fieldset>' + 
                            
                            '<input type="submit" value="' + Common._e("Here we go!") + '"' + disable_form + ' />' + 
                        '</form>' + 
                        
                        '<div class="info report">' + 
                            Common._e("Share this link with your friends:") + ' <span></span>' + 
                        '</div>';
                    
                    break;
                
                // Register tool
                case 'registerer':
                    disable_form = Utils.disableInput(REGISTRATION, 'off');
                    
                    if(!disable_form)
                        lock_host = Utils.disableInput(LOCK_HOST, 'on');
                    
                    code = '<p>' + Common._e("Register a new XMPP account to join your friends on your own social cloud. That's simple!") + '</p>';
                    
                    if(LEGAL)
                        code += '<p>' + Common.printf(Common._e("By using our service, you accept %s."), '<b><a href="' + Common.encodeQuotes(LEGAL) + '" target="_blank">' + Common._e("our terms of use") + '</a></b>') + '</p>';
                    
                    code += '<form action="#" method="post">' + 
                            '<fieldset>' + 
                                '<legend>' + Common._e("Required") + '</legend>' + 
                                
                                '<label for="rnick">' + Common._e("Address") + '</label>' + 
                                '<input type="text" class="nick" id="rnick" ' + disable_form + ' pattern="[^@/]+" required="" placeholder="' + Common._e("Username") + '" /><span class="jid">@</span><input type="text" class="server" id="rserver" value="' + HOST_MAIN + '" ' + disable_form + lock_host + ' pattern="[^@/]+" required="" placeholder="' + Common._e("Server") + '" />' + 
                                '<label for="rpassword">' + Common._e("Password") + '</label>' + 
                                '<input type="password" class="password" id="rpassword" ' + disable_form + ' required="" placeholder="' + Common._e("Enter password") + '" /><input type="password" class="spassword" id="spassword" ' + disable_form + ' required="" placeholder="' + Common._e("Once again...") + '" />';
                    
                    if(REGISTER_API == 'on')
                        code += '<div class="captcha_grp">' + 
                                    '<label for="captcha">' + Common._e("Code") + '</label><input type="text" class="captcha" id="captcha" ' + disable_form + ' maxlength="6" pattern="[a-zA-Z0-9]{6}" required="" placeholder="' + Common._e("Security code") + '" /><img class="captcha_img" src="./server/captcha.php?id=' + genID() + '" alt="" />' + 
                                '</div>';
                    
                    code += '</fieldset>' + 
                            
                            '<input type="submit" value="' + Common._e("Here we go!") + '" ' + disable_form + '/>' + 
                        '</form>';
                    
                    break;
            }
            
            // Form disabled?
            if(disable_form)
                code += '<div class="info fail">' + 
                        Common._e("This tool has been disabled!") + 
                    '</div>';
            
            // Create this HTML code
            if(code && !Common.exists(current)) {
                // Append it!
                $(right + '.homediv.default').after('<div class="' + div + ' homediv">' + code + '</div>');
                
                // Create the attached events
                switch(div) {
                    // Login tool
                    case 'loginer':
                        $(current + ' a.to-anonymous').click(function() {
                            return self.change('anonymouser');
                        });
                        
                        $(current + ' a.advanced').click(self.showAdvanced);
                        $(current + ' form').submit(self.loginForm);
                        
                        break;
                    
                    // Anonymous login tool
                    case 'anonymouser':
                        $(current + ' a.to-home').click(function() {
                            return self.change('loginer');
                        });
                        
                        $(current + ' form').submit(Connection.doAnonymous);
                        
                        // Keyup event on anonymous join's room input
                        $(current + ' input.room').keyup(function() {
                            var value = $(this).val();
                            var report = current + ' .report';
                            var span = report + ' span';
                            
                            if(!value) {
                                $(report).hide();
                                $(span).text('');
                            }
                            
                            else {
                                $(report).show();
                                $(span).text(JAPPIX_LOCATION + '?r=' + value);
                            }
                        });
                        
                        break;
                    
                    // Register tool
                    case 'registerer':
                        // Server input change
                        $('#home input.server').keyup(function(e) {
                            if($.trim($(this).val()) == HOST_MAIN) {
                                $('#home .captcha_grp').show();
                                $('#home input.captcha').removeAttr('disabled');
                            } else {
                                $('#home .captcha_grp').hide();
                                $('#home input.captcha').attr('disabled', true);
                            }
                        });
                        
                        // Register input placeholder
                        // FIXME: breaks IE compatibility
                        //$('#home input[placeholder]').placeholder();
                        
                        // Register form submit
                        $(current + ' form').submit(self.registerForm);
                        
                        break;
                }
            }
            
            // We focus on the first input
            $(document).oneTime(10, function() {
                $(right + 'input:visible:first').focus();
            });
        } catch(e) {
            Console.error('Home.change', e);
        } finally {
            return false;
        }

    };


    /**
     * Allows the user to display the advanced login options
     * @public
     * @return {boolean}
     */
    self.showAdvanced = function() {

        try {
            // Hide the link
            $('#home a.advanced').hide();
            
            // Show the fieldset
            $('#home fieldset.advanced').show();
        } catch(e) {
            Console.error('Home.showAdvanced', e);
        } finally {
            return false;
        }

    };


    /**
     * Reads the login form values
     * @public
     * @return {boolean}
     */
    self.loginForm = function() {

        try {
            // We get the values
            var lPath = '#home .loginer ';
            var lServer = $(lPath + '.server').val();
            var lNick = Common.nodeprep($(lPath + '.nick').val());
            var lPass = $(lPath + '.password').val();
            var lResource = $(lPath + '.resource').val();
            var lPriority = $(lPath + '.priority').val();
            var lRemember = $(lPath + '.remember').filter(':checked').size();
            
            // Enough values?
            if(lServer && lNick && lPass && lResource && lPriority) {
                Connection.doLogin(lNick, lServer, lPass, lResource, lPriority, lRemember);
            } else {
                $(lPath + 'input[type="text"], ' + lPath + 'input[type="password"]').each(function() {
                    var select = $(this);
                    
                    if(!select.val())
                        $(document).oneTime(10, function() {
                            select.addClass('please-complete').focus();
                        });
                    else
                        select.removeClass('please-complete');  
                });
            }
        } catch(e) {
            Console.error('Home.loginForm', e);
        } finally {
            return false;
        }

    };


    /**
     * Reads the register form values
     * @public
     * @return {boolean}
     */
    self.registerForm = function() {

        try {
            var rPath = '#home .registerer ';
    
            // Remove the success info
            $(rPath + '.success').remove();
            
            // Get the values
            var username = Common.nodeprep($(rPath + '.nick').val());
            var domain = $(rPath + '.server').val();
            var pass = $(rPath + '.password').val();
            var spass = $(rPath + '.spassword').val();
            var captcha = $(rPath + '.captcha').val();
            
            // Enough values?
            if(domain && username && pass && spass && (pass == spass) && !((REGISTER_API == 'on') && (domain == HOST_MAIN) && !captcha)) {
                // We remove the not completed class to avoid problems
                $('#home .registerer input').removeClass('please-complete');
                
                // Fire the register event!
                Connection.doRegister(username, domain, pass, captcha);
            }
            
            // Something is missing?
            else {
                $(rPath + 'input[type="text"], ' + rPath + 'input[type="password"]').each(function() {
                    var select = $(this);
                    
                    if(!select.val() || (select.is('#spassword') && pass && (pass != spass)))
                        $(document).oneTime(10, function() {
                            select.addClass('please-complete').focus();
                        });
                    else
                        select.removeClass('please-complete');  
                });
            }
        } catch(e) {
            Console.error('Home.registerForm', e);
        } finally {
            return false;
        }

    };


    /**
     * Plugin launcher
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.launch = function() {

        try {
            $(document).ready(function() {
                // Define the vars
                var home = '#home ';
                var button = home + 'button';
                var corp = home + '.corporation';
                var aboutus = home + '.aboutus';
                var locale = home + '.locale';
                
                // Removes the <noscript /> elements to lighten the DOM
                $('noscript').remove();
                
                // Allows the user to switch the home page
                $(button).click(function() {
                    // Login button
                    if($(this).is('.login'))
                        return self.change('loginer');
                    
                    // Register button
                    else
                        return self.change('registerer');
                });
                
                // Allows the user to view the corporation & about infobox
                $(corp + ', ' + aboutus).hover(function() {
                    $(this).addClass('hovered');
                }, function() {
                    $(this).removeClass('hovered');
                });
                
                // Allows the user to switch the language
                $(locale).hover(function() {
                    // Initialize the HTML code
                    var keepget = $(locale).attr('data-keepget');
                    var html = '<div class="list">';
                    
                    // Generate each locale HTML code
                    for(var i in LOCALES_AVAILABLE_ID) {
                        html += '<a href="./?l=' + LOCALES_AVAILABLE_ID[i] + keepget + '">' + LOCALES_AVAILABLE_NAMES[i].htmlEnc() + '</a>';
                    }
                    
                    html += '</div>';
                    
                    // Append the HTML code
                    $(locale).append(html);
                }, function() {
                    $(locale + ' .list').remove();
                });
                
                // Disables the browser HTTP-requests stopper
                $(document).keydown(function(e) {
                    if((e.keyCode == 27) && !System.isDeveloper())
                        return false;
                });
                
                // Warns for an obsolete browser
                if(Utils.isObsolete()) {
                    // Add the code
                    $(locale).after(
                        '<div class="obsolete">' + 
                            '<p>' + Common._e("Your browser is out of date!") + '</p>' + 
                            
                            '<a class="firefox browsers-images" title="' + Common.printf(Common._e("Last %s version is better!"), 'Mozilla Firefox') + '" href="http://www.mozilla.com/firefox/"></a>' + 
                            '<a class="chrome browsers-images" title="' + Common.printf(Common._e("Last %s version is better!"), 'Google Chrome') + '" href="http://www.google.com/chrome"></a>' + 
                            '<a class="safari browsers-images" title="' + Common.printf(Common._e("Last %s version is better!"), 'Safari') + '" href="http://www.apple.com/safari/"></a>' + 
                            '<a class="opera browsers-images" title="' + Common.printf(Common._e("Last %s version is better!"), 'Opera') + '" href="http://www.opera.com/"></a>' + 
                            '<a class="ie browsers-images" title="' + Common.printf(Common._e("Last %s version is better!"), 'Internet Explorer') + '" href="http://www.microsoft.com/hk/windows/internet-explorer/"></a>' + 
                        '</div>'
                    );
                    
                    // Display it later
                    $(home + '.obsolete').oneTime('1s', function() {
                        $(this).slideDown();
                    });
                    
                    Console.warn('Jappix does not support this browser!');
                }
                
                Console.log('Welcome to Jappix! Happy coding in developer mode!');
            });
        } catch(e) {
            Console.error('Home.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Home.launch();
/*

Jappix - An open social platform
These are the talkpage JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Talk = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Creates the talkpage events
     * @public
     * @return {undefined}
     */
    self.events = function() {

        try {
            // Launch all associated bundles
            Microblog.instance();
            Roster.instance();
            Presence.instance();
            PEP.instance();
            Notification.instance();
            Music.instance();
        } catch(e) {
            Console.error('Talk.events', e);
        }

    };


    /**
     * Creates the talkpage code
     * @public
     * @return {boolean}
     */
    self.create = function() {

        try {
            // Talkpage exists?
            if(Common.exists('#talk'))
                return false;
            
            // Anonymous detector
            var anonymous = Utils.isAnonymous();
            
            // Generate the HTML code
            var html = 
            '<div id="talk" class="removable">' + 
                '<div id="top-content">' + 
                    '<div class="tools tools-logo talk-images"></div>' + 
                    
                    '<div class="tools tools-all">';
                        
                        if(!anonymous) html += 
                        '<a href="#" onclick="return Inbox.open();" class="inbox-hidable">' + Common._e("Messages") +  '</a>' + 
                        '<a href="#" onclick="return vCard.open();" class="vcard">' + Common._e("Profile") +  '</a>' + 
                        '<a href="#" onclick="return Options.open();" class="options-hidable">' + Common._e("Options") +  '</a>' + 
                        '<a href="#" onclick="return Connection.normalQuit();" class="quit">' + Common._e("Disconnect") +  '</a>';
                        
                        else html +=
                        '<a href="./">' + Common._e("Disconnect") +  '</a>';
                    
                    html +=
                    '</div>';
                    
                    if(!anonymous && document.createElement('audio').canPlayType) html += 
                    '<div class="tools-all ibubble">' + 
                        '<div class="tools music talk-images" onclick="return Music.open();"></div>' + 
                        
                        '<div class="music-content tools-content bubble hidable">' + 
                            '<div class="tools-content-subarrow talk-images"></div>' + 
                            
                            '<div class="tools-content-subitem">' + 
                                '<div class="player">' + 
                                    '<a href="#" class="stop talk-images" onclick="return Music.action(\'stop\');"></a>' + 
                                '</div>' + 
                                
                                '<div class="list">' + 
                                    '<p class="no-results">' + Common._e("No result!") +  '</p>' + 
                                '</div>' + 
                                
                                '<div class="search">' + 
                                    '<input type="text" />' + 
                                '</div>' + 
                            '</div>' + 
                        '</div>' + 
                    '</div>';
                    
                    if(!anonymous) html += 
                    '<div class="tools-all ibubble">' + 
                        '<div class="tools notifications talk-images" onclick="return Bubble.show(\'.notifications-content\');"></div>' + 
                        
                        '<div class="notifications-content tools-content bubble hidable">' + 
                            '<div class="tools-content-subarrow talk-images"></div>' + 
                            
                            '<div class="tools-content-subitem">' + 
                                '<a class="empty" href="#" onclick="return Notification.clear();">' + Common._e("Empty") +  '</a>' + 
                                '<p class="nothing">' + Common._e("No notifications.") +  '</p>' + 
                            '</div>' + 
                        '</div>' + 
                    '</div>';

                    if(!anonymous) html += 
                    '<div class="tools-all">' + 
                        '<div class="tools jingle talk-images" onclick="return Jingle.open();">' + 
                            '<span class="streaming-items">' + 
                                '<span class="counter" data-default="00:00:00">00:00:00</span>' + 
                                '<a class="stop" href="#" onclick="return Jingle.stop();">' + Common._e("Stop") + '</a>' + 
                            '</span>' + 
                        '</div>' + 

                        '<div class="jingle-content tools-content">' + 
                            '<div class="tools-content-subarrow talk-images"></div>' + 
                            
                            '<div class="tools-content-subitem"></div>' + 
                        '</div>' + 
                    '</div>';
                
                html +=
                '</div>' + 
                
                '<div id="main-content">' + 
                    '<div id="left-content">';
                        if(!anonymous) html += 
                        '<div id="roster">' + 
                            '<div class="content"></div>' + 
                            
                            '<div class="filter">' + 
                                '<input type="text" placeholder="' + Common._e("Filter") +  '" />' + 
                                '<a href="#">x</a>' + 
                            '</div>' + 
                            
                            '<div class="foot ibubble">' + 
                                '<div class="roster-add roster-icon">' + 
                                    '<a href="#" class="add talk-images" title="' + Common._e("Add a friend") +  '"></a>' + 
                                '</div>' + 
                                
                                '<div class="roster-join roster-icon">' + 
                                    '<a href="#" class="join talk-images" title="' + Common._e("Join a chat") +  '"></a>' + 
                                '</div>' + 
                                
                                '<div class="roster-groupchat roster-icon">' + 
                                    '<a href="#" class="groupchat talk-images" title="' + Common._e("Your groupchats") +  '"></a>' + 
                                '</div>' + 
                                
                                '<div class="roster-more roster-icon">' + 
                                    '<a href="#" class="more talk-images" title="' + Common._e("More stuff") +  '"></a>' + 
                                '</div>' + 
                                
                                '<div style="clear: both;"></div>' + 
                            '</div>' + 
                        '</div>';
                        
                        html +=
                        '<div id="my-infos">' + 
                            '<div class="content">' + 
                                '<div class="element f-presence ibubble">' + 
                                    '<a href="#" class="icon picker disabled" data-value="available">' + 
                                        '<span class="talk-images"></span>' + 
                                    '</a>' + 
                                    
                                    '<input id="presence-status" type="text" placeholder="' + Common._e("Status") + '" disabled="" />' + 
                                '</div>';
                                
                                if(!anonymous) html += 
                                '<div class="element f-mood pep-hidable ibubble">' + 
                                    '<a href="#" class="icon picker" data-value="happy">' + 
                                        '<span class="talk-images"></span>' + 
                                    '</a>' + 
                                    
                                    '<input id="mood-text" type="text" placeholder="' + Common._e("Mood") + '" />' + 
                                '</div>' + 
                                
                                '<div class="element f-activity pep-hidable ibubble">' + 
                                    '<a href="#" class="icon picker" data-value="exercising">' + 
                                        '<span class="talk-images activity-exercising"></span>' + 
                                    '</a>' + 
                                    
                                    '<input id="activity-text" type="text" placeholder="' + Common._e("Activity") + '" />' + 
                                '</div>';
                            
                            html +=
                            '</div>' + 
                        '</div>' + 
                    '</div>' + 
                    
                    '<div id="right-content">' + 
                        '<div id="page-switch">' + 
                            '<div class="chans">';
                                if(!anonymous) html += 
                                '<div class="channel switcher activechan" onclick="return Interface.switchChan(\'channel\');">' + 
                                    '<div class="icon talk-images"></div>' + 
                                
                                    '<div class="name">' + Common._e("Channel") +  '</div>' + 
                                '</div>';

                            html +=
                            '</div>';
                            
                            if(anonymous) html +=
                                '<div class="join ibubble">' + 
                                    '<div class="join-button talk-images" onclick="return Interface.loadJoinGroupchat();" title="' + Common._e("Join groupchat") +  '"></div>' + 
                                '</div>';

                            html +=
                            '<div class="more ibubble">' + 
                                '<div class="more-button talk-images" onclick="return Interface.loadChatSwitch();" title="' + Common._e("All tabs") +  '"></div>' + 
                            '</div>' + 
                        '</div>' + 
                        
                        '<div id="page-engine">';
                            if(!anonymous) html += 
                            '<div id="channel" class="page-engine-chan" style="display: block;">' + 
                                '<div class="top mixed ' + hex_md5(Common.getXID()) + '">' + 
                                    '<div class="avatar-container">' + 
                                        '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                                    '</div>' + 
                                    
                                    '<div class="update">' + 
                                        '<p>' + Common._e("What\'s up with you?") +  '</p>' + 
                                        
                                        '<div class="microblog-body">' + 
                                            '<input class="focusable" type="text" name="microblog_body" placeholder="' + Common._e("Type something you want to share with your friends...") + '" disabled="" />' + 
                                        '</div>' + 
                                        
                                        '<div class="one-microblog-icon ibubble">' + 
                                            '<a href="#" onclick="return Bubble.show(\'#attach\');" title="' + Common._e("Attach a file") +  '" class="postit attach talk-images"></a>' + 
                                            
                                            '<form id="attach" class="bubble hidable" action="./server/file-share.php" method="post" enctype="multipart/form-data">' + 
                                                '<div class="attach-subarrow talk-images"></div>' + 
                                                
                                                '<div class="attach-subitem">' + 
                                                    '<p class="attach-p">' + Common._e("Attach a file") +  '</p>' + 
                                                    Interface.generateFileShare() + 
                                                '</div>' + 
                                            '</form>' + 
                                        '</div>' + 
                                    '</div>' + 
                                '</div>' + 
                                
                                '<div class="content mixed"></div>' + 
                                
                                '<div class="footer">' + 
                                    '<div class="sync talk-images">' + Common._e("You are synchronized with your network.") +  '</div>' + 
                                    
                                    '<div class="unsync talk-images">' + Common._e("Cannot send anything: you can only receive notices!") +  '</div>' + 
                                    
                                    '<div class="fetch wait-small">' + Common._e("Fetching the social channel...") +  '</div>' + 
                                '</div>' + 
                            '</div>';
                        
                        html +=
                        '</div>' + 
                    '</div>' + 
                '</div>' + 
            '</div>';
            
            // Create the HTML code
            $('body').prepend(html);
            
            // Adapt the roster size
            Roster.adapt();
            
            // Create JS events
            self.events();
            
            // Start the auto idle functions
            Presence.liveIdle();
            
            return true;
        } catch(e) {
            Console.error('Talk.create', e);
        }

    };


    /**
     * Destroys the talkpage code
     * @public
     * @return {undefined}
     */
    self.destroy = function() {

        try {
            // Reset our database
            DataStore.resetDB();
            
            // Reset some vars
            STANZA_ID = 1;
            Roster.blist_all = false;
            Presence.first_sent = false;
            Search.search_filtered = false;
            Avatar.pending = [];
            JOIN_SUGGEST = [];
            
            // Kill all timers, exept the board ones
            $('*:not(#board .one-board)').stopTime();
            
            // Kill the auto idle functions
            Presence.dieIdle();
            
            // We renitalise the html markup as its initiale look
            $('.removable').remove();
            Interface.title('home');
            
            // Finally we show the homepage
            $('#home').show();
        } catch(e) {
            Console.error('Talk.destroy', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the popup JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Popup = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Creates a popup code
     * @public
     * @param {string} id
     * @param {string} content
     * @return {boolean}
     */
    self.create = function(id, content) {

        try {
            // Popup exists?
            if(Common.exists('#' + id)) {
                return false;
            }
            
            // Popop on top of another one?
            var top_of = Common.exists('div.lock:has(div.popup)');
            
            // Append the popup code
            $('body').append(
                '<div id="' + id + '" class="lock removable">' + 
                    '<div class="popup">' + 
                        content + 
                    '</div>' + 
                '</div>'
            );
            
            // Avoids darker popup background (if on top of another popup)
            if(top_of) {
                $('#' + id).css('background', 'transparent');
            }
            
            // Attach popup events
            self.instance(id);
            
            return true;
        } catch(e) {
            Console.error('Popup.create', e);
        }

    };


    /**
     * Destroys a popup code
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.destroy = function(id) {

        try {
            // Stop the popup timers
            $('#' + id + ' *').stopTime();
            
            // Remove the popup
            $('#' + id).remove();
            
            // Manage input focus
            Interface.inputFocus();
        } catch(e) {
            Console.error('Popup.destroy', e);
        }

    };


    /**
     * Attaches popup events
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.instance = function(id) {

        try {
            // Click events
            $('#' + id).click(function(evt) {
                // Click on lock background?
                if($(evt.target).is('.lock:not(.unavoidable)')) {
                    // Destroy the popup
                    self.destroy(id);
                    
                    return false;
                }
            });
        } catch(e) {
            Console.error('Popup.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the audio JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Audio = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self._timeout_stop = false;


    /**
     * Returns whether browser supports audio or not
     * @private
     * @return {boolean}
     */
    self._is_supported = function() {

        is_supported = true;

        try {
            if((BrowserDetect.browser == 'Explorer') && (BrowserDetect.version < 9)) {
                is_supported = false;
            }
        } catch(e) {
            Console.error('Audio._is_supported', e);
        } finally {
            return is_supported;
        }

    };


    /**
     * Plays the given sound ID
     * @public
     * @param {string} name
     * @return {boolean}
     */
    self.play = function(name, repeat) {

        try {
            repeat = (typeof repeat === 'boolean') ? repeat : false;

            // Not supported?
            if(!self._is_supported()) {
                return false;
            }
            
            // If the sounds are enabled
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'sounds') === '1') {
                // If the audio elements aren't yet in the DOM
                if(!Common.exists('#audio')) {
                    $('body').append(
                        '<div id="audio">' + 
                            '<audio id="new-chat" preload="auto" data-duration="2">' + 
                                '<source src="' + './sounds/new-chat.mp3' + '" />' + 
                                '<source src="' + './sounds/new-chat.oga' + '" />' + 
                            '</audio>' + 
                            
                            '<audio id="receive-message" preload="auto" data-duration="2">' + 
                                '<source src="' + './sounds/receive-message.mp3' + '" />' + 
                                '<source src="' + './sounds/receive-message.oga' + '" />' + 
                            '</audio>' + 
                            
                            '<audio id="notification" preload="auto" data-duration="2">' + 
                                '<source src="' + './sounds/notification.mp3' + '" />' + 
                                '<source src="' + './sounds/notification.oga' + '" />' + 
                            '</audio>' + 
                            
                            '<audio id="incoming-call" preload="auto" data-duration="7">' + 
                                '<source src="' + './sounds/incoming-call.mp3' + '" />' + 
                                '<source src="' + './sounds/incoming-call.oga' + '" />' + 
                            '</audio>' + 
                            
                            '<audio id="outgoing-call" preload="auto" data-duration="30">' + 
                                '<source src="' + './sounds/outgoing-call.mp3' + '" />' + 
                                '<source src="' + './sounds/outgoing-call.oga' + '" />' + 
                            '</audio>' + 
                        '</div>'
                    );
                }
                
                // We play the target sound
                var audio_raw_sel = $('#audio audio').filter('#' + name);
                var audio_sel = audio_raw_sel[0];

                if(audio_sel) {
                    // Fixes Chrome audio bug when Get API serves expired files (for development work purposes)
                    if(window.chrome && System.isDeveloper()) {
                        audio_sel.load();
                    }

                    // Must repeat sound?
                    if(repeat === true) {
                        // We hardcoded sound duration as it's a mess to add load event handlers to determine duration via Audio API...
                        var duration = parseInt((audio_raw_sel.attr('data-duration') || 0), 10);

                        self._timeout_stop = false;
                        
                        audio_raw_sel.oneTime((duration + 's'), function() {
                            if(!self._timeout_stop) {
                                self.play(name, repeat);
                            }
                        });
                    }

                    audio_sel.play();

                    Console.info('Played sound with name: ' + name + ' (' + (repeat ? 'repeatedly' : 'one time') + ')');
                } else {
                    throw 'Sound does not exist: ' + name;
                }
            }
        } catch(e) {
            Console.error('Audio.play', e);
        } finally {
            return false;
        }

    };


    /**
     * Stops the given sound ID
     * @public
     * @param {string} name
     * @return {boolean}
     */
    self.stop = function(name) {

        try {
            // Not supported?
            if(!self._is_supported()) {
                return false;
            }
            
            self._timeout_stop = true;

            // Check the audio container exists before doing anything...
            var audio_parent_sel = $('#audio');
            var audio_raw_sel = audio_parent_sel.find('audio').filter('#' + name);
            var audio_sel = audio_raw_sel[0];

            if(audio_parent_sel.size()) {
                audio_raw_sel.stopTime();
                
                if(audio_sel) {
                    if(!audio_sel.paused) {
                        audio_sel.pause();

                        Console.info('Stopped sound with name: ' + name);
                    } else {
                        Console.info('Sound with name: ' + name + ' already stopped');
                    }
                } else {
                    throw 'Sound does not exist: ' + name;
                }
            } else {
                Console.warn('Audio container does not exist, aborting as nothing likely to be playing! (already stopped)');
            }
        } catch(e) {
            Console.error('Audio.stop', e);
        } finally {
            return false;
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the notification board JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var Board = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Creates a board panel
     * @public
     * @param {string} type
     * @param {string} id
     * @return {boolean}
     */
    self.create = function(type, id) {

        try {
            // Text var
            var text = '';
            
            // Info
            if(type == 'info') {
                switch(id) {
                    // Password change
                    case 1:
                        text = Common._e("Your password has been changed, now you can connect to your account with your new login data.");
                        
                        break;
                    
                    // Account deletion
                    case 2:
                        text = Common._e("Your XMPP account has been removed, bye!");
                        
                        break;
                    
                    // Account logout
                    case 3:
                        text = Common._e("You have been logged out of your XMPP account, have a nice day!");
                        
                        break;
                    
                    // Groupchat join
                    case 4:
                        text = Common._e("The room you tried to join doesn't seem to exist.");
                        
                        break;
                    
                    // Groupchat removal
                    case 5:
                        text = Common._e("The groupchat has been removed.");
                        
                        break;
                    
                    // Non-existant groupchat user
                    case 6:
                        text = Common._e("The user that you want to reach is not present in the room.");
                        
                        break;
                }
            }
            
            // Error
            else {
                switch(id) {
                    // Custom error
                    case 1:
                        text = '<b>' + Common._e("Error") + '</b> &raquo; <span></span>';
                        
                        break;
                    
                    // Network error
                    case 2:
                        text = Common._e("Jappix has been interrupted by a network issue, a bug or bad login (check that you entered the right credentials), sorry for the inconvenience.");
                        
                        break;
                    
                    // List retrieving error
                    case 3:
                        text = Common._e("The element list on this server could not be obtained!");
                        
                        break;
                    
                    // Attaching error
                    case 4:
                        text = Common.printf(Common._e("An error occured while uploading your file: maybe it is too big (%s maximum) or forbidden!"), JAPPIX_MAX_UPLOAD);
                        
                        break;
                }
            }
            
            // No text?
            if(!text)
                return false;
            
            // Append the content
            $('#board').append('<div class="one-board ' + type + '" data-id="' + id + '">' + text + '</div>');
            
            // Events (click and auto-hide)
            $('#board .one-board.' + type + '[data-id="' + id + '"]')
            
            .click(function() {
                self.closeThis(this);
            })
            
            .oneTime('5s', function() {
                self.closeThis(this);
            })
            
            .slideDown();
            
            return true;
        } catch(e) {
            Console.error('Board.create', e);
        }

    };


    /**
     * Destroys the existing board notifications
     * @public
     * @return {undefined}
     */
    self.destroy = function() {

        try {
            $('#board').empty();
        } catch(e) {
            Console.error('Board.destroy', e);
        }

    };


    /**
     * Executes a given action on the notification board
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.action = function(id, type) {

        try {
            // In a first, we destroy other boards
            self.destroy();
            
            // Then we display the board
            self.create(type, id);
        } catch(e) {
            Console.error('Board.action', e);
        }

    };


    /**
     * Opens a given error ID
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.openThisError = function(id) {

        try {
            self.action(id, 'error');
        } catch(e) {
            Console.error('Board.openThisError', e);
        }

    };


    /**
     * Opens a given info ID
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.openThisInfo = function(id) {

        try {
            self.action(id, 'info');
        } catch(e) {
            Console.error('Board.openThisInfo', e);
        }

    };


    /**
     * Closes a given board
     * @public
     * @param {string} board
     * @return {undefined}
     */
    self.closeThis = function(board) {

        try {
            $(board).slideUp('normal', function() {
                $(this).remove();
            });
        } catch(e) {
            Console.error('Board.closeThis', e);
        }

    };


    /**
     * Creates a quick board (HTML5 notification)
     * @public
     * @param {string} xid
     * @param {string} type
     * @param {string} content
     * @param {string} title
     * @param {string} icon
     * @return {object}
     */
    self.quick = function(xid, type, content, title, icon) {

        try {
            // Cannot process?
            if(Common.isFocused() || !content || !(window.webkitNotifications || window.Notification)) {
                return;
            }
            
            // Default icon?
            if(!icon) {
                icon = './images/others/default-avatar.png';
                
                // Avatar icon?
                if(xid) {
                    var avatar_xml = Common.XMLFromString(
                        DataStore.getPersistent('global', 'avatar', xid)
                    );
                    var avatar_type = $(avatar_xml).find('type').text() || 'image/png';
                    var avatar_binval = $(avatar_xml).find('binval').text();
                    
                    if(avatar_binval && avatar_type)
                        icon = 'data:' + avatar_type + ';base64,' + avatar_binval;
                }
            }
            
            // Default title?
            if(!title) {
                title = Common._e("New event!");
            }

            // Click callback
            var cb_click_fn = function() {
                // Click action?
                switch(type) {
                    case 'chat':
                        Interface.switchChan(hex_md5(xid));
                        break;
                    
                    case 'groupchat':
                        Interface.switchChan(hex_md5(Common.bareXID(xid)));
                        break;
                    
                    default:
                        break;
                }
                
                // Focus on msg-me
                window.focus();
                
                // Remove notification
                this.cancel();
            };
            
            // Check for notification permission
            try {
                if(Notification.permission == 'granted' || Notification.permission === undefined) {
                    var notification = new Notification(title, {
                        dir: 'auto',
                        lang: '',
                        body: content,
                        tag: type,
                        icon: icon
                    });

                    notification.onclick = cb_click_fn;

                    setTimeout(function() {
                        notification.close();
                    }, 10000);

                    if(notification.permission == 'granted') {
                        return notification;
                    }
                }
            } catch(_e) {
                if(window.webkitNotifications.checkPermission() === 0) {
                    // Create notification
                    var notification = window.webkitNotifications.createNotification(icon, title, content);
                    
                    // Auto-hide after a while
                    notification.ondisplay = function(event) {
                        setTimeout(function() {
                            event.currentTarget.cancel();
                        }, 10000);
                    };
                    
                    // Click event
                    notification.onclick = cb_click_fn;
                    
                    // Show notification
                    notification.show();
                    
                    return notification;
                }
            }

            return null;
        } catch(e) {
            Console.error('Board.quick', e);
        }

    };


    /**
     * Asks for permission to show quick boards (HTML5 notification)
     * @public
     * @return {undefined}
     */
    self.quickPermission = function() {

        try {
            try {
                // W3C Notification API (still a draft!)
                if(Notification.permission !== 'granted') {
                    // Ask for permission
                    Notification.requestPermission();
                }
            } catch (_e) {
                // WebKit Notification API (fallback)
                if(!window.webkitNotifications || (window.webkitNotifications.checkPermission() === 0)) {
                    return;
                }
                
                // Ask for permission
                window.webkitNotifications.requestPermission();
            }
        } catch(e) {
            Console.error('Board.quickPermission', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            // Fires quickPermission() on document click
            $(document).click(function() {
                // Ask for permission to use quick boards
                if((typeof con != 'undefined') && con.connected())
                    self.quickPermission();
            });
        } catch(e) {
            Console.error('Board.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Board.launch();
/*

Jappix - An open social platform
These are the bubble JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Bubble = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Closes all the opened bubbles
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy all the elements
            $('.bubble.hidable:visible').hide();
            $('.bubble.removable').remove();
            $('body').off('click');
        } catch(e) {
            Console.error('Bubble.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Click function when a bubble is opened
     * @public
     * @param {object} selector
     * @return {boolean}
     */
    self.show = function(selector) {

        try {
            // Hidable bubbles special things
            if($(selector).is('.hidable')) {
                // This bubble is yet displayed? So abort!
                if($(selector).is(':visible'))
                    return self.close();
                
                // Close all the bubbles
                self.close();
                
                // Show the requested bubble
                $(selector).show();
            }
            
            // Removable bubbles special things
            else {
                // This bubble is yet added? So abort!
                if(Common.exists(selector))
                    return self.close();
                
                // Close all the bubbles
                self.close();
            }
            
            // Creates a new click event to close the bubble
            $('body').on('click', function(evt) {
                var target = evt.target;
                
                // If this is a click away from a bubble
                if(!$(target).parents('.ibubble').size())
                    self.close();
            });
        } catch(e) {
            Console.error('Bubble.show', e);
        } finally {
            return false;
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the chat JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Eric, Maranda

*/

// Bundle
var Chat = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Correctly opens a new chat
     * @public
     * @param {string} xid
     * @param {string} type
     * @param {string} nickname
     * @param {string} password
     * @param {string} title
     * @return {boolean}
     */
    self.checkCreate = function(xid, type, nickname, password, title) {

        try {
            // No XID?
            if(!xid)
                return false;
            
            // We generate some stuffs
            var hash = hex_md5(xid);
            var name;
            
            // Gets the name of the user/title of the room
            if(title)
                name = title;
            
            else {
                // Private groupchat chat
                if(type == 'private')
                    name = Common.thisResource(xid);
                
                // XMPP-ID
                else if(xid.indexOf('@') != -1)
                    name = Name.getBuddy(xid);
                
                // Gateway
                else
                    name = xid;
            }
            
            // If the target div does not exist
            if(!Common.exists('#' + hash)) {
                // We check the type of the chat to open
                if((type == 'chat') || (type == 'private'))
                    self.create(hash, xid, name, type);
                
                else if(type == 'groupchat') {
                    // Try to read the room stored configuration
                    if(!Utils.isAnonymous() && (!nickname || !password || !title)) {
                        // Catch the room data
                        var fData = $(Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'favorites', xid)));
                        var fNick = fData.find('nick').text();
                        var fPwd = fData.find('password').text();
                        var fName = fData.find('name').text();
                        
                        // Apply the room data
                        if(!nickname && fNick)
                            nickname = fNick;
                        if(!password && fPwd)
                            password = fPwd;
                        if(!title && fName)
                            name = fName;
                    }
                    
                    Groupchat.create(hash, xid, name, nickname, password);
                }
            }
            
            // Switch to the newly-created chat
            Interface.switchChan(hash);
        } catch(e) {
            Console.error('Chat.checkCreate', e);
        } finally {
            return false;
        }

    };


    /**
     * Generates the chat DOM elements
     * @public
     * @param {string} type
     * @param {string} id
     * @param {string} xid
     * @param {string} nick
     * @return {undefined}
     */
    self.generate = function(type, id, xid, nick) {

        try {
            // Generate some stuffs
            var path = '#' + id + ' .';
            var escaped_xid = escape(xid);
            
            // Special code
            var specialAttributes, specialAvatar, specialName, specialCode, specialLink, specialDisabled, specialStyle, specialMAM;
            
            // Groupchat special code
            if(type == 'groupchat') {
                specialAttributes = ' data-type="groupchat"';
                specialAvatar = '';
                specialName = '<p class="bc-infos"><b>' + Common._e("Subject") + '</b> <span class="muc-topic">' + Common._e("no subject defined for this room.") + '</span></p>';
                specialCode = '<div class="content groupchat-content" id="chat-content-' + id + '"></div><div class="list"><div class="moderator role"><p class="title">' + Common._e("Moderators") + '</p></div><div class="participant role"><p class="title">' + Common._e("Participants") + '</p></div><div class="visitor role"><p class="title">' + Common._e("Visitors") + '</p></div><div class="none role"><p class="title">' + Common._e("Others") + '</p></div></div>';
                specialLink = '<a href="#" class="tools-mucadmin tools-tooltip talk-images chat-tools-content" title="' + Common._e("Administration panel for this room") + '"></a>';
                specialStyle = '';
                
                // Is this a gateway?
                if(xid.match(/%/))
                    specialDisabled = '';
                else
                    specialDisabled = ' disabled=""';
            }
            
            // Chat (or other things?!) special code
            else {
                specialMAM = '<div class="wait-mam wait-small"></div>';
                specialAttributes = ' data-type="chat"';
                specialAvatar = '<div class="avatar-container"><img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" /></div>';
                specialName = '<div class="bc-pep"></div><p class="bc-infos"><span class="unavailable show talk-images"></span></p>';
                specialCode = '<div class="content" id="chat-content-' + id + '">' + specialMAM + '</div>';
                specialLink = '<a href="#" class="tools-jingle-audio tools-tooltip talk-images chat-tools-content" title="' + Common._e("Call (audio only)") + '"></a>' + 
                              '<a href="#" class="tools-jingle-video tools-tooltip talk-images chat-tools-content" title="' + Common._e("Call (video)") + '"></a>' + 
                              '<a href="#" class="tools-infos tools-tooltip talk-images chat-tools-content" title="' + Common._e("Show user profile") + '"></a>';
                specialStyle = ' style="display: none;"';
                specialDisabled = '';
            }
            
            // Not a groupchat private chat, we can use the buddy add icon
            if((type == 'chat') || (type == 'groupchat')) {
                var addTitle;
                
                if(type == 'chat')
                    addTitle = Common._e("Add this contact to your friends");
                else
                    addTitle = Common._e("Add this groupchat to your favorites");
                
                specialLink += '<a href="#" class="tools-add tools-tooltip talk-images chat-tools-content" title="' + addTitle + '"></a>';
            }
            
            // IE DOM parsing bug fix
            var specialStylePicker = '<div class="chat-tools-content chat-tools-style"' + specialStyle + '>' + 
                            '<a href="#" class="tools-style tools-tooltip talk-images"></a>' + 
                         '</div>';
            
            if((BrowserDetect.browser == 'Explorer') && (BrowserDetect.version < 9))
                specialStylePicker = '';
            
            // Append the chat HTML code
            $('#page-engine').append(
                '<div id="' + id + '" class="page-engine-chan chat one-counter"' + specialAttributes + ' data-xid="' + escaped_xid + '">' + 
                    '<div class="top ' + id + '">' + 
                        specialAvatar + 
                        
                        '<div class="name">' + 
                            '<p class="bc-name bc-name-nick">' + nick.htmlEnc() + '</p>' + 
                            specialName + 
                        '</div>' + 
                    '</div>' + 
                    
                    specialCode + 
                    
                    '<div class="text">' + 
                        '<div class="footer">' + 
                            '<div class="chat-tools-content chat-tools-smileys">' + 
                                '<a href="#" class="tools-smileys tools-tooltip talk-images"></a>' + 
                            '</div>' + 
                            
                            specialStylePicker + 
                            
                            '<div class="chat-tools-content chat-tools-file">' + 
                                '<a href="#" class="tools-file tools-tooltip talk-images"></a>' + 
                            '</div>' + 
                            
                            '<div class="chat-tools-content chat-tools-save">' + 
                                '<a href="#" class="tools-save tools-tooltip talk-images"></a>' + 
                            '</div>' + 
                            
                            '<a href="#" class="tools-clear tools-tooltip talk-images chat-tools-content" title="' + Common._e("Clean current chat") + '"></a>' + 
                            
                            specialLink + 
                        '</div>' + 
                        
                        '<div class="compose">' + 
                            '<textarea class="message-area focusable" ' + specialDisabled + ' data-to="' + escaped_xid + '" /></textarea>' + 
                        '</div>' + 
                    '</div>' + 
                '</div>'
            );
            
            // Click event: chat cleaner
            $(path + 'tools-clear').click(function() {
                self.clean(id);
            });

            // Click event: call (audio)
            $(path + 'tools-jingle-audio').click(function() {
                Jingle.start(xid, 'audio');
            });

            // Click event: call (video)
            $(path + 'tools-jingle-video').click(function() {
                Jingle.start(xid, 'video');
            });
            
            // Click event: user-infos
            $(path + 'tools-infos').click(function() {
                UserInfos.open(xid);
            });
        } catch(e) {
            Console.error('Chat.generate', e);
        }

    };


    /**
     * Generates the chat switch elements
     * @public
     * @param {string} type
     * @param {string} id
     * @param {string} xid
     * @param {string} nick
     * @return {undefined}
     */
    self.generateSwitch = function(type, id, xid, nick) {

        try {
            // Path to the element
            var chat_switch = '#page-switch .';
            
            // Special code
            var specialClass = ' unavailable';
            var show_close = true;
            
            // Groupchat
            if(type == 'groupchat') {
                specialClass = ' groupchat-default';
                
                if(Utils.isAnonymous() && (xid == Common.generateXID(ANONYMOUS_ROOM, 'groupchat')))
                    show_close = false;
            }
            
            // Generate the HTML code
            var html = '<div class="' + id + ' switcher chan" onclick="return Interface.switchChan(\'' + Utils.encodeOnclick(id) + '\')">' + 
                    '<div class="icon talk-images' + specialClass + '"></div>' + 
                    
                    '<div class="name">' + nick.htmlEnc() + '</div>';
            
            // Show the close button if not MUC and not anonymous
            if(show_close)
                html += '<div class="exit" title="' + Common._e("Close this tab") + '" onclick="return Interface.quitThisChat(\'' + Utils.encodeOnclick(xid) + '\', \'' + Utils.encodeOnclick(id) + '\', \'' + Utils.encodeOnclick(type) + '\');">x</div>';
            
            // Close the HTML
            html += '</div>';
            
            // Append the HTML code
            $(chat_switch + 'chans, ' + chat_switch + 'more-content').append(html);
        } catch(e) {
            Console.error('Chat.generateSwitch', e);
        }

    };


    /**
     * Cleans given the chat lines
     * @public
     * @param {string} chat
     * @return {undefined}
     */
    self.clean = function(chat) {

        try {
            // Remove the messages
            $('#page-engine #' + chat + ' .content .one-group').remove();
            
            // Clear the history database
            Message.removeLocalArchive(chat);
            
            // Focus again
            $(document).oneTime(10, function() {
                $('#page-engine #' + chat + ' .text .message-area').focus();
            });
        } catch(e) {
            Console.error('Chat.clean', e);
        }

    };


    /**
     * Returns whether chat exists or not
     * @public
     * @param {string} hash
     * @return {boolean}
     */
    self.exists = function(hash) {

        exists = false;

        try {
            if(hash) {
                exists = Common.exists('#' + hash + '.page-engine-chan[data-type="chat"]');
            }
        } catch(e) {
            Console.error('Chat.exists', e);
        } finally {
            return exists;
        }

    };


    /**
     * Creates a new chat
     * @public
     * @param {string} hash
     * @param {string} xid
     * @param {string} nick
     * @param {string} type
     * @return {undefined}
     */
    self.create = function(hash, xid, nick, type) {

        try {
            Console.info('New chat: ' + xid);
            
            // Create the chat content
            self.generate(type, hash, xid, nick);
            
            // Create the chat switcher
            self.generateSwitch(type, hash, xid, nick);
            
            // If the user is not in our roster
            if(type == 'chat') {
                // MAM? Get archives from there!
                if(Features.enabledMAM()) {
                    MAM.getArchives({
                        'with': xid
                    }, {
                        'max': MAM.REQ_MAX,
                        'before': ''
                    });
                } else {
                    // Restore the chat history
                    var chat_history = Message.readLocalArchive(hash);
                    
                    if(chat_history) {
                        // Generate hashs
                        var my_hash = hex_md5(Common.getXID());
                        var friend_hash = hex_md5(xid);
                        
                        // Add chat history HTML
                        $('#' + hash + ' .content').append(chat_history);
                        
                        // Filter old groups & messages
                        $('#' + hash + ' .one-group[data-type="user-message"]').addClass('from-history').attr('data-type', 'old-message');
                        $('#' + hash + ' .user-message').removeClass('user-message').addClass('old-message');
                        
                        // Regenerate user names
                        $('#' + hash + ' .one-group.' + my_hash + ' b.name').text(Name.getBuddy(Common.getXID()));
                        $('#' + hash + ' .one-group.' + friend_hash + ' b.name').text(Name.getBuddy(xid));
                        
                        // Regenerate group dates
                        $('#' + hash + ' .one-group').each(function() {
                            var current_stamp = parseInt($(this).attr('data-stamp'));
                            $(this).find('span.date').text(DateUtils.relative(current_stamp));
                        });
                        
                        // Regenerate avatars
                        if(Common.exists('#' + hash + ' .one-group.' + my_hash + ' .avatar-container'))
                            Avatar.get(Common.getXID(), 'cache', 'true', 'forget');
                        if(Common.exists('#' + hash + ' .one-group.' + friend_hash + ' .avatar-container'))
                            Avatar.get(xid, 'cache', 'true', 'forget');
                    }
                }

                // Add button
                if(!Roster.isFriend(xid))
                    $('#' + hash + ' .tools-add').click(function() {
                        // Hide the icon (to tell the user all is okay)
                        $(this).hide();
                        
                        // Send the subscribe request
                        Roster.addThisContact(xid, nick);
                    }).show();
            }
            
            // We catch the user's informations (like this avatar, vcard, and so on...)
            UserInfos.get(hash, xid, nick, type);
            
            // The icons-hover functions
            Tooltip.icons(xid, hash);
            
            // The event handlers
            var inputDetect = $('#page-engine #' + hash + ' .message-area');
            
            inputDetect.focus(function() {
                // Clean notifications for this chat
                Interface.chanCleanNotify(hash);
                
                // Store focus on this chat!
                Interface.chat_focus_hash = hash;
            });
            
            inputDetect.blur(function() {
                // Reset storage about focus on this chat!
                if(Interface.chat_focus_hash == hash)
                    Interface.chat_focus_hash = null;
            });
            
            inputDetect.keypress(function(e) {
                // Enter key
                if(e.keyCode == 13) {
                    // Add a new line
                    if(e.shiftKey || e.ctrlKey) {
                        inputDetect.val(inputDetect.val() + '\n');
                    } else {
                        // Send the message
                        Message.send(hash, 'chat');
                        
                        // Reset the composing database entry
                        DataStore.setDB(Connection.desktop_hash, 'chatstate', xid, 'off');
                    }
                    
                    return false;
                }
            });

            // Scroll in chat content
            $('#page-engine #' + hash + ' .content').scroll(function() {
                var self = this;

                if(Features.enabledMAM() && !(xid in MAM.map_pending)) {
                    var has_state = xid in MAM.map_states;
                    var rsm_count = has_state ? MAM.map_states[xid].rsm.count : 1;
                    var rsm_before = has_state ? MAM.map_states[xid].rsm.first : '';

                    // Request more archives?
                    if(rsm_count > 0 && $(this).scrollTop() < MAM.SCROLL_THRESHOLD) {
                        var was_scroll_top = $(self).scrollTop() <= 32;
                        var wait_mam = $('#' + hash).find('.wait-mam');
                        wait_mam.show();

                        MAM.getArchives({
                            'with': xid
                        }, {
                            'max': MAM.REQ_MAX,
                            'before': rsm_before
                        }, function() {
                            var wait_mam_height = was_scroll_top ? 0 : wait_mam.height();
                            wait_mam.hide();

                            // Restore scroll?
                            if($(self).scrollTop() < MAM.SCROLL_THRESHOLD) {
                                var sel_mam_chunk = $(self).find('.mam-chunk:first');

                                var cont_padding_top = parseInt($(self).css('padding-top').replace(/[^-\d\.]/g, ''));
                                var cont_one_group_margin_bottom = parseInt(sel_mam_chunk.find('.one-group:last').css('margin-bottom').replace(/[^-\d\.]/g, ''));
                                var cont_mam_chunk_height = sel_mam_chunk.height();

                                $(self).scrollTop(wait_mam_height + cont_padding_top + cont_one_group_margin_bottom + cont_mam_chunk_height);
                            }
                        });
                    }
                }
            });
            
            // Chatstate events
            ChatState.events(inputDetect, xid, hash, 'chat');
        } catch(e) {
            Console.error('Chat.create', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the groupchat JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda, Eric

*/

// Bundle
var Groupchat = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    var JOIN_SUGGEST = [];


    /**
     * Displays the MUC admin elements
     * @public
     * @param {string} affiliation
     * @param {string} id
     * @param {string} xid
     * @param {number} statuscode
     * @return {undefined}
     */
    self.openAdmin = function(affiliation, id, xid, statuscode) {

        try {
            // We must be in the "login" mode
            if(Utils.isAnonymous())
                return;
            
            // We check if the user is a room owner or administrator to give him privileges
            if(affiliation == 'owner' || affiliation == 'admin')
                $('#' + id + ' .tools-mucadmin').show();
            
            // We check if the room hasn't been yet created
            if(statuscode == 201)
                Board.openThisInfo(4);
            
            // We add the click event
            $('#' + id + ' .tools-mucadmin').click(function() {
                MUCAdmin.open(xid, affiliation);
            });
        } catch(e) {
            Console.error('Groupchat.openAdmin', e);
        }

    };


    /**
     * Initializes a connection with a MUC groupchat
     * @public
     * @param {string} room
     * @param {string} nickname
     * @param {string} password
     * @return {boolean}
     */
    self.getMUC = function(room, nickname, password) {

        try {
            // Room hash
            var hash = hex_md5(room);
            
            // Reset the elements
            $('#' + hash + ' .muc-ask').remove();
            $('#' + hash + ' .compose').show();
            
            // No nickname?
            if(!nickname) {
                // Get some values
                if(!Utils.isAnonymous())
                    nickname = Name.getNick();
                else
                    nickname = ANONYMOUS_NICK;
                
                // If the nickname could not be retrieved, ask it
                if(!nickname)
                    self.generateMUCAsk('nickname', room, hash, nickname, password);
            }
            
            // Got our nickname?
            if(nickname) {
                // Get our general presence
                var show = DataStore.getDB(Connection.desktop_hash, 'presence-show', 1);
                var status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
            
                // Set my nick
                $('#' + hash).attr('data-nick', escape(nickname));
            
                // Send the appropriate presence
                Presence.send(room + '/' + nickname, '', show, status, '', true, password, self.handleMUC);
            }
        } catch(e) {
            Console.error('Groupchat.getMUC', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the MUC main elements
     * @public
     * @param {object} presence
     * @return {undefined}
     */
    self.handleMUC = function(presence) {

        try {
            // We get the xml content
            var xml = presence.getNode();
            var from = Common.fullXID(Common.getStanzaFrom(presence));
            var room = Common.bareXID(from);
            var nickname = Common.thisResource(from);
            var hash = hex_md5(room);
            
            // No ID: must fix M-Link bug
            if(presence.getID() === null) {
                presence.setID(1);
            }
            
            Console.info('First MUC presence: ' + from);
            
            // Catch the errors
            if(!Errors.handle(xml)) {
                // Define some stuffs
                var muc_user = $(xml).find('x[xmlns="' + NS_MUC_USER + '"]');
                var affiliation = muc_user.find('item').attr('affiliation');
                        var statuscode = parseInt(muc_user.find('status').attr('code'));
                
                // Handle my presence
                Presence.handle(presence);
                
                // Check if I am a room owner
                self.openAdmin(affiliation, hash, room, statuscode);
                
                // Tell the MUC we can notify the incoming presences
                $(document).oneTime('15s', function() {
                    $('#' + hash).attr('data-initial', 'true');
                });
                
                // Enable the chatting input
                $(document).oneTime(10, function() {
                    $('#' + hash + ' .message-area').removeAttr('disabled').focus();
                });
            }
            
            // A password is required
            else if($(xml).find('error[type="auth"] not-authorized').size()) {
                self.generateMUCAsk('password', room, hash, nickname);
            }
            
            // There's a nickname conflict
            else if($(xml).find('error[type="cancel"] conflict').size()) {
                self.generateMUCAsk('nickname', room, hash);
            }
        } catch(e) {
            Console.error('Groupchat.handleMUC', e);
        }

    };


    /**
     * Generates a correct MUC asker
     * @public
     * @param {string} type
     * @param {string} room
     * @param {string} hash
     * @param {string} nickname
     * @param {string} password
     * @return {undefined}
     */
    self.generateMUCAsk = function(type, room, hash, nickname, password) {

        try {
            // Generate the path to the elements
            var path_to = '#' + hash + ' .muc-ask';
            
            // Define the label text
            var label_text;
            
            switch(type) {
                case 'nickname':
                    label_text = Common._e("Nickname");
                    break;
                
                case 'password':
                    label_text = Common._e("Password");
                    break;
            }
            
            // Create the HTML markup
            $('#' + hash + ' .compose').hide();
            
            $('#' + hash).append(
                '<div class="muc-ask text">' + 
                    '<label>' + label_text + '</label>' + 
                    '<input class="focusable" type="text" />' + 
                '</div>'
            );
            
            // When a key is pressed in the input
            $(path_to + ' input').keyup(function(e) {
                var value_input = $(this).val();
                
                // Enter key pressed
                if(e.keyCode == 13) {
                    // $.trim() fixes #304
                    if(type == 'nickname' && $.trim(value_input)) {
                        nickname = $.trim(value_input);
                        return self.getMUC(room, nickname, password);
                    }
                    
                    if(type == 'password' && value_input) {
                        password = value_input;
                        return self.getMUC(room, nickname, password);
                    }
                }
            });
            
            // Focus on the input
            $(document).oneTime(10, function() {
                $(path_to + ' input').focus();
            });
        } catch(e) {
            Console.error('Groupchat.generateMUCAsk', e);
        }

    };


    /**
     * Creates a new groupchat
     * @public
     * @param {string} hash
     * @param {string} room
     * @param {string} chan
     * @param {string} nickname
     * @param {string} password
     * @return {undefined}
     */
    self.create = function(hash, room, chan, nickname, password) {

        /* REF: http://xmpp.org/extensions/xep-0045.html */

        try {
            Console.info('New groupchat: ' + room);
    
            // Create the chat content
            Chat.generate('groupchat', hash, room, chan);
            
            // Create the chat switcher
            Chat.generateSwitch('groupchat', hash, room, chan);
            
            // The icons-hover functions
            Tooltip.icons(room, hash);
            
            // Click event on the add tool
            $('#' + hash + ' .tools-add').click(function() {
                // Hide the icon (to tell the user all is okay)
                $(this).hide();
                
                // Add the groupchat to the user favorites
                Favorites.addThis(room, chan);
            });
            
            // Must show the add button?
            if(!DataStore.existDB('favorites', room))
                $('#' + hash + ' .tools-add').show();
            
            // The event handlers
            var inputDetect = $('#' + hash + ' .message-area');
            
            // Focus event
            inputDetect.focus(function() {
                // Clean notifications for this chat
                Interface.chanCleanNotify(hash);
                
                // Store focus on this chat!
                Interface.chat_focus_hash = hash;
            });
            
            // Blur event
            inputDetect.blur(function() {
                // Reset storage about focus on this chat!
                if(Interface.chat_focus_hash == hash)
                    Interface.chat_focus_hash = null;

                // Reset autocompletion
                Autocompletion.reset(hash);
            });
            
            // Lock to the input
            inputDetect.keydown(function(e) {
                // Enter key
                if(e.keyCode == 13) {
                    // If shift key (without any others modifiers) was pressed, add a new line
                    if(e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey)
                        inputDetect.val(inputDetect.val() + '\n');
                    
                    // Send the message
                    else {
                        Message.send(hash, 'groupchat');
                        
                        // Reset the composing database entry
                        DataStore.setDB(Connection.desktop_hash, 'chatstate', room, 'off');
                    }
                    
                    return false;
                }
                
                // Tabulation key (without any modifiers)
                else if(!e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.keyCode == 9) {
                    Autocompletion.create(hash);
                    
                    return false;
                }
                
                // Reset the autocompleter
                else {
                    Autocompletion.reset(hash);
                }
            });
            
            // Chatstate events
            ChatState.events(inputDetect, room, hash, 'groupchat');
            
            // Get the current muc informations and content
            self.getMUC(room, nickname, password);
        } catch(e) {
            Console.error('Groupchat.create', e);
        }

    };


    /**
     * Generates a groupchat to join array
     * @public
     * @return {object}
     */
    self.arrayJoin = function() {

        try {
            // Values array
            var muc_arr = [GROUPCHATS_JOIN];
            var new_arr = [];
            
            // Try to split it
            if(GROUPCHATS_JOIN.indexOf(',') != -1)
                muc_arr = GROUPCHATS_JOIN.split(',');
            
            for(var i in muc_arr) {
                // Get the current value
                var muc_current = $.trim(muc_arr[i]);
                
                // No current value?
                if(!muc_current)
                    continue;
                
                // Filter the current value
                muc_current = Common.generateXID(muc_current, 'groupchat');
                
                // Add the current value
                if(!Utils.existArrayValue(new_arr, muc_current))
                    new_arr.push(muc_current);
            }
            
            return new_arr;
        } catch(e) {
            Console.error('Groupchat.arrayJoin', e);
        }

    };


    /**
     * Joins the defined groupchats
     * @public
     * @return {undefined}
     */
    self.joinConf = function() {

        try {
            // Nothing to join?
            if(!JOIN_SUGGEST)
                return;
            
            // Join the chats
            if(JOIN_SUGGEST.length) {
                for(var g in JOIN_SUGGEST) {
                    Chat.checkCreate(JOIN_SUGGEST[g], 'groupchat');
                }
            }
        } catch(e) {
            Console.error('Groupchat.joinConf', e);
        }

    };


    /**
     * Checks suggest utility
     * @public
     * @return {undefined}
     */
    self.suggestCheck = function() {

        try {
            var groupchat_arr = self.arrayJoin();
    
            // Must suggest the user?
            if((GROUPCHATS_SUGGEST == 'on') && groupchat_arr.length) {
                if(Common.exists('#suggest'))
                    return;
                
                // Create HTML code
                var html = '<div id="suggest" class="removable">';
                    html += '<div class="title">' + Common._e("Suggested chatrooms") + '</div>';
                    
                    html += '<div class="content">';
                        for(var g in groupchat_arr) {
                            html += '<a class="one" href="#" data-xid="' + Common.encodeQuotes(groupchat_arr[g]) + '">';
                                html += '<span class="icon talk-images"></span>';
                                html += '<span class="name">' + Utils.capitaliseFirstLetter(Common.getXIDNick(groupchat_arr[g]).htmlEnc()) + '</span>';
                                html += '<span class="state talk-images"></span>';
                                html += '<span class="clear"></span>';
                            html += '</a>';
                        }
                    html += '</div>';
                    
                    html += '<div class="bottom">';
                        html += '<a class="next continue disabled" href="#">' + Common._e("Continue") + '</a>';
                        html += '<a class="next skip" href="#">' + Common._e("Skip") + '</a>';
                    html += '</div>';
                html += '</div>';
                
                // Append HTML code
                $('body').append(html);
                
                // Click events
                $('#suggest .content a.one').click(function() {
                    // Add/remove the active class
                    $(this).toggleClass('active');
                    
                    // We require at least one room to be chosen
                    if(Common.exists('#suggest .content a.one.active'))
                        $('#suggest a.next').removeClass('disabled');
                    else
                        $('#suggest a.next').addClass('disabled');
                    
                    return false;
                });
                
                $('#suggest a.next').click(function() {
                    // Disabled?
                    if($(this).hasClass('disabled')) {
                        return false;
                    }
                    
                    // Store groupchats to join?
                    if($(this).is('.continue')) {
                        $('#suggest .content a.one.active').each(function() {
                            JOIN_SUGGEST.push($(this).attr('data-xid'));
                        });
                    }
                    
                    // Switch to talk UI
                    $('#suggest').remove();
                    Connection.triggerConnected();
                    
                    return false;
                });
            } else {
                JOIN_SUGGEST = groupchat_arr;
                
                Connection.triggerConnected();
            }
        } catch(e) {
            Console.error('Groupchat.suggestCheck', e);
        }

    };


    /**
     * Bans a user from given room
     * @public
     * @param {string} room_xid
     * @param {string} ban_xid
     * @param {string} reason
     * @return {object}
     */
    self.banUser = function(room_xid, ban_xid, reason) {

        try {
            // We check if the user exists
            if(!ban_xid) {
                Board.openThisInfo(6);

                Console.warning('Could not ban user with XID: ' + ban_xid + ' from room: ' + room_xid);
            } else {
                // We generate the ban IQ
                var iq = new JSJaCIQ();
                iq.setTo(room_xid);
                iq.setType('set');
                
                var iqQuery = iq.setQuery(NS_MUC_ADMIN);
                var item = iqQuery.appendChild(iq.buildNode('item', {'affiliation': 'outcast', 'jid': ban_xid, 'xmlns': NS_MUC_ADMIN}));
                
                if(reason) {
                    item.appendChild(iq.buildNode('reason', {'xmlns': NS_MUC_ADMIN}, reason));
                }
                
                con.send(iq, Errors.handleReply);

                Console.log('Banned user with XID: ' + ban_xid + ' from room: ' + room_xid);
            }
        } catch(e) {
            Console.error('Groupchat.banUser', e);
        }

    };


    /**
     * Kicks a user from given room
     * @public
     * @param {string} room_xid
     * @param {string} kick_xid
     * @param {string} nick
     * @param {string} reason
     * @return {object}
     */
    self.kickUser = function(room_xid, kick_xid, nick, reason) {

        try {
            // We check if the user exists
            if(!room_xid) {
                Board.openThisInfo(6);

                Console.warning('Could not kick user "' + nick + '" from room: ' + room_xid);
            } else {
                // We generate the kick IQ
                var iq = new JSJaCIQ();
                iq.setTo(room_xid);
                iq.setType('set');
                
                var iqQuery = iq.setQuery(NS_MUC_ADMIN);
                var item = iqQuery.appendChild(iq.buildNode('item', {'nick': nick, 'role': 'none', 'xmlns': NS_MUC_ADMIN}));
                
                if(reason) {
                    item.appendChild(iq.buildNode('reason', {'xmlns': NS_MUC_ADMIN}, reason));
                }
                
                con.send(iq, Errors.handleReply);

                Console.info('Kicked user "' + nick + '" from room: ' + room_xid);
            }
        } catch(e) {
            Console.error('Groupchat.kickUser', e);
        }

    };


    /**
     * Promotes an user as groupchat moderator
     * @public
     * @param {string} muc_xid
     * @param {string} user_xid
     * @return {object}
     */
    self.promoteModerator = function(muc_xid, user_xid) {

        try {
            MUCAdmin.setAffiliation(muc_xid, user_xid, 'admin');
        } catch(e) {
            Console.error('Groupchat.promoteModerator', e);
        }

    };


    /**
     * Demotes an user as being groupchat moderator
     * @public
     * @param {string} muc_xid
     * @param {string} user_xid
     * @return {object}
     */
    self.demoteModerator = function(muc_xid, user_xid) {

        try {
            MUCAdmin.setAffiliation(muc_xid, user_xid, 'none');
        } catch(e) {
            Console.error('Groupchat.demoteModerator', e);
        }

    };


    /**
     * Returns user affiliation in groupchat
     * @public
     * @param {string} muc_xid
     * @param {string} nick
     * @return {object}
     */
    self.affiliationUser = function(muc_xid, nick) {

        try {
            // Initial data
            var affiliations = ['none', 'member', 'admin', 'owner'];
            var affiliation = {
                code: 0,
                name: affiliations[0]
            };

            // Get user data
            var user_sel = $('#' + hex_md5(muc_xid) + ' .list .user[data-nick="' + escape(nick) + '"]');

            if(user_sel.size()) {
                var user_affiliation = user_sel.attr('data-affiliation');

                if(user_affiliation && Utils.existArrayValue(affiliations, user_affiliation)) {
                    affiliation.code = Utils.indexArrayValue(affiliations, user_affiliation);
                    affiliation.name = user_affiliation;
                }
            }

            return affiliation;
        } catch(e) {
            Console.error('Groupchat.affiliationUser', e);
        }

    };


    /**
     * Returns our affiliation in groupchat
     * @public
     * @param {string} muc_xid
     * @return {object}
     */
    self.affiliationMe = function(muc_xid) {

        try {
            // Get my nick
            var my_nick = unescape($('#' + hex_md5(muc_xid)).attr('data-nick') || '');

            // Return my affiliation
            return self.affiliationUser(muc_xid, my_nick);
        } catch(e) {
            Console.error('Groupchat.affiliationMe', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the smileys JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Smileys = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Generates the correct HTML code for an emoticon insertion tool
     * @public
     * @param {string} smiley
     * @param {string} image
     * @param {string} hash
     * @return {undefined}
     */
    self.emoteLink = function(smiley, image, hash) {

        try {
            return '<a href="#" class="emoticon emoticon-' + image + ' smileys-images" data-smiley="' + smiley + '"></a>';
        } catch(e) {
            Console.error('Smileys.emoteLink', e);
        }

    };


    /**
     * Emoticon links arrays
     * @public
     * @param {string} hash
     * @return {object}
     */
    self.links = function(hash) {

        try {
            var links = '';
            
            var sArray = [
                ':-D',
                ']:->',
                '8-)',
                ':-P',
                ':-)',
                ';-)',
                ':-$',
                ':-|',
                ':-/',
                '=-O',
                ':-(',
                ':\'-(',
                ':-@',
                ':-!',
                '({)',
                '(})',
                ':3',
                '(@)',
                ':-[',
                ':-{}',
                '<3',
                '</3',
                '@}->--',
                '(W)',
                '(Y)',
                '(N)',
                '(I)',
                '(C)',
                '(D)',
                '(B)',
                '(Z)',
                '(X)',
                '(P)',
                '(T)',
                '(8)',
                '(%)',
                '(E)',
                '(R)',
                '(*)',
                '(S)'
            ];
            
            var cArray = [
                'biggrin',
                'devil',
                'coolglasses',
                'tongue',
                'smile',
                'wink',
                'blush',
                'stare',
                'frowning',
                'oh',
                'unhappy',
                'cry',
                'angry',
                'puke',
                'hugright',
                'hugleft',
                'lion',
                'pussy',
                'bat',
                'kiss',
                'heart',
                'brheart',
                'flower',
                'brflower',
                'thumbup',
                'thumbdown',
                'lamp',
                'coffee',
                'drink',
                'beer',
                'boy',
                'girl',
                'photo',
                'phone',
                'music',
                'cuffs',
                'mail',
                'rainbow',
                'star',
                'moon'
            ];
            
            for(var i in sArray) {
                links += self.emoteLink(sArray[i], cArray[i], hash);
            }
            
            return links;
        } catch(e) {
            Console.error('Smileys.links', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the Out of Band Data JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var OOB = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Sends an OOB request to someone
     * @public
     * @param {string} to
     * @param {string} type
     * @param {string} url
     * @param {string} desc
     * @return {undefined}
     */
    self.send = function(to, type, url, desc) {

        try {
            // IQ stanza?
            if(type == 'iq') {
                // Get some values
                var id = hex_md5(genID() + to + url + desc);
                to = Caps.getFeatureResource(to, NS_IQOOB);
                
                // IQs cannot be sent to offline users
                if(!to)
                    return;
                
                // Register the ID
                DataStore.setDB(Connection.desktop_hash, 'send/url', id, url);
                DataStore.setDB(Connection.desktop_hash, 'send/desc', id, desc);
                
                var aIQ = new JSJaCIQ();
                aIQ.setTo(Common.fullXID(to));
                aIQ.setType('set');
                aIQ.setID(id);
                
                // Append the query content
                var aQuery = aIQ.setQuery(NS_IQOOB);
                aQuery.appendChild(aIQ.buildNode('url', {'xmlns': NS_IQOOB}, url));
                aQuery.appendChild(aIQ.buildNode('desc', {'xmlns': NS_IQOOB}, desc));
                
                con.send(aIQ);
            }
            
            // Message stanza?
            else {
                var aMsg = new JSJaCMessage();
                aMsg.setTo(Common.bareXID(to));
                
                // Append the content
                aMsg.setBody(desc);
                var aX = aMsg.appendNode('x', {'xmlns': NS_XOOB});
                aX.appendChild(aMsg.buildNode('url', {'xmlns': NS_XOOB}, url));
                
                con.send(aMsg);
            }
            
            Console.log('Sent OOB request to: ' + to + ' (' + desc + ')');
        } catch(e) {
            Console.error('OOB.send', e);
        }

    };


    /**
     * Handles an OOB request
     * @public
     * @param {string} from
     * @param {string} id
     * @param {string} type
     * @param {string} node
     * @return {undefined}
     */
    self.handle = function(from, id, type, node) {

        try {
            var xid = '';
            var url = '';
            var desc = '';
            
            // IQ stanza?
            if(type == 'iq') {
                xid = Common.fullXID(from);
                url = $(node).find('url').text();
                desc = $(node).find('desc').text();
            }
            
            // Message stanza?
            else {
                xid = Common.bareXID(from);
                url = $(node).find('url').text();
                desc = $(node).find('body').text();
            }
            
            // No desc?
            if(!desc) {
                desc = url;
            }
            
            // Open a new notification
            if(type && xid && url && desc) {
                Notification.create('send', xid, [xid, url, type, id, node], desc, hex_md5(xid + url + desc + id));
            }
        } catch(e) {
            Console.error('OOB.handle', e);
        }

    };


    /**
     * Replies to an OOB request
     * @public
     * @param {string} to
     * @param {string} id
     * @param {string} choice
     * @param {string} type
     * @param {object} node
     * @return {undefined}
     */
    self.reply = function(to, id, choice, type, node) {

        try {
            // Not IQ type?
            if(type != 'iq')
                return;
            
            // New IQ
            var aIQ = new JSJaCIQ();
            aIQ.setTo(to);
            aIQ.setID(id);
            
            // OOB request accepted
            if(choice == 'accept') {
                aIQ.setType('result');
                
                Console.info('Accepted file request from: ' + to);
            }
            
            // OOB request rejected
            else {
                aIQ.setType('error');
                
                // Append stanza content
                for(var i = 0; i < node.childNodes.length; i++)
                    aIQ.getNode().appendChild(node.childNodes.item(i).cloneNode(true));
                
                // Append error content
                var aError = aIQ.appendNode('error', {'xmlns': NS_CLIENT, 'code': '406', 'type': 'modify'});
                aError.appendChild(aIQ.buildNode('not-acceptable', {'xmlns': NS_STANZAS}));
                
                Console.info('Rejected file request from: ' + to);
            }
            
            con.send(aIQ);
        } catch(e) {
            Console.error('OOB.reply', e);
        }

    };


    /**
     * Wait event for OOB upload
     * @public
     * @return {undefined}
     */
    self.waitUpload = function() {

        try {
            // Append the wait icon
            $('#page-engine .chat-tools-file:not(.mini) .tooltip-subitem *').hide();
            $('#page-engine .chat-tools-file:not(.mini) .tooltip-subitem').append('<div class="wait wait-medium"></div>');
            
            // Lock the bubble
            $('#page-engine .chat-tools-file:not(.mini)').addClass('mini');
        } catch(e) {
            Console.error('OOB.waitUpload', e);
        }

    };


    /**
     * Success event for OOB upload
     * @public
     * @param {string} responseXML
     * @return {undefined}
     */
    self.handleUpload = function(responseXML) {

        try {
            // Data selector
            var dData = $(responseXML).find('jappix');
            
            // Get the values
            var fID = dData.find('id').text();
            var fURL = dData.find('url').text();
            var fDesc = dData.find('desc').text();
            
            // Get the OOB values
            var oob_has;
            
            // No ID provided?
            if(!fID)
                oob_has = ':has(.wait)';
            else
                oob_has = ':has(#oob-upload input[value="' + fID + '"])';
            
            var xid = $('#page-engine .page-engine-chan' + oob_has).attr('data-xid');
            var oob_type = $('#page-engine .chat-tools-file' + oob_has).attr('data-oob');
            
            // Reset the file send tool
            $('#page-engine .chat-tools-file' + oob_has).removeClass('mini');
            $('#page-engine .bubble-file' + oob_has).remove();
            
            // Not available?
            if($('#page-engine .chat-tools-file' + oob_has).is(':hidden') && (oob_type == 'iq')) {
                Board.openThisError(4);
                
                // Remove the file we sent
                if(fURL)
                    $.get(fURL + '&action=remove');
            }
            
            // Everything okay?
            else if(fURL && fDesc && !dData.find('error').size()) {
                // Send the OOB request
                self.send(xid, oob_type, fURL, fDesc);
                
                // Notify the sender
                Notification.create('send_pending', xid, [xid, fURL, oob_type, '', ''], fDesc, hex_md5(fURL + fDesc + fID));
                
                Console.info('File request sent.');
            }
            
            // Upload error?
            else {
                Board.openThisError(4);
                
                Console.error('Error while sending the file', dData.find('error').text());
            }
        } catch(e) {
            Console.error('OOB.handleUpload', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the avatar JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var Avatar = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.pending = [];


    /**
     * Requests the avatar of a given user
     * @public
     * @param {string} xid
     * @param {string} mode
     * @param {boolean} enabled
     * @param {boolean} photo
     * @return {boolean}
     */
    self.get = function(xid, mode, enabled, photo) {

        /* REF: http://xmpp.org/extensions/xep-0153.html */

        try {
            // No need to get the avatar, another process is yet running
            if(Utils.existArrayValue(self.pending, xid))
                return false;
            
            // Initialize: XML data is in one SQL entry, because some browser are sloooow with SQL requests
            var xml = Common.XMLFromString(
                DataStore.getPersistent('global', 'avatar', xid)
            );
            var forced = false;
            
            // Retrieving forced?
            if($(xml).find('forced').text() == 'true')
                forced = true;
            
            // No avatar in presence
            if(!photo && !forced && enabled == 'true') {
                // Pending marker
                self.pending.push(xid);
                
                // Reset the avatar
                self.reset(xid, hex_md5(xid));
                
                Console.warn('No avatar for: ' + xid);
            }
            
            // Try to catch the avatar
            else {
                // Define some stuffs
                var type = $(xml).find('type').text();
                var binval = $(xml).find('binval').text();
                var checksum = $(xml).find('checksum').text();
                var updated = false;

                // Process the checksum of the avatar
                if(checksum == photo || photo == 'forget' || forced)
                    updated = true;

                // If the avatar is yet stored and a new retrieving is not needed
                if(mode == 'cache' && type && binval && checksum && updated) {
                    // Pending marker
                    self.pending.push(xid);
                    
                    // Display the cache avatar
                    self.display(xid, hex_md5(xid), type, binval);
                    
                    Console.info('Read avatar from cache: ' + xid);
                }
                
                // Else if the request has not yet been fired, we get it
                else if((!updated || mode == 'force' || photo == 'forget') && enabled != 'false') {
                    // Pending marker
                    self.pending.push(xid);
                    
                    // Get the latest avatar
                    var iq = new JSJaCIQ();
                    iq.setType('get');
                    iq.setTo(xid);
                    
                    iq.appendNode('vCard', {'xmlns': NS_VCARD});
                    
                    con.send(iq, self.handle);
                    
                    Console.info('Get avatar from server: ' + xid);
                }
            }
            
            return true;
        } catch(e) {
            Console.error('Avatar.get', e);
        }

    };


    /**
     * Handles the avatar
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handle = function(iq) {

        try {
            // Extract the XML values
            var handleXML = iq.getNode();
            var handleFrom = Common.fullXID(Common.getStanzaFrom(iq));
            
            // Is this me? Remove the resource!
            if(Common.bareXID(handleFrom) == Common.getXID()) {
                handleFrom = Common.bareXID(handleFrom);
            }
            
            // Get some other values
            var hash = hex_md5(handleFrom);
            var find = $(handleXML).find('vCard');
            var aChecksum = 'none';
            var oChecksum = null;
            
            // Read our own checksum
            if(handleFrom == Common.getXID()) {
                oChecksum = DataStore.getDB(Connection.desktop_hash, 'checksum', 1);
                
                // Avoid the "null" value
                if(!oChecksum)
                    oChecksum = '';
            }
            
            // vCard not empty?
            if(find.size()) {
                // We get our profile details
                if(handleFrom == Common.getXID()) {
                    // Get the names
                    var names = Name.generateBuddy(iq);
                    
                    // Write the values to the database
                    DataStore.setDB(Connection.desktop_hash, 'profile', 'name', names[0]);
                    DataStore.setDB(Connection.desktop_hash, 'profile', 'nick', names[1]);
                }
                
                // We get the avatar
                var aType = find.find('TYPE:first').text();
                var aBinval = find.find('BINVAL:first').text();
                
                // No binval?
                if(!aBinval) {
                    aType = 'none';
                    aBinval = 'none';
                }
                
                // Enough data
                else {
                    // No type?
                    if(!aType)
                        aType = 'image/png';
                    
                    // Process the checksum
                    else
                        aChecksum = hex_sha1(Base64.decode(aBinval));
                }
                
                // We display the user avatar
                self.display(handleFrom, hash, aType, aBinval);
                
                // Store the avatar
                DataStore.setPersistent('global', 'avatar', handleFrom, '<avatar><type>' + aType + '</type><binval>' + aBinval + '</binval><checksum>' + aChecksum + '</checksum><forced>false</forced></avatar>');
                
                Console.info('Avatar retrieved from server: ' + handleFrom);
            }
            
            // vCard is empty
            else {
                self.reset(handleFrom);
            }
            
            // We got a new checksum for us?
            if(((oChecksum !== null) && (oChecksum != aChecksum)) || !Presence.first_sent) {
                // Define a proper checksum
                var pChecksum = aChecksum;
                
                if(pChecksum == 'none')
                    pChecksum = '';
                
                // Update our temp. checksum
                DataStore.setDB(Connection.desktop_hash, 'checksum', 1, pChecksum);
                
                // Send the stanza
                if(!Presence.first_sent)
                    Storage.get(NS_OPTIONS);
                else if(DataStore.hasPersistent())
                    Presence.sendActions(pChecksum);
            }
        } catch(e) {
            Console.error('Avatar.handle', e);
        }

    };


    /**
     * Reset the avatar of an user
     * @public
     * @param {string} xid
     * @param {string} hash
     * @return {undefined}
     */
    self.reset = function(xid, hash) {

        try {
            // Store the empty avatar
            DataStore.setPersistent('global', 'avatar', xid, '<avatar><type>none</type><binval>none</binval><checksum>none</checksum><forced>false</forced></avatar>');
            
            // Display the empty avatar
            self.display(xid, hash, 'none', 'none');
        } catch(e) {
            Console.error('Avatar.reset', e);
        }

    };


    /**
     * Displays the avatar of an user
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {string} type
     * @param {string} binval
     * @return {undefined}
     */
    self.display = function(xid, hash, type, binval) {

        try {
            // Initialize the vars
            var container = hash + ' .avatar-container';
            var code = '<img class="avatar" src="';
            
            // If the avatar exists
            if((type != 'none') && (binval != 'none'))
                code += 'data:' + type + ';base64,' + binval;
            else
                code += './images/others/default-avatar.png';
            
            code += '" alt="" />';
            
            // Replace with the new avatar (in the roster and in the chat)
            $('.' + container).html(code);
            
            // We can remove the pending marker
            Utils.removeArrayValue(self.pending, xid);
        } catch(e) {
            Console.error('Avatar.display', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the mucadmin JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var MUCAdmin = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the MUC admin popup
     * @public
     * @param {string} xid
     * @param {string} aff
     * @return {undefined}
     */
    self.open = function(xid, aff) {

        try {
            // Popup HTML content
            var html_full = 
            '<div class="top">' + Common._e("MUC administration") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="head mucadmin-head">' + 
                    '<div class="head-text mucadmin-head-text">' + Common._e("You administrate this room") + '</div>' + 
                    
                    '<div class="mucadmin-head-jid">' + xid + '</div>' + 
                '</div>' + 
                
                '<div class="mucadmin-forms">' + 
                    '<div class="mucadmin-topic">' + 
                        '<fieldset>' + 
                            '<legend>' + Common._e("Subject") + '</legend>' + 
                            
                            '<label for="topic-text">' + Common._e("Enter new subject") + '</label>' + 
                            '<textarea id="topic-text" name="room-topic" rows="8" cols="60" ></textarea>' + 
                        '</fieldset>' + 
                    '</div>' + 
                    
                    '<div class="mucadmin-conf">' + 
                        '<fieldset>' + 
                            '<legend>' + Common._e("Configuration") + '</legend>' + 
                            
                            '<div class="results mucadmin-results"></div>' + 
                        '</fieldset>' + 
                    '</div>' + 
                    
                    '<div class="mucadmin-aut">' + 
                        '<fieldset>' + 
                            '<legend>' + Common._e("Authorizations") + '</legend>' + 
                            
                            '<label>' + Common._e("Member list") + '</label>' + 
                            '<div class="aut-member aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'member\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                            
                            '<label>' + Common._e("Owner list") + '</label>' + 
                            '<div class="aut-owner aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'owner\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                            
                            '<label>' + Common._e("Administrator list") + '</label>' + 
                            '<div class="aut-admin aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'admin\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                            
                            '<label>' + Common._e("Outcast list") + '</label>' + 
                            '<div class="aut-outcast aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'outcast\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                        '</fieldset>' + 
                    '</div>' + 
                    
                    '<div class="mucadmin-others">' + 
                        '<fieldset>' + 
                            '<legend>' + Common._e("Others") + '</legend>' + 
                            
                            '<label>' + Common._e("Destroy this MUC") + '</label>' + 
                            '<a href="#" onclick="return MUCAdmin.destroy();">' + Common._e("Yes, let's do it!") + '</a>' + 
                        '</fieldset>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish save">' + Common._e("Save") + '</a>' + 
                '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>' + 
            '</div>';
            
            var html_partial = 
            '<div class="top">' + Common._e("MUC administration") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="head mucadmin-head">' + 
                    '<div class="head-text mucadmin-head-text">' + Common._e("You administrate this room") + '</div>' + 
                    
                    '<div class="mucadmin-head-jid">' + xid + '</div>' + 
                '</div>' + 
                
                '<div class="mucadmin-forms">' + 
                    '<div class="mucadmin-aut">' + 
                        '<fieldset>' + 
                            '<legend>' + Common._e("Authorizations") + '</legend>' + 
                            
                            '<label>' + Common._e("Member list") + '</label>' + 
                            '<div class="aut-member aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'member\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                            
                            '<label>' + Common._e("Outcast list") + '</label>' + 
                            '<div class="aut-outcast aut-group">' + 
                                '<a href="#" class="aut-add" onclick="return MUCAdmin.addInput(\'\', \'outcast\');">' + Common._e("Add an input") + '</a>' + 
                            '</div>' + 
                        '</fieldset>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish save">' + Common._e("Save") + '</a>' + 
                '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>' + 
            '</div>';   
            
            // Create the popup
            if(aff == 'owner')
                Popup.create('mucadmin', html_full);
            if(aff == 'admin')
                Popup.create('mucadmin', html_partial);
            
            // Associate the events
            self.instance();
                
            // We get the affiliated user's privileges
            if(aff == 'owner') {
                self.query(xid, 'member');
                self.query(xid, 'owner');
                self.query(xid, 'admin');
                self.query(xid, 'outcast');
                // We query the room to edit
                DataForm.go(xid, 'muc', '', '', 'mucadmin');
            } else if(aff == 'admin') {
                self.query(xid, 'member');
                self.query(xid, 'outcast');
            }
        } catch(e) {
            Console.error('MUCAdmin.open', e);
        }

    };


    /**
     * Closes the MUC admin popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('mucadmin');
        } catch(e) {
            Console.error('MUCAdmin.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Removes a MUC admin input
     * @public
     * @param {string} element
     * @return {boolean}
     */
    self.removeInput = function(element) {

        try {
            var path = $(element).parent();
            
            // We first hide the container of the input
            path.hide();
            
            // Then, we add a special class to the input
            path.find('input').addClass('aut-dustbin');
        } catch(e) {
            Console.error('MUCAdmin.removeInput', e);
        } finally {
            return false;
        }

    };


    /**
     * Adds a MUC admin input
     * @public
     * @param {type} xid
     * @param {type} affiliation
     * @return {boolean}
     */
    self.addInput = function(xid, affiliation) {

        try {
            var hash = hex_md5(xid + affiliation);
    
            // Add the HTML code
            $('#mucadmin .aut-' + affiliation + ' .aut-add').after(
                '<div class="one-aut ' + hash + '">' + 
                    '<input id="aut-' + affiliation + '" name="' + affiliation + '" type="text" class="mucadmin-i" value="' + xid + '" />' + 
                    '<a href="#" class="aut-remove">[-]</a>' + 
                '</div>'
            );
            
            // Click event
            $('#mucadmin .' + hash + ' .aut-remove').click(function() {
                return self.removeInput(this);
            });
            
            // Focus on the input we added
            if(!xid) {
                $(document).oneTime(10, function() {
                    $('#mucadmin .' + hash + ' input').focus();
                });
            }
        } catch(e) {
            Console.error('MUCAdmin.addInput', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the MUC admin form
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleAuth = function(iq) {

        try {
            // We got the authorizations results
            $(iq.getQuery()).find('item').each(function() {
                // We parse the received xml
                var xid = $(this).attr('jid');
                var affiliation = $(this).attr('affiliation');
                
                // We create one input for one XID
                self.addInput(xid, affiliation);
            });
            
            // Hide the wait icon
            $('#mucadmin .wait').hide();
            
            Console.log('MUC admin items received: ' + Common.fullXID(Common.getStanzaFrom(iq)));
        } catch(e) {
            Console.error('MUCAdmin.handleAuth', e);
        }

    };


    /**
     * Queries the MUC admin form
     * @public
     * @param {string} xid
     * @param {string} type
     * @return {undefined}
     */
    self.query = function(xid, type) {

        try {
            // Show the wait icon
            $('#mucadmin .wait').show();
            
            // New IQ
            var iq = new JSJaCIQ();
            
            iq.setTo(xid);
            iq.setType('get');
            
            var iqQuery = iq.setQuery(NS_MUC_ADMIN);
            iqQuery.appendChild(iq.buildNode('item', {'affiliation': type, 'xmlns': NS_MUC_ADMIN}));
            
            con.send(iq, self.handleAuth);
        } catch(e) {
            Console.error('MUCAdmin.query', e);
        }

    };


    /**
     * Sends the new chat-room topic
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.sendTopic = function(xid) {

        try {
            // We get the new topic
            var topic = $('.mucadmin-topic textarea').val();
            
            // We send the new topic if not blank
            if(topic) {
                var m = new JSJaCMessage();
                m.setTo(xid);
                m.setType('groupchat');
                m.setSubject(topic);
                con.send(m);
                
                Console.info('MUC admin topic sent: ' + topic);
            }
        } catch(e) {
            Console.error('MUCAdmin.sendTopic', e);
        }

    };


    /**
     * Sends the MUC admin auth form
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.sendAuth = function(xid) {

        try {
            // We define the values array
            var types = new Array('member', 'owner', 'admin', 'outcast');

            $.each(types, function(i) {
                // We get the current type
                var tType = types[i];
                
                // We loop for all the elements
                $('.mucadmin-aut .aut-' + tType + ' input').each(function() {
                    // We get the needed values
                    var value = $(this).val();
                    var affiliation = ($(this).hasClass('aut-dustbin') && value) ? 'none' : tType;

                    // Submit affiliation
                    if(value && affiliation) {
                        self.setAffiliation(xid, value, affiliation);
                    }
                });
            });
            
            Console.info('MUC admin authorizations form sent: ' + xid);
        } catch(e) {
            Console.error('MUCAdmin.sendAuth', e);
        }

    };


    /**
     * Sets the affiliation for a given user
     * @public
     * @param {string} muc_xid
     * @param {string} user_xid
     * @param {string} affiliation
     * @return {undefined}
     */
    self.setAffiliation = function(muc_xid, user_xid, affiliation) {

        try {
            // If no affiliation set, assume it's 'none'
            affiliation = affiliation || 'none';

            // Go Go Go!!
            var iq = new JSJaCIQ();
            iq.setTo(muc_xid);
            iq.setType('set');

            var iqQuery = iq.setQuery(NS_MUC_ADMIN);
    
            var item = iqQuery.appendChild(iq.buildNode('item', {
                'jid': user_xid,
                'affiliation': affiliation,
                'xmlns': NS_MUC_ADMIN
            }));
    
            con.send(iq, Errors.handleReply);
        } catch(e) {
            Console.error('MUCAdmin.setAffiliation', e);
        }

    };


    /**
     * Checks if the MUC room was destroyed
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleDestroyIQ = function(iq) {

        try {
            if(!Errors.handleReply(iq)) {
                // We close the groupchat
                var room = Common.fullXID(Common.getStanzaFrom(iq));
                var hash = hex_md5(room);
                Interface.quitThisChat(room, hash, 'groupchat');
                
                // We close the muc admin popup
                self.close();
                
                // We tell the user that all is okay
                Board.openThisInfo(5);
                
                // We remove the user's favorite
                if(DataStore.existDB('favorites', room))
                    Favorites.removeThis(room, Common.explodeThis('@', room, 0));
                
                Console.info('MUC admin destroyed: ' + room);
            }
            
            // We hide the wait icon
            $('#mucadmin .wait').hide();
        } catch(e) {
            Console.error('MUCAdmin.handleDestroyIQ', e);
        }

    };


    /**
     * Destroys a MUC room
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.destroyIQ = function(xid) {

        try {
            // We ask the server to delete the room
            var iq = new JSJaCIQ();
            
            iq.setTo(xid);
            iq.setType('set');
            var iqQuery = iq.setQuery(NS_MUC_OWNER);
            iqQuery.appendChild(iq.buildNode('destroy', {'xmlns': NS_MUC_OWNER}));
            
            con.send(iq, self.handleDestroyIQ);
            
            Console.info('MUC admin destroy sent: ' + xid);
        } catch(e) {
            Console.error('MUCAdmin.destroyIQ', e);
        } finally {
            return false;
        }

    };


    /**
     * Performs the MUC room destroy functions
     * @public
     * @return {undefined}
     */
    self.destroy = function() {

        try {
            // We get the XID of the current room
            var xid = $('#mucadmin .mucadmin-head-jid').text();
            
            // We show the wait icon
            $('#mucadmin .wait').show();
            
            // We send the iq
            self.destroyIQ(xid);
        } catch(e) {
            Console.error('MUCAdmin.destroy', e);
        }

    };


    /**
     * Sends all the MUC admin stuffs
     * @public
     * @return {undefined}
     */
    self.send = function() {

        try {
            // We get the XID of the current room
            var xid = $('#mucadmin .mucadmin-head-jid').text();
            
            // We change the room topic
            self.sendTopic(xid);
            
            // We send the needed queries
            DataForm.send('x', 'submit', 'submit', $('#mucadmin .mucadmin-results').attr('data-session'), xid, '', '', 'mucadmin');
            self.sendAuth(xid);
        } catch(e) {
            Console.error('MUCAdmin.send', e);
        }

    };


    /**
     * Saves the MUC admin elements
     * @public
     * @return {boolean}
     */
    self.save = function() {

        try {
            // We send the new options
            self.send();
            
            // And we quit the popup
            return self.close();
        } catch(e) {
            Console.error('MUCAdmin.save', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#mucadmin .bottom .finish').click(function() {
                if($(this).is('.cancel'))
                    return self.close();
                if($(this).is('.save'))
                    return self.save();
            });
        } catch(e) {
            Console.error('MUCAdmin.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the connection JS script for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var Connection = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.current_session = false;
    self.desktop_hash = null;
    self.connected = false;
    self.reconnect_try = 0;
    self.reconnect_timer = 0;
    self.resume = false;


    /**
     * Does the user login
     * @public
     * @param {string} lNick
     * @param {string} lServer
     * @param {string} lPass
     * @param {string} lResource
     * @param {number} lPriority
     * @param {boolean} lRemember
     * @param {object} loginOpts
     * @return {boolean}
     */
    self.doLogin = function(lNick, lServer, lPass, lResource, lPriority, lRemember, loginOpts) {

        try {
            // get optionnal conn handlers
            oExtend = loginOpts || {};

            // We remove the not completed class to avoid problems
            $('#home .loginer input').removeClass('please-complete');
            
            // We add the login wait div
            Interface.showGeneralWait();
            
            if(Common.hasWebSocket()) {
                // WebSocket supported & configured
                con = new JSJaCWebSocketConnection({
                    httpbase: HOST_WEBSOCKET
                });
            } else {
                var httpbase = (HOST_BOSH_MAIN || HOST_BOSH);

                // Check BOSH origin
                BOSH_SAME_ORIGIN = Origin.isSame(httpbase);
                
                // We create the new http-binding connection
                con = new JSJaCHttpBindingConnection({
                    httpbase: httpbase
                });
            }
            
            // And we handle everything that happen
            self.setupCon(con, oExtend);
            
            // Generate a resource
            var random_resource = DataStore.getDB(self.desktop_hash, 'session', 'resource');
            
            if(!random_resource) {
                random_resource = lResource + ' (' + (new Date()).getTime() + ')';
            }
            
            // We retrieve what the user typed in the login inputs
            oArgs = {};
            oArgs.domain = $.trim(lServer);
            oArgs.username = $.trim(lNick);
            oArgs.resource = random_resource;
            oArgs.pass = lPass;
            oArgs.secure = true;
            oArgs.xmllang = XML_LANG;

            self.desktop_hash = 'jd.' + hex_md5(oArgs.username + '@' + oArgs.domain);
            
            // Store the resource (for reconnection)
            DataStore.setDB(self.desktop_hash, 'session', 'resource', random_resource);
            
            // Store session XML in temporary database
            self.storeSession(lNick, lServer, lPass, lResource, lPriority, lRemember);
            
            // We store the infos of the user into the data-base
            DataStore.setDB(self.desktop_hash, 'priority', 1, lPriority);
            
            // We connect !
            con.connect(oArgs);
            
            // Change the page title
            Interface.title('wait');
            
            Console.info('Jappix is connecting...');
        } catch(e) {
            Console.error('Connection.doLogin', e);

            // Reset Jappix
            Talk.destroy();
            
            // Open an unknown error
            Board.openThisError(2);
        } finally {
            return false;
        }

    };


    /**
     * Handles the user registration
     * @public
     * @return {undefined}
     */
    self.handleRegistered = function() {

        try {
            Console.info('A new account has been registered.');
            
            // We remove the waiting image
            Interface.removeGeneralWait();
            
            // Reset the title
            Interface.title('home');
            
            // We show the success information
            $('#home .registerer .success').fadeIn('fast');
            
            // We quit the session
            if(Common.isConnected()) {
                self.logout();
            }
        } catch(e) {
            Console.error('Connection.handleRegistered', e);
        }

    };


    /**
     * Does the user registration
     * @public
     * @param {string} username
     * @param {string} domain
     * @param {string} pass
     * @param {string} captcha
     * @return {boolean}
     */
    self.doRegister = function(username, domain, pass, captcha) {

        try {
            Console.info('Trying to register an account...');
    
            // We change the registered information text
            $('#home .homediv.registerer').append(
                '<div class="info success">' + 
                    Common._e("You have been registered, here is your XMPP address:") + ' <b>' + username.htmlEnc() + '@' + domain.htmlEnc() + '</b> - <a href="#">' + Common._e("Login") + '</a>' + 
                '</div>'
            );
            
            // Login link
            $('#home .homediv.registerer .success a').click(function() {
                return self.doLogin(username, domain, pass, '', '10', false);
            });
            
            if((REGISTER_API == 'on') && (domain == HOST_MAIN) && captcha) {
                // Show the waiting image
                Interface.showGeneralWait();
                
                // Change the page title
                Interface.title('wait');
                
                // Send request
                $.post('./server/register.php', {username: username, domain: domain, password: pass, captcha: captcha}, function(data) {
                    // Error registering
                    Interface.removeGeneralWait();
                    Interface.title('home');
                    
                    // In all case, update CAPTCHA
                    $('#home img.captcha_img').attr('src', './server/captcha.php?id=' + genID());
                    $('#home input.captcha').val('');
                    
                    // Registration okay
                    if($(data).find('query status').text() == '1') {
                        self.handleRegistered();
                    } else {
                        // Show error message
                        var error_message = '';
                        
                        switch($(data).find('query message').text()) {
                            case 'CAPTCHA Not Matching':
                                error_message = Common._e("The security code you entered is invalid. Please retry with another one.");
                                
                                $('#home input.captcha').focus();
                                
                                break;
                            
                            case 'Username Unavailable':
                                error_message = Common._e("The username you picked is not available. Please try another one.");
                                
                                $('#home input.nick').focus();
                                
                                break;
                            
                            default:
                                error_message = Common._e("There was an error registering your account. Please retry.");
                                
                                break;
                        }
                        
                        if(error_message)
                            Errors.show('', error_message, '');
                    }
                });
            } else {
                try {
                    oArgs = {};

                    if(Common.hasWebSocket()) {
                        // WebSocket supported & configured
                        con = new JSJaCWebSocketConnection({
                            httpbase: HOST_WEBSOCKET
                        });
                    } else {
                        var httpbase = (HOST_BOSH_MAIN || HOST_BOSH);

                        // Check BOSH origin
                        BOSH_SAME_ORIGIN = Origin.isSame(httpbase);
                        
                        // We create the new http-binding connection
                        con = new JSJaCHttpBindingConnection({
                            httpbase: httpbase
                        });
                    }
                    
                    // We setup the connection !
                    con.registerHandler('onconnect', self.handleRegistered);
                    con.registerHandler('onerror', Errors.handle);
                    
                    // We retrieve what the user typed in the register inputs
                    oArgs = {};
                    oArgs.domain = $.trim(domain);
                    oArgs.username = $.trim(username);
                    oArgs.resource = JAPPIX_RESOURCE + ' Register (' + (new Date()).getTime() + ')';
                    oArgs.pass = pass;
                    oArgs.register = true;
                    oArgs.secure = true;
                    oArgs.xmllang = XML_LANG;
                    
                    con.connect(oArgs);
                    
                    // Show the waiting image
                    Interface.showGeneralWait();
                    
                    // Change the page title
                    Interface.title('wait');
                }
                
                catch(e) {
                    // Logs errors
                    Console.error('doRegister', e);
                }
            }
        } catch(e) {
            Console.error('Connection.doRegister', e);
        } finally {
            return false;
        }

    };


    /**
     * Does the user anonymous login
     * @public
     * @return {boolean}
     */
    self.doAnonymous = function() {

        try {
            Console.info('Trying to login anonymously...');
            
            var aPath = '#home .anonymouser ';
            var room = $(aPath + '.room').val();
            var nick = $(aPath + '.nick').val();
            
            // If the form is correctly completed
            if(room && nick) {
                // We remove the not completed class to avoid problems
                $('#home .anonymouser input').removeClass('please-complete');
                
                // Redirect the user to the anonymous room
                window.location.href = JAPPIX_LOCATION + '?r=' + room + '&n=' + nick;
            }
            
            // We check if the form is entirely completed
            else {
                $(aPath + 'input[type="text"]').each(function() {
                    var select = $(this);
                    
                    if(!select.val())
                        $(document).oneTime(10, function() {
                            select.addClass('please-complete').focus();
                        });
                    else
                        select.removeClass('please-complete');  
                });
            }
        } catch(e) {
            Console.error('Connection.doAnonymous', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the user connected event
     * @public
     * @return {undefined}
     */
    self.handleConnected = function() {

        try {
            Console.info('Jappix is now connected.');
            
            // Connection markers
            self.connected = true;
            self.reconnect_try = 0;
            self.reconnect_timer = 0;
            
            // We hide the home page
            $('#home').hide();
            
            // Any suggest to do before triggering connected event?
            Groupchat.suggestCheck();
            
            // Remove the waiting item
            Interface.removeGeneralWait();

            // Init Jingle
            Jingle.init();
        } catch(e) {
            Console.error('Connection.handleConnected', e);
        }

    };


    /**
     * Triggers the connected state
     * @public
     * @return {undefined}
     */
    self.triggerConnected = function() {

        try {
            // Not resumed?
            if(!self.resume) {
                // Remember the session?
                if(DataStore.getDB(self.desktop_hash, 'remember', 'session'))
                    DataStore.setPersistent('global', 'session', 1, self.current_session);
                
                // We show the chatting app.
                Talk.create();
                
                // We reset the homepage
                Home.change('default');
                
                // We get all the other things
                self.getEverything();
                
                // Set last activity stamp
                DateUtils.last_activity = DateUtils.getTimeStamp();
            }
            
            // Resumed
            else {
                // Send our presence
                Presence.sendActions();
                
                // Change the title
                Interface.updateTitle();
            }
        } catch(e) {
            Console.error('Connection.triggerConnected', e);
        }

    };


    /**
     * Handles the user disconnected event
     * @public
     * @return {undefined}
     */
    self.handleDisconnected = function() {

        try {
            Console.info('Jappix is now disconnected.');
            
            // Normal disconnection
            if(!self.current_session && !self.connected) {
                Talk.destroy();
                self.desktop_hash = null;
            }
        } catch(e) {
            Console.error('Connection.handleDisconnected', e);
        }

    };


    /**
     * Setups the normal connection
     * @public
     * @param {object} con
     * @param {object} oExtend
     * @return {undefined}
     */
    self.setupCon = function(con, oExtend) {

        try {
            // Setup connection handlers
            con.registerHandler('message', Message.handle);
            con.registerHandler('presence', Presence.handle);
            con.registerHandler('iq', IQ.handle);
            con.registerHandler('onconnect', self.handleConnected);
            con.registerHandler('onerror', Errors.handle);
            con.registerHandler('ondisconnect', self.handleDisconnected);
            
            // Extended handlers
            oExtend = oExtend || {};
            
            jQuery.each(oExtend, function(keywd,funct) {
                con.registerHandler(keywd, funct);
            });
        } catch(e) {
            Console.error('Connection.setupCon', e);
        }

    };


    /**
     * Logouts from the server
     * @public
     * @return {boolean}
     */
    self.logout = function() {

        logout_done = false;

        try {
            if(Common.isConnected()) {
                Console.info('Jappix is disconnecting...');

                // Disconnect from the XMPP server
                con.disconnect();

                logout_done = true;
            }
        } catch(e) {
            Console.error('Connection.logout', e);
        } finally {
            return logout_done;
        }

    };


    /**
     * Terminates the user session
     * @public
     * @return {undefined}
     */
    self.terminate = function() {

        try {
            if(Common.isConnected()) {
                // Clear temporary session storage
                self.resetConMarkers();
                
                // Show the waiting item (useful if BOSH is sloooow)
                Interface.showGeneralWait();
                
                // Change the page title
                Interface.title('wait');
                
                // Disconnect from the XMPP server
                self.logout();
            }
        } catch(e) {
            Console.error('Connection.terminate', e);
        }

    };


    /**
     * Quits a session
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.quit = function() {

        try {
            if(!Common.isConnected()) {
                return;
            }
            
            // We show the waiting image
            Interface.showGeneralWait();
            
            // Change the page title
            Interface.title('wait');
            
            // We disconnect from the XMPP server
            self.logout();
        } catch(e) {
            Console.error('Connection.quit', e);
        }

    };


    /**
     * Creates the reconnect pane
     * @public
     * @param {string} mode
     * @return {undefined}
     */
    self.createReconnect = function(mode) {

        try {
            Console.error('This is not a normal disconnection, show the reconnect pane...');
    
            // Reconnect pane not yet displayed?
            if(!Common.exists('#reconnect')) {
                // Blur the focused input/textarea/select
                $('input, select, textarea').blur();
                
                // Create the HTML code
                var html = '<div id="reconnect" class="lock">' + 
                        '<div class="pane">' + 
                            Common._e("Due to a network issue, you were disconnected. What do you want to do now?");
                
                // Can we cancel reconnection?
                if(mode == 'normal')
                    html += '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>';
                
                html += '<a href="#" class="finish reconnect">' + Common._e("Reconnect") + '</a>' + 
                    '</div></div>';
                
                // Append the code
                $('body').append(html);
                
                // Click events
                if(mode == 'normal')
                    $('#reconnect a.finish.cancel').click(function() {
                        return self.cancelReconnect();
                    });
                
                $('#reconnect a.finish.reconnect').click(function() {
                    return self.acceptReconnect(mode);
                });
                
                // Try to reconnect automatically after a while
                if(self.reconnect_try < 5)
                    self.reconnect_timer = 5 + (5 * self.reconnect_try);
                else
                    self.reconnect_timer = 120;
                
                // Change the try number
                self.reconnect_try++;
                
                // Fire the event!
                $('#reconnect a.finish.reconnect').everyTime('1s', function() {
                    // We can reconnect!
                    if(self.reconnect_timer === 0)
                        return self.acceptReconnect(mode);
                    
                    // Button text
                    if(self.reconnect_timer <= 10)
                        $(this).text(Common._e("Reconnect") + ' (' + self.reconnect_timer + ')');
                    
                    // Remove 1 second
                    self.reconnect_timer--;
                });
                
                // Page title
                Interface.updateTitle();
            }
        } catch(e) {
            Console.error('Connection.createReconnect', e);
        }

    };


    /**
     * Reconnects the user if he was disconnected (network issue)
     * @public
     * @param {string} mode
     * @return {boolean}
     */
    self.acceptReconnect = function(mode) {

        try {
            Console.info('Trying to reconnect the user...');
            
            // Resume marker
            self.resume = true;
            
            // Show waiting item
            Interface.showGeneralWait();
            
            // Reset some various stuffs
            var groupchats = '#page-engine .page-engine-chan[data-type="groupchat"]';
            $(groupchats + ' .list .role').hide();
            $(groupchats + ' .one-group, ' + groupchats + ' .list .user').remove();
            $(groupchats).attr('data-initial', 'false');
            
            // Stop the timer
            $('#reconnect a.finish.reconnect').stopTime();
            
            // Remove the reconnect pane
            $('#reconnect').remove();
            
            // Try to login again
            if(mode == 'normal')
                self.loginFromSession(Common.XMLFromString(self.current_session));
            else if(mode == 'anonymous')
                Anonymous.login(HOST_ANONYMOUS);
        } catch(e) {
            Console.error('Connection.acceptReconnect', e);
        } finally {
            return false;
        }

    };


    /**
     * Cancel the reconnection of user account (network issue)
     * @public
     * @return {boolean}
     */
    self.cancelReconnect = function() {

        try {
            Console.info('User has canceled automatic reconnection...');
            
            // Stop the timer
            $('#reconnect a.finish.reconnect').stopTime();
            
            // Remove the reconnect pane
            $('#reconnect').remove();
            
            // Destroy the talk page
            Talk.destroy();
            
            // Renitialize the previous session parameters
            self.resetConMarkers();
        } catch(e) {
            Console.error('Connection.cancelReconnect', e);
        } finally {
            return false;
        }

    };


    /**
     * Clears session reminder database
     * @public
     * @return {undefined}
     */
    self.clearLastSession = function() {

        try {
            // Clear temporary storage
            self.resetConMarkers();
            
            // Clear persistent storage
            if($(Common.XMLFromString(DataStore.getPersistent('global', 'session', 1))).find('stored').text() == 'true') {
                DataStore.removePersistent('global', 'session', 1);
            }
        } catch(e) {
            Console.error('Connection.clearLastSession', e);
        }

    };


    /**
     * Resets the connection markers
     * @public
     * @return {undefined}
     */
    self.resetConMarkers = function() {

        try {
            self.current_session = false;
            self.connected = false;
            self.resume = false;
            self.reconnect_try = 0;
            self.reconnect_timer = 0;
        } catch(e) {
            Console.error('Connection.resetConMarkers', e);
        }

    };


    /**
     * Logins from a saved session
     * @public
     * @param {string} data
     * @return {undefined}
     */
    self.loginFromSession = function(data) {

        try {
            // Select the data
            var session = $(data);
            
            // Fire the login event
            self.doLogin(
                session.find('username').text(),
                session.find('domain').text(),
                session.find('password').text(),
                session.find('resource').text(),
                session.find('priority').text(),
                false
            );
        } catch(e) {
            Console.error('Connection.loginFromSession', e);
        }

    };


    /**
     * Quits a session normally
     * @public
     * @return {boolean}
     */
    self.normalQuit = function() {

        try {
            // Reset our database
            self.clearLastSession();
            
            // We quit the current session
            self.quit();
            
            // We show an info
            Board.openThisInfo(3);
        } catch(e) {
            Console.error('Connection.normalQuit', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets all the users stuff
     * @public
     * @return {undefined}
     */
    self.getEverything = function() {

        try {
            Features.get();
            Roster.get();
            Privacy.list();
            Storage.get(NS_ROSTERNOTES);
        } catch(e) {
            Console.error('Connection.getEverything', e);
        }

    };


    /**
     * Generates session data to store
     * @public
     * @param {string} lNick
     * @param {string} lServer
     * @param {string} lPass
     * @param {string} lResource
     * @param {number} lPriority
     * @param {boolean} lRemember
     * @return {undefined}
     */
    self.storeSession = function(lNick, lServer, lPass, lResource, lPriority, lRemember) {

        try {
            // Generate a session XML to be stored
            session_xml = '<session><stored>true</stored><domain>' + lServer.htmlEnc() + '</domain><username>' + lNick.htmlEnc() + '</username><resource>' + lResource.htmlEnc() + '</resource><password>' + lPass.htmlEnc() + '</password><priority>' + lPriority.htmlEnc() + '</priority></session>';
            
            // Save the session parameters (for reconnect if network issue)
            self.current_session = session_xml;
            
            // Remember me?
            if(lRemember) {
                DataStore.setDB(self.desktop_hash, 'remember', 'session', 1);
            }
            
            return session_xml;
        } catch(e) {
            Console.error('Connection.storeSession', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            $(document).ready(function() {
                // Logouts when Jappix is closed
                $(window).bind('beforeunload', Connection.terminate);
                
                // Nothing to do when anonymous!
                if(Utils.isAnonymous())
                    return;
                
                // Connection params submitted in URL?
                if(XMPPLinks.links_var.u && XMPPLinks.links_var.q) {
                    // Generate login data
                    var login_xid = Common.bareXID(Common.generateXID(XMPPLinks.links_var.u, 'chat'));
                    var login_nick = Common.getXIDNick(login_xid);
                    var login_server = Common.getXIDHost(login_xid);
                    var login_pwd = XMPPLinks.links_var.q;
                    var login_resource = JAPPIX_RESOURCE + ' (' + (new Date()).getTime() + ')';
                    var login_priority = '10';
                    var login_remember = 1;
                    
                    // Must store session?
                    if(XMPPLinks.links_var.h && (XMPPLinks.links_var.h === '1')) {
                        // Store session
                        var session_xml = self.storeSession(login_nick, login_server, login_pwd, login_resource, login_priority, true);
                        DataStore.setPersistent('global', 'session', 1, session_xml);
                        
                        // Redirect to a clean URL
                        document.location.href = './';
                    } else {
                        // Hide the homepage
                        $('#home').hide();
                        
                        // Show the waiting icon
                        Interface.showGeneralWait();
                        
                        // Proceed login
                        self.doLogin(login_nick, login_server, login_pwd, login_resource, login_priority, login_remember);
                    }
                    
                    return;
                }
                
                // Try to resume a stored session, if not anonymous
                var session = Common.XMLFromString(
                    DataStore.getPersistent('global', 'session', 1)
                );
                
                if($(session).find('stored').text() == 'true') {
                    // Hide the homepage
                    $('#home').hide();
                    
                    // Show the waiting icon
                    Interface.showGeneralWait();
                    
                    // Login!
                    self.loginFromSession(session);
                    
                    Console.info('Saved session found, resuming it...');
                }
                
                // Not connected, maybe a XMPP link is submitted?
                else if((parent.location.hash != '#OK') && XMPPLinks.links_var.x) {
                    Home.change('loginer');
                    
                    Console.info('A XMPP link is set, switch to login page.');
                }
            });
        } catch(e) {
            Console.error('Connection.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Connection.launch();
/*

Jappix - An open social platform
These are the dataform JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var DataForm = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};

    
    /**
     * Gets the defined dataform elements
     * @public
     * @param {string} host
     * @param {string} type
     * @param {string} node
     * @param {string} action
     * @param {string} target
     * @return {boolean}
     */
    self.go = function(host, type, node, action, target) {

        try {
            // Clean the current session
            self.clean(target);
            
            // We tell the user that a search has been launched
            $('#' + target + ' .wait').show();
            
            // If we have enough data
            if(host && type) {
                // Generate a session ID
                var sessionID = Math.round(100000.5 + (((900000.49999) - (100000.5)) * Math.random()));
                var id = target + '-' + sessionID + '-' + genID();
                $('.' + target + '-results').attr('data-session', target + '-' + sessionID);
                
                // We request the service item
                var iq = new JSJaCIQ();
                iq.setID(id);
                iq.setTo(host);
                iq.setType('get');
                
                // MUC admin query
                if(type == 'muc') {
                    iq.setQuery(NS_MUC_OWNER);
                    con.send(iq, self.handleMUC);
                }
                
                // Browse query
                else if(type == 'browse') {
                    var iqQuery = iq.setQuery(NS_DISCO_ITEMS);
                    
                    if(node)
                        iqQuery.setAttribute('node', node);
                    
                    con.send(iq, self.handleBrowse);
                }
                
                // Command
                else if(type == 'command') {
                    var items;
                    
                    if(node)
                        items = iq.appendNode('command', {'node': node, 'xmlns': NS_COMMANDS});
                    
                    else {
                        items = iq.setQuery(NS_DISCO_ITEMS);
                        items.setAttribute('node', NS_COMMANDS);
                    }
                    
                    if(action && node) {
                        iq.setType('set');
                        items.setAttribute('action', action);
                    }
                    
                    con.send(iq, self.handleCommand);
                }
                
                // Search query
                else if(type == 'search') {
                    iq.setQuery(NS_SEARCH);
                    con.send(iq, self.handleSearch);
                }
                
                // Subscribe query
                else if(type == 'subscribe') {
                    iq.setQuery(NS_REGISTER);
                    con.send(iq, self.handleSubscribe);
                }
                
                // Join
                else if(type == 'join') {
                    if(target == 'discovery')
                        Discovery.close();
                    
                    Chat.checkCreate(host, 'groupchat');
                }
            }
        } catch(e) {
            Console.error('DataForm.go', e);
        } finally {
            return false;
        }

    };


    /**
     * Sends a given dataform
     * @public
     * @param {string} type
     * @param {string} action
     * @param {string} x_type
     * @param {string} id
     * @param {string} xid
     * @param {string} node
     * @param {string} sessionid
     * @param {string} target
     * @return {boolean}
     */
    self.send = function(type, action, x_type, id, xid, node, sessionid, target) {

        try {
            // Path
            var pathID = '#' + target + ' .results[data-session="' + id + '"]';
            
            // New IQ
            var iq = new JSJaCIQ();
            iq.setTo(xid);
            iq.setType('set');
            
            // Set the correct query
            var query;
            
            if(type == 'subscribe')
                iqQuery = iq.setQuery(NS_REGISTER);
            else if(type == 'search')
                iqQuery = iq.setQuery(NS_SEARCH);
            else if(type == 'command')
                iqQuery = iq.appendNode('command', {'xmlns': NS_COMMANDS, 'node': node, 'sessionid': sessionid, 'action': action});
            else if(type == 'x')
                iqQuery = iq.setQuery(NS_MUC_OWNER);
            
            // Build the XML document
            if(action != 'cancel') {
                // No X node
                if(Common.exists('input.register-special') && (type == 'subscribe')) {
                    $('input.register-special').each(function() {
                        var iName = $(this).attr('name');
                        var iValue = $(this).val();
                        
                        iqQuery.appendChild(iq.buildNode(iName, {'xmlns': NS_REGISTER}, iValue));
                    });
                }
                
                // Can create the X node
                else {
                    var iqX = iqQuery.appendChild(iq.buildNode('x', {'xmlns': NS_XDATA, 'type': x_type}));
                    
                    // Each input
                    $(pathID + ' .oneresult input, ' + pathID + ' .oneresult textarea, ' + pathID + ' .oneresult select').each(function() {
                        // Get the current input value
                        var iVar = $(this).attr('name');
                        var iType = $(this).attr('data-type');
                        var iValue = $(this).val();
                        
                        // Build a new field node
                        var field = iqX.appendChild(iq.buildNode('field', {'var': iVar, 'type': iType, 'xmlns': NS_XDATA}));
                        
                        // Boolean input?
                        if(iType == 'boolean') {
                            if($(this).filter(':checked').size())
                                iValue = '1';
                            else
                                iValue = '0';
                        }
                        
                        // JID-multi input?
                        if(iType == 'jid-multi') {
                            // Values array
                            var xid_arr = [iValue];
                            var xid_check = [];
                            
                            // Try to split it
                            if(iValue.indexOf(',') != -1)
                                xid_arr = iValue.split(',');
                            
                            // Append each value to the XML document
                            for(var i in xid_arr) {
                                // Get the current value
                                xid_current = $.trim(xid_arr[i]);
                                
                                // No current value?
                                if(!xid_current)
                                    continue;
                                
                                // Add the current value
                                if(!Utils.existArrayValue(xid_check, xid_current)) {
                                    xid_check.push(xid_current);
                                    field.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, xid_current));
                                }
                            }
                        }
                        
                        // List-multi selector?
                        else if(iType == 'list-multi') {
                            // Any value?
                            if(iValue && iValue.length) {
                                for(var j in iValue) {
                                    field.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, iValue[j]));
                                }
                            }
                        }
                        
                        // Other inputs?
                        else
                            field.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, iValue));
                    });
                }
            }
            
            // Clean the current session
            self.clean(target);
            
            // Show the waiting item
            $('#' + target + ' .wait').show();
            
            // Change the ID of the current discovered item
            var iqID = target + '-' + genID();
            $('#' + target + ' .' + target + '-results').attr('data-session', iqID);
            iq.setID(iqID);
            
            // Send the IQ
            if(type == 'subscribe')
                con.send(iq, self.handleSubscribe);
            else if(type == 'search')
                con.send(iq, self.handleSearch);
            else if(type == 'command')
                con.send(iq, self.handleCommand);
            else
                con.send(iq);
        } catch(e) {
            Console.error('DataForm.send', e);
        } finally {
            return false;
        }

    };


    /**
     * Displays the good dataform buttons
     * @public
     * @param {string} type
     * @param {string} action
     * @param {string} id
     * @param {string} xid
     * @param {string} node
     * @param {string} sessionid
     * @param {string} target
     * @param {string} pathID
     * @return {undefined}
     */
    self.buttons = function(type, action, id, xid, node, sessionid, target, pathID) {

        try {
            // No need to use buttons?
            if(type == 'muc')
                return;
            
            // Override the "undefined" output
            if(!id)
                id = '';
            if(!xid)
                xid = '';
            if(!node)
                node = '';
            if(!sessionid)
                sessionid = '';
            
            // We generate the buttons code
            var buttonsCode = '<div class="oneresult ' + target + '-oneresult ' + target + '-formtools">';
            
            if(action == 'submit') {
                if((target == 'adhoc') && (type == 'command')) {
                    buttonsCode += '<a href="#" class="submit" onclick="return self.send(\'' + Utils.encodeOnclick(type) + '\', \'execute\', \'submit\', \'' + Utils.encodeOnclick(id) + '\', \'' + Utils.encodeOnclick(xid) + '\', \'' + Utils.encodeOnclick(node) + '\', \'' + Utils.encodeOnclick(sessionid) + '\', \'' + Utils.encodeOnclick(target) + '\');">' + Common._e("Submit") + '</a>';
                    
                    // When keyup on one text input
                    $(pathID + ' input').keyup(function(e) {
                        if(e.keyCode == 13) {
                            self.send(type, 'execute', 'submit', id, xid, node, sessionid, target);
                            
                            return false;
                        }
                    });
                }
                
                else {
                    buttonsCode += '<a href="#" class="submit" onclick="return self.send(\'' + Utils.encodeOnclick(type) + '\', \'submit\', \'submit\', \'' + Utils.encodeOnclick(id) + '\', \'' + Utils.encodeOnclick(xid) + '\', \'' + Utils.encodeOnclick(node) + '\', \'' + Utils.encodeOnclick(sessionid) + '\', \'' + Utils.encodeOnclick(target) + '\');">' + Common._e("Submit") + '</a>';
                    
                    // When keyup on one text input
                    $(pathID + ' input').keyup(function(e) {
                        if(e.keyCode == 13) {
                            self.send(type, 'submit', 'submit', id, xid, node, sessionid, target);
                            
                            return false;
                        }
                    });
                }
            }
            
            if((action == 'submit') && (type != 'subscribe') && (type != 'search'))
                buttonsCode += '<a href="#" class="submit" onclick="return self.send(\'' + Utils.encodeOnclick(type) + '\', \'cancel\', \'cancel\', \'' + Utils.encodeOnclick(id) + '\', \'' + Utils.encodeOnclick(xid) + '\', \'' + Utils.encodeOnclick(node) + '\', \'' + Utils.encodeOnclick(sessionid) + '\', \'' + Utils.encodeOnclick(target) + '\');">' + Common._e("Cancel") + '</a>';
            
            if(((action == 'back') || (type == 'subscribe') || (type == 'search')) && (target == 'discovery'))
                buttonsCode += '<a href="#" class="back" onclick="return Discovery.start();">' + Common._e("Close") + '</a>';
            
            if((action == 'back') && ((target == 'welcome') || (target == 'directory')))
                buttonsCode += '<a href="#" class="back" onclick="return DataForm.go(HOST_VJUD, \'search\', \'\', \'\', \'' + target + '\');">' + Common._e("Previous") + '</a>';
            
            if((action == 'back') && (target == 'adhoc'))
                buttonsCode += '<a href="#" class="back" onclick="return DataForm.go(\'' + Utils.encodeOnclick(xid) + '\', \'command\', \'\', \'\', \'adhoc\');">' + Common._e("Previous") + '</a>';
            
            buttonsCode += '</div>';
            
            // We display the buttons code
            $(pathID).append(buttonsCode);
            
            // If no submit link, lock the form
            if(!Common.exists(pathID + ' a.submit'))
                $(pathID + ' input, ' + pathID + ' textarea').attr('readonly', true);
        } catch(e) {
            Console.error('DataForm.buttons', e);
        }

    };


    /**
     * Handles the MUC dataform
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleMUC = function(iq) {

        try {
            Errors.handleReply(iq);
            self.handleContent(iq, 'muc');
        } catch(e) {
            Console.error('DataForm.handleMUC', e);
        }

    };


    /**
     * Handles the browse dataform
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleBrowse = function(iq) {

        try {
            Errors.handleReply(iq);
            self.handleContent(iq, 'browse');
        } catch(e) {
            Console.error('DataForm.handleBrowse', e);
        }

    };
    

    /**
     * Handles the command dataform
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleCommand = function(iq) {

        try {
            Errors.handleReply(iq);
            self.handleContent(iq, 'command');
        } catch(e) {
            Console.error('DataForm.handleCommand', e);
        }

    };


    /**
     * Handles the subscribe dataform
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleSubscribe = function(iq) {

        try {
            Errors.handleReply(iq);
            self.handleContent(iq, 'subscribe');
        } catch(e) {
            Console.error('DataForm.handleSubscribe', e);
        }

    };


    /**
     * Handles the search dataform
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleSearch = function(iq) {

        try {
            Errors.handleReply(iq);
            self.handleContent(iq, 'search');
        } catch(e) {
            Console.error('DataForm.handleSearch', e);
        }

    };


    /**
     * Handles the dataform content
     * @public
     * @param {object} iq
     * @param {string} type
     * @return {undefined}
     */
    self.handleContent = function(iq, type) {

        try {
            // Get the ID
            var sID = iq.getID();
            
            // Get the target
            var splitted = sID.split('-');
            var target = splitted[0];
            var sessionID = target + '-' + splitted[1];
            var from = Common.fullXID(Common.getStanzaFrom(iq));
            var pathID = '#' + target + ' .results[data-session="' + sessionID + '"]';
            
            // If an error occured
            if(!iq || (iq.getType() != 'result'))
                self.noResult(pathID);
            
            // If we got something okay
            else {
                var handleXML = iq.getNode();
                
                if(type == 'browse') {
                    if($(handleXML).find('item').attr('jid')) {
                        // Get the query node
                        var queryNode = $(handleXML).find('query').attr('node');
                        
                        $(handleXML).find('item').each(function() {
                            // We parse the received xml
                            var itemHost = $(this).attr('jid');
                            var itemNode = $(this).attr('node');
                            var itemName = $(this).attr('name');
                            var itemHash = hex_md5(itemHost);
                            
                            // Node
                            if(itemNode)
                                $(pathID).append(
                                    '<div class="oneresult ' + target + '-oneresult" onclick="return DataForm.go(\'' + Utils.encodeOnclick(itemHost) + '\', \'browse\', \'' + Utils.encodeOnclick(itemNode) + '\', \'\', \'' + Utils.encodeOnclick(target) + '\');">' + 
                                        '<div class="one-name">' + itemNode.htmlEnc() + '</div>' + 
                                    '</div>'
                                );
                            
                            // Item
                            else if(queryNode && itemName)
                                $(pathID).append(
                                    '<div class="oneresult ' + target + '-oneresult">' + 
                                        '<div class="one-name">' + itemName.htmlEnc() + '</div>' + 
                                    '</div>'
                                );
                            
                            // Item with children
                            else {
                                // We display the waiting element
                                $(pathID + ' .disco-wait .disco-category-title').after(
                                    '<div class="oneresult ' + target + '-oneresult ' + itemHash + '">' + 
                                        '<div class="one-icon loading talk-images"></div>' + 
                                        '<div class="one-host">' + itemHost + '</div>' + 
                                        '<div class="one-type">' + Common._e("Requesting this service...") + '</div>' + 
                                    '</div>'
                                );
                                
                                // We display the category
                                $('#' + target + ' .disco-wait').show();
                                
                                // We ask the server what's the service type
                                self.getType(itemHost, itemNode, sessionID);
                            }
                        });
                    }
                    
                    // Else, there are no items for this query
                    else
                        self.noResult(pathID);
                }
                
                else if((type == 'muc') || (type == 'search') || (type == 'subscribe') || ((type == 'command') && $(handleXML).find('command').attr('xmlns'))) {
                    // Get some values
                    var xCommand = $(handleXML).find('command');
                    var bNode = xCommand.attr('node');
                    var bSession = xCommand.attr('sessionid');
                    var bStatus = xCommand.attr('status');
                    var xRegister = $(handleXML).find('query[xmlns="' + NS_REGISTER + '"]').text();
                    var xElement = $(handleXML).find('x');
                    
                    // Search done
                    if((xElement.attr('type') == 'result') && (type == 'search')) {
                        var bPath = pathID;
                        
                        // Display the result
                        $(handleXML).find('item').each(function() {
                            // Have some "flexibility" for what regards field names, it would be better to return the whole original DF
                            // layout, but on a large amount of result which have many fields, there's a very high chance the browser can
                            // choke on old systems or new ones even.

                            // Search for useful fields, return first result. This is rather hacky, but jQuery is horrible when it comes to
                            // matching st. using patterns. (TODO: Improve and return the full DF layout without choking the browser)
                            var bName;
                            var bCountry;
                            var doneName, doneCountry;

                            $.each($(this).find('field'), function(i, item)
                            {                                                                                                                                                                                                                      
                                var $item = $(item);
                                if ($(item).attr('var').match(/^(fn|name|[^n][^i][^c][^k]name)$/gi) && doneName !== true) {
                                    bName = $item.children('value:first').text();
                                    doneName = true;
                                } else if ($(item).attr('var').match(/^(ctry|country.*)$/gi) && doneCountry !== true) {
                                    bCountry = $item.children('value:first').text();
                                    doneCountry = true;
                                }
                            });

                            var bXID = $(this).find('field[var="jid"] value:first').text();
                            var dName = bName;
                            
                            // Override "undefined" value
                            if(!bXID)
                                bXID = '';
                            if(!bName)
                                bName = Common._e("Unknown name");
                            if(!bCountry)
                                bCountry = Common._e("Unknown country");
                            
                            // User hash
                            var bHash = hex_md5(bXID);
                            
                            // HTML code
                            var bHTML = '<div class="oneresult ' + target + '-oneresult ' + bHash + '">' + 
                                    '<div class="avatar-container">' + 
                                        '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                                    '</div>' + 
                                    '<div class="one-fn">' + bName + '</div>' + 
                                    '<div class="one-ctry">' + bCountry + '</div>' + 
                                    '<div class="one-jid">' + bXID + '</div>' + 
                                    '<div class="buttons-container">';
                            
                            // The buddy is not in our buddy list?
                            if(!Common.exists('#roster .buddy[data-xid="' + escape(bXID) + '"]'))
                                bHTML += '<a href="#" class="one-add one-vjud one-button talk-images">' + Common._e("Add") + '</a>';
                            
                            // Chat button, if not in welcome/directory mode
                            if(target == 'discovery')
                                bHTML += '<a href="#" class="one-chat one-vjud one-button talk-images">' + Common._e("Chat") + '</a>';
                            
                            // Profile button, if not in discovery mode
                            else
                                bHTML += '<a href="#" class="one-profile one-vjud one-button talk-images">' + Common._e("Profile") + '</a>';
                            
                            // Close the HTML element
                            bHTML += '</div></div>';
                            
                            $(bPath).append(bHTML);
                            
                            // Click events
                            $(bPath + ' .' + bHash + ' a').click(function() {
                                // Buddy add
                                if($(this).is('.one-add')) {
                                    $(this).hide();
                                    
                                    Roster.addThisContact(bXID, dName);
                                }
                                
                                // Buddy chat
                                if($(this).is('.one-chat')) {
                                    if(target == 'discovery')
                                        Discovery.close();
                                    
                                    Chat.checkCreate(bXID, 'chat', '', '', dName);
                                }
                                
                                // Buddy profile
                                if($(this).is('.one-profile'))
                                    UserInfos.open(bXID);
                                
                                return false;
                            });
                            
                            // Get the user's avatar
                            if(bXID)
                                Avatar.get(bXID, 'cache', 'true', 'forget');
                        });
                        
                        // No result?
                        if(!$(handleXML).find('item').size())
                            self.noResult(pathID);
                        
                        // Previous button
                        self.buttons(type, 'back', sessionID, from, bNode, bSession, target, pathID);
                    }
                    
                    // Command to complete
                    else if(xElement.attr('xmlns') || ((type == 'subscribe') && xRegister)) {
                        // We display the elements
                        self.fill(handleXML, sessionID);
                        
                        // We display the buttons
                        if(bStatus != 'completed')
                            self.buttons(type, 'submit', sessionID, from, bNode, bSession, target, pathID);
                        else
                            self.buttons(type, 'back', sessionID, from, bNode, bSession, target, pathID);
                    }
                    
                    // Command completed or subscription done
                    else if(((bStatus == 'completed') && (type == 'command')) || (!xRegister && (type == 'subscribe'))) {
                        // Display the good text
                        var cNote = $(xCommand).find('note');
                        
                        // Any note?
                        if(cNote.size()) {
                            cNote.each(function() {
                                $(pathID).append(
                                    '<div class="onetitle ' + target + '-oneresult">' + $(this).text().htmlEnc() + '</div>'
                                );
                            });
                        }
                        
                        // Default text
                        else
                            $(pathID).append('<div class="oneinstructions ' + target + '-oneresult">' + Common._e("Your form has been sent.") + '</div>');
                        
                        // Display the back button
                        self.buttons(type, 'back', sessionID, from, '', '', target, pathID);
                        
                        // Add the gateway to our roster if subscribed
                        if(type == 'subscribe')
                            Roster.addThisContact(from);
                    }
                    
                    // Command canceled
                    else if((bStatus == 'canceled') && (type == 'command')) {
                        if(target == 'discovery')
                            Discovery.start();
                        else if(target == 'adhoc')
                            dataForm(from, 'command', '', '', 'adhoc');
                    }
                    
                    // No items for this query
                    else
                        self.noResult(pathID);
                }
                
                else if(type == 'command') {
                    if($(handleXML).find('item').attr('jid')) {
                        // We display the elements
                        $(handleXML).find('item').each(function() {
                            // We parse the received xml
                            var itemHost = $(this).attr('jid');
                            var itemNode = $(this).attr('node');
                            var itemName = $(this).attr('name');
                            var itemHash = hex_md5(itemHost);
                            
                            // We display the waiting element
                            $(pathID).prepend(
                                '<div class="oneresult ' + target + '-oneresult ' + itemHash + '" onclick="return DataForm.go(\'' + Utils.encodeOnclick(itemHost) + '\', \'command\', \'' + Utils.encodeOnclick(itemNode) + '\', \'execute\', \'' + Utils.encodeOnclick(target) + '\');">' + 
                                    '<div class="one-name">' + itemName + '</div>' + 
                                    '<div class="one-next">¬ª</div>' + 
                                '</div>'
                            );
                        });
                    }
                    
                    // Else, there are no items for this query
                    else
                        self.noResult(pathID);
                }
            }
            
            // Focus on the first input
            $(document).oneTime(10, function() {
                $(pathID + ' input:visible:first').focus();
            });
            
            // Hide the wait icon
            $('#' + target + ' .wait').hide();
        } catch(e) {
            Console.error('DataForm.handleContent', e);
        }

    };


    /**
     * Fills the dataform elements
     * @public
     * @param {type} xml
     * @param {type} id
     * @return {boolean}
     */
    self.fill = function(xml, id) {

        /* REF: http://xmpp.org/extensions/xep-0004.html */

        try {
            // Initialize new vars
            var target = id.split('-')[0];
            var pathID = '#' + target + ' .results[data-session="' + id + '"]';
            var selector, is_dataform;
            
            // Is it a dataform?
            if($(xml).find('x[xmlns="' + NS_XDATA + '"]').size())
                is_dataform = true;
            else
                is_dataform = false;
            
            // Determines the good selector to use
            if(is_dataform)
                selector = $(xml).find('x[xmlns="' + NS_XDATA + '"]');
            else
                selector = $(xml);
            
            // Form title
            selector.find('title').each(function() {
                $(pathID).append(
                    '<div class="onetitle ' + target + '-oneresult">' + $(this).text().htmlEnc() + '</div>'
                );
            });
            
            // Form instructions
            selector.find('instructions').each(function() {
                $(pathID).append(
                    '<div class="oneinstructions ' + target + '-oneresult">' + $(this).text().htmlEnc() + '</div>'
                );
            });
            
            // Register?
            if(!is_dataform) {
                // Items to detect
                var reg_names = [Common._e("Nickname"), Common._e("Name"), Common._e("Password"), Common._e("E-mail")];
                var reg_ids = ['username', 'name', 'password', 'email'];
                
                // Append these inputs
                $.each(reg_names, function(a) {
                    selector.find(reg_ids[a]).each(function() {
                        $(pathID).append(
                            '<div class="oneresult ' + target + '-oneresult">' + 
                                '<label>' + reg_names[a] + '</label>' + 
                                '<input name="' + reg_ids[a] + '" type="text" class="register-special dataform-i" />' + 
                            '</div>'
                        );
                    });
                });
                
                return false;
            }
            
            // Dataform?
            selector.find('field').each(function() {
                // We parse the received xml
                var type = $(this).attr('type');
                var label = $(this).attr('label');
                var field = $(this).attr('var');
                var value = $(this).find('value:first').text();
                var required = '';
                
                // No value?
                if(!field)
                    return;
                
                // Required input?
                if($(this).find('required').size())
                    required = ' required=""';
                
                // Compatibility fix
                if(!label)
                    label = field;
                
                if(!type)
                    type = '';
                
                // Generate some values
                var input;
                var hideThis = '';
                
                // Fixed field
                if(type == 'fixed')
                    $(pathID).append('<div class="oneinstructions">' + value.htmlEnc() + '</div>');
                
                else {
                    // Hidden field
                    if(type == 'hidden') {
                        hideThis = ' style="display: none;"';
                        input = '<input name="' + Common.encodeQuotes(field) + '" data-type="' + Common.encodeQuotes(type) + '" type="hidden" class="dataform-i" value="' + Common.encodeQuotes(value) + '" ' + required + ' />';
                    }

                    // Boolean field
                    else if(type == 'boolean') {
                        var checked;
                        
                        if(value == '1')
                            checked = 'checked';
                        else
                            checked = '';
                        
                        input = '<input name="' + Common.encodeQuotes(field) + '" type="checkbox" data-type="' + Common.encodeQuotes(type) + '" class="dataform-i df-checkbox" ' + checked + required + ' />';
                    }
                    
                    // List-single/list-multi field
                    else if((type == 'list-single') || (type == 'list-multi')) {
                        var multiple = '';
                        
                        // Multiple options?
                        if(type == 'list-multi')
                            multiple = ' multiple=""';
                        
                        // Append the select field
                        input = '<select name="' + Common.encodeQuotes(field) + '" data-type="' + Common.encodeQuotes(type) + '" class="dataform-i"' + required + multiple + '>';
                        var selected;
                        
                        // Append the available options
                        $(this).find('option').each(function() {
                            var nLabel = $(this).attr('label');
                            var nValue = $(this).find('value').text();
                            
                            // No label?
                            if(!nLabel)
                                nLabel = nValue;
                            
                            // If this is the selected value
                            if(nValue == value)
                                selected = 'selected';
                            else
                                selected = '';
                            
                            input += '<option ' + selected + ' value="' + Common.encodeQuotes(nValue) + '">' + nLabel.htmlEnc() + '</option>';
                        });
                        
                        input += '</select>';
                    }
                    
                    // Text-multi field
                    else if(type == 'text-multi')
                        input = '<textarea rows="8" cols="60" data-type="' + Common.encodeQuotes(type) + '" name="' + Common.encodeQuotes(field) + '" class="dataform-i"' + required + '>' + value.htmlEnc() + '</textarea>';
                    
                    // JID-multi field
                    else if(type == 'jid-multi') {
                        // Put the XID into an array
                        var xid_arr = [];
                        
                        $(this).find('value').each(function() {
                            var cValue = $(this).text();
                            
                            if(!Utils.existArrayValue(xid_arr, cValue))
                                xid_arr.push(cValue);
                        });
                        
                        // Sort the array
                        xid_arr.sort();
                        
                        // Create the input
                        var xid_value = '';
                        
                        if(xid_arr.length) {
                            for(var i in xid_arr) {
                                // Any pre-value
                                if(xid_value)
                                    xid_value += ', ';
                                
                                // Add the current XID
                                xid_value += xid_arr[i];
                            }
                        }
                        
                        input = '<input name="' + Common.encodeQuotes(field) + '" data-type="' + Common.encodeQuotes(type) + '" type="text" class="dataform-i" value="' + Common.encodeQuotes(xid_value) + '" placeholder="jack@jappix.com, jones@jappix.com"' + required + ' />';
                    }
                    
                    // Other stuffs that are similar
                    else {
                        // Text-single field
                        var iType = 'text';
                        
                        // Text-private field
                        if(type == 'text-private')
                            iType = 'password';
                        
                        // JID-single field
                        else if(type == 'jid-single')
                            iType = 'email';
                        
                        input = '<input name="' + Common.encodeQuotes(field) + '" data-type="' + Common.encodeQuotes(type) + '" type="' + iType + '" class="dataform-i" value="' + Common.encodeQuotes(value) + '"' + required + ' />';
                    }
                    
                    // Append the HTML markup for this field
                    $(pathID).append(
                        '<div class="oneresult ' + target + '-oneresult"' + hideThis + '>' + 
                            '<label>' + label.htmlEnc() + '</label>' + 
                            input + 
                        '</div>'
                    );
                }
            });
        } catch(e) {
            Console.error('DataForm.fill', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the dataform type
     * @public
     * @param {string} host
     * @param {string} node
     * @param {string} id
     * @return {undefined}
     */
    self.getType = function(host, node, id) {

        try {
            var iq = new JSJaCIQ();
            iq.setID(id + '-' + genID());
            iq.setTo(host);
            iq.setType('get');
            
            var iqQuery = iq.setQuery(NS_DISCO_INFO);
            
            if(node) {
                iqQuery.setAttribute('node', node);
            }
            
            con.send(iq, self.handleThisBrowse);
        } catch(e) {
            Console.error('DataForm.getType', e);
        }

    };


    /**
     * Handles the browse stanza
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleThisBrowse = function(iq) {

        /* REF: http://xmpp.org/registrar/disco-categories.html */

        try {
            var id = iq.getID();
            var splitted = id.split('-');
            var target = splitted[0];
            var sessionID = target + '-' + splitted[1];
            var from = Common.fullXID(Common.getStanzaFrom(iq));
            var hash = hex_md5(from);
            var handleXML = iq.getQuery();
            var pathID = '#' + target + ' .results[data-session="' + sessionID + '"]';
            
            // We first remove the waiting element
            $(pathID + ' .disco-wait .' + hash).remove();
            
            if($(handleXML).find('identity').attr('type')) {
                var category = $(handleXML).find('identity').attr('category');
                var type = $(handleXML).find('identity').attr('type');
                var named = $(handleXML).find('identity').attr('name');
                
                if(named)
                    gName = named;
                else
                    gName = '';
                
                var one, two, three, four, five;
                
                // Get the features that this entity supports
                var findFeature = $(handleXML).find('feature');
                
                for(var i in findFeature) {
                    var current = findFeature.eq(i).attr('var');
                    
                    switch(current) {
                        case NS_SEARCH:
                            one = 1;
                            break;
                        
                        case NS_MUC:
                            two = 1;
                            break;
                        
                        case NS_REGISTER:
                            three = 1;
                            break;
                        
                        case NS_COMMANDS:
                            four = 1;
                            break;
                        
                        case NS_DISCO_ITEMS:
                            five = 1;
                            break;
                        
                        default:
                            break;
                    }
                }
                
                var buttons = Array(one, two, three, four, five);
                
                // We define the toolbox links depending on the supported features
                var tools = '';
                var aTools = Array('search', 'join', 'subscribe', 'command', 'browse');
                var bTools = Array(Common._e("Search"), Common._e("Join"), Common._e("Subscribe"), Common._e("Command"), Common._e("Browse"));
                
                for(var b in buttons) {
                    if(buttons[b]) {
                        tools += '<a href="#" class="one-button ' + aTools[b] + ' talk-images" onclick="return DataForm.go(\'' + Utils.encodeOnclick(from) + '\', \'' + Utils.encodeOnclick(aTools[b]) + '\', \'\', \'\', \'' + Utils.encodeOnclick(target) + '\');" title="' + Utils.encodeOnclick(bTools[b]) + '"></a>';
                    }
                }
                
                // As defined in the ref, we detect the type of each category to put an icon
                switch(category) {
                    case 'account':
                    case 'auth':
                    case 'automation':
                    case 'client':
                    case 'collaboration':
                    case 'component':
                    case 'conference':
                    case 'directory':
                    case 'gateway':
                    case 'headline':
                    case 'hierarchy':
                    case 'proxy':
                    case 'pubsub':
                    case 'server':
                    case 'store':
                        break;
                    
                    default:
                        category = 'others';
                }
                
                // We display the item we found
                $(pathID + ' .disco-' + category + ' .disco-category-title').after(
                    '<div class="oneresult ' + target + '-oneresult ' + hash + '">' + 
                        '<div class="one-icon ' + category + ' talk-images"></div>' + 
                        '<div class="one-host">' + from + '</div>' + 
                        '<div class="one-type">' + gName + '</div>' + 
                        '<div class="one-actions">' + tools + '</div>' + 
                    '</div>'
                );
                
                // We display the category
                $(pathID + ' .disco-' + category).show();
            }
            
            else {
                $(pathID + ' .disco-others .disco-category-title').after(
                    '<div class="oneresult ' + target + '-oneresult">' + 
                        '<div class="one-icon down talk-images"></div>' + 
                        '<div class="one-host">' + from + '</div>' + 
                        '<div class="one-type">' + Common._e("Service offline or broken") + '</div>' + 
                    '</div>'
                );
                
                // We display the category
                $(pathID + ' .disco-others').show();
            }
            
            // We hide the waiting stuffs if there's no remaining loading items
            if(!$(pathID + ' .disco-wait .' + target + '-oneresult').size()) {
                $(pathID + ' .disco-wait, #' + target + ' .wait').hide();
            }
        } catch(e) {
            Console.error('DataForm.handleThisBrowse', e);
        }

    };


    /**
     * Cleans the current data-form popup
     * @public
     * @param {string} target
     * @return {undefined}
     */
    self.clean = function(target) {

        try {
            if(target == 'discovery') {
                Discovery.clean();
            } else {
                $('#' + target + ' div.results').empty();
            }
        } catch(e) {
            Console.error('DataForm.clean', e);
        }

    };


    /**
     * Displays the no result indicator
     * @public
     * @param {string} path
     * @return {undefined}
     */
    self.noResult = function(path) {

        try {
            $(path).prepend('<p class="no-results">' + Common._e("Sorry, but the entity didn't return any result!") + '</p>');
        } catch(e) {
            Console.error('DataForm.noResult', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the discovery JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Discovery = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the discovery popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Service discovery") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="discovery-head">' + 
                    '<div class="disco-server-text">' + Common._e("Server to query") + '</div>' + 
                    
                    '<input name="disco-server-input" class="disco-server-input" value="' + Common.encodeQuotes(HOST_MAIN) + '" />' + 
                '</div>' + 
                
                '<div class="results discovery-results">' + 
                    '<div class="disco-category disco-account">' + 
                        '<p class="disco-category-title">' + Common._e("Accounts") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-auth">' + 
                        '<p class="disco-category-title">' + Common._e("Authentications") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-automation">' + 
                        '<p class="disco-category-title">' + Common._e("Automation") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-client">' + 
                        '<p class="disco-category-title">' + Common._e("Clients") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-collaboration">' + 
                        '<p class="disco-category-title">' + Common._e("Collaboration") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-component">' + 
                        '<p class="disco-category-title">' + Common._e("Components") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-conference">' + 
                        '<p class="disco-category-title">' + Common._e("Rooms") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-directory">' + 
                        '<p class="disco-category-title">' + Common._e("Directories") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-gateway">' + 
                        '<p class="disco-category-title">' + Common._e("Gateways") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-headline">' + 
                        '<p class="disco-category-title">' + Common._e("News") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-hierarchy">' + 
                        '<p class="disco-category-title">' + Common._e("Hierarchy") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-proxy">' + 
                        '<p class="disco-category-title">' + Common._e("Proxies") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-pubsub">' + 
                        '<p class="disco-category-title">' + Common._e("Publication/Subscription") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-server">' + 
                        '<p class="disco-category-title">' + Common._e("Server") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-store">' + 
                        '<p class="disco-category-title">' + Common._e("Storage") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-others">' + 
                        '<p class="disco-category-title">' + Common._e("Others") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="disco-category disco-wait">' + 
                        '<p class="disco-category-title">' + Common._e("Loading") + '</p>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('discovery', html);
            
            // Associate the events
            self.instance();
            
            // We request a disco to the default server
            self.start();
        } catch(e) {
            Console.error('Discovery.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Quits the discovery popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('discovery');
        } catch(e) {
            Console.error('Discovery.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Launches a discovery
     * @public
     * @return {boolean}
     */
    self.start = function() {

        /* REF: http://xmpp.org/extensions/xep-0030.html */

        try {
            // We get the server to query
            var discoServer = $('#discovery .disco-server-input').val();
            
            // We launch the items query
            DataForm.go(discoServer, 'browse', '', '', 'discovery');
            
            Console.log('Service discovery launched: ' + discoServer);
        } catch(e) {
            Console.error('Discovery.start', e);
        } finally {
            return false;
        }

    };


    /**
     * Cleans the discovery results
     * @public
     * @return {boolean}
     */
    self.clean = function() {

        try {
            // We remove the results
            $('#discovery .discovery-oneresult, #discovery .oneinstructions, #discovery .onetitle, #discovery .no-results').remove();
            
            // We clean the user info
            $('#discovery .disco-server-info').text('');
            
            // We hide the wait icon, the no result alert and the results
            $('#discovery .wait, #discovery .disco-category').hide();
        } catch(e) {
            Console.error('Discovery.clean', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click event
            $('#discovery .bottom .finish').click(self.close);
            
            // Keyboard event
            $('#discovery .disco-server-input').keyup(function(e) {
                if(e.keyCode == 13) {
                    // No value?
                    if(!$(this).val())
                        $(this).val(HOST_MAIN);
                    
                    // Start the discovery
                    self.start();
                    
                    return false;
                }
            });
        } catch(e) {
            Console.error('Discovery.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the directory JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Directory = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the directory popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("User directory") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="directory-head">' + 
                    '<div class="directory-server-text">' + Common._e("Server to query") + '</div>' + 
                    
                    '<input name="directory-server-input" class="directory-server-input" value="' + Common.encodeQuotes(HOST_VJUD) + '" />' + 
                '</div>' + 
                
                '<div class="results directory-results"></div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('directory', html);
            
            // Associate the events
            self.instance();
            
            // Start a search!
            self.start();
        } catch(e) {
            Console.error('Directory.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Quits the directory popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('directory');
        } catch(e) {
            Console.error('Directory.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Launches a directory search
     * @public
     * @return {boolean}
     */
    self.start = function() {

        try {
            // Get the server to query
            var server = $('#directory .directory-server-input').val();
            
            // Launch the search!
            DataForm.go($('#directory .directory-server-input').val(), 'search', '', '', 'directory');
            
            Console.log('Directory search launched: ' + server);
        } catch(e) {
            Console.error('Directory.start', e);
        } finally {
            return false;
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click event
            $('#directory .bottom .finish').click(self.close);
            
            // Keyboard event
            $('#directory .directory-server-input').keyup(function(e) {
                if(e.keyCode == 13) {
                    // No value?
                    if(!$(this).val())
                        $(this).val(HOST_VJUD);
                    
                    // Start the directory search
                    self.start();
                    
                    return false;
                }
            });
        } catch(e) {
            Console.error('Directory.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the Ad-Hoc JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var AdHoc = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the adhoc popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Commands") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="adhoc-head"></div>' + 
                
                '<div class="results adhoc-results"></div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('adhoc', html);
            
            // Associate the events
            self.launch();
        } catch(e) {
            Console.error('AdHoc.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Closes the adhoc popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('adhoc');
        } catch(e) {
            Console.error('AdHoc.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Retrieves an entity adhoc command
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.retrieve = function(xid) {

        try {
            // Open the popup
            self.open();
            
            // Add a XID marker
            $('#adhoc .adhoc-head').html('<b>' + Name.getBuddy(xid).htmlEnc() + '</b> (' + xid.htmlEnc() + ')');
            
            // Get the highest entity resource
            var highest = Presence.highestPriority(xid);
            
            if(highest)
                xid = highest;
            
            // Start a new adhoc command
            DataForm.go(xid, 'command', '', '', 'adhoc');
        } catch(e) {
            Console.error('AdHoc.retrieve', e);
        } finally {
            return false;
        }

    };


    /**
     * Starts an adhoc command on the user server
     * @public
     * @param {string} server
     * @return {undefined}
     */
    self.server = function(server) {

        try {
            // Open the popup
            self.open();
            
            // Add a XID marker
            $('#adhoc .adhoc-head').html('<b>' + server.htmlEnc() + '</b>');
            
            // Start a new adhoc command
            DataForm.go(server, 'command', '', '', 'adhoc');
        } catch(e) {
            Console.error('AdHoc.server', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            // Click event
            $('#adhoc .bottom .finish').click(
                self.close()
            );
        } catch(e) {
            Console.error('AdHoc.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the privacy JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Privacy = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the privacy popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Privacy") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="privacy-head">' + 
                    '<div class="list-left">' + 
                        '<span>' + Common._e("Choose") + '</span>' + 
                        '<select disabled=""></select>' + 
                        '<a href="#" class="list-remove one-button talk-images" title="' + Common._e("Remove") + '"></a>' + 
                    '</div>' + 
                    
                    '<div class="list-center"></div>' + 
                    
                    '<div class="list-right">' + 
                        '<span>' + Common._e("Add") + '</span>' + 
                        '<input type="text" placeholder="' + Common._e("List name") + '" />' + 
                    '</div>' + 
                '</div>' + 
                
                '<div class="privacy-item">' + 
                    '<span>' + Common._e("Item") + '</span>' + 
                    '<select disabled=""></select>' + 
                    '<a href="#" class="item-add one-button talk-images" title="' + Common._e("Add") + '"></a>' + 
                    '<a href="#" class="item-remove one-button talk-images" title="' + Common._e("Remove") + '"></a>' + 
                    '<a href="#" class="item-save one-button talk-images">' + Common._e("Save") + '</a>' + 
                    
                    '<div class="clear"></div>' + 
                '</div>' + 
                
                '<div class="privacy-form">' + 
                    '<div class="privacy-first">' + 
                        '<label><input type="radio" name="action" value="allow" disabled="" />' + Common._e("Allow") + '</label>' + 
                        '<label><input type="radio" name="action" value="deny" disabled="" />' + Common._e("Deny") + '</label>' + 
                    '</div>' + 
                    
                    '<div class="privacy-second">' + 
                        '<label><input type="radio" name="type" value="jid" disabled="" />' + Common._e("Address") + '</label>' + 
                        '<input type="text" name="jid" disabled="" />' + 
                        
                        '<label><input type="radio" name="type" value="group" disabled="" />' + Common._e("Group") + '</label>' + 
                        '<select name="group" disabled="">' + self.groupsToHTML() + '</select>' + 
                        
                        '<label><input type="radio" name="type" value="subscription" disabled="" />' + Common._e("Subscription") + '</label>' + 
                        '<select name="subscription" disabled="">' + 
                            '<option value="none">' + Common._e("None") + '</option>' + 
                            '<option value="both">' + Common._e("Both") + '</option>' + 
                            '<option value="from">' + Common._e("From") + '</option>' + 
                            '<option value="to">' + Common._e("To") + '</option>' + 
                        '</select>' + 
                        
                        '<label><input type="radio" name="type" value="everybody" disabled="" />' + Common._e("Everybody") + '</label>' + 
                    '</div>' + 
                    
                    '<div class="privacy-third">' + 
                        '<label><input type="checkbox" name="send-messages" disabled="" />' + Common._e("Send messages") + '</label>' + 
                        '<label><input type="checkbox" name="send-queries" disabled="" />' + Common._e("Send queries") + '</label>' + 
                        '<label><input type="checkbox" name="see-status" disabled="" />' + Common._e("See my status") + '</label>' + 
                        '<label><input type="checkbox" name="send-status" disabled="" />' + Common._e("Send his/her status") + '</label>' + 
                        '<label><input type="checkbox" name="everything" disabled="" />' + Common._e("Everything") + '</label>' + 
                    '</div>' + 
                    
                    '<div class="clear"></div>' + 
                '</div>' + 
                
                '<div class="privacy-active">' + 
                    '<label>' + Common._e("Order") + '<input type="text" name="order" value="1" disabled="" /></label>' + 
                    
                    '<div class="privacy-active-elements">' + 
                        '<label><input type="checkbox" name="active" disabled="" />' + Common._e("Active for this session") + '</label>' + 
                        '<label><input type="checkbox" name="default" disabled="" />' + Common._e("Always active") + '</label>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('privacy', html);
            
            // Associate the events
            self.instance();
            
            // Display the available privacy lists
            self.displayLists();
            
            // Get the first list items
            self.displayItems();
        } catch(e) {
            Console.error('Privacy.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Quits the privacy popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('privacy');
        } catch(e) {
            Console.error('Privacy.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Sets the received state for privacy block list
     * @public
     * @return {undefined}
     */
    self.received = function() {

        try {
            // Store marker
            DataStore.setDB(Connection.desktop_hash, 'privacy-marker', 'available', 'true');
            
            // Show privacy elements
            $('.privacy-hidable').show();
        } catch(e) {
            Console.error('Privacy.received', e);
        }

    };


    /**
     * Gets available privacy lists
     * @public
     * @return {undefined}
     */
    self.list = function() {

        try {
            // Build query
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            iq.setQuery(NS_PRIVACY);
            
            con.send(iq, self.handleList);
            
            Console.log('Getting available privacy list(s)...');
        } catch(e) {
            Console.error('Privacy.list', e);
        }

    };


    /**
     * Handles available privacy lists
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleList = function(iq) {

        try {
            // Error?
            if(iq.getType() == 'error') {
                return Console.warn('Privacy lists not supported!');
            }
            
            // Get IQ query content
            var iqQuery = iq.getQuery();
            
            // Save the content
            DataStore.setDB(Connection.desktop_hash, 'privacy-lists', 'available', Common.xmlToString(iqQuery));
            
            // Any block list?
            if($(iqQuery).find('list[name="block"]').size()) {
                // Not the default one?
                if(!$(iqQuery).find('default[name="block"]').size())
                    self.change('block', 'default');
                else
                    DataStore.setDB(Connection.desktop_hash, 'privacy-marker', 'default', 'block');
                
                // Not the active one?
                if(!$(iqQuery).find('active[name="block"]').size())
                    self.change('block', 'active');
                else
                    DataStore.setDB(Connection.desktop_hash, 'privacy-marker', 'active', 'block');
                
                // Get the block list rules
                self.get('block');
            }
            
            // Apply the received marker here
            else {
                Privacy.received();
            }
            
            Console.info('Got available privacy list(s).');
        } catch(e) {
            Console.error('Privacy.handleList', e);
        }

    };


    /**
     * Gets privacy lists
     * @public
     * @param {object} list
     * @return {undefined}
     */
    self.get = function(list) {

        try {
            // Build query
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            // Privacy query
            var iqQuery = iq.setQuery(NS_PRIVACY);
            iqQuery.appendChild(iq.buildNode('list', {'xmlns': NS_PRIVACY, 'name': list}));
            
            con.send(iq, self.handleGet);
            
            // Must show the wait item?
            if(Common.exists('#privacy')) {
                $('#privacy .wait').show();
            }
            
            Console.log('Getting privacy list(s): ' + list);
        } catch(e) {
            Console.error('Privacy.get', e);
        }

    };


    /**
     * Handles privacy lists
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleGet = function(iq) {

        try {
            // Apply a "received" marker
            Privacy.received();
            
            // Store the data for each list
            $(iq.getQuery()).find('list').each(function() {
                // Read list name
                var list_name = $(this).attr('name');
                
                // Store list content
                DataStore.setDB(Connection.desktop_hash, 'privacy', list_name, Common.xmlToString(this));
                
                // Is this a block list?
                if(list_name == 'block') {
                    // Reset buddies
                    $('#roster .buddy').removeClass('blocked');
                    
                    // XID types
                    $(this).find('item[action="deny"][type="jid"]').each(function() {
                        $('#roster .buddy[data-xid="' + escape($(this).attr('value')) + '"]').addClass('blocked');
                    });
                    
                    // Group types
                    $(this).find('item[action="deny"][type="group"]').each(function() {
                        $('#roster .group' + hex_md5($(this).attr('value')) + ' .buddy').addClass('blocked');
                    });
                }
            });
            
            // Must display it to the popup?
            if(Common.exists('#privacy')) {
                self.displayItems();
                
                $('#privacy .wait').hide();
            }
            
            Console.info('Got privacy list(s).');
        } catch(e) {
            Console.error('Privacy.handleGet', e);
        }

    };


    /**
     * Sets a privacy list
     * @public
     * @param {string} list
     * @param {object} types
     * @param {object} values
     * @param {object} actions
     * @param {object} orders
     * @param {object} presence_in
     * @param {object} presence_out
     * @param {object} msg
     * @param {object} iq_p
     * @return {undefined}
     */
    self.set = function(list, types, values, actions, orders, presence_in, presence_out, msg, iq_p) {

        try {
            // Build query
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // Privacy query
            var iqQuery = iq.setQuery(NS_PRIVACY);
            var iqList = iqQuery.appendChild(iq.buildNode('list', {'xmlns': NS_PRIVACY, 'name': list}));
            
            // Build the item elements
            if(types && types.length) {
                for(var i = 0; i < types.length; i++) {
                    // Item element
                    var iqItem = iqList.appendChild(iq.buildNode('item', {'xmlns': NS_PRIVACY}));
                    
                    // Item attributes
                    if(types[i])
                        iqItem.setAttribute('type', types[i]);
                    if(values[i])
                        iqItem.setAttribute('value', values[i]);
                    if(actions[i])
                        iqItem.setAttribute('action', actions[i]);
                    if(orders[i])
                        iqItem.setAttribute('order', orders[i]);
                    
                    // Child elements
                    if(presence_in[i])
                        iqItem.appendChild(iq.buildNode('presence-in', {'xmlns': NS_PRIVACY}));
                    if(presence_out[i])
                        iqItem.appendChild(iq.buildNode('presence-out', {'xmlns': NS_PRIVACY}));
                    if(msg[i])
                        iqItem.appendChild(iq.buildNode('message', {'xmlns': NS_PRIVACY}));
                    if(iq_p[i])
                        iqItem.appendChild(iq.buildNode('iq', {'xmlns': NS_PRIVACY}));
                }
            }
            
            con.send(iq, function(iq) {
                if(iq.getType() == 'result')
                    Console.log('Sent privacy list.');
                else
                    Console.error('Error sending privacy list.');
            });
            
            Console.log('Sending privacy list: ' + list);
        } catch(e) {
            Console.error('Privacy.set', e);
        }

    };


    /**
     * Push a privacy list item to a list
     * @public
     * @param {string} list
     * @param {string} type
     * @param {string} value
     * @param {string} action
     * @param {boolean} presence_in
     * @param {boolean} presence_out
     * @param {boolean} msg
     * @param {boolean} iq_p
     * @param {string} hash
     * @param {string} special_action
     * @return {undefined}
     */
    self.push = function(list, type, value, action, presence_in, presence_out, msg, iq_p, hash, special_action) {

        try {
            // Read the stored elements (to add them)
            var stored = Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'privacy', list));
            
            // Read the first value
            var first_val = value[0];

            // Order generation flow
            var order = [];
            var highest_order = 0;
            
            // Must remove the given value?
            if(special_action == 'remove') {
                type = [];
                value = [];
                action = [];
                presence_in = [];
                presence_out = [];
                iq_p = [];
            }
            
            // Serialize them to an array
            $(stored).find('item').each(function() {
                // Attributes
                var c_type = $(this).attr('type');
                var c_value = $(this).attr('value');
                var c_action = $(this).attr('action');
                var c_order = $(this).attr('order');
                
                // Generate hash
                var c_hash = hex_md5(c_type + c_value);
                
                // Do not push it twice!
                if(((c_hash != hash) && (special_action != 'roster')) || ((first_val != c_value) && (special_action == 'roster'))) {
                    if(!c_type)
                        c_type = '';
                    if(!c_value)
                        c_value = '';
                    if(!c_action)
                        c_action = '';
                    if(!c_order)
                        c_order = '';
                    
                    if(!isNaN(c_order) && parseInt(c_order) > highest_order)
                        highest_order = parseInt(c_order);

                    type.push(c_type);
                    value.push(c_value);
                    action.push(c_action);
                    order.push(c_order);
                    
                    // Child elements
                    if($(this).find('presence-in').size())
                        presence_in.push(true);
                    else
                        presence_in.push(false);
                    
                    if($(this).find('presence-out').size())
                        presence_out.push(true);
                    else
                        presence_out.push(false);
                    
                    if($(this).find('message').size())
                        msg.push(true);
                    else
                        msg.push(false);
                    
                    if($(this).find('iq').size())
                        iq_p.push(true);
                    else
                        iq_p.push(false);
                }
            });

            order.unshift((++highest_order) + '');
            
            // Send it!
            self.set(list, type, value, action, order, presence_in, presence_out, msg, iq_p);
        } catch(e) {
            Console.error('Privacy.push', e);
        }

    };


    /**
     * Change a privacy list status
     * @public
     * @param {string} list
     * @param {string} status
     * @return {undefined}
     */
    self.change = function(list, status) {

        try {
            // Yet sent?
            if(DataStore.getDB(Connection.desktop_hash, 'privacy-marker', status) == list)
                return;
            
            // Write a marker
            DataStore.setDB(Connection.desktop_hash, 'privacy-marker', status, list);
            
            // Build query
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // Privacy query
            var iqQuery = iq.setQuery(NS_PRIVACY);
            var iqStatus = iqQuery.appendChild(iq.buildNode(status, {'xmlns': NS_PRIVACY}));
            
            // Can add a "name" attribute?
            if(list)
                iqStatus.setAttribute('name', list);
            
            con.send(iq);
            
            Console.log('Changing privacy list status: ' + list + ' to: ' + status);
        } catch(e) {
            Console.error('Privacy.change', e);
        }

    };


    /**
     * Checks the privacy status (action) of a value
     * @public
     * @param {string} list
     * @param {string} value
     * @return {undefined}
     */
    self.status = function(list, value) {

        try {
            return $(Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'privacy', list))).find('item[value="' + value + '"]').attr('action');
        } catch(e) {
            Console.error('Privacy.status', e);
        }

    };


    /**
     * Converts the groups array into a <option /> string
     * @public
     * @return {string}
     */
    self.groupsToHTML = function() {

        var html = '';

        try {
            var groups = Roster.getAllGroups();
            
            // Generate HTML
            for(var i in groups) {
                html += '<option value="' + Common.encodeQuotes(groups[i]) +'">' + groups[i].htmlEnc() + '</option>';
            }
        } catch(e) {
            Console.error('Privacy.groupsToHTML', e);
        } finally {
            return html;
        }

    };


    /**
     * Displays the privacy lists
     * @public
     * @return {boolean}
     */
    self.displayLists = function() {

        try {
            // Initialize
            var code = '';
            var select = $('#privacy .privacy-head .list-left select');
            var data = Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'privacy-lists', 'available'));
            
            // Parse the XML data!
            $(data).find('list').each(function() {
                var list_name = $(this).attr('name');
                
                if(list_name)
                    code += '<option value="' + Common.encodeQuotes(list_name) + '">' + list_name.htmlEnc() + '</option>';
            });
            
            // Apply HTML code
            select.html(code);
            
            // Not empty?
            if(code)
                select.removeAttr('disabled');
            else
                select.attr('disabled', true);
        } catch(e) {
            Console.error('Privacy.displayLists', e);
        } finally {
            return true;
        }

    };


    /**
     * Displays the privacy items for a list
     * @public
     * @return {boolean}
     */
    self.displayItems = function() {

        try {
            // Reset the form
            self.clearForm();
            self.disableForm();
            
            // Initialize
            var code = '';
            var select = $('#privacy .privacy-item select');
            var list = $('#privacy .privacy-head .list-left select').val();
            
            // Reset the item select
            select.html('');
            
            // No list?
            if(!list)
                return false;
            
            // Reset the list status
            $('#privacy .privacy-active input[type="checkbox"]').removeAttr('checked');
            
            // Display the list status
            var status = ['active', 'default'];
            
            for(var s in status) {
                if(DataStore.getDB(Connection.desktop_hash, 'privacy-marker', status[s]) == list)
                    $('#privacy .privacy-active input[name=' + status[s] + ']').attr('checked', true);
            }
            
            // Try to read the stored items
            var items = Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'privacy', list));
            
            // Must retrieve the data?
            if(!items) {
                select.attr('disabled', true);
                
                return self.get(list);
            }
            
            else
                select.removeAttr('disabled');
            
            // Parse the XML data!
            $(items).find('item').each(function() {
                // Read attributes
                var item_type = $(this).attr('type');
                var item_value = $(this).attr('value');
                var item_action = $(this).attr('action');
                var item_order = $(this).attr('order');
                
                // Generate hash
                var item_hash = hex_md5(item_type + item_value + item_action + item_order);
                
                // Read sub-elements
                var item_presencein = $(this).find('presence-in').size();
                var item_presenceout = $(this).find('presence-out').size();
                var item_message = $(this).find('message').size();
                var item_iq = $(this).find('iq').size();
                
                // Apply default values (if missing)
                if(!item_type)
                    item_type = '';
                if(!item_value)
                    item_value = '';
                if(!item_action)
                    item_action = 'allow';
                if(!item_order)
                    item_order = '1';
                
                // Apply sub-elements values
                if(item_presencein)
                    item_presencein = 'true';
                else
                    item_presencein = 'false';
                
                if(item_presenceout)
                    item_presenceout = 'true';
                else
                    item_presenceout = 'false';
                
                if(item_message)
                    item_message = 'true';
                else
                    item_message = 'false';
                
                if(item_iq)
                    item_iq = 'true';
                else
                    item_iq = 'false';
                
                // Generate item description
                var desc = '';
                var desc_arr = [item_type, item_value, item_action, item_order];
                
                for(var d in desc_arr) {
                    // Nothing to display?
                    if(!desc_arr[d])
                        continue;
                    
                    if(desc)
                        desc += ' - ';
                    
                    desc += desc_arr[d];
                }
                
                // Add the select option
                code += '<option data-type="' + Common.encodeQuotes(item_type) + '" data-value="' + Common.encodeQuotes(item_value) + '" data-action="' + Common.encodeQuotes(item_action) + '" data-order="' + Common.encodeQuotes(item_order) + '" data-presence_in="' + Common.encodeQuotes(item_presencein) + '" data-presence_out="' + Common.encodeQuotes(item_presenceout) + '" data-message="' + Common.encodeQuotes(item_message) + '" data-iq="' + Common.encodeQuotes(item_iq) + '" data-hash="' + Common.encodeQuotes(item_hash) + '">' + 
                        desc + 
                    '</option>';
            });
            
            // Append the code
            select.append(code);
            
            // Display the first item form
            var first_item = select.find('option:first');
            self.displayForm(
                       first_item.attr('data-type'),
                       first_item.attr('data-value'),
                       first_item.attr('data-action'),
                       first_item.attr('data-order'),
                       first_item.attr('data-presence_in'),
                       first_item.attr('data-presence_out'),
                       first_item.attr('data-message'),
                       first_item.attr('data-iq')
                      );
            
            return true;
        } catch(e) {
            Console.error('Privacy.displayItems', e);
        }

    };


    /**
     * Displays the privacy form for an item
     * @public
     * @param {string} type
     * @param {string} value
     * @param {string} action
     * @param {string} order
     * @param {string} presence_in
     * @param {string} presence_out
     * @param {string} message
     * @param {string} iq
     * @return {undefined}
     */
    self.displayForm = function(type, value, action, order, presence_in, presence_out, message, iq) {

        try {
            // Reset the form
            self.clearForm();
            
            // Apply the action
            $('#privacy .privacy-first input[name="action"][value="' + action + '"]').attr('checked', true);
            
            // Apply the type & value
            var privacy_second = '#privacy .privacy-second';
            var privacy_type = privacy_second + ' input[name="type"]';
            var type_check, value_input;
            
            switch(type) {
                case 'jid':
                    type_check = privacy_type + '[value="jid"]';
                    value_input = privacy_second + ' input[type="text"][name="jid"]';
                    
                    break;
                
                case 'group':
                    type_check = privacy_type + '[value="group"]';
                    value_input = privacy_second + ' select[name="group"]';
                    
                    break;
                
                case 'subscription':
                    type_check = privacy_type + '[value="subscription"]';
                    value_input = privacy_second + ' select[name="subscription"]';
                    
                    break;
                
                default:
                    type_check = privacy_type + '[value="everybody"]';
                    
                    break;
            }
            
            // Check the target
            $(type_check).attr('checked', true);
            
            // Can apply a value?
            if(value_input)
                $(value_input).val(value);
            
            // Apply the things to do
            var privacy_do = '#privacy .privacy-third input[type="checkbox"]';
            
            if(presence_in == 'true')
                $(privacy_do + '[name="send-status"]').attr('checked', true);
            if(presence_out == 'true')
                $(privacy_do + '[name="see-status"]').attr('checked', true);
            if(message == 'true')
                $(privacy_do + '[name="send-messages"]').attr('checked', true);
            if(iq == 'true')
                $(privacy_do + '[name="send-queries"]').attr('checked', true);
            
            if(!$(privacy_do).filter(':checked').size())
                $(privacy_do + '[name="everything"]').attr('checked', true);
            
            // Apply the order
            $('#privacy .privacy-active input[name="order"]').val(order);
            
            // Enable the forms
            $('#privacy .privacy-form input, #privacy .privacy-form select, #privacy .privacy-active input').removeAttr('disabled');
        } catch(e) {
            Console.error('Privacy.displayForm', e);
        }

    };


    /**
     * Clears the privacy list form
     * @public
     * @return {undefined}
     */
    self.clearForm = function() {

        try {
            // Uncheck checkboxes & radio inputs
            $('#privacy .privacy-form input[type="checkbox"], #privacy .privacy-form input[type="radio"]').removeAttr('checked');
            
            // Reset select
            $('#privacy .privacy-form select option').removeAttr('selected');
            $('#privacy .privacy-form select option:first').attr('selected', true);
            
            // Reset text input
            $('#privacy .privacy-form input[type="text"]').val('');
            
            // Reset order input
            $('#privacy .privacy-active input[name="order"]').val('1');
        } catch(e) {
            Console.error('Privacy.clearForm', e);
        }

    };


    /**
     * Disables the privacy list form
     * @public
     * @return {undefined}
     */
    self.disableForm = function() {

        try {
            $('#privacy .privacy-form input, #privacy .privacy-form select, #privacy .privacy-active input').attr('disabled', true);
        } catch(e) {
            Console.error('Privacy.disableForm', e);
        }

    };


    /**
     * Enables the privacy list form
     * @public
     * @param {string} rank
     * @return {undefined}
     */
    self.enableForm = function(rank) {

        try {
            $('#privacy .privacy-' + rank + ' input, #privacy .privacy-' + rank + ' select').removeAttr('disabled');
        } catch(e) {
            Console.error('Privacy.enableForm', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#privacy .bottom .finish').click(Privacy.close);
            
            // Placeholder events
            $('#privacy input[placeholder]').placeholder();
            
            // Form events
            $('#privacy .privacy-head a.list-remove').click(function() {
                // Get list name
                var list = $('#privacy .privacy-head .list-left select').val();
                
                // No value?
                if(!list)
                    return false;
                
                // Remove it from popup
                $('#privacy .privacy-head .list-left select option[value="' + list + '"]').remove();
                
                // Nothing remaining?
                if(!Common.exists('#privacy .privacy-head .list-left select option'))
                    $('#privacy .privacy-head .list-left select option').attr('disabled', true);
                
                // Empty the item select
                $('#privacy .privacy-item select').attr('disabled', true).html('');
                
                // Disable this list before removing it
                var status = ['active', 'default'];
                
                for(var s in status) {
                    if(DataStore.getDB(Connection.desktop_hash, 'privacy-marker', status[s]) == list)
                        self.change('', status[s]);
                }
                
                // Remove from server
                self.set(list);
                
                // Reset the form
                self.clearForm();
                self.disableForm();
                
                return false;
            });
            
            $('#privacy .privacy-head .list-right input').keyup(function(e) {
                // Not enter?
                if(e.keyCode != 13)
                    return;
                
                // Get list name
                var list = $('#privacy .privacy-head .list-right input').val();
                var select = '#privacy .privacy-head .list-left select';
                var existed = true;
                
                // Create the new element
                if(!Common.exists(select + ' option[value="' + list + '"]')) {
                    // Marker
                    existed = false;
                    
                    // Create a new option
                    $(select).append('<option value="' + Common.encodeQuotes(list) + '">' + list.htmlEnc() + '</option>');
                    
                    // Reset the item select
                    $('#privacy .privacy-item select').attr('disabled', true).html('');
                }
                
                // Change the select value & enable it
                $(select).val(list).removeAttr('disabled');
                
                // Reset its value
                $(this).val('');
                
                // Reset the form
                self.clearForm();
                self.disableForm();
                
                // Must reload the list items?
                if(existed) {
                    self.displayItems();
                    $('#privacy .privacy-item select').removeAttr('disabled');
                }
            });
            
            $('#privacy .privacy-head .list-left select').change(self.displayItems);
            
            $('#privacy .privacy-item select').change(function() {
                // Get the selected item
                var item = $(this).find('option:selected');
                
                // Display the data!
                self.displayForm(
                       item.attr('data-type'),
                       item.attr('data-value'),
                       item.attr('data-action'),
                       item.attr('data-order'),
                       item.attr('data-presence_in'),
                       item.attr('data-presence_out'),
                       item.attr('data-message'),
                       item.attr('data-iq')
                      );
            });
            
            $('#privacy .privacy-item a.item-add').click(function() {
                // Cannot add anything?
                if(!Common.exists('#privacy .privacy-head .list-left select option:selected'))
                    return false;
                
                // Disable item select
                $('#privacy .privacy-item select').attr('disabled', true);
                
                // Reset the form
                self.clearForm();
                self.disableForm();
                
                // Enable first form item
                self.enableForm('first');
                self.enableForm('active');
                
                return false;
            });
            
            $('#privacy .privacy-item a.item-remove').click(function() {
                // Cannot add anything?
                if(!Common.exists('#privacy .privacy-head .list-left select option:selected'))
                    return false;
                
                // Get values
                var list = $('#privacy .privacy-head .list-left select').val();
                var selected = $('#privacy .privacy-item select option:selected');
                var item = selected.attr('data-value');
                var hash = selected.attr('data-hash');
                
                // Remove it from popup
                $('#privacy .privacy-item select option:selected').remove();
                
                // No more items in this list?
                if(!Common.exists('#privacy .privacy-item select option')) {
                    // Disable this select
                    $('#privacy .privacy-item select').attr('disabled', true);
                    
                    // Remove the privacy list select item
                    $('#privacy .privacy-head .list-left select option[value="' + list + '"]').remove();
                    
                    // No more privacy lists?
                    if(!Common.exists('#privacy .privacy-head .list-left select option'))
                        $('#privacy .privacy-head .list-left select').attr('disabled', true);
                    
                    // Disable this list before removing it
                    var status = ['active', 'default'];
                    
                    for(var s in status) {
                        if(DataStore.getDB(Connection.desktop_hash, 'privacy-marker', status[s]) == list)
                            self.change('', status[s]);
                    }
                }
                
                // Synchronize it with server
                self.push(list, [], [item], [], [], [], [], [], [], hash, 'remove');
                
                // Reset the form
                self.clearForm();
                self.disableForm();
                
                return false;
            });
            
            $('#privacy .privacy-item a.item-save').click(function() {
                // Canot push item?
                if(Common.exists('#privacy .privacy-form input:disabled'))
                    return false;
                
                // Get the hash
                var item_hash = '';
                
                if(!$('#privacy .privacy-item select').is(':disabled'))
                    item_hash = $('#privacy .privacy-item select option:selected').attr('data-hash');
                
                // Read the form
                var privacy_second = '#privacy .privacy-second';
                var item_list = $('#privacy .privacy-head .list-left select').val();
                var item_action = $('#privacy .privacy-first input[name="action"]').filter(':checked').val();
                var item_type = $(privacy_second + ' input[name="type"]').filter(':checked').val();
                var item_order = $('#privacy .privacy-active input[name="order"]').val();
                var item_value = '';
                
                // Switch the type to get the value
                switch(item_type) {
                    case 'jid':
                        item_value = $(privacy_second + ' input[type="text"][name="jid"]').val();
                        
                        break;
                    
                    case 'group':
                        item_value = $(privacy_second + ' select[name="group"]').val();
                        
                        break;
                    
                    case 'subscription':
                        item_value = $(privacy_second + ' select[name="subscription"]').val();
                        
                        break;
                    
                    default:
                        item_type = '';
                        
                        break;
                }
                
                // Get the selected things to do
                var privacy_third_cb = '#privacy .privacy-third input[type="checkbox"]';
                var item_prin = false;
                var item_prout = false;
                var item_msg = false;
                var item_iq = false;
                
                // Individual select?
                if(!$(privacy_third_cb + '[name="everything"]').filter(':checked').size()) {
                    if($(privacy_third_cb + '[name="send-messages"]').filter(':checked').size())
                        item_msg = true;
                    if($(privacy_third_cb + '[name="send-queries"]').filter(':checked').size())
                        item_iq = true;
                    if($(privacy_third_cb + '[name="send-queries"]').filter(':checked').size())
                        item_iq = true;
                    if($(privacy_third_cb + '[name="see-status"]').filter(':checked').size())
                        item_prout = true;
                    if($(privacy_third_cb + '[name="send-status"]').filter(':checked').size())
                        item_prin = true;
                }
                
                // Push item to the server!
                self.push(
                        item_list,
                        [item_type],
                        [item_value],
                        [item_action],
                        [item_order],
                        [item_prin],
                        [item_prout],
                        [item_msg],
                        [item_iq],
                        item_hash
                       );
                
                return false;
            });
            
            $('#privacy .privacy-first input').change(function() {
                self.enableForm('second');
            });
            
            $('#privacy .privacy-second input').change(function() {
                self.enableForm('third');
            });
            
            $('#privacy .privacy-third input[type="checkbox"]').change(function() {
                // Target
                var target = '#privacy .privacy-third input[type="checkbox"]';
                
                // Must tick "everything" checkbox?
                if(!$(target).filter(':checked').size())
                    $(target + '[name="everything"]').attr('checked', true);
                
                // Must untick the other checkboxes?
                else if($(this).is('[name="everything"]'))
                    $(target + ':not([name="everything"])').removeAttr('checked');
                
                // Must untick "everything" checkbox?
                else
                    $(target + '[name="everything"]').removeAttr('checked');
            });
            
            $('#privacy .privacy-active input[name="order"]').keyup(function() {
                // Get the value
                var value = $(this).val();
                
                // No value?
                if(!value)
                    return;
                
                // Not a number?
                if(isNaN(value))
                    value = 1;
                else
                    value = parseInt(value);
                
                // Negative?        
                if(value < 0)
                    value = value * -1;
                
                // Apply the filtered value
                $(this).val(value);
            })
            
            .blur(function() {
                // No value?
                if(!$(this).val())
                    $(this).val('1');
            });
            
            $('#privacy .privacy-active .privacy-active-elements input').change(function() {
                // Get the values
                var list_name = $('#privacy .privacy-head .list-left select').val();
                var state_name = $(this).attr('name');
                
                // Cannot continue?
                if(!list_name || !state_name)
                    return;
                
                // Change the current list status
                if($(this).filter(':checked').size())
                    self.change(list_name, state_name);
                else
                    self.change('', state_name);
            });
        } catch(e) {
            Console.error('Privacy.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the error functions for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Errors = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Shows the given error output
     * @public
     * @param {string} condition
     * @param {string} reason
     * @param {string} type
     * @return {undefined}
     */
    self.show = function(condition, reason, type) {

        try {
            // Enough data to output the error
            if(condition || reason) {
                // Initialize the error text
                var eText = '';
                
                // Any error condition
                if(condition)
                    eText += condition;
                
                // Any error type
                if(type && eText)
                    eText += ' (' + type + ')';
                
                // Any error reason
                if(reason) {
                    if(eText)
                        eText += ' - ';
                    
                    eText += reason;
                }
                
                // We reveal the error
                Board.openThisError(1);
                
                // Create the error text
                $('#board .one-board.error[data-id="1"] span').text(eText);
            }
            
            // Not enough data to output the error: output a generic board
            else {
                Board.openThisError(2);
            }
        } catch(e) {
            Console.error('Errors.show', e);
        }

    };


    /**
     * Handles the error from a packet and return true if any error
     * @public
     * @param {object} packet
     * @return {boolean}
     */
    self.handle = function(packet) {

        /* REF: http://xmpp.org/extensions/xep-0086.html */

        try {
            // Initialize
            var type, code, reason, condition;
            var node = $(packet);
            
            // First level error (connection error)
            if(node.is('error')) {
                // Get the value
                code = node.attr('code');
                
                // Specific error reason
                switch(code) {
                    case '401':
                        reason = Common._e("Authorization failed");
                        break;
                    
                    case '409':
                        reason = Common._e("Registration failed, please choose a different username");
                        break;
                    
                    case '503':
                        reason = Common._e("Service unavailable");
                        break;
                    
                    case '500':
                        reason = Common._e("Internal server error, try later");
                        break;
                    
                    default:
                        reason = node.find('text').text();
                        break;
                }
                
                // Remove the general wait item (security)
                Interface.removeGeneralWait();
                
                // Show reconnect pane
                if(Connection.current_session && Connection.connected) {
                    // Anonymous?
                    if(Utils.isAnonymous())
                        Connection.createReconnect('anonymous');
                    else
                        Connection.createReconnect('normal');
                }
                
                // Show the homepage (security)
                else if(!Connection.current_session || !Connection.connected) {
                    $('#home').show();
                    Interface.title('home');
                }
                
                // Still connected? (security)
                if(Common.isConnected()) {
                    con.disconnect();
                }
                
                Console.error('First level error received.');
            }
            
            // Second level error (another error)
            else if(node.find('error').size()) {
                type = node.find('error').attr('type');
                reason = node.find('error text').text();
                condition = packet.getElementsByTagName('error').item(0).childNodes.item(0).nodeName.replace(/-/g, ' ');
                
                Console.error('Second level error received.');
            } else {
                return false;
            }
            
            // Show the error board
            self.show(condition, reason, type);
            
            // Return there's an error
            return true;
        } catch(e) {
            Console.error('Errors.handle', e);
        }

    };


    /**
     * Handles the error reply of a packet
     * @public
     * @param {object} packet
     * @return {boolean}
     */
    self.handleReply = function(packet) {

        try {
            return self.handle(packet.getNode());
        } catch(e) {
            Console.error('Errors.handleReply', e);
        }

    };


    /**
     * Handles the error reply for a message
     * @public
     * @param {object} packet
     * @return {boolean}
     */
    self.handleMessage = function(packet) {

        try {
            if(!self.handleReply(packet)) {
                Message.handle(packet);
            }
        } catch(e) {
            Console.error('Errors.handleMessage', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the buddy name related JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Name = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Gets an user name for buddy add tool
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.getAddUser = function(xid) {

        try {
            var iq = new JSJaCIQ();
            iq.setType('get');
            iq.setTo(xid);
            
            iq.appendNode('vCard', {'xmlns': NS_VCARD});
            
            con.send(iq, self.handleAddUser);
        } catch(e) {
            Console.error('Name.getAddUser', e);
        }

    };


    /**
     * Handles an user name for buddy add tool
     * @public
     * @param {object} iq
     * @return {boolean}
     */
    self.handleAddUser = function(iq) {

        try {
            // Was it an obsolete request?
            if(!Common.exists('.add-contact-name-get[data-for="' + escape(Common.bareXID(Common.getStanzaFrom(iq))) + '"]'))
                return false;
            
            // Reset the waiting item
            $('.add-contact-name-get').hide().removeAttr('data-for');
            
            // Get the names
            if(iq.getType() == 'result') {
                var full_name = self.generateBuddy(iq)[0];
                
                if(full_name)
                    $('.add-contact-name').val(full_name);
            }
        } catch(e) {
            Console.error('Name.handleAddUser', e);
        } finally {
            return false;
        }

    };


    /**
     * Generates the good buddy name from a vCard IQ reply
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.generateBuddy = function(iq) {

        try {
            // Get the IQ content
            var xml = $(iq.getNode()).find('vCard');
            
            // Get the full name & the nickname
            var pFull = xml.find('FN:first').text();
            var pNick = xml.find('NICKNAME:first').text();
            
            // No full name?
            if(!pFull) {
                // Get the given name
                var pN = xml.find('N:first');
                var pGiven = pN.find('GIVEN:first').text();
                
                if(pGiven) {
                    pFull = pGiven;
                    
                    // Get the family name (optional)
                    var pFamily = pN.find('FAMILY:first').text();
                    
                    if(pFamily)
                        pFull += ' ' + pFamily;
                }
            }
            
            return [pFull, pNick];
        } catch(e) {
            Console.error('Name.generateBuddy', e);
        }

    };


    /**
     * Returns the given XID buddy name
     * @public
     * @param {string} xid
     * @return {string}
     */
    self.getBuddy = function(xid) {

        try {
            // Initialize
            var cname, bname;
            
            // Cut the XID resource
            xid = Common.bareXID(xid);
            
            // This is me?
            if(Utils.isAnonymous() && !xid)
                bname = Common._e("You");
            else if(xid == Common.getXID())
                bname = self.get();
            
            // Not me!
            else {
                cname = $('#roster .buddy[data-xid="' + escape(xid) + '"]:first .buddy-name').html();
                
                // If the complete name exists
                if(cname)
                    bname = cname.revertHtmlEnc();
                
                // Else, we just get the nickname of the buddy
                else
                    bname = Common.getXIDNick(xid);
            }
            
            return bname;
        } catch(e) {
            Console.error('Name.getBuddy', e);
        }

    };


    /**
     * Gets the nickname of the user
     * @public
     * @return {string}
     */
    self.getNick = function() {

        try {
            // Try to read the user nickname
            var nick = DataStore.getDB(Connection.desktop_hash, 'profile', 'nick');
            
            // No nick?
            if(!nick)
                nick = con.username;
            
            return nick;
        } catch(e) {
            Console.error('Name.getNick', e);
        }

    };


    /**
     * Gets the full name of the user
     * @public
     * @return {string}
     */
    self.get = function() {

        try {
            // Try to read the user name
            var name = DataStore.getDB(Connection.desktop_hash, 'profile', 'name');
            
            // No name? Use the nickname instead!
            if(!name)
                name = self.getNick();
            
            return name;
        } catch(e) {
            Console.error('Name.get', e);
        }

    };


    /**
     * Gets the MUC nickname of the user
     * @public
     * @param {string} id
     * @return {string}
     */
    self.getMUCNick = function(id) {

        try {
            return unescape($('#' + id).attr('data-nick'));
        } catch(e) {
            Console.error('Name.getMUCNick', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the favorites JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Favorites = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the favorites popup
     * @public
     * @return {undefined}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Manage favorite rooms") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="switch-fav">' + 
                    '<div class="room-switcher room-list">' + 
                        '<div class="icon list-icon talk-images"></div>' + 
                        
                        Common._e("Change favorites") + 
                    '</div>' + 
                    
                    '<div class="room-switcher room-search">' + 
                        '<div class="icon search-icon talk-images"></div>' + 
                        
                        Common._e("Search a room") + 
                    '</div>' + 
                '</div>' + 
                
                '<div class="static-fav">' + 
                    '<div class="favorites-edit favorites-content">' + 
                        '<div class="head fedit-head static-fav-head">' + 
                            '<div class="head-text fedit-head-text">' + Common._e("Select a favorite") + '</div>' + 
                            
                            '<select name="fedit-head-select" class="head-select fedit-head-select"></select>' + 
                        '</div>' + 
                        
                        '<div class="results fedit-results static-fav-results">' + 
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Name") + '</label>' + 
                                
                                '<input class="fedit-title" type="text" required="" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Nickname") + '</label>' + 
                                
                                '<input class="fedit-nick" type="text" value="' + Name.getNick() + '" required="" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Room") + '</label>' + 
                                
                                '<input class="fedit-chan" type="text" required="" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Server") + '</label>' + 
                                
                                '<input class="fedit-server" type="text" value="' + HOST_MUC + '" required="" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Password") + '</label>' + 
                                
                                '<input class="fedit-password" type="password" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-line">' + 
                                '<label>' + Common._e("Automatic") + '</label>' + 
                                
                                '<input type="checkbox" class="fedit-autojoin" />' + 
                            '</div>' + 
                            
                            '<div class="fedit-actions">' + 
                                '<a href="#" class="fedit-terminate fedit-add add one-button talk-images">' + Common._e("Add") + '</a>' + 
                                '<a href="#" class="fedit-terminate fedit-edit one-button talk-images">' + Common._e("Edit") + '</a>' + 
                                '<a href="#" class="fedit-terminate fedit-remove remove one-button talk-images">' + Common._e("Remove") + '</a>' + 
                            '</div>' + 
                        '</div>' + 
                    '</div>' + 
                    
                    '<div class="favorites-search favorites-content">' + 
                        '<div class="head fsearch-head static-fav-head">' + 
                            '<div class="head-text fsearch-head-text">' + Common._e("Search a room on") + '</div>' + 
                            
                            '<input type="text" class="head-input fsearch-head-server" value="' + HOST_MUC + '" />' + 
                        '</div>' + 
                        
                        '<div class="results fsearch-results static-fav-results">' + 
                            '<p class="fsearch-noresults">' + Common._e("No room found on this server.") + '</p>' + 
                        '</div>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('favorites', html);
            
            // Load the favorites
            self.load();
            
            // Associate the events
            self.instance();
        } catch(e) {
            Console.error('Favorites.open', e);
        }

    };


    /**
     * Resets the favorites elements
     * @public
     * @return {undefined}
     */
    self.reset = function() {

        try {
            var path = '#favorites ';
    
            $(path + '.wait, ' + path + '.fedit-terminate').hide();
            $(path + '.fedit-add').show();
            $(path + '.fsearch-oneresult').remove();
            $(path + 'input').val('');
            $(path + '.please-complete').removeClass('please-complete');
            $(path + '.fedit-nick').val(Name.getNick());
            $(path + '.fsearch-head-server, ' + path + '.fedit-server').val(HOST_MUC);
            $(path + '.fedit-autojoin').removeAttr('checked');
        } catch(e) {
            Console.error('Favorites.reset', e);
        }

    };


    /**
     * Quits the favorites popup
     * @public
     * @return {boolean}
     */
    self.quit = function() {

        try {
            // Destroy the popup
            Popup.destroy('favorites');
        } catch(e) {
            Console.error('Favorites.quit', e);
        } finally {
            return false;
        }

    };


    /**
     * Adds a room to the favorites
     * @public
     * @param {string} roomXID
     * @param {string} roomName
     * @return {boolean}
     */
    self.addThis = function(roomXID, roomName) {

        try {
            // Button path
            var button = '#favorites .fsearch-results div[data-xid="' + escape(roomXID) + '"] a.one-button';
            
            // Add a remove button instead of the add one
            $(button + '.add').replaceWith('<a href="#" class="one-button remove talk-images">' + Common._e("Remove") + '</a>');
            
            // Click event
            $(button + '.remove').click(function() {
                return self.removeThis(roomXID, roomName);
            });
            
            // Hide the add button in the (opened?) groupchat
            $('#' + hex_md5(roomXID) + ' .tools-add').hide();
            
            // Add the database entry
            self.display(roomXID, Common.explodeThis(' (', roomName, 0), Name.getNick(), '0', '');
            
            // Publish the favorites
            self.publish();
        } catch(e) {
            Console.error('Favorites.addThis', e);
        } finally {
            return false;
        }

    };


    /**
     * Removes a room from the favorites
     * @public
     * @param {string} roomXID
     * @param {string} roomName
     * @return {boolean}
     */
    self.removeThis = function(roomXID, roomName) {

        try {
            // Button path
            var button = '#favorites .fsearch-results div[data-xid="' + escape(roomXID) + '"] a.one-button';
            
            // Add a remove button instead of the add one
            $(button + '.remove').replaceWith('<a href="#" class="one-button add talk-images">' + Common._e("Add") + '</a>');
            
            // Click event
            $(button + '.add').click(function() {
                return self.addThis(roomXID, roomName);
            });
            
            // Show the add button in the (opened?) groupchat
            $('#' + hex_md5(roomXID) + ' .tools-add').show();
            
            // Remove the favorite
            self.remove(roomXID, true);
            
            // Publish the favorites
            self.publish();
        } catch(e) {
            Console.error('Favorites.removeThis', e);
        } finally {
            return false;
        }

    };


    /**
     * Edits a favorite
     * @public
     * @return {undefined}
     */
    self.edit = function() {

        try {
            // Path to favorites
            var favorites = '#favorites .';
            
            // Reset the favorites
            self.reset();
            
            // Show the edit/remove button, hide the others
            $(favorites + 'fedit-terminate').hide();
            $(favorites + 'fedit-edit').show();
            $(favorites + 'fedit-remove').show();
            
            // We retrieve the values
            var xid = $(favorites + 'fedit-head-select').val();
            var data = Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'favorites', xid));
            
            // If this is not the default room
            if(xid != 'none') {
                // We apply the values
                $(favorites + 'fedit-title').val($(data).find('name').text());
                $(favorites + 'fedit-nick').val($(data).find('nick').text());
                $(favorites + 'fedit-chan').val(Common.getXIDNick(xid));
                $(favorites + 'fedit-server').val(Common.getXIDHost(xid));
                $(favorites + 'fedit-password').val($(data).find('password').text());
                
                if($(data).find('autojoin').text() == 'true')
                    $(favorites + 'fedit-autojoin').attr('checked', true);
            }
        } catch(e) {
            Console.error('Favorites.edit', e);
        }

    };


    /**
     * Terminate a favorite editing
     * @public
     * @param {string} type
     * @return {boolean}
     */
    self.terminateThis = function(type) {

        try {
            // Path to favorites
            var favorites = '#favorites ';
            
            // We get the values of the current edited groupchat
            var old_xid = $(favorites + '.fedit-head-select').val();
            
            var title = $(favorites + '.fedit-title').val();
            var nick = $(favorites + '.fedit-nick').val();
            var room = $(favorites + '.fedit-chan').val();
            var server = $(favorites + '.fedit-server').val();
            var xid = room + '@' + server;
            var password = $(favorites + '.fedit-password').val();
            var autojoin = 'false';
            
            if($(favorites + '.fedit-autojoin').filter(':checked').size())
                autojoin = 'true';
            
            // We check the missing values and send this if okay
            if((type == 'add') || (type == 'edit')) {
                if(title && nick && room && server) {
                    // Remove the edited room
                    if(type == 'edit')
                        self.remove(old_xid, true);
                    
                    // Display the favorites
                    self.display(xid, title, nick, autojoin, password);
                    
                    // Reset the inputs
                    self.reset();
                }
                
                else {
                    $(favorites + 'input[required]').each(function() {
                        var select = $(this);
                        
                        if(!select.val())
                            $(document).oneTime(10, function() {
                                select.addClass('please-complete').focus();
                            });
                        else
                            select.removeClass('please-complete');  
                    });
                }
            }
            
            // Must remove a favorite?
            else if(type == 'remove') {
                self.remove(old_xid, true);
                
                // Reset the inputs
                self.reset();
            }
            
            // Publish the new favorites
            self.publish();
            
            Console.info('Action on this bookmark: ' + room + '@' + server + ' / ' + type);
        } catch(e) {
            Console.error('Favorites.terminateThis', e);
        } finally {
            return false;
        }

    };


    /**
     * Removes a favorite
     * @public
     * @param {string} xid
     * @param {boolean} database
     * @return {undefined}
     */
    self.remove = function(xid, database) {

        try {
            // We remove the target favorite everywhere needed
            $('.buddy-conf-groupchat-select option[value="' + xid + '"]').remove();
            $('.fedit-head-select option[value="' + xid + '"]').remove();
            
            // Must remove it from database?
            if(database) {
                DataStore.removeDB(Connection.desktop_hash, 'favorites', xid);
            }
        } catch(e) {
            Console.error('Favorites.remove', e);
        }

    };


    /**
     * Sends a favorite to the XMPP server
     * @public
     * @return {undefined}
     */
    self.publish = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var query = iq.setQuery(NS_PRIVATE);
            var storage = query.appendChild(iq.buildNode('storage', {'xmlns': NS_BOOKMARKS}));
            
            // We generate the XML
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'favorites_(.+)');

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored favorite
                if(current.match(db_regex)) {
                    var data = Common.XMLFromString(DataStore.storageDB.getItem(current));
                    var xid = $(data).find('xid').text();
                    var rName = $(data).find('name').text();
                    var nick = $(data).find('nick').text();
                    var password = $(data).find('password').text();
                    var autojoin = $(data).find('autojoin').text();
                    
                    // We create the node for this groupchat
                    var item = storage.appendChild(iq.buildNode('conference', {'name': rName, 'jid': xid, 'autojoin': autojoin, xmlns: NS_BOOKMARKS}));
                    item.appendChild(iq.buildNode('nick', {xmlns: NS_BOOKMARKS}, nick));
                    
                    if(password)
                        item.appendChild(iq.buildNode('password', {xmlns: NS_BOOKMARKS}, password));
                    
                    Console.info('Bookmark sent: ' + xid);
                }
            }
            
            con.send(iq);
        } catch(e) {
            Console.error('Favorites.publish', e);
        }

    };


    /**
     * Gets a list of the MUC items on a given server
     * @public
     * @return {undefined}
     */
    self.getGCList = function() {

        try {
            var path = '#favorites .';
            var gcServer = $('.fsearch-head-server').val();
            
            // We reset some things
            $(path + 'fsearch-oneresult').remove();
            $(path + 'fsearch-noresults').hide();
            $(path + 'wait').show();
            
            var iq = new JSJaCIQ();
            iq.setType('get');
            iq.setTo(gcServer);
            
            iq.setQuery(NS_DISCO_ITEMS);
            
            con.send(iq, self.handleGCList);
        } catch(e) {
            Console.error('Favorites.getGCList', e);
        }

    };


    /**
     * Handles the MUC items list
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleGCList = function(iq) {

        try {
            var path = '#favorites .';
            var from = Common.fullXID(Common.getStanzaFrom(iq));
            
            if(!iq || (iq.getType() != 'result')) {
                Board.openThisError(3);
                
                $(path + 'wait').hide();
                
                Console.error('Error while retrieving the rooms: ' + from);
            }
            
            else {
                var handleXML = iq.getQuery();
                
                if($(handleXML).find('item').size()) {
                    // Initialize the HTML code
                    var html = '';
                    
                    $(handleXML).find('item').each(function() {
                        var roomXID = $(this).attr('jid');
                        var roomName = $(this).attr('name');
                        
                        if(roomXID && roomName) {
                            // Escaped values
                            var escaped_xid = Utils.encodeOnclick(roomXID);
                            var escaped_name = Utils.encodeOnclick(roomName);
                            
                            // Initialize the room HTML
                            html += '<div class="oneresult fsearch-oneresult" data-xid="' + escape(roomXID) + '">' + 
                                    '<div class="room-name">' + roomName.htmlEnc() + '</div>' + 
                                    '<a href="#" class="one-button join talk-images" onclick="return Favorites.join(\'' + escaped_xid + '\');">' + Common._e("Join") + '</a>';
                            
                            // This room is yet a favorite
                            if(DataStore.existDB('favorites', roomXID))
                                html += '<a href="#" class="one-button remove talk-images" onclick="return Favorites.removeThis(\'' + escaped_xid + '\', \'' + escaped_name + '\');">' + Common._e("Remove") + '</a>';
                            else
                                html += '<a href="#" class="one-button add talk-images" onclick="return Favorites.addThis(\'' + escaped_xid + '\', \'' + escaped_name + '\');">' + Common._e("Add") + '</a>';
                            
                            // Close the room HTML
                            html += '</div>';
                        }
                    });
                    
                    // Append this code to the popup
                    $(path + 'fsearch-results').append(html);
                }
                
                else
                    $(path + 'fsearch-noresults').show();
                
                Console.info('Rooms retrieved: ' + from);
            }
            
            $(path + 'wait').hide();
        } catch(e) {
            Console.error('Favorites.handleGCList', e);
        }

    };


    /**
     * Joins a groupchat from favorites
     * @public
     * @param {string} room
     * @return {boolean}
     */
    self.join = function(room) {

        try {
            self.quit();
            Chat.checkCreate(room, 'groupchat', '', '', Common.getXIDNick(room));
        } catch(e) {
            Console.error('Favorites.join', e);
        } finally {
            return false;
        }

    };


    /**
     * Displays a given favorite
     * @public
     * @param {string} xid
     * @param {string} name
     * @param {string} nick
     * @param {boolean} autojoin
     * @param {string} password
     * @return {undefined}
     */
    self.display = function(xid, name, nick, autojoin, password) {

        try {
            // Generate the HTML code
            var html = '<option value="' + Common.encodeQuotes(xid) + '">' + name.htmlEnc() + '</option>';
            
            // Remove the existing favorite
            self.remove(xid, false);
            
            // We complete the select forms
            $('#roster .gc-join-first-option, #favorites .fedit-head-select-first-option').after(html);
            
            // We store the informations
            var value = '<groupchat><xid>' + xid.htmlEnc() + '</xid><name>' + name.htmlEnc() + '</name><nick>' + nick.htmlEnc() + '</nick><autojoin>' + autojoin.htmlEnc() + '</autojoin><password>' + password.htmlEnc() + '</password></groupchat>';
            DataStore.setDB(Connection.desktop_hash, 'favorites', xid, value);
        } catch(e) {
            Console.error('Favorites.display', e);
        }

    };


    /**
     * Loads the favorites for the popup
     * @public
     * @return {undefined}
     */
    self.load = function() {

        try {
            // Initialize the HTML code
            var html = '';
            
            // Read the database
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'favorites_(.+)');

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored favorite
                if(current.match(db_regex)) {
                    var data = Common.XMLFromString(DataStore.storageDB.getItem(current));
                    
                    // Add the current favorite to the HTML code
                    html += '<option value="' + Common.encodeQuotes($(data).find('xid').text()) + '">' + $(data).find('name').text().htmlEnc() + '</option>';
                }
            }
            
            // Generate specific HTML code
            var favorites_bubble = '<option value="none" class="gc-join-first-option" selected="">' + Common._e("Select a favorite") +  '</option>' + html;
            var favorites_popup = '<option value="none" class="fedit-head-select-first-option" selected="">' + Common._e("Select a favorite") + '</option>' + html;
            
            // Append the HTML code
            $('#roster .buddy-conf-groupchat-select').html(favorites_bubble);
            $('#favorites .fedit-head-select').html(favorites_popup);
        } catch(e) {
            Console.error('Favorites.load', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            var path = '#favorites .';
            
            // Keyboard events
            $(path + 'fsearch-head-server').keyup(function(e) {
                if(e.keyCode == 13) {
                    // No value?
                    if(!$(this).val())
                        $(this).val(HOST_MUC);
                    
                    // Get the list
                    self.getGCList();
                }
            });
            
            $(path + 'fedit-line input').keyup(function(e) {
                if(e.keyCode == 13) {
                    // Edit a favorite
                    if($(path + 'fedit-edit').is(':visible'))
                        self.terminateThis('edit');
                    
                    // Add a favorite
                    else
                        self.terminateThis('add');
                }
            });
            
            // Change events
            $('.fedit-head-select').change(self.edit);
            
            // Click events
            $(path + 'room-switcher').click(function() {
                $(path + 'favorites-content').hide();
                self.reset();
            });
            
            $(path + 'room-list').click(function() {
                $(path + 'favorites-edit').show();
            });
            
            $(path + 'room-search').click(function() {
                $(path + 'favorites-search').show();
                self.getGCList();
            });
            
            $(path + 'fedit-add').click(function() {
                return self.terminateThis('add');
            });
            
            $(path + 'fedit-edit').click(function() {
                return self.terminateThis('edit');
            });
            
            $(path + 'fedit-remove').click(function() {
                return self.terminateThis('remove');
            });
            
            $(path + 'bottom .finish').click(function() {
                return self.quit();
            });
        } catch(e) {
            Console.error('Favorites.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
This is the server features JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var Features = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Constants */
    self.SERVER_NAMES = [
        'metronome',
        'prosody',
        'ejabberd',
        'jabberd',
        'openfire',
        'tigase',
        'isode'
    ];


    /* Variables */
    self.server_name = null;


    /**
     * Gets the features of a server
     * @public
     * @return {undefined}
     */
    self.get = function() {

        /* REF: http://xmpp.org/extensions/xep-0030.html */

        try {
            // Get the main values
            var to = Utils.getServer();
            var caps = con.server_caps;
            var xml = null;
            
            // Try to get the stored data
            if(caps) {
                xml = Common.XMLFromString(
                    DataStore.getPersistent('global', 'caps', caps)
                );
            }
            
            // Any stored data?
            if(xml) {
                self.handle(xml);
                
                Console.log('Read server CAPS from cache.');
            } else {
                // Not stored (or no CAPS)!
                var iq = new JSJaCIQ();
                
                iq.setTo(to);
                iq.setType('get');
                iq.setQuery(NS_DISCO_INFO);
                
                con.send(iq, Caps.handleDiscoInfos);
                
                Console.log('Read server CAPS from network.');
            }
        } catch(e) {
            Console.error('Features.get', e);
        }

    };


    /**
     * Handles the features of a server
     * @public
     * @param {string} xml
     * @return {boolean}
     */
    self.handle = function(xml) {

        try {
            // Selector
            var selector = $(xml);
            
            // Functions
            var check_feature_fn = function(namespace) {
                // This weird selector fixes an IE8 bug...
                return (selector.find('feature').filter(function() {
                    return ($(this).attr('var') == namespace);
                }).size() > 0 ? true : false);
            };

            // Markers
            var namespaces = [NS_PUBSUB, NS_PUBSUB_CN, NS_URN_MAM, NS_COMMANDS, NS_URN_CARBONS];

            var identity = selector.find('identity');

            var cur_feature;
            var features = {
                // This weird selector fixes the same IE8 bug as above...
                'pep': (identity.filter(function() {
                    var this_sel = $(this);
                    return (this_sel.attr('category') == 'pubsub' && this_sel.attr('type') == 'pep');
                }).size() && true)
            };

            $.each(namespaces, function(n, namespace) {
                features[namespace] = check_feature_fn(namespace);

                if(features[namespace] === true) {
                    self.enable(namespace);
                }
            });

            // Retrieve server identity
            self.server_name = self._normalizeServerName(
                identity.filter('[category="server"]').attr('name')
            );

            // Enable the pep elements if available
            if(features.pep === true) {
                // Update our database
                self.enable('pep');

                // Get the PEP nodes to initiate
                Microblog.getInit();
                PEP.getInitGeoloc();
                
                // Get the notifications
                Notification.get();
                
                // Geolocate the user
                PEP.geolocate();
                
                // Enable microblogging send tools
                Microblog.wait('sync');
                $('.postit.attach').css('display', 'block');
                
                Console.info('XMPP server supports PEP.');
            } else {
                Microblog.wait('unsync');
                
                Console.warn('XMPP server does not support PEP.');
            }

            // Hide the private life fieldset if nothing to show
            if(features.pep === false && features[NS_URN_MAM] === false) {
                $('#options fieldset.privacy').hide();
            }
            
            // Apply the features
            self.apply('talk');
            
            // Process the roster height
            if(features.pep === true) {
                Roster.adapt();
            }

            // Enable Message Carbons?
            if(features[NS_URN_CARBONS] === true) {
                Carbons.enable();
            }
        } catch(e) {
            Console.error('Features.handle', e);
        } finally {
            return false;
        }

    };


    /**
     * The function to apply the features to an element
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.apply = function(id) {

        try {
            // Path to the elements
            var path = '#' + id + ' .';
            
            // PEP features
            if(self.enabledPEP()) {
                $(path + 'pep-hidable').show();
            }
            
            // PubSub features
            if(self.enabledPubSub()) {
                $(path + 'pubsub-hidable').show();
            }

            // PubSub Config-Node features
            if(self.enabledPubSubCN()) {
                $(path + 'pubsub-hidable-cn').show();
            }
            
            // MAM features
            if(self.enabledMAM()) {
                $(path + 'mam-hidable').show();
                $(path + 'mam-showable').hide();
            }

            // MAM Purge
            if(self.enabledMAMPurge()) {
                $(path + 'mam-purge-hidable').show();
            }
            
            // Commands features
            if(self.enabledCommands()) {
                $(path + 'commands-hidable').show();
            }
            
            // XMPP links (browser feature)
            if(navigator.registerProtocolHandler) {
                $(path + 'xmpplinks-hidable').show();
            }
        } catch(e) {
            Console.error('Features.apply', e);
        }

    };


    /**
     * Enables a feature
     * @public
     * @param {string} feature
     * @return {undefined}
     */
    self.enable = function(feature) {

        try {
            DataStore.setDB(Connection.desktop_hash, 'feature', feature, 'true');
        } catch(e) {
            Console.error('Features.enable', e);
        }

    };


    /**
     * Checks if a feature is enabled
     * @public
     * @param {string} feature
     * @return {boolean}
     */
    self.isEnabled = function(feature) {

        try {
            return DataStore.getDB(Connection.desktop_hash, 'feature', feature) === 'true';
        } catch(e) {
            Console.error('Features.isEnabled', e);
        }

    };


    /**
     * Returns the XMPP server PEP support
     * @public
     * @return {boolean}
     */
    self.enabledPEP = function() {

        try {
            return self.isEnabled('pep');
        } catch(e) {
            Console.error('Features.enabledPEP', e);
        }

    };


    /**
     * Returns the XMPP server PubSub support
     * @public
     * @return {boolean}
     */
    self.enabledPubSub = function() {

        try {
            return self.isEnabled(NS_PUBSUB);
        } catch(e) {
            Console.error('Features.enabledPubSub', e);
        }

    };


    /**
     * Returns the XMPP server PubSub Config-Node support
     * @public
     * @return {boolean}
     */
    self.enabledPubSubCN = function() {

        try {
            return self.isEnabled(NS_PUBSUB_CN);
        } catch(e) {
            Console.error('Features.enabledPubSubCN', e);
        }

    };


    /**
     * Returns the XMPP server MAM support
     * @public
     * @return {boolean}
     */
    self.enabledMAM = function() {

        try {
            return self.isEnabled(NS_URN_MAM);
        } catch(e) {
            Console.error('Features.enabledMAM', e);
        }

    };


    /**
     * Returns Metronome MAM Purge support
     * @public
     * @return {boolean}
     */
    self.enabledMAMPurge = function() {

        try {
            if(self.isEnabled(NS_URN_MAM)) {
                return self.isEnabled(NS_METRONOME_MAM_PURGE);
            } else {
               return false;
            }
        } catch(e) {
            Console.error('Features.enabledMAMPurge', e);
        }

    };


    /**
     * Returns the XMPP server Carbons support
     * @public
     * @return {boolean}
     */
    self.enabledCarbons = function() {

        try {
            return self.isEnabled(NS_URN_CARBONS);
        } catch(e) {
            Console.error('Features.enabledCarbons', e);
        }

    };


    /**
     * Returns the XMPP server commands support
     * @public
     * @return {boolean}
     */
    self.enabledCommands = function() {

        try {
            return self.isEnabled(NS_COMMANDS);
        } catch(e) {
            Console.error('Features.enabledCommands', e);
        }

    };


    /**
     * Normalizes the XMPP server name
     * @private
     * @return {string}
     */
    self._normalizeServerName = function(name) {

        try {
            var cur_r;

            for(var i in self.SERVER_NAMES) {
                cur_r = new RegExp(self.SERVER_NAMES[i], 'gi');

                if(cur_r.exec(name) !== null) {
                    name = self.SERVER_NAMES[i];
                    break;
                }
            }
        } catch(e) {
            Console.error('Features._normalizeServerName', e);
        } finally {
            return name;
        }

    };


    /**
     * Returns the XMPP server name
     * @public
     * @return {string}
     */
    self.getServerName = function() {

        try {
            return self.server_name;
        } catch(e) {
            Console.error('Features.getServerName', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the interface JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Interface = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.chat_focus_hash = null;


    /**
     * Changes the title of the document
     * @public
     * @param {string} new_title
     * @return {undefined}
     */
    self.title = function(title_type) {

        try {
            // Anonymous mode?
            var head_name = Name.get();
            
            if(Utils.isAnonymous()) {
                head_name = ANONYMOUS_ROOM + ' (' + Common._e("anonymous mode") + ')';
            }
            
            // We change the title to give essential informations
            switch(title_type) {
                case 'home':
                    document.title = SERVICE_NAME + ' ‚Ä¢ ' + SERVICE_DESC;
                    break;
                
                case 'talk':
                    document.title = SERVICE_NAME + ' ‚Ä¢ ' + head_name;
                    break;
                
                case 'new':
                    document.title = '[' + self.pendingEvents() + '] ' + SERVICE_NAME + ' ‚Ä¢ ' + head_name;
                    break;
                
                case 'wait':
                    document.title = SERVICE_NAME + ' ‚Ä¢ ' + Common._e("Please wait...");
                    break;
            }
        } catch(e) {
            Console.error('Interface.title', e);
        }

    };


    /**
     * Creates a general-wait item
     * @public
     * @return {boolean}
     */
    self.showGeneralWait = function() {

        try {
            // Item exists?
            if(Common.exists('#general-wait'))
                return false;
            
            // Generate the HTML code
            var html = 
            '<div id="general-wait" class="removable">' + 
                '<div class="general-wait-content wait-big"></div>' + 
            '</div>';
            
            // Append the HTML code
            $('body').append(html);
            
            return true;
        } catch(e) {
            Console.error('Interface.showGeneralWait', e);
        }

    };


    /**
     * Removes the general-wait item
     * @public
     * @return {undefined}
     */
    self.removeGeneralWait = function() {

        try {
            $('#general-wait').remove();
        } catch(e) {
            Console.error('Interface.removeGeneralWait', e);
        }

    };


    /**
     * Generates a file upload valid form content
     * @public
     * @return {undefined}
     */
    self.generateFileShare = function() {

        try {
            return  '<input type="hidden" name="MAX_FILE_SIZE" value="' + Common.encodeQuotes(JAPPIX_MAX_FILE_SIZE) + '">' + 
                    '<input type="hidden" name="user" value="' + Common.encodeQuotes(Common.getXID()) + '" />' + 
                    '<input type="hidden" name="location" value="' + Common.encodeQuotes(Utils.generateURL(JAPPIX_LOCATION)) + '" />' + 
                    '<input type="hidden" name="id" value="' + (new Date()).getTime() + '" />' + 
                    '<input type="file" name="file" required="" />' + 
                    '<input type="submit" value="' + Common._e("Send") + '" />';
        } catch(e) {
            Console.error('Interface.generateFileShare', e);
        }

    };


    /**
     * Switches to the given chan
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.switchChan = function(id) {

        try {
            if(Common.exists('#' + id)) {
                // We show the page-engine content
                $('.page-engine-chan').hide();
                $('#' + id).show();
                
                // We edit the tab switcher
                $('#page-switch .switcher').removeClass('activechan').addClass('chan');
                $('#page-switch .' + id).addClass('activechan').removeClass('chan');
                
                // Scroll down to the last message
                if(id != 'channel') {
                    self.autoScroll(id);
                }
                
                // Manage input focus
                self.inputFocus();
            }
        } catch(e) {
            Console.error('Interface.switchChan', e);
        } finally {
            return false;
        }

    };


    /**
     * Loads the complete chat switcher
     * @public
     * @return {undefined}
     */
    self.loadChatSwitch = function() {

        try {
            // Path
            var more_content = '#page-switch .more-content';
            
            // Yet displayed?
            if(Common.exists(more_content))
                return Bubble.close();
            
            // Add the bubble
            Bubble.show(more_content);
            
            // Append the content
            $('#page-switch .more').append(
                '<div class="more-content bubble removable">' + 
                    $('#page-switch .chans').html() + 
                '</div>'
            );
        } catch(e) {
            Console.error('Interface.loadChatSwitch', e);
        } finally {
            return false;
        }

    };


    /**
     * Loads the groupchat joiner
     * @public
     * @return {undefined}
     */
    self.loadJoinGroupchat = function() {

        try {
            // Path
            var join_content = '#page-switch .join-content';
            var join_sel = $('#page-switch .join');
            
            // Yet displayed?
            if(Common.exists(join_content))
                return Bubble.close();
            
            // Add the bubble
            Bubble.show(join_content);
            
            // Append the content
            join_sel.append(
                '<div class="join-content bubble removable">' + 
                    '<input type="text" class="join-groupchat-xid" required="" placeholder="' + Common._e("Groupchat name") + '" />' + 
                '</div>'
            );

            var input_sel = join_sel.find('input.join-groupchat-xid');

            input_sel.keyup(function(e) {
                // Enter: continue
                if(e.keyCode == 13) {
                    var this_sel = $(this);
                    var xid = $.trim(this_sel.val());
                    
                    if(xid) {
                        // Generate a correct XID
                        xid = Common.generateXID(xid, 'groupchat');
                        
                        Bubble.close();
                        Chat.checkCreate(xid, 'groupchat');
                    } else {
                        this_sel.addClass('please-complete');
                    }

                    return false;
                }
            });

            $(document).oneTime(10, function() {
                input_sel.focus();
            });
        } catch(e) {
            Console.error('Interface.loadJoinGroupchat', e);
        } finally {
            return false;
        }

    };


    /**
     * Puts the selected smiley in the good page-engine input
     * @public
     * @param {string} smiley
     * @param {string} hash
     * @return {boolean}
     */
    self.insertSmiley = function(smiley, hash) {

        try {
            // We define the variables
            var selector = $('#' + hash + ' .message-area');
            var oValue = selector.val();
            
            // Any old value?
            if(oValue && !oValue.match(/^(.+)(\s)+$/)) {
                oValue += ' ';
            }
            
            var nValue = oValue + smiley + ' ';
            
            // Put the new value and focus on it
            $(document).oneTime(10, function() {
                selector.val(nValue).focus();
            });
        } catch(e) {
            Console.error('Interface.insertSmiley', e);
        }

    };


    /**
     * Deletes all the associated elements of the chat we want to remove
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.deleteThisChat = function(hash) {

        try {
            $('#' + hash + ', #page-switch .' + hash).remove();
        } catch(e) {
            Console.error('Interface.deleteThisChat', e);
        }

    };


    /**
     * Closes the given chat
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {string} type
     * @return {boolean}
     */
    self.quitThisChat = function(xid, hash, type) {

        try {
            if(type == 'groupchat') {
                // Send our unavailable presence
                Presence.send(xid + '/' + Name.getMUCNick(hash), 'unavailable');
                
                // Remove all presence database entries for this groupchat
                var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'presence' + ('_(.+)'));

                for(var i = 0; i < DataStore.storageDB.length; i++) {
                    // Get the pointer values
                    var current = DataStore.storageDB.key(i);

                    if(current.match(db_regex)) {
                        var cXID = RegExp.$1;
                        
                        // If the pointer is on a presence from this groupchat
                        if(Common.bareXID(cXID) == xid) {
                            // Generate the hash for the current XID
                            var cHash = hex_md5(cXID);
                            
                            // Disable the message textarea
                            $('#' + cHash + ' .message-area').attr('disabled', true);
                            
                            // Remove the presence for this XID
                            DataStore.removeDB(Connection.desktop_hash, 'presence-stanza', cXID);
                            DataStore.removeDB(Connection.desktop_hash, 'presence-resources', cXID);
                            Presence.funnel(cXID, cHash);
                        }
                    }
                }
            } else {
                ChatState.send('gone', xid, hash);
            }

            // Clear MAM storage for this chat
            if(xid in MAM.map_states) {
                delete MAM.map_states[xid];
            }
            
            // Get the chat ID which is before
            var previous = $('#' + hash).prev().attr('id');
            
            // Remove the chat
            self.deleteThisChat(hash);
            
            // Reset the switcher
            if(!Common.exists('#page-switch .switcher.activechan')) {
                self.switchChan(previous);
            }
            
            // Reset the notifications
            self.chanCleanNotify(hash);
        } catch(e) {
            Console.error('Interface.quitThisChat', e);
        } finally {
            return false;
        }

    };


    /**
     * Generates the chat logs
     * @public
     * @param {string} xid
     * @param {string} hash
     * @return {boolean}
     */
    self.generateChatLog = function(xid, hash) {

        try {
            // Get the main values
            var path = '#' + hash + ' .';
            var content = $(path + 'content').clone().contents();
            var avatar = $(path + 'top .avatar-container:first').html();
            var nick = $(path + 'top .bc-name').text();
            var date = DateUtils.getXMPPTime('local');
            var type = $('#' + hash).attr('data-type');
            var direction = $('html').attr('dir') || 'ltr';
            
            // Filter the content smileys
            $(content).find('img.emoticon').each(function() {
                $(this).replaceWith($(this).attr('alt'));
            });
            
            // Remove the useless attributes
            $(content).removeAttr('data-type').removeAttr('data-stamp');
            
            // Remove the content avatars
            $(content).find('.avatar-container').remove();
            
            // Remove the content click events
            $(content).find('a').removeAttr('onclick');
            
            // Extract the content HTML code
            content = $(content).parent().html();
            
            // No avatar?
            if(!avatar || !avatar.match(/data:/))
                avatar = 'none';
            
            // POST the values to the server
            $.post('./server/generate-chat.php', { 'content': content, 'xid': xid, 'nick': nick, 'avatar': avatar, 'date': date, 'type': type, 'direction': direction }, function(data) {
                // Handled!
                $(path + 'tooltip-waitlog').replaceWith('<a class="tooltip-actionlog" href="./server/download-chat.php?id=' + data + '" target="_blank">' + Common._e("Download file!") + '</a>');
            });
        } catch(e) {
            Console.error('Interface.generateChatLog', e);
        } finally {
            return false;
        }

    };


    /**
     * Notifies the user from a new incoming message
     * @public
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.messageNotify = function(hash, type) {

        try {
            // Initialize the vars
            var chat_switch = '#page-switch .';
            var tested = chat_switch + hash;
            var active = $(tested).hasClass('activechan');
            
            // We notify the user if he has not the focus on the chat
            if(!active || !Common.isFocused() || (self.chat_focus_hash != hash)) {
                if(!active) {
                    if(type == 'personal') {
                        $(tested + ', ' + chat_switch + 'more-button').addClass('chan-newmessage');
                    } else if(type == 'unread') {
                        $(tested).addClass('chan-unread');
                    }
                }
                
                // Count the number of pending messages
                var pending = 1;
                
                if(Common.exists('#' + hash + '[data-counter]')) {
                    pending = parseInt($('#' + hash).attr('data-counter')) + 1;
                }
                
                $('#' + hash).attr('data-counter', pending);
            }
            
            // Update the page title
            self.updateTitle();
        } catch(e) {
            Console.error('Interface.messageNotify', e);
        }

    };


    /**
     * Returns the number of pending events
     * @public
     * @return {number}
     */
    self.pendingEvents = function() {

        try {
            // Count the number of notifications
            var number = 0;
            
            $('.one-counter[data-counter]').each(function() {
                number = number + parseInt($(this).attr('data-counter'));
            });
            
            return number;
        } catch(e) {
            Console.error('Interface.pendingEvents', e);
        }

    };


    /**
     * Updates the page title
     * @public
     * @return {undefined}
     */
    self.updateTitle = function() {

        try {
            // Any pending events?
            if(Common.exists('.one-counter[data-counter]'))
                self.title('new');
            else
                self.title('talk');
        } catch(e) {
            Console.error('Interface.updateTitle', e);
        }

    };


    /**
     * Cleans the given chat notifications
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.chanCleanNotify = function(hash) {

        try {
            // We remove the class that tell the user of a new message
            var chat_switch = '#page-switch .';
            $(chat_switch + hash).removeClass('chan-newmessage chan-unread');
            
            // We reset the global notifications if no more unread messages
            if(!$(chat_switch + 'chans .chan-newmessage').size())
                $(chat_switch + 'more-button').removeClass('chan-newmessage');
            
            // We reset the chat counter
            $('#' + hash).removeAttr('data-counter');
            
            // Update the page title
            self.updateTitle();
        } catch(e) {
            Console.error('Interface.chanCleanNotify', e);
        }

    };


    /**
     * Scrolls to the last chat message
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.autoScroll = function(hash) {

        try {
            // Avoid a JS error
            if(Common.exists('#' + hash)) {
                var container = document.getElementById('chat-content-' + hash);
                
                // Scroll down!
                container.scrollTop = container.scrollHeight;
            }
        } catch(e) {
            Console.error('Interface.autoScroll', e);
        }

    };


    /**
     * Shows all the buddies in the roster
     * @public
     * @param {string} from
     * @return {undefined}
     */
    self.showAllBuddies = function(from) {

        try {
            // Put a marker
            Roster.blist_all = true;
            
            // We switch the two modes
            $('.buddy-conf-more-display-unavailable').hide();
            $('.buddy-conf-more-display-available').show();
            
            // Security: reset all the groups toggle event
            $('#roster .group-buddies').show();
            $('#roster .group span').text('-');
            
            // We show the disconnected buddies
            $('.hidden-buddy').show();
            
            // We show all the groups
            $('#roster .one-group').show();
            
            if(Search.search_filtered)
                Search.funnelFilterBuddy();
            
            // Store this in the options
            if((from == 'roster') && Options.loaded()) {
                DataStore.setDB(Connection.desktop_hash, 'options', 'roster-showall', '1');
                Options.store();
            }
        } catch(e) {
            Console.error('Interface.showAllBuddies', e);
        }

    };


    /**
     * Shows only the online buddies in the roster
     * @public
     * @param {string} from
     * @return {undefined}
     */
    self.showOnlineBuddies = function(from) {

        try {
            // Remove the marker
            Roster.blist_all = false;
            
            // We switch the two modes
            $('.buddy-conf-more-display-available').hide();
            $('.buddy-conf-more-display-unavailable').show();
            
            // Security: reset all the groups toggle event
            $('#roster .group-buddies').show();
            $('#roster .group span').text('-');
            
            // We hide the disconnected buddies
            $('.hidden-buddy').hide();
            
            // We check the groups to hide
            Roster.updateGroups();
            
            if(Search.search_filtered) {
                Search.funnelFilterBuddy();
            }
            
            // Store this in the options
            if((from == 'roster') && Options.loaded()) {
                DataStore.setDB(Connection.desktop_hash, 'options', 'roster-showall', '0');
                Options.store();
            }
        } catch(e) {
            Console.error('Interface.showOnlineBuddies', e);
        }

    };


    /**
     * Focuses on the right input
     * @public
     * @return {undefined}
     */
    self.inputFocus = function() {

        try {
            // No popup shown
            if(!Common.exists('.popup')) {
                $(document).oneTime(10, function() {
                    $('.focusable:visible:first').focus();
                });
            }
        } catch(e) {
            Console.error('Interface.inputFocus', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            $(document).ready(function() {
                // Focus on the first visible input
                $(window).focus(self.inputFocus);
            });
        } catch(e) {
            Console.error('Interface.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Interface.launch();
/*

Jappix - An open social platform
These are the XMPP links handling JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var XMPPLinks = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Does an action with the provided XMPP link
     * @public
     * @param {string} link
     * @return {boolean}
     */
    self.go = function(link) {

        /* REF: http://xmpp.org/registrar/querytypes.html */

        try {
            // Remove the "xmpp:" string
            link = Common.explodeThis(':', link, 1);
            
            // The XMPP URI has no "?"
            if(link.indexOf('?') == -1)
                Chat.checkCreate(link, 'chat');
            
            // Parse the URI
            else {
                var xid = Common.explodeThis('?', link, 0);
                var action = Common.explodeThis('?', link, 1);
                
                switch(action) {
                    // Groupchat
                    case 'join':
                        Chat.checkCreate(xid, 'groupchat');
                        
                        break;
                    
                    // Profile
                    case 'vcard':
                        UserInfos.open(xid);
                        
                        break;
                    
                    // Subscription
                    case 'subscribe':
                        Roster.addThisContact(xid);
                        
                        break;
                    
                    // Unsubscription
                    case 'unsubscribe':
                        Roster.send(xid, 'remove');
                        
                        break;
                    
                    // Private chat
                    default:
                        Chat.checkCreate(xid, 'chat');
                        
                        break;
                }
            }
        } catch(e) {
            Console.error('XMPPLinks.do', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the links vars (get parameters in URL)
     */
    self.links_var = (function() {
        var vars = [];
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        
        for(var i = 0; i < hashes.length; i++) {
            var hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = $.trim(decodeURIComponent(hash[1]));
        }
        
        return vars;
    })();


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the IQ JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var IQ = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Handles an incoming IQ packet
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handle = function(iq) {

        try {
            // Gets the IQ content
            var iqNode = iq.getNode();
            var iqFrom = Common.fullXID(Common.getStanzaFrom(iq));
            var iqID = iq.getID();
            var iqQueryXMLNS = iq.getQueryXMLNS();
            var iqQuery = iq.getQuery();
            var iqType = iq.getType();

            // Handle Jingle packet?
            JSJaCJingle_route(iq);
            
            // Build the response
            var iqResponse = new JSJaCIQ();
            
            iqResponse.setID(iqID);
            iqResponse.setTo(iqFrom);
            iqResponse.setType('result');
            
            // OOB request
            if((iqQueryXMLNS == NS_IQOOB) && (iqType == 'set')) {
                /* REF: http://xmpp.org/extensions/xep-0066.html */
                
                OOB.handle(iqFrom, iqID, 'iq', iqNode);
                
                Console.log('Received IQ OOB request: ' + iqFrom);
            }
            
            // OOB reply
            else if(DataStore.getDB(Connection.desktop_hash, 'send/url', iqID)) {
                // Get the values
                var oob_url = DataStore.getDB(Connection.desktop_hash, 'send/url', iqID);
                var oob_desc = DataStore.getDB(Connection.desktop_hash, 'send/desc', iqID);
                var notif_id = hex_md5(oob_url + oob_desc + iqType + iqFrom + iqID);
                
                if($(iqNode).find('error').size()) {
                    // Error?
                    if($(iqNode).find('error not-acceptable').size()) {
                        // Rejected?
                        Notification.create('send_reject', iqFrom, [iqFrom, oob_url, 'iq', iqID, iqNode], oob_desc, notif_id);
                    } else {
                        // Failed?
                        Notification.create('send_fail', iqFrom, [iqFrom, oob_url, 'iq', iqID, iqNode], oob_desc, notif_id);
                    }
                    
                    // Remove the file
                    $.get(oob_url + '&action=remove');
                } else if(iqType == 'result') {
                    // Success?
                    Notification.create('send_accept', iqFrom, [iqFrom, oob_url, 'iq', iqID, iqNode], oob_desc, notif_id);
                }
            }
            
            // Software version query
            else if((iqQueryXMLNS == NS_VERSION) && (iqType == 'get')) {
                /* REF: http://xmpp.org/extensions/xep-0092.html */
                
                iqQuery = iqResponse.setQuery(NS_VERSION);
                
                iqQuery.appendChild(iqResponse.buildNode('name', {'xmlns': NS_VERSION}, 'Jappix'));
                iqQuery.appendChild(iqResponse.buildNode('version', {'xmlns': NS_VERSION}, JAPPIX_VERSION));
                iqQuery.appendChild(iqResponse.buildNode('os', {'xmlns': NS_VERSION}, BrowserDetect.OS));
                
                con.send(iqResponse);
                
                Console.log('Received software version query: ' + iqFrom);
            }
            
            // Last activity query
            else if((iqQueryXMLNS == NS_LAST) && (iqType == 'get')) {
                /* REF: http://xmpp.org/extensions/xep-0012.html */
                
                iqQuery = iqResponse.setQuery(NS_LAST);
                iqQuery.setAttribute('seconds', DateUtils.getLastActivity());
                
                con.send(iqResponse);
                
                Console.log('Received last activity query: ' + iqFrom);
            }
            
            // Privacy lists push
            else if((iqQueryXMLNS == NS_PRIVACY) && (iqType == 'set') && Common.isSafeStanza(iq)) {
                // REF : http://xmpp.org/extensions/xep-0016.html
                
                // Roster push
                con.send(iqResponse);
                
                // Get the lists
                $(iqQuery).find('list').each(function() {
                    Privacy.get($(this).attr('name'));
                });
                
                Console.log('Received privacy lists push: ' + iqFrom);
            }
            
            // Roster push
            else if((iqQueryXMLNS == NS_ROSTER) && (iqType == 'set') && Common.isSafeStanza(iq)) {
                // REF : http://xmpp.org/extensions/xep-0092.html
                
                // Roster push
                con.send(iqResponse);
                
                // Get the values
                $(iqQuery).find('item').each(function() {
                    Roster.parse($(this), 'presence');
                });
                
                Console.log('Received roster push: ' + iqFrom);
            }
            
            // Roster Item Exchange query
            else if($(iqNode).find('x[xmlns="' + NS_ROSTERX + '"]').size()) {
                // Open a new notification
                Notification.create('rosterx', iqFrom, [iqNode], '');
                
                Console.log('Roster Item Exchange from: ' + iqFrom);
            }
            
            // Disco info query
            else if((iqQueryXMLNS == NS_DISCO_INFO) && (iqType == 'get')) {
                /* REF: http://xmpp.org/extensions/xep-0030.html */
                
                iqQuery = iqResponse.setQuery(NS_DISCO_INFO);
                
                // We set the name of the client
                iqQuery.appendChild(iqResponse.buildNode('identity', {
                    'category': 'client',
                    'type': 'web',
                    'name': 'Jappix',
                    'xmlns': NS_DISCO_INFO
                }));
                
                // We set all the supported features
                var disco_infos = Caps.myDiscoInfos();
                
                $.each(disco_infos, function(i, disco_info) {
                    iqQuery.appendChild(iqResponse.buildNode('feature', {'var': disco_info, 'xmlns': NS_DISCO_INFO}));
                });
                
                con.send(iqResponse);
                
                Console.log('Received disco#infos query: ' + iqFrom);
            }
            
            // User time query
            else if($(iqNode).find('time').size() && (iqType == 'get')) {
                /* REF: http://xmpp.org/extensions/xep-0202.html */
                
                var iqTime = iqResponse.appendNode('time', {'xmlns': NS_URN_TIME});
                iqTime.appendChild(iqResponse.buildNode('tzo', {'xmlns': NS_URN_TIME}, DateUtils.getTZO()));
                iqTime.appendChild(iqResponse.buildNode('utc', {'xmlns': NS_URN_TIME}, DateUtils.getXMPPTime('utc')));
                
                con.send(iqResponse);
                
                Console.log('Received local time query: ' + iqFrom);
            }
            
            // Ping
            else if($(iqNode).find('ping').size() && (iqType == 'get')) {
                /* REF: http://xmpp.org/extensions/xep-0199.html */
                
                con.send(iqResponse);
                
                Console.log('Received a ping: ' + iqFrom);
            }

            // Jingle
            else if($(iqNode).find('jingle').size()) {
                /* REF: http://xmpp.org/extensions/xep-0166.html */
                
                // Handled via JSJaCJingle_route() (see above)
                
                Console.log('Received a Jingle packet: ' + iqFrom);
            }
            
            // Not implemented
            else if(!$(iqNode).find('error').size() && ((iqType == 'get') || (iqType == 'set'))) {
                // Change IQ type
                iqResponse.setType('error');
                
                // Append stanza content
                for(var c = 0; c < iqNode.childNodes.length; c++) {
                    iqResponse.getNode().appendChild(iqNode.childNodes.item(c).cloneNode(true));
                }
                
                // Append error content
                var iqError = iqResponse.appendNode('error', {'xmlns': NS_CLIENT, 'code': '501', 'type': 'cancel'});
                iqError.appendChild(iqResponse.buildNode('feature-not-implemented', {'xmlns': NS_STANZAS}));
                iqError.appendChild(iqResponse.buildNode('text', {'xmlns': NS_STANZAS}, Common._e("The feature requested is not implemented by the recipient or server and therefore cannot be processed.")));
                
                con.send(iqResponse);
                
                Console.log('Received an unsupported IQ query from: ' + iqFrom);
            }
        } catch(e) {
            Console.error('IQ.handle', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the messages JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var Message = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Handles the incoming message packets
     * @public
     * @param {object} message
     * @return {boolean}
     */
    self.handle = function(message) {

        try {
            // Error packet? Stop!
            if(Errors.handleReply(message))
                return;
            
            // Carbon-forwarded message?
            if(message.getChild('sent', NS_URN_CARBONS)) {
                Carbons.handleSent(message); return;
            }
            if(message.getChild('received', NS_URN_CARBONS)) {
                Carbons.handleReceived(message); return;
            }

            // MAM-forwarded message?
            var c_mam = message.getChild('result', NS_URN_MAM);

            if(c_mam) {
                var c_mam_sel = $(c_mam);
                var c_mam_delay = c_mam_sel.find('delay[xmlns="' + NS_URN_DELAY + '"]');
                var c_mam_forward = c_mam_sel.find('forwarded[xmlns="' + NS_URN_FORWARD + '"]');

                if(c_mam_forward.size()) {
                    MAM.handleMessage(c_mam_forward, c_mam_delay);
                }

                return;
            }

            // We get the message items
            var from = Common.fullXID(Common.getStanzaFrom(message));
            var id = message.getID();
            var type = message.getType();
            var body = $.trim(message.getBody());
            var node = message.getNode();
            var subject = $.trim(message.getSubject());
            
            // Keep raw message body
            var raw_body = body;
            
            // We generate some values
            var xid = Common.bareXID(from);
            var resource = Common.thisResource(from);
            var hash = hex_md5(xid);
            var xHTML = $(node).find('html body').size();
            var GCUser = false;
            
            // This message comes from a groupchat user
            if(Utils.isPrivate(xid) && ((type == 'chat') || !type) && resource) {
                GCUser = true;
                xid = from;
                hash = hex_md5(xid);
            }
            
            // Get message date
            var time, stamp;
            var delay = DateUtils.readMessageDelay(node);
            
            // Any delay?
            if(delay) {
                time = DateUtils.relative(delay);
                stamp = DateUtils.extractStamp(Date.jab2date(delay));
            } else {
                time = DateUtils.getCompleteTime();
                stamp = DateUtils.extractStamp(new Date());
            }
            
            // Received message
            if(Receipts.hasReceived(message))
                return Receipts.messageReceived(hash, id);
            
            // Chatstate message
            if(node && !delay && ((((type == 'chat') || !type) && !Common.exists('#page-switch .' + hash + ' .unavailable')) || (type == 'groupchat'))) {
                /* REF: http://xmpp.org/extensions/xep-0085.html */
                
                // Re-process the hash
                var chatstate_hash = hash;
                
                if(type == 'groupchat')
                    chatstate_hash = hex_md5(from);
                
                // Do something depending of the received state
                if($(node).find('active').size()) {
                    ChatState.display('active', chatstate_hash, type);
                    
                    // Tell Jappix the entity supports chatstates
                    $('#' + chatstate_hash + ' .message-area').attr('data-chatstates', 'true');
                    
                    Console.log('Active chatstate received from: ' + from);
                }
                
                else if($(node).find('composing').size()) {
                    ChatState.display('composing', chatstate_hash, type);

                    Console.log('Composing chatstate received from: ' + from);
                }
                
                else if($(node).find('paused').size()) {
                    ChatState.display('paused', chatstate_hash, type);

                    Console.log('Paused chatstate received from: ' + from);
                }
                
                else if($(node).find('inactive').size()){
                    ChatState.display('inactive', chatstate_hash, type);

                    Console.log('Inactive chatstate received from: ' + from);
                }
                
                else if($(node).find('gone').size()){
                    ChatState.display('gone', chatstate_hash, type);

                    Console.log('Gone chatstate received from: ' + from);
                }
            }
            
            // Jappix App message
            if(message.getChild('app', 'jappix:app')) {
                // Get notification data
                var jappix_app_node = $(node).find('app[xmlns="jappix:app"]');
                var jappix_app_name = jappix_app_node.find('name');

                var jappix_app_name_id = jappix_app_name.attr('id');
                var jappix_app_name_value = jappix_app_name.text();

                // Jappix Me notification?
                if(jappix_app_name_id == 'me') {
                    // Get more notification data
                    var jappix_app_data = jappix_app_node.find('data[xmlns="jappix:app:me"]');
                    var jappix_app_data_action = jappix_app_data.find('action');
                    var jappix_app_data_url = jappix_app_data.find('url');

                    var jappix_app_data_action_type = jappix_app_data_action.attr('type');
                    var jappix_app_data_action_success = jappix_app_data_action.attr('success');
                    var jappix_app_data_action_job = jappix_app_data_action.attr('job');
                    var jappix_app_data_url_value = jappix_app_data_url.text();

                    // Validate data
                    if(jappix_app_data_action_type && jappix_app_data_action_success && jappix_app_data_action_job) {
                        // Filter success
                        jappix_app_data_action_success = parseInt(jappix_app_data_action_success) == 1 ? 'success' : 'error';

                        // Generate notification namespace
                        var jappix_me_notification_ns = jappix_app_name_id + '_' + jappix_app_data_action_type + '_' + jappix_app_data_action_job + '_' + jappix_app_data_action_success;

                        // Open a new notification
                        Notification.create(jappix_me_notification_ns, xid, [jappix_app_name_value, jappix_app_data_url_value], body);
                        
                        Console.log('Jappix Me notification from: ' + xid + ' with namespace: ' + jappix_me_notification_ns);
                        
                        return false;
                    }
                }
            }

            // Invite message
            if($(node).find('x[xmlns="' + NS_MUC_USER + '"] invite').size()) {
                // We get the needed values
                var iFrom = $(node).find('x[xmlns="' + NS_MUC_USER + '"] invite').attr('from');
                var iRoom = $(node).find('x[xmlns="' + NS_XCONFERENCE + '"]').attr('jid');
                
                // Old invite method?
                if(!iRoom)
                    iRoom = from;
                
                // We display the notification
                Notification.create('invite_room', iFrom, [iRoom], body);
                
                Console.log('Invite Request from: ' + iFrom + ' to join: ' + iRoom);
                
                return false;
            }
            
            // Request message
            if(message.getChild('confirm', NS_HTTP_AUTH)) {
                // Open a new notification
                Notification.create('request', xid, [message], body);
                
                Console.log('HTTP Request from: ' + xid);
                
                return false;
            }
            
            // OOB message
            if(message.getChild('x', NS_XOOB)) {
                OOB.handle(from, id, 'x', node);
                
                Console.log('Message OOB request from: ' + xid);
                
                return false;
            }
            
            // Roster Item Exchange message
            if(message.getChild('x', NS_ROSTERX)) {
                // Open a new notification
                Notification.create('rosterx', xid, [message], body);
                
                Console.log('Roster Item Exchange from: ' + xid);
                
                return false;
            }
            
            // Normal message
            if((type == 'normal') && body) {
                // Message date
                var messageDate = delay;
                
                // No message date?
                if(!messageDate)
                    messageDate = DateUtils.getXMPPTime('utc');
                
                // Message ID
                var messageID = hex_md5(xid + subject + messageDate);
                
                // We store the received message
                Inbox.storeMessage(xid, subject, body, 'unread', messageID, messageDate);
                
                // Display the inbox message
                if(Common.exists('#inbox'))
                    Inbox.displayMessage(xid, subject, body, 'unread', messageID, messageDate);
                
                // Check we have new messages (play a sound if any unread messages)
                if(Inbox.checkMessages())
                    Audio.play('notification');
                
                // Send it to the server
                Inbox.store();
                
                return false;
            }
            
            // PubSub event
            if($(node).find('event').attr('xmlns') == NS_PUBSUB_EVENT) {
                // We get the needed values
                var iParse = $(node).find('event items');
                var iNode = iParse.attr('node');
                var tText;
                
                // Turn around the different result cases
                if(iNode) {
                    switch(iNode) {
                        // Mood
                        case NS_MOOD:
                            // Retrieve the values
                            var iMood = iParse.find('mood');
                            var fValue = '';
                            tText = '';
                            
                            // There's something
                            if(iMood.children().size()) {
                                // Read the value
                                fValue = node.getElementsByTagName('mood').item(0).childNodes.item(0).nodeName;
                                
                                // Read the text
                                tText = iMood.find('text').text();
                                
                                // Avoid errors
                                if(!fValue)
                                    fValue = '';
                            }
                            
                            // Store the PEP event (and display it)
                            PEP.store(xid, 'mood', fValue, tText);
                            
                            break;
                        
                        // Activity
                        case NS_ACTIVITY:
                            // Retrieve the values
                            var iActivity = iParse.find('activity');
                            var sValue = '';
                            tText = '';
                            
                            // There's something
                            if(iActivity.children().size()) {
                                // Read the value
                                fValue = node.getElementsByTagName('activity').item(0).childNodes.item(0).nodeName;
                                
                                // Read the text
                                tText = iActivity.find('text').text();
                                
                                // Avoid errors
                                if(!fValue)
                                    fValue = '';
                            }
                            
                            // Store the PEP event (and display it)
                            PEP.store(xid, 'activity', fValue, tText);
                            
                            break;
                        
                        // Tune
                        case NS_TUNE:
                            // Retrieve the values
                            var iTune = iParse.find('tune');
                            var tArtist = iTune.find('artist').text();
                            var tSource = iTune.find('source').text();
                            var tTitle = iTune.find('title').text();
                            var tURI = iTune.find('uri').text();
                            
                            // Store the PEP event (and display it)
                            PEP.store(xid, 'tune', tArtist, tTitle, tSource, tURI);
                            
                            break;
                        
                        // Geolocation
                        case NS_GEOLOC:
                            // Retrieve the values
                            var iGeoloc = iParse.find('geoloc');
                            var tLat = iGeoloc.find('lat').text();
                            var tLon = iGeoloc.find('lon').text();
                            
                            // Any extra-values?
                            var tLocality = iGeoloc.find('locality').text();
                            var tRegion = iGeoloc.find('region').text();
                            var tCountry = iGeoloc.find('country').text();
                            var tHuman = PEP.humanPosition(tLocality, tRegion, tCountry);
                            
                            // Store the PEP event (and display it)
                            PEP.store(xid, 'geoloc', tLat, tLon, tHuman);
                            
                            break;
                        
                        // Microblog
                        case NS_URN_MBLOG:
                            Microblog.display(message, xid, hash, 'mixed', 'push');
                            
                            break;
                        
                        // Inbox
                        case NS_URN_INBOX:
                            // Do not handle friend's notifications
                            if(xid == Common.getXID())
                                Notification.handle(message);
                            
                            break;
                    }
                }
                
                return false;
            }
            
            // If this is a room topic message
            if(subject && (type == 'groupchat')) {
                // Filter the vars
                var filter_subject = subject.replace(/\n+/g, ' ');
                var filteredSubject = Filter.message(filter_subject, resource, true);
                var filteredName = resource.htmlEnc();
                
                // Display the new subject at the top
                $('#' + hash + ' .top .name .bc-infos .muc-topic').replaceWith('<span class="muc-topic" title="' + filter_subject + '">' + filteredSubject + '</span>');
                
                // Display the new subject as a system message
                if(resource) {
                    var topic_body = filteredName + ' ' + Common._e("changed the subject to:") + ' ' + Filter.message(subject, resource, true);
                    self.display(type, from, hash, filteredName, topic_body, time, stamp, 'system-message', false);
                }
            }
            
            // If the message has a content
            if(xHTML || body) {
                var filteredMessage;
                var html_escape = true;
                
                // IE bug fix
                if((BrowserDetect.browser == 'Explorer') && (BrowserDetect.version < 9)) {
                    xHTML = 0;
                }
                
                //If this is a xHTML message
                if(xHTML) {
                    html_escape = false;
                    
                    // Filter the xHTML message
                    body = Filter.xhtml(node);
                }
                
                // Groupchat message
                if(type == 'groupchat') {
                    /* REF: http://xmpp.org/extensions/xep-0045.html */
                    
                    // We generate the message type and time
                    var message_type = 'user-message';
                    
                    // This is an old message
                    if(delay && resource) {
                        message_type = 'old-message';
                    }
                    
                    // This is a system message
                    else if(!resource) {
                        message_type = 'system-message';
                    }
                    
                    var nickQuote = '';
                    
                    // If this is not an old message
                    if(message_type == 'user-message') {
                        var myNick = Name.getMUCNick(hash);
                        
                        // If an user quoted our nick (with some checks)
                        var regex = new RegExp('((^)|( )|(@))' + Common.escapeRegex(myNick) + '(($)|(:)|(,)|( ))', 'gi');
                        
                        if(body.match(regex) && (myNick != resource) && (message_type == 'user-message'))
                            nickQuote = ' my-nick';
                        
                        // We notify the user if there's a new personal message
                        if(nickQuote) {
                            Interface.messageNotify(hash, 'personal');
                            Board.quick(from, 'groupchat', raw_body, resource);
                            Audio.play('receive-message');
                        }
                        
                        // We notify the user there's a new unread MUC message
                        else {
                            Interface.messageNotify(hash, 'unread');
                            
                            // Play sound to all users in the MUC, except user who sent the message.
                            if(myNick != resource) {
                                Audio.play('receive-message');
                            }
                        }
                    }
                    
                    // Display the received message
                    self.display(type, from, hash, resource.htmlEnc(), body, time, stamp, message_type, html_escape, nickQuote);
                }
                
                // Chat message
                else {
                    // Gets the nickname of the user
                    var fromName = resource;
                    var chatType = 'chat';
                    
                    // Must send a receipt notification?
                    if(Receipts.has(message) && (id !== null))
                        Receipts.sendReceived(type, from, id);
                    
                    // It does not come from a groupchat user, get the full name
                    if(!GCUser) {
                        fromName = Name.getBuddy(xid);
                    } else {
                        chatType = 'private';
                    }
                    
                    // If the chat isn't yet opened, open it !
                    if(!Common.exists('#' + hash)) {
                        // We create a new chat
                        Chat.create(hash, xid, fromName, chatType);
                        
                        // We tell the user that a new chat has started
                        Audio.play('new-chat');
                    } else {
                        Audio.play('receive-message');
                    }
                    
                    // Display the received message
                    self.display(type, xid, hash, fromName.htmlEnc(), body, time, stamp, 'user-message', html_escape, '', 'him');
                    
                    // We notify the user
                    Interface.messageNotify(hash, 'personal');
                    Board.quick(xid, 'chat', raw_body, fromName);
                }
                
                return false;
            }
            
            return false;
        } catch(e) {
            Console.error('Message.handle', e);
        }

    };


    /**
     * Sends a given message
     * @public
     * @param {string} hash
     * @param {string} type
     * @return {boolean}
     */
    self.send = function(hash, type) {

        try {
            // Get the values
            var message_area = $('#' + hash + ' .message-area');
            var body = $.trim(message_area.val());
            var xid = unescape(message_area.attr('data-to'));
            var nXID;
            
            // If the user didn't entered any message, stop
            if(!body || !xid)
                return false;
        
            // We send the message through the XMPP network
            var aMsg = new JSJaCMessage();
            aMsg.setTo(xid);
            
            // Set an ID
            var id = genID();
            aMsg.setID(id);
            
            // /help shortcut
            if(body.match(/^\/help\s*(.*)/)) {
                // Help text
                var help_text = '<p class="help" xmlns="http://www.w3.org/1999/xhtml">';
                help_text += '<b>' + Common._e("Available shortcuts:") + '</b>';
                
                // Shortcuts array
                var shortcuts = [];
                
                // Common shortcuts
                shortcuts.push(Common.printf(Common._e("%s removes the chat logs"), '<em>/clear</em>'));
                shortcuts.push(Common.printf(Common._e("%s joins a groupchat"), '<em>/join jid</em>'));
                shortcuts.push(Common.printf(Common._e("%s closes the chat"), '<em>/part</em>'));
                shortcuts.push(Common.printf(Common._e("%s shows the user profile"), '<em>/whois jid</em>'));
                
                // Groupchat shortcuts
                if(type == 'groupchat') {
                    shortcuts.push(Common.printf(Common._e("%s sends a message to the room"), '<em>/say message</em>'));
                    shortcuts.push(Common.printf(Common._e("%s changes your nickname"), '<em>/nick nickname</em>'));
                    shortcuts.push(Common.printf(Common._e("%s sends a message to someone in the room"), '<em>/msg nickname message</em>'));
                    shortcuts.push(Common.printf(Common._e("%s changes the room topic"), '<em>/topic subject</em>'));
                    shortcuts.push(Common.printf(Common._e("%s kicks a user of the room"), '<em>/kick [reason:] nickname</em>'));
                    shortcuts.push(Common.printf(Common._e("%s bans a user of the room"), '<em>/ban [reason:] nickname</em>'));
                    shortcuts.push(Common.printf(Common._e("%s invites someone to join the room"), '<em>/invite jid message</em>'));
                }
                
                // Generate the code from the array
                shortcuts = shortcuts.sort();
                
                for(var s in shortcuts)
                    help_text += shortcuts[s] + '<br />';
                
                help_text += '</p>';
                
                // Display the message
                self.display(type, xid, hash, 'help', help_text, DateUtils.getCompleteTime(), DateUtils.getTimeStamp(), 'system-message', false);
                
                // Reset chatstate
                ChatState.send('active', xid, hash);
            }
            
            // /clear shortcut
            else if(body.match(/^\/clear/)) {
                Chat.clean(hex_md5(xid));
                
                // Reset chatstate
                ChatState.send('active', xid, hash);
            }
            
            // /join shortcut
            else if(body.match(/^\/join (\S+)\s*(.*)/)) {
                // Join
                var room = Common.generateXID(RegExp.$1, 'groupchat');
                var pass = RegExp.$2;
                
                Chat.checkCreate(room, 'groupchat');
                
                // Reset chatstate
                ChatState.send('active', xid, hash);
            }
            
            // /part shortcut
            else if(body.match(/^\/part\s*(.*)/) && (!Utils.isAnonymous() || (Utils.isAnonymous() && (xid != Common.generateXID(ANONYMOUS_ROOM, 'groupchat')))))
                Interface.quitThisChat(xid, hex_md5(xid), type);
            
            // /whois shortcut
            else if(body.match(/^\/whois(( (\S+))|($))/)) {
                var whois_xid = RegExp.$3;
                
                // Groupchat WHOIS
                if(type == 'groupchat') {
                    nXID = Utils.getMUCUserXID(xid, whois_xid);
                    
                    if(!nXID) {
                        Board.openThisInfo(6);
                    } else {
                        UserInfos.open(nXID);
                    }
                }
                
                // Chat or private WHOIS
                else {
                    if(!whois_xid) {
                        UserInfos.open(xid);
                    } else {
                        UserInfos.open(whois_xid);
                    }
                }
                
                // Reset chatstate
                ChatState.send('active', xid, hash);
            }
            
            // Chat message type
            else if(type == 'chat') {
                aMsg.setType('chat');
                
                // Generates the correct message depending of the choosen style
                var genMsg = self.generate(aMsg, body, hash);
                var html_escape = (genMsg !== 'XHTML');
                
                // Receipt request
                var receipt_request = Receipts.request(hash);
                
                if(receipt_request)
                    aMsg.appendNode('request', {'xmlns': NS_URN_RECEIPTS});
                
                // Chatstate
                aMsg.appendNode('active', {'xmlns': NS_CHATSTATES});
                
                // Send it!
                con.send(aMsg, Errors.handleReply);
                
                // Filter the xHTML message (for us!)
                if(!html_escape) {
                    body = Filter.xhtml(aMsg.getNode());
                }
                
                // Finally we display the message we just sent
                var my_xid = Common.getXID();
                
                self.display('chat', my_xid, hash, Name.getBuddy(my_xid).htmlEnc(), body, DateUtils.getCompleteTime(), DateUtils.getTimeStamp(), 'user-message', html_escape, '', 'me', id);
                
                // Receipt timer
                if(receipt_request) {
                    Receipts.checkReceived(hash, id);
                }
            }
            
            // Groupchat message type
            else if(type == 'groupchat') {
                // /say shortcut
                if(body.match(/^\/say (.+)/)) {
                    body = body.replace(/^\/say (.+)/, '$1');
                    
                    aMsg.setType('groupchat');
                    self.generate(aMsg, body, hash);
                    
                    con.send(aMsg, Errors.handleReply);
                }
                
                // /nick shortcut
                else if(body.match(/^\/nick (.+)/)) {
                    var nick = body.replace(/^\/nick (.+)/, '$1');
                    
                    // Does not exist yet?
                    if(!Utils.getMUCUserXID(xid, nick)) {
                        // Send a new presence
                        Presence.send(xid + '/' + nick, '', Presence.getUserShow(), self.getUserStatus(), '', false, false, Errors.handleReply);
                        
                        // Change the stored nickname
                        $('#' + hex_md5(xid)).attr('data-nick', escape(nick));
                        
                        // Reset chatstate
                        ChatState.send('active', xid, hash);
                    }
                }
                
                // /msg shortcut
                else if(body.match(/^\/msg (\S+)\s+(.+)/)) {
                    var msg_nick = RegExp.$1;
                    var msg_body = RegExp.$2;
                    nXID = Utils.getMUCUserXID(xid, msg_nick);
                    
                    // We check if the user exists
                    if(!nXID)
                        Board.openThisInfo(6);
                    
                    // If the private message is not empty
                    else if(msg_body) {
                        aMsg.setType('chat');
                        aMsg.setTo(nXID);
                        self.generate(aMsg, msg_body, hash);
                        
                        con.send(aMsg, Errors.handleReply);
                    }
                }
                
                // /topic shortcut
                else if(body.match(/^\/topic (.+)/)) {
                    var topic = body.replace(/^\/topic (.+)/, '$1');
                    
                    aMsg.setType('groupchat');
                    aMsg.setSubject(topic);
                    
                    con.send(aMsg, Errors.handleMessage);
                    
                    // Reset chatstate
                    ChatState.send('active', xid, hash);
                }
                
                // /ban shortcut
                else if(body.match(/^\/ban (.*)/)) {
                    var ban_nick = $.trim(RegExp.$1);
                    var ban_reason = '';
                    
                    // We check if the user exists, if not it may be because a reason is given
                    // we do not check it at first because the nickname could contain ':'
                    var ban_xid = Utils.getMUCUserRealXID(xid, ban_nick);

                    if(!ban_xid && (body.match(/^\/ban ([^:]+)[:]*(.*)/))) {
                        ban_reason = $.trim(RegExp.$1);
                        ban_nick = $.trim(RegExp.$2);

                        if(ban_nick.length === 0) {
                            ban_nick = ban_reason;
                            ban_reason = '';
                        }

                        ban_xid = Utils.getMUCUserXID(xid, ban_nick);
                    }
                    
                    Groupchat.banUser(xid, ban_xid, ban_reason);
                    
                    // Reset chatstate
                    ChatState.send('active', xid, hash);
                }
                
                // /kick shortcut
                else if(body.match(/^\/kick (.*)/)) {
                    var kick_nick = $.trim(RegExp.$1);
                    var kick_reason =  '';

                    // We check if the user exists, if not it may be because a reason is given
                    // we do not check it at first because the nickname could contain ':'
                    var kick_xid = Utils.getMUCUserRealXID(xid, kick_nick);

                    if(!kick_xid && (body.match(/^\/kick ([^:]+)[:]*(.*)/))) {
                        kick_reason = $.trim(RegExp.$1);
                        kick_nick = $.trim(RegExp.$2);

                        if(kick_nick.length === 0) {
                            kick_nick = kick_reason;
                            kick_reason = '';
                        }

                        kick_xid = Utils.getMUCUserXID(xid, kick_nick);
                    }
                    
                    Groupchat.kickUser(xid, kick_xid, kick_nick, kick_reason);
                    
                    // Reset chatstate
                    ChatState.send('active', xid, hash);
                }
                
                // /invite shortcut
                else if(body.match(/^\/invite (\S+)\s*(.*)/)) {
                    var i_xid = RegExp.$1;
                    var invite_reason = RegExp.$2;

                    var x = aMsg.appendNode('x', {'xmlns': NS_MUC_USER});
                    var aNode = x.appendChild(aMsg.buildNode('invite', {'to': i_xid, 'xmlns': NS_MUC_USER}));
                    
                    if(invite_reason) {
                        aNode.appendChild(aMsg.buildNode('reason', {'xmlns': NS_MUC_USER}, invite_reason));
                    }
                    
                    con.send(aMsg, Errors.handleReply);
                    
                    // Reset chatstate
                    ChatState.send('active', xid, hash);
                }
                
                // No shortcut, this is a message
                else {
                    aMsg.setType('groupchat');
                    
                    // Chatstate
                    aMsg.appendNode('active', {'xmlns': NS_CHATSTATES});
                    
                    self.generate(aMsg, body, hash);
                    
                    con.send(aMsg, Errors.handleMessage);
                    
                    Console.info('Message sent to: ' + xid + ' / ' + type);
                }
            }
            
            // We reset the message input
            $('#' + hash + ' .message-area').val('');
        } catch(e) {
            Console.error('Message.send', e);
        } finally {
            return false;
        }

    };


    /**
     * Generates the correct message area style
     * @public
     * @param {string} hash
     * @return {string}
     */
    self.generateStyle = function() {

        try {
            // Initialize the vars
            var styles = '#' + hash + ' div.bubble-style';
            var font = styles + ' a.font-current';
            var fontsize = styles + ' a.fontsize-current';
            var checkbox = styles + ' input[type="checkbox"]';
            var color = '#' + hash + ' .message-area[data-color]';
            var style = '';
            
            // Get the font value
            $(font).filter('[data-font]').each(function() {
                style += 'font-family: ' + $(this).attr('data-font') + ';';
            });
            
            // Get the font value
            $(fontsize).filter('[data-value]').each(function() {
                style += 'font-size: ' + $(this).attr('data-value') + 'px;';
            });
            
            // Loop the input values
            $(checkbox).filter(':checked').each(function() {
                // If there is a previous element
                if(style)
                    style += ' ';
                
                // Get the current style
                switch($(this).attr('class')) {
                    case 'bold':
                        style += 'font-weight: bold;';
                        break;
                    
                    case 'italic':
                        style += 'font-style: italic;';
                        break;
                    
                    case 'underline':
                        style += 'text-decoration: underline;';
                        break;
                }
            });
            
            // Get the color value
            $(color).each(function() {
                style += 'color: #' + $(this).attr('data-color');
            });
            
            return style;
        } catch(e) {
            Console.error('Message.generateStyle', e);
        }

    };


    /**
     * Read messages from local archive
     * @public
     * @param {string} hash
     * @return {string}
     */
    self.readLocalArchive = function(hash) {

        try {
            return DataStore.getPersistent(Common.getXID(), 'history', hash);
        } catch(e) {
            Console.error('Message.readLocalArchive', e);
        }

    };


    /**
     * Stores message in local archive
     * @public
     * @param {string} hash
     * @param {string} store_html
     * @return {undefined}
     */
    self.storeLocalArchive = function(hash, store_html) {

        try {
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'localarchives') != '0') {
                DataStore.setPersistent(Common.getXID(), 'history', hash, store_html);
            }
        } catch(e) {
            Console.error('Message.storeLocalArchive', e);
        }

    };


    /**
     * Removes messages from local archive
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.removeLocalArchive = function(hash) {

        try {
            DataStore.removePersistent(Common.getXID(), 'history', hash);
        } catch(e) {
            Console.error('Message.removeLocalArchive', e);
        }

    };


    /**
     * Flushes local messages archive
     * @public
     * @return {undefined}
     */
    self.flushLocalArchive = function() {

        try {
            var flush_count = 0;
            var db_regex = new RegExp(('^' + Common.getXID() + '_') + ('history_'));

            for(var i = 0; i < JappixDataStore.storagePersistent.length; i++) {
                var db_current = JappixDataStore.storagePersistent.key(i);

                if(db_regex.exec(db_current)) {
                    JappixDataStore.storagePersistent.removeItem(db_current);
                    flush_count++;
                }
            }

            Console.info('Flushed ' + flush_count + ' archives in total.');
        } catch(e) {
            Console.error('Message.flushLocalArchive', e);
        }

    };


    /**
     * Generates the correct message code
     * @public
     * @param {object} aMsg
     * @param {string} body
     * @param {string} hash
     * @return {string}
     */
    self.generate = function(aMsg, body, hash) {

        try {
            // Create the classical body
            aMsg.setBody(body);
            
            // Get the style
            var style = $('#' + hash + ' .message-area').attr('style');
            
            // A message style is choosen
            if(style) {
                // Explode the message body new lines (to create one <p /> element by line)
                var new_lines = new Array(body);
                
                if(body.match(/\n/))
                    new_lines = body.split('\n');
                
                // Create the XML elements
                var aHtml = aMsg.appendNode('html', {'xmlns': NS_XHTML_IM});
                var aBody = aHtml.appendChild(aMsg.buildNode('body', {'xmlns': NS_XHTML}));
                
                // Use the exploded body array to create one element per entry
                for(var i in new_lines) {
                    // Current line
                    var cLine = new_lines[i];
                    
                    // Blank line, we put a <br />
                    if(cLine.match(/(^)(\s+)($)/) || !cLine)
                        aBody.appendChild(aMsg.buildNode('br', {'xmlns': NS_XHTML}));
                    
                    // Line with content, we put a <p />
                    else {
                        // HTML encode the line
                        cLine = cLine.htmlEnc();
                        
                        // Filter the links
                        cLine = Links.apply(cLine, 'xhtml-im', style);
                        
                        // Append the filtered line
                        $(aBody).append($('<p style="' + style + '">' + cLine + '</p>'));
                    }
                }
                
                return 'XHTML';
            }
            
            return 'PLAIN';
        } catch(e) {
            Console.error('Message.generate', e);
        }

    };


    /**
     * Displays a given message in a chat tab
     * @public
     * @param {string} type
     * @param {string} xid
     * @param {string} hash
     * @param {string} name
     * @param {string} body
     * @param {string} time
     * @param {string} stamp
     * @param {string} message_type
     * @param {boolean} html_escape
     * @param {string} nick_quote
     * @param {string} mode
     * @param {string} id
     * @param {object} c_target_sel
     * @param {boolean} no_scroll
     * @return {undefined}
     */
    self.display = function(type, xid, hash, name, body, time, stamp, message_type, html_escape, nick_quote, mode, id, c_target_sel, no_scroll) {

        try {
            // Target
            if(typeof c_target_sel === 'undefined') {
                c_target_sel = $('#' + hash + ' .content');
            }

            // Generate some stuffs
            var has_avatar = false;
            var xid_hash = '';
            
            if(!nick_quote) {
                nick_quote = '';
            }
            
            if(message_type != 'system-message') {
                has_avatar = true;
                xid_hash = hex_md5(xid);
            }
            
            // Can scroll?
            var cont_scroll = document.getElementById('chat-content-' + hash);
            var can_scroll = false;
            
            if((!cont_scroll.scrollTop || ((cont_scroll.clientHeight + cont_scroll.scrollTop) == cont_scroll.scrollHeight)) && no_scroll !== true) {
                can_scroll = true;
            }
            
            // Any ID?
            var data_id = '';
            
            if(id) {
                data_id = ' data-id="' + id + '"';
            }
            
            // Filter the message
            var filteredMessage = Filter.message(body, name, html_escape);

            // Display the received message in the room
            var messageCode = '<div class="one-line ' + message_type + nick_quote + '" data-stamp="' + stamp + '"' + data_id + '>';
            
            // Name color attribute
            if(type == 'groupchat') {
                attribute = ' style="color: ' + Common.generateColor(name) + ';" class="name';
            } else {
                attribute = ' class="name';
                
                if(mode) {
                    attribute += ' ' + mode;
                }
            }
            
            // Close the class attribute
            if(message_type == 'system-message') {
                attribute += ' hidden"';
            } else {
                attribute += '"';
            }
            
            // Filter the previous displayed message
            var last = c_target_sel.find('.one-group:not(.from-history):last');
            var last_name = last.find('b.name').attr('data-xid');
            var last_type = last.attr('data-type');
            var last_stamp = parseInt(last.attr('data-stamp'));
            var grouped = false;
            
            // We can group it with another previous message
            if((last_name == xid) && (message_type == last_type) && ((stamp - last_stamp) <= 1800)) {
                grouped = true;
            }
            
            // Is it a /me command?
            if(body.match(/(^|>)(\/me )([^<]+)/)) {
                filteredMessage = '<i>' + filteredMessage + '</i>';
            }
            
            messageCode += filteredMessage + '</div>';
            
            // Must group it?
            if(!grouped) {
                // Generate message headers
                var message_head = '';
                
                // Any avatar to add?
                if(has_avatar) {
                    message_head += '<div class="avatar-container"><img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" /></div>';
                }
                
                // Add the date & the name
                message_head += '<span class="date">' + time + '</span><b data-xid="' + Common.encodeQuotes(xid) + '" ' + attribute + '>' + name + '</b>';
                
                // Generate message code
                messageCode = '<div class="one-group ' + xid_hash + '" data-type="' + message_type + '" data-stamp="' + stamp + '">' + message_head + messageCode + '</div>';
            }

            // Write the code in the DOM
            if(grouped) {
                c_target_sel.find('.one-group:last').append(messageCode);
            } else {
                c_target_sel.append(messageCode);
            }

            // Store the last MAM.REQ_MAX message groups
            if(!Features.enabledMAM() && (type == 'chat') && (message_type == 'user-message')) {
                // Filter the DOM
                var dom_filter = $('#' + hash + ' .content').clone().contents();
                var default_avatar = ('./images/others/default-avatar.png').replace(/&amp;/g, '&'); // Fixes #252
                
                $(dom_filter).find('.system-message').parent().remove();
                $(dom_filter).find('.avatar-container img.avatar').attr('src', default_avatar);
                $(dom_filter).find('.one-line').parent().slice(0, $(dom_filter).find('.one-line').parent().size() - MAM.REQ_MAX).remove();
                
                var store_html = $(dom_filter).parent().html();
                
                // Store the data
                if(store_html) {
                    self.storeLocalArchive(hash, store_html);
                }
            }
            
            // Must get the avatar?
            if(has_avatar && xid && !grouped) {
                Avatar.get(xid, 'cache', 'true', 'forget');
            }
            
            // Scroll to this message
            if(can_scroll) {
                Interface.autoScroll(hash);
            }
        } catch(e) {
            Console.error('Message.display', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the chatstate JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var ChatState = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Sends a given chatstate to a given entity
     * @public
     * @param {string} state
     * @param {string} xid
     * @param {string} hash
     * @return {undefined}
     */
    self.send = function(state, xid, hash) {

        try {
            var user_type = $('#' + hash).attr('data-type');
            
            // If the friend client supports chatstates and is online
            if((user_type == 'groupchat') || ((user_type == 'chat') && $('#' + hash + ' .message-area').attr('data-chatstates') && !Common.exists('#page-switch .' + hash + ' .unavailable'))) {
                // Already sent?
                if(DataStore.getDB(Connection.desktop_hash, 'currentchatstate', xid) == state)
                    return;
                
                // Write the state
                DataStore.setDB(Connection.desktop_hash, 'currentchatstate', xid, state);
                
                // New message stanza
                var aMsg = new JSJaCMessage();
                aMsg.setTo(xid);
                aMsg.setType(user_type);
                
                // Append the chatstate node
                aMsg.appendNode(state, {'xmlns': NS_CHATSTATES});
                
                // Send this!
                con.send(aMsg);
            }
        } catch(e) {
            Console.error('ChatState.send', e);
        }

    };


    /**
     * Displays a given chatstate in a given chat
     * @public
     * @param {string} state
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.display = function(state, hash, type) {

        try {
            // Groupchat?
            if(type == 'groupchat') {
                self.reset(hash, type);
                
                // "gone" state not allowed
                if(state != 'gone')
                    $('#page-engine .page-engine-chan .user.' + hash).addClass(state);
            }
            
            // Chat
            else {
                // We change the buddy name color in the page-switch
                self.reset(hash, type);
                $('#page-switch .' + hash + ' .name').addClass(state);
                
                // We generate the chatstate text
                var text = '';
                
                switch(state) {
                    // Active
                    case 'active':
                        text = Common._e("Your friend is paying attention to the conversation.");
                        
                        break;
                    
                    // Composing
                    case 'composing':
                        text = Common._e("Your friend is writing a message...");
                        
                        break;
                    
                    // Paused
                    case 'paused':
                        text = Common._e("Your friend stopped writing a message.");
                        
                        break;
                    
                    // Inactive
                    case 'inactive':
                        text = Common._e("Your friend is doing something else.");
                        
                        break;
                    
                    // Gone
                    case 'gone':
                        text = Common._e("Your friend closed the chat.");
                        
                        break;
                }
                
                // We reset the previous state
                $('#' + hash + ' .chatstate').remove();
                
                // We create the chatstate
                $('#' + hash + ' .content').after('<div class="' + state + ' chatstate">' + text + '</div>');
            }
        } catch(e) {
            Console.error('ChatState.display', e);
        }

    };


    /**
     * Resets the chatstate switcher marker
     * @public
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.reset = function(hash, type) {

        try {
            // Define the selector
            var selector;
            
            if(type == 'groupchat')
                selector = $('#page-engine .page-engine-chan .user.' + hash);
            else
                selector = $('#page-switch .' + hash + ' .name');
            
            // Reset!
            selector.removeClass('active composing paused inactive gone');
        } catch(e) {
            Console.error('ChatState.reset', e);
        }

    };


    /**
     * Adds the chatstate events
     * @public
     * @param {object} target
     * @param {string} xid
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.events = function(target, xid, hash, type) {

        try {
            target.keyup(function(e) {
                if(e.keyCode != 13) {
                    // Composing a message
                    if($(this).val() && (DataStore.getDB(Connection.desktop_hash, 'chatstate', xid) != 'on')) {
                        // We change the state detect input
                        DataStore.setDB(Connection.desktop_hash, 'chatstate', xid, 'on');
                        
                        // We send the friend a "composing" chatstate
                        self.send('composing', xid, hash);
                    }
                    
                    // Flushed the message which was being composed
                    else if(!$(this).val() && (DataStore.getDB(Connection.desktop_hash, 'chatstate', xid) == 'on')) {
                        // We change the state detect input
                        DataStore.setDB(Connection.desktop_hash, 'chatstate', xid, 'off');
                        
                        // We send the friend an "active" chatstate
                        self.send('active', xid, hash);
                    }
                }
            });
            
            target.change(function() {
                // Reset the composing database entry
                DataStore.setDB(Connection.desktop_hash, 'chatstate', xid, 'off');
            });
            
            target.focus(function() {
                // Not needed
                if(target.is(':disabled'))
                    return;
                
                // Something was written, user started writing again
                if($(this).val())
                    self.send('composing', xid, hash);

                // Chat only: Nothing in the input, user is active
                else if(type == 'chat')
                    self.send('active', xid, hash);
            });
            
            target.blur(function() {
                // Not needed
                if(target.is(':disabled'))
                    return;
                
                // Something was written, user paused
                if($(this).val())
                    self.send('paused', xid, hash);

                // Chat only: Nothing in the input, user is inactive
                else if(type == 'chat')
                    self.send('inactive', xid, hash);
            });
        } catch(e) {
            Console.error('ChatState.events', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the receipts JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Receipts = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Checks if we can send a receipt request
     * @public
     * @param {string} hash
     * @return {boolean}
     */
    self.request = function(hash) {

        has_support = false;

        try {
            // Entity have support for receipt?
            if($('#' + hash + ' .message-area').attr('data-receipts') == 'true') {
                has_support = true;
            }
        } catch(e) {
            Console.error('Receipts.request', e);
        } finally {
            return has_support;
        }

    };


    /**
     * Checks if there is a receipt request
     * @public
     * @param {object} packet
     * @return {boolean}
     */
    self.has = function(packet) {

        has_receipt = false;

        try {
            // Any receipt request?
            if(packet.getChild('request', NS_URN_RECEIPTS)) {
                has_receipt = true;
            }
        } catch(e) {
            Console.error('Receipts.has', e);
        } finally {
            return has_receipt;
        }

    };


    /**
     * Checks if there is a received reply
     * @public
     * @param {object} packet
     * @return {boolean}
     */
    self.hasReceived = function(packet) {

        has_received = false;

        try {
            // Any received reply?
            if(packet.getChild('received', NS_URN_RECEIPTS)) {
                has_received = true;
            }
        } catch(e) {
            Console.error('Receipts.received', e);
        } finally {
            return has_received;
        }

    };


    /**
     * Sends a received notification
     * @public
     * @param {string} type
     * @param {string} to
     * @param {string} id
     * @return {undefined}
     */
    self.sendReceived = function(type, to, id) {

        try {
            var aMsg = new JSJaCMessage();
            aMsg.setTo(to);
            aMsg.setID(id);
            
            // Any type?
            if(type)
                aMsg.setType(type);
            
            // Append the received node
            aMsg.appendNode('received', {'xmlns': NS_URN_RECEIPTS, 'id': id});
            
            con.send(aMsg);
            
            Console.log('Sent received to: ' + to);
        } catch(e) {
            Console.error('Receipts.sendReceived', e);
        }

    };


    /**
     * Tells the message has been received
     * @public
     * @param {string} hash
     * @param {string} id
     * @return {boolean}
     */
    self.messageReceived = function(hash, id) {

        try {
            // Line selector
            var path = $('#' + hash + ' .one-line[data-id="' + id + '"]');
            
            // Add a received marker
            path.attr('data-received', 'true')
                .removeAttr('data-lost');
            
            // Group selector
            var group = path.parent();
            
            // Remove the group marker
            if(!group.find('.one-line[data-lost]').size()) {
                group.find('b.name').removeClass('talk-images')
                            .removeAttr('title');
            }
        } catch(e) {
            Console.error('Receipts.messageReceived', e);
        } finally {
            return false;
        }

    };


    /**
     * Checks if the message has been received
     * @public
     * @param {string} hash
     * @param {string} id
     * @return {undefined}
     */
    self.checkReceived = function(hash, id) {

        try {
            // Fire a check 10 seconds later
            $('#' + hash + ' .one-line[data-id="' + id + '"]').oneTime('10s', function() {
                // Not received?
                if($(this).attr('data-received') != 'true') {
                    // Add a "lost" marker
                    $(this).attr('data-lost', 'true');
                    
                    // Add a warn on the buddy-name
                    $(this).parent().find('b.name').addClass('talk-images')
                                       .attr('title', Common._e("Your friend seems not to have received your message(s)!"));
                }
            });
        } catch(e) {
            Console.error('Receipts.checkReceived', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the tooltip JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Tooltip = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Creates a tooltip code
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {string} type
     * @return {boolean}
     */
    self.create = function(xid, hash, type) {

        try {
            // Path to the element
            var path = '#' + hash;
            var path_tooltip = path + ' .chat-tools-' + type;
            var path_bubble = path_tooltip + ' .bubble-' + type;
            
            // Yet exists?
            if(Common.exists(path_bubble))
                return false;
            
            // Generates special tooltip HTML code
            var title = '';
            var content = '';
            
            switch(type) {
                // Smileys
                case 'smileys':
                    title = Common._e("Smiley insertion");
                    content = Smileys.links(hash);
                    
                    break;
                
                // Style
                case 'style':
                    title = Common._e("Change style");
                    
                    // Generate fonts list
                    var fonts = {
                        'arial': 'Arial, Helvetica, sans-serif',
                        'arial-black': '\'Arial Black\', Gadget, sans-serif',
                        'bookman-old-style': '\'Bookman Old Style\', serif',
                        'comic-sans-ms': '\'Comic Sans MS\', cursive',
                        'courier': 'Courier, monospace',
                        'courier-new': '\'Courier New\', Courier, monospace',
                        'garamond': 'Garamond, serif',
                        'georgia': 'Georgia, serif',
                        'impact': 'Impact, Charcoal, sans-serif',
                        'lucida-console': '\'Lucida Console\', Monaco, monospace',
                        'lucida-sans-unicode': '\'Lucida Sans Unicode\', \'Lucida Grande\', sans-serif',
                        'ms-sans-serif': '\'MS Sans Serif\', Geneva, sans-serif',
                        'ms-serif': '\'MS Serif\', \'New York\', sans-serif',
                        'palatino-linotype': '\'Palatino Linotype\', \'Book Antiqua\', Palatino, serif',
                        'symbol': 'Symbol, sans-serif',
                        'tahoma': 'Tahoma, Geneva, sans-serif',
                        'times-new-roman': '\'Times New Roman\', Times, serif',
                        'trebuchet-ms': '\'Trebuchet MS\', Helvetica, sans-serif',
                        'verdana': 'Verdana, Geneva, sans-serif',
                        'webdings': 'Webdings, sans-serif',
                        'wingdings': 'Wingdings, \'Zapf Dingbats\', sans-serif'
                    };
                    
                    var fonts_html = '<div class="font-list">';
                    
                    // No fonts
                    fonts_html += '<a href="#">' + Common._e("None") + '</a>';
                    
                    // Available fonts
                    $.each(fonts, function(id_name, full_name) {
                        // Generate short name
                        var short_name = full_name;
                        
                        if(short_name.match(/,/)) {
                            var name_split = short_name.split(',');
                            short_name = $.trim(name_split[0]);
                        }
                        
                        short_name = short_name.replace(/([^a-z0-9\s]+)/gi, '');
                        
                        // Add this to the HTML
                        fonts_html += '<a href="#" data-value="' + Common.encodeQuotes(id_name) + '" data-font="' + Common.encodeQuotes(full_name) + '" style="font-family: ' + Common.encodeQuotes(full_name) + ';">' + short_name.htmlEnc() + '</a>';
                    });
                    fonts_html += '</div>';
                    
                    content = 
                        '<label class="font">' + 
                            '<div class="font-icon talk-images"></div>' + 
                            
                            '<div class="fontsize-change">' + 
                                '<a class="fontsize-current" href="#">12</a>' + 
                                '<div class="fontsize-list">' + 
                                    '<a href="#" class="reset talk-images"></a>' + 
                                    '<a href="#" data-value="10" style="font-size: 10px;">10</a>' + 
                                    '<a href="#" data-value="12" style="font-size: 12px;">12</a>' + 
                                    '<a href="#" data-value="14" style="font-size: 14px;">14</a>' + 
                                    '<a href="#" data-value="16" style="font-size: 16px;">16</a>' + 
                                    '<a href="#" data-value="18" style="font-size: 18px;">18</a>' + 
                                '</div>' + 
                            '</div>' + 
                            
                            '<div class="font-change">' + 
                                '<a class="font-current" href="#">' + Common._e("None") + '</a>' + 
                                fonts_html + 
                            '</div>' + 
                        '</label>' + 
                        '<label class="bold"><input type="checkbox" class="bold" />' + Common._e("Text in bold") + '</label>' + 
                        '<label class="italic"><input type="checkbox" class="italic" />' + Common._e("Text in italic") + '</label>' + 
                        '<label class="underline"><input type="checkbox" class="underline" />' + Common._e("Underlined text") + '</label>' + 
                        '<a href="#" class="color" style="background-color: #b10808; clear: both;" data-color="b10808"></a>' + 
                        '<a href="#" class="color" style="background-color: #e5860c;" data-color="e5860c"></a>' + 
                        '<a href="#" class="color" style="background-color: #f0f30e;" data-color="f0f30e"></a>' + 
                        '<a href="#" class="color" style="background-color: #009a04;" data-color="009a04"></a>' + 
                        '<a href="#" class="color" style="background-color: #0ba9a0;" data-color="0ba9a0"></a>' + 
                        '<a href="#" class="color" style="background-color: #04228f;" data-color="04228f"></a>' + 
                        '<a href="#" class="color" style="background-color: #9d0ab7;" data-color="9d0ab7"></a>' + 
                        '<div class="color-picker">' + 
                            '<a href="#" class="color-more talk-images"></a>' + 
                            '<div class="color-hex">' + 
                                '<span class="hex-begin">#</span>' + 
                                '<input class="hex-value" type="text" maxlength="6" placeholder="e1e1e1" />' + 
                            '</div>' + 
                        '</div>';
                    
                    break;
                
                // File send
                case 'file':
                    title = Common._e("Send a file");
                    content = '<p style="margin-bottom: 8px;">' + Common._e("Once uploaded, your friend will be prompted to download the file you sent.") + '</p>';
                    content += '<form id="oob-upload" action="./server/send.php" method="post" enctype="multipart/form-data">' + Interface.generateFileShare() + '</form>';
                    
                    break;
                
                // Chat log
                case 'save':
                    title = Common._e("Save chat");
                    content = '<p style="margin-bottom: 8px;">' + Common._e("Click on the following link to get the chat log, and wait. Then click again to get the file.") + '</p>';
                    
                    // Possible to generate any log?
                    if($(path + ' .one-line').size())
                        content += '<a href="#" class="tooltip-actionlog">' + Common._e("Generate file!") + '</a>';
                    else
                        content += '<span class="tooltip-nolog">' + Common._e("This chat is empty!") + '</span>';
                    
                    break;
            }
            
            // Generates general tooltip HTML code
            var html = 
                '<div class="tooltip bubble-' + type + '">' + 
                    '<div class="tooltip-subitem">' + 
                        '<p class="tooltip-top">' + title + '</p>' + 
                        content + 
                    '</div>' + 
                    
                    '<div class="tooltip-subarrow talk-images"></div>' + 
                '</div>';
            
            // Append the HTML code
            $(path_tooltip).append(html);
            
            // Special events
            switch(type) {
                // Smileys
                case 'smileys':
                    // Apply click event on smiley links
                    $(path_tooltip + ' a.emoticon').click(function() {
                        return Interface.insertSmiley($(this).attr('data-smiley'), hash);
                    });
                    
                    break;
                
                // Style
                case 'style':
                    // Paths to items
                    var message_area = path + ' .message-area';
                    var bubble_style = path_tooltip + ' .bubble-style';
                    var style = bubble_style + ' input:checkbox';
                    var colors = bubble_style + ' a.color';
                    var font_current = bubble_style + ' a.font-current';
                    var font_list = bubble_style + ' div.font-list';
                    var font_select = font_list + ' a';
                    var fontsize_current = bubble_style + ' a.fontsize-current';
                    var fontsize_list = bubble_style + ' div.fontsize-list';
                    var fontsize_select = fontsize_list + ' a';
                    var color = bubble_style + ' div.color-picker';
                    var color_more = color + ' a.color-more';
                    var color_hex = color + ' div.color-hex';
                    
                    // Click event on style bubble
                    $(bubble_style).click(function() {
                        // Hide font selector if opened
                        if($(font_list).is(':visible'))
                            $(font_current).click();
                        
                        // Hide font-size selector if opened
                        if($(fontsize_list).is(':visible'))
                            $(fontsize_current).click();
                        
                        // Hide color selector if opened
                        if($(color_hex).is(':visible'))
                            $(color_more).click();
                    });
                    
                    // Click event on font picker
                    $(font_current).click(function() {
                        // The clicked color is yet selected
                        if($(font_list).is(':visible'))
                            $(this).parent().removeClass('listed');
                        else
                            $(this).parent().addClass('listed');
                        
                        return false;
                    });
                    
                    // Click event on a new font in the picker
                    $(font_select).click(function() {
                        // No font selected
                        if(!$(this).attr('data-value')) {
                            $(font_current).removeAttr('data-font')
                                           .removeAttr('data-value')
                                           .text(Common._e("None"));
                            
                            $(message_area).removeAttr('data-font');
                        }
                        
                        // A font is defined
                        else {
                            $(font_current).attr('data-font', $(this).attr('data-font'))
                                           .attr('data-value', $(this).attr('data-value'))
                                           .text($(font_list).find('a[data-value="' + $(this).attr('data-value') + '"]').text());
                            
                            $(message_area).attr('data-font', $(this).attr('data-value'));
                        }
                        
                        return false;
                    });
                    
                    // Click event on font-size picker
                    $(fontsize_current).click(function() {
                        // The clicked color is yet selected
                        if($(fontsize_list).is(':visible'))
                            $(this).parent().removeClass('listed');
                        else
                            $(this).parent().addClass('listed');
                        
                        return false;
                    });
                    
                    // Click event on a new font-size in the picker
                    $(fontsize_select).click(function() {
                        // No font-size selected
                        if(!$(this).attr('data-value')) {
                            $(fontsize_current).removeAttr('data-value').text(Common._e("16"));
                            $(message_area).removeAttr('data-fontsize');
                        }
                        
                        // A font-size is defined
                        else {
                            $(fontsize_current).attr('data-value', $(this).attr('data-value'))
                                               .text($(this).attr('data-value'));
                            $(message_area).attr('data-fontsize', $(this).attr('data-value'));
                        }
                        
                        return false;
                    });
                    
                    // Click event on color picker
                    $(colors).click(function() {
                        // Reset the manual picker
                        $(color_hex).find('input').val('');
                        
                        // The clicked color is yet selected
                        if($(this).hasClass('selected')) {
                            $(message_area).removeAttr('data-color');
                            $(this).removeClass('selected');
                        }
                        
                        else {
                            $(message_area).attr('data-color', $(this).attr('data-color'));
                            $(colors).removeClass('selected');
                            $(this).addClass('selected');
                        }
                        
                        return false;
                    });
                    
                    // Click event on color picker
                    $(color_more).click(function() {
                        // The clicked color is yet selected
                        if($(color_hex).is(':visible'))
                            $(this).parent().removeClass('opened');
                        
                        else {
                            $(this).parent().addClass('opened');
                            
                            // Focus
                            $(document).oneTime(10, function() {
                                $(color_hex).find('input').focus();
                            });
                        }
                        
                        return false;
                    });
                    
                    // Click event on color hex
                    $(color_hex).click(function() {
                        return false;
                    });
                    
                    // Keyup event on color picker
                    $(color_hex).find('input').keyup(function(e) {
                        // Submit
                        if(e.keyCode == 13) {
                            if($(color_hex).is(':visible')) {
                                $(color_more).click();
                                
                                // Focus again on the message textarea
                                $(document).oneTime(10, function() {
                                    $(message_area).focus();
                                });
                            }
                            
                            return false;
                        }
                        
                        // Reset current color
                        $(message_area).removeAttr('data-color');
                        $(colors).removeClass('selected');
                        
                        // Change value
                        var new_value = $(this).val().replace(/([^a-z0-9]+)/gi, '');
                        $(this).val(new_value);
                        
                        if(new_value)
                            $(message_area).attr('data-color', new_value);
                        
                        // Regenerate style
                        var style = Message.generateStyle(hash);
                        
                        // Any style to apply?
                        if(style)
                            $(message_area).attr('style', style);
                        else
                            $(message_area).removeAttr('style');
                    }).placeholder();
                    
                    // Change event on text style checkboxes
                    $(style).change(function() {
                        // Get current type
                        var style_data = 'data-' + $(this).attr('class');
                        
                        // Checked checkbox?
                        if($(this).filter(':checked').size())
                            $(message_area).attr(style_data, true);
                        else
                            $(message_area).removeAttr(style_data);
                    });
                    
                    // Update the textarea style when it is changed
                    $(style + ', ' + colors + ', ' + font_select + ', ' + fontsize_select).click(function() {
                        var style = Message.generateStyle(hash);
                        
                        // Any style to apply?
                        if(style)
                            $(message_area).attr('style', style);
                        else
                            $(message_area).removeAttr('style');
                        
                        // Focus again on the message textarea
                        $(document).oneTime(10, function() {
                            $(message_area).focus();
                        });
                    });
                    
                    // Load current style
                    self.loadStyleSelector(hash);
                    
                    break;
                
                // File send
                case 'file':
                    // File upload vars
                    var oob_upload_options = {
                        dataType:       'xml',
                        beforeSubmit:   OOB.waitUpload,
                        success:        OOB.handleUpload
                    };
                    
                    // Upload form submit event
                    $(path_tooltip + ' #oob-upload').submit(function() {
                        if($(path_tooltip + ' #oob-upload input[type="file"]').val())
                            $(this).ajaxSubmit(oob_upload_options);
                        
                        return false;
                    });
                    
                    // Upload input change event
                    $(path_tooltip + ' #oob-upload input[type="file"]').change(function() {
                        if($(this).val())
                            $(path_tooltip + ' #oob-upload').ajaxSubmit(oob_upload_options);
                        
                        return false;
                    });
                    
                    // Input click event
                    $(path_tooltip + ' #oob-upload input[type="file"], ' + path_tooltip + ' #oob-upload input[type="submit"]').click(function() {
                        if(Common.exists(path_tooltip + ' #oob-upload input[type="reset"]'))
                            return;
                        
                        // Lock the bubble
                        $(path_bubble).addClass('locked');
                        
                        // Add a cancel button
                        $(this).after('<input type="reset" value="' + Common._e("Cancel") + '" />');
                        
                        // Cancel button click event
                        $(path_tooltip + ' #oob-upload input[type="reset"]').click(function() {
                            // Remove the bubble
                            $(path_bubble).removeClass('locked');
                            self.destroy(hash, 'file');
                        });
                    });
                    
                    break;
                
                // Chat log
                case 'save':
                    // Chat log generation click event
                    $(path_tooltip + ' .tooltip-actionlog').click(function() {
                        // Replace it with a waiting notice
                        $(this).replaceWith('<span class="tooltip-waitlog">' + Common._e("Please wait...") + '</span>');
                        
                        Interface.generateChatLog(xid, hash);
                        
                        return false;
                    });
                    
                    break;
            }
            
            return true;
        } catch(e) {
            Console.error('Tooltip.create', e);
        }

    };


    /**
     * Destroys a tooltip code
     * @public
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.destroy = function(hash, type) {

        try {
            $('#' + hash + ' .chat-tools-content:not(.mini) .bubble-' + type + ':not(.locked)').remove();
        } catch(e) {
            Console.error('Tooltip.destroy', e);
        }

    };


    /**
     * Applies the page-engine tooltips hover event
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {string} type
     * @return {undefined}
     */
    self.hover = function(xid, hash, type) {

        try {
            $('#' + hash + ' .chat-tools-' + type).hover(function() {
                self.create(xid, hash, type);
            }, function() {
                self.destroy(hash, type);
            });
        } catch(e) {
            Console.error('Tooltip.hover', e);
        }

    };


    /**
     * Applies the hover function to the needed things
     * @public
     * @param {string} xid
     * @param {string} hash
     * @return {undefined}
     */
    self.icons = function(xid, hash) {

        try {
            // Hover events
            self.hover(xid, hash, 'smileys');
            self.hover(xid, hash, 'style');
            self.hover(xid, hash, 'file');
            self.hover(xid, hash, 'save');
            
            // Click events
            $('#' + hash + ' a.chat-tools-content, #' + hash + ' .chat-tools-content a').click(function() {
                return false;
            });
        } catch(e) {
            Console.error('Tooltip.icons', e);
        }

    };


    /**
     * Loads the style selector options
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.loadStyleSelector = function(hash) {

        try {
            // Define the vars
            var path = '#' + hash;
            var message_area = $(path + ' .message-area');
            var bubble_style = path + ' .bubble-style';
            var font = message_area.attr('data-font');
            var font_select = $(bubble_style + ' div.font-list').find('a[data-value="' + font + '"]');
            var fontsize = message_area.attr('data-fontsize');
            var color = message_area.attr('data-color');
            
            // Apply message font
            if(font) {
                $(bubble_style + ' a.font-current').attr('data-value', font)
                                                   .attr('data-font', font_select.attr('data-font'))
                                                   .text(font_select.text());
            }
            
            // Apply message font-size
            if(fontsize) {
                $(bubble_style + ' a.fontsize-current').attr('data-value', fontsize)
                                                       .text(fontsize);
            }
            
            // Apply the options to the style selector
            $(bubble_style + ' input[type="checkbox"]').each(function() {
                // Current input enabled?
                if(message_area.attr('data-' + $(this).attr('class')))
                    $(this).attr('checked', true);
            });
            
            // Apply message color
            if(color) {
                if($(bubble_style + ' a.color[data-color="' + color + '"]').size())
                    $(bubble_style + ' a.color[data-color="' + color + '"]').addClass('selected');
                else
                    $(bubble_style + ' div.color-hex input.hex-value').val(color);
            }
        } catch(e) {
            Console.error('Tooltip.loadStyleSelector', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the filtering JS script for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var Filter = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Generates a given emoticon HTML code
     * @public
     * @param {string} image
     * @param {string} text
     * @param {string} after
     * @return {string}
     */
    self.emoteImage = function(image, text, after) {

        try {
            return ' <img class="emoticon emoticon-' + image + ' smileys-images" alt="' + Common.encodeQuotes(text) + '" src="' + './images/others/blank.gif' + '" /> ' + after;
        } catch(e) {
            Console.error('Filter.emoteImage', e);
        }

    };


    /**
     * Filters a given message
     * @public
     * @param {string} neutralMessage
     * @param {string} nick
     * @param {string} html_escape
     * @return {string}
     */
    self.message = function(neutralMessage, nick, html_escape) {

        try {
            var filteredMessage = neutralMessage;
            
            // We encode the HTML special chars
            if(html_escape)
                filteredMessage = filteredMessage.htmlEnc();
            
            // /me command
            filteredMessage = filteredMessage.replace(/((^)|((.+)(>)))(\/me )([^<]+)/, nick + ' $7')
            
            // We replace the smilies text into images
            .replace(/(:-?@)($|\s|<)/gi, self.emoteImage('angry', '$1', '$2'))
            .replace(/(:-?\[)($|\s|<)/gi, self.emoteImage('bat', '$1', '$2'))
            .replace(/(\(B\))($|\s|<)/g, self.emoteImage('beer', '$1', '$2'))
            .replace(/((:-?D)|(XD))($|\s|<)/gi, self.emoteImage('biggrin', '$1', '$4'))
            .replace(/(:-?\$)($|\s|<)/gi, self.emoteImage('blush', '$1', '$2'))
            .replace(/(\(Z\))($|\s|<)/g, self.emoteImage('boy', '$1', '$2'))
            .replace(/(\(W\))($|\s|<)/g, self.emoteImage('brflower', '$1', '$2'))            
            .replace(/((&lt;\/3)|(\(U\)))($|\s|<)/g, self.emoteImage('brheart', '$1', '$4'))         
            .replace(/(\(C\))($|\s|<)/g, self.emoteImage('coffee', '$1', '$2'))          
            .replace(/((8-\))|(\(H\)))($|\s|<)/g, self.emoteImage('coolglasses', '$1', '$4'))
            .replace(/(:'-?\()($|\s|<)/gi, self.emoteImage('cry', '$1', '$2'))
            .replace(/(\(%\))($|\s|<)/g, self.emoteImage('cuffs', '$1', '$2'))
            .replace(/(\]:-?&gt;)($|\s|<)/gi, self.emoteImage('devil', '$1', '$2'))          
            .replace(/(\(D\))($|\s|<)/g, self.emoteImage('drink', '$1', '$2'))
            .replace(/(@}-&gt;--)($|\s|<)/gi, self.emoteImage('flower', '$1', '$2'))
            .replace(/((:-?\/)|(:-?S))($|\s|<)/gi, self.emoteImage('frowning', '$1', '$4'))
            .replace(/(\(X\))($|\s|<)/g, self.emoteImage('girl', '$1', '$2'))
            .replace(/((&lt;3)|(\(L\)))($|\s|<)/g, self.emoteImage('heart', '$1', '$4'))
            .replace(/(\(}\))($|\s|<)/g, self.emoteImage('hugleft', '$1', '$2'))         
            .replace(/(\({\))($|\s|<)/g, self.emoteImage('hugright', '$1', '$2'))
            .replace(/(:-?{})($|\s|<)/gi, self.emoteImage('kiss', '$1', '$2'))
            .replace(/(\(I\))($|\s|<)/g, self.emoteImage('lamp', '$1', '$2'))
            .replace(/(:-?3)($|\s|<)/gi, self.emoteImage('lion', '$1', '$2'))
            .replace(/(\(E\))($|\s|<)/g, self.emoteImage('mail', '$1', '$2'))
            .replace(/(\(S\))($|\s|<)/g, self.emoteImage('moon', '$1', '$2'))
            .replace(/(\(8\))($|\s|<)/g, self.emoteImage('music', '$1', '$2'))
            .replace(/((=-?O)|(:-?O))($|\s|<)/gi, self.emoteImage('oh', '$1', '$4'))
            .replace(/(\(T\))($|\s|<)/g, self.emoteImage('phone', '$1', '$2'))
            .replace(/(\(P\))($|\s|<)/g, self.emoteImage('photo', '$1', '$2'))
            .replace(/(:-?!)($|\s|<)/gi, self.emoteImage('puke', '$1', '$2'))
            .replace(/(\(@\))($|\s|<)/g, self.emoteImage('pussy', '$1', '$2'))
            .replace(/(\(R\))($|\s|<)/g, self.emoteImage('rainbow', '$1', '$2'))
            .replace(/(:-?\))($|\s|<)/gi, self.emoteImage('smile', '$1', '$2'))
            .replace(/(\(\*\))($|\s|<)/g, self.emoteImage('star', '$1', '$2'))
            .replace(/(:-?\|)($|\s|<)/gi, self.emoteImage('stare', '$1', '$2'))
            .replace(/(\(N\))($|\s|<)/g, self.emoteImage('thumbdown', '$1', '$2'))
            .replace(/(\(Y\))($|\s|<)/g, self.emoteImage('thumbup', '$1', '$2'))
            .replace(/(:-?P)($|\s|<)/gi, self.emoteImage('tongue', '$1', '$2'))
            .replace(/(:-?\()($|\s|<)/gi, self.emoteImage('unhappy', '$1', '$2'))
            .replace(/(;-?\))($|\s|<)/gi, self.emoteImage('wink', '$1', '$2'))
            
            // Text in bold
            .replace(/(^|\s|>|\()((\*)([^<>'"\*]+)(\*))($|\s|<|\))/gi, '$1<b>$2</b>$6')
            
            // Italic text
            .replace(/(^|\s|>|\()((\/)([^<>'"\/]+)(\/))($|\s|<|\))/gi, '$1<em>$2</em>$6')
            
            // Underlined text
            .replace(/(^|\s|>|\()((_)([^<>'"_]+)(_))($|\s|<|\))/gi, '$1<span style="text-decoration: underline;">$2</span>$6');
            
            // Add the links
            if(html_escape) {
                filteredMessage = Links.apply(filteredMessage, 'desktop');
            }
            
            // Filter integratebox links
            filteredMessage = IntegrateBox.filter(filteredMessage);
            
            return filteredMessage;
        } catch(e) {
            Console.error('Filter.message', e);
        }

    };


    /**
     * Filters a xHTML message to be displayed in Jappix
     * @public
     * @param {string} code
     * @return {string}
     */
    self.xhtml = function(code) {

        try {
            // Allowed elements array
            var elements = new Array(
                        'a',
                        'abbr',
                        'acronym',
                            'address',
                            'blockquote',
                        'body',
                        'br',
                        'cite',
                            'code',
                            'dd',
                            'dfn',
                            'div',
                            'dt',
                            'em',
                            'h1',
                            'h2',
                            'h3',
                            'h4',
                            'h5',
                            'h6',
                            'head',
                            'html',
                            'kbd',
                            'li',
                            'ol',
                            'p',
                            'pre',
                            'q',
                            'samp',
                            'span',
                            'strong',
                            'title',
                            'ul',
                            'var'
                           );
            
            // Allowed attributes array
            var attributes = new Array(
                           'accesskey',
                           'alt',
                           'charset',
                           'cite',
                           'class',
                           'height',
                           'href',
                           'hreflang',
                           'id',
                           'longdesc',
                           'profile',
                           'rel',
                           'rev',
                           'src',
                           'style',
                           'tabindex',
                           'title',
                           'type',
                           'uri',
                           'version',
                           'width',
                           'xml:lang',
                           'xmlns'
                          );
                          
            // Check if Filter for XHTML-IM images is enabled
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'no-xhtml-images') != '1') {
                elements.push("img");
            }
            
            // Remove forbidden elements
            $(code).find('html body *').each(function() {
                // This element is not authorized
                if(!Utils.existArrayValue(elements, (this).nodeName.toLowerCase()))
                    $(this).remove();
            });
            
            // Remove forbidden attributes
            $(code).find('html body *').each(function() {
                // Put a pointer on this element (jQuery way & normal way)
                var cSelector = $(this);
                var cElement = (this);
                
                // Loop the attributes of the current element
                $(cElement.attributes).each(function(index) {
                    // Read the current attribute
                    var cAttr = cElement.attributes[index];
                    var cName = cAttr.name;
                    var cVal = cAttr.value;
                    
                    // This attribute is not authorized, or contains JS code
                    if(!Utils.existArrayValue(attributes, cName.toLowerCase()) || ((cVal.toLowerCase()).match(/(^|"|')javascript:/)))
                        cSelector.removeAttr(cName);
                });
            });
            
            // Filter some other elements
            $(code).find('a').attr('target', '_blank');
            
            return $(code).find('html body').html();
        } catch(e) {
            Console.error('Filter.xhtml', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the links JS script for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var Links = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Apply links in a string
     * @public
     * @param {string} string
     * @param {string} mode
     * @param {string} style
     * @return {string}
     */
    self.apply = function(string, mode, style) {

        try {
            var target;
            
            // Links style
            if(!style)
                style = '';
            else
                style = ' style="' + style + '"';
            
            // Open in new tabs
            if(mode != 'xhtml-im')
                target = ' target="_blank"';
            else
                target = '';
            
            // XMPP address
            string = string.replace(/(\s|<br \/>|^)(([a-zA-Z0-9\._-]+)@([a-zA-Z0-9\.\/_-]+))(,|\s|$)/gi, '$1<a href="xmpp:$2" target="_blank"' + style + '>$2</a>$5');
            
            // Simple link
            string = string.replace(/(\s|<br \/>|^|\()((https?|ftp|file|xmpp|irc|mailto|vnc|webcal|ssh|ldap|smb|magnet|spotify)(:)([^<>'"\s\)]+))/gim, '$1<a href="$2"' + target + style + '>$2</a>');
            
            return string;
        } catch(e) {
            Console.error('Links.apply', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixLinks = Links;
/*

Jappix - An open social platform
These are the inbox JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Inbox = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the inbox popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Your inbox") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="head inbox-head">' + 
                    '<div class="head-text inbox-head-text">' + Common._e("Available actions") + '</div>' + 
                    
                    '<div class="head-actions inbox-head-actions">' + 
                        '<a href="#" class="a-delete-messages">' + Common._e("Clean") + '</a>' + 
                        '<a href="#" class="a-new-message">' + Common._e("New") + '</a>' + 
                        '<a href="#" class="a-show-messages">' + Common._e("Received") + '</a>' + 
                    '</div>' + 
                '</div>' + 
                
                '<div class="inbox-results">' + 
                    '<p class="inbox-noresults">' + Common._e("Your inbox is empty.") + '</p>' + 
                    
                    '<div class="inbox"></div>' + 
                '</div>' + 
                
                '<div class="inbox-new">' + 
                    '<div class="inbox-new-to inbox-new-block search">' + 
                        '<p class="inbox-new-text">' + Common._e("To") + '</p>' + 
                        
                        '<input name="inbox-new-to-input" class="inbox-new-input inbox-new-to-input" type="text" required="" />' + 
                    '</div>' + 
                    
                    '<div class="inbox-new-topic inbox-new-block">' + 
                        '<p class="inbox-new-text">' + Common._e("Subject") + '</p>' + 
                        
                        '<input name="inbox-new-subject-input" class="inbox-new-input inbox-new-subject-input" type="text" required="" />' + 
                    '</div>' + 
                    
                    '<div class="inbox-new-body inbox-new-block">' + 
                        '<p class="inbox-new-text">' + Common._e("Content") + '</p>' + 
                        
                        '<textarea class="inbox-new-textarea" rows="8" cols="60" required=""></textarea>' + 
                    '</div>' + 
                    
                    '<form class="inbox-new-file inbox-new-block" action="./server/file-share.php" method="post" enctype="multipart/form-data">' + 
                        '<p class="inbox-new-text">' + Common._e("File") + '</p>' + 
                        
                        Interface.generateFileShare() + 
                    '</form>' + 
                    
                    '<div class="inbox-new-send inbox-new-block">' + 
                        '<a href="#" class="send one-button talk-images">' + Common._e("Send message") + '</a>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('inbox', html);
            
            // Associate the events
            self.instance();
            
            // Load the messages
            self.load();
        } catch(e) {
            Console.error('Inbox.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Closes the inbox popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('inbox');
        } catch(e) {
            Console.error('Inbox.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Opens the message compose tool
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.composeMessage = function(xid) {

        try {
            // Open things
            self.open();
            self.newMessage();
            
            // Apply XID
            $('#inbox .inbox-new-to-input').val(xid);
            
            // Focus to the next item
            $(document).oneTime(10, function() {
                $('#inbox .inbox-new-subject-input').focus();
            });
        } catch(e) {
            Console.error('Inbox.composeMessage', e);
        } finally {
            return false;
        }

    };


    /**
     * Stores the inbox
     * @public
     * @return {undefined}
     */
    self.store = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            var query = iq.setQuery(NS_PRIVATE);
            var storage = query.appendChild(iq.buildNode('storage', {'xmlns': NS_INBOX}));
            
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'inbox' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored message
                if(current.match(db_regex)) {
                    // Get the values
                    var value = $(Common.XMLFromString(DataStore.storageDB.getItem(current)));
                    
                    // Create the storage node
                    storage.appendChild(iq.buildNode('message', {
                                             'id': value.find('id').text().revertHtmlEnc(),
                                             'from': value.find('from').text().revertHtmlEnc(),
                                             'subject': value.find('subject').text().revertHtmlEnc(),
                                             'status': value.find('status').text().revertHtmlEnc(),
                                             'date': value.find('date').text().revertHtmlEnc(),
                                             'xmlns': NS_INBOX
                                            },
                                            
                                            value.find('content').text().revertHtmlEnc()
                                    ));
                }
            }
            
            con.send(iq);
        } catch(e) {
            Console.error('Inbox.store', e);
        }

    };


    /**
     * Creates a new normal message
     * @public
     * @return {boolean}
     */
    self.newMessage = function() {

        try {
            // Init
            var mPath = '#inbox .';
            
            // Reset the previous buddy search
            Search.resetBuddy('#inbox .inbox-new-to');
            
            // We switch the divs
            $(mPath + 'inbox-results, #inbox .a-new-message, #inbox .a-delete-messages').hide();
            $(mPath + 'inbox-new, #inbox .a-show-messages').show();
            
            // We focus on the first input
            $(document).oneTime(10, function() {
                $(mPath + 'inbox-new-to-input').focus();
            });
            
            // We reset some stuffs
            self.cleanNewMessage();
        } catch(e) {
            Console.error('Inbox.newMessage', e);
        } finally {
            return false;
        }

    };
    

    /**
     * Cleans the inbox
     * @public
     * @return {undefined}
     */
    self.cleanNewMessage = function() {

        try {
            // Init
            var mPath = '#inbox .';
            
            // We reset the forms
            $(mPath + 'inbox-new-block:not(form) input, ' + mPath + 'inbox-new textarea').val('').removeClass('please-complete');
            $(mPath + 'inbox-new-file a').remove();
            $(mPath + 'inbox-new-file input').show();
            
            // We close an eventual opened message
            $(mPath + 'message-content').remove();
            $(mPath + 'one-message').removeClass('message-reading');
        } catch(e) {
            Console.error('Inbox.cleanNewMessage', e);
        }

    };


    /**
     * Sends a normal message
     * @public
     * @param {string} to
     * @param {string} subject
     * @param {string} body
     * @return {undefined}
     */
    self.sendMessage = function(to, subject, body) {

        try {
            // We send the message
            var mess = new JSJaCMessage();
            
            // Main attributes
            mess.setTo(to);
            mess.setSubject(subject);
            mess.setType('normal');
            
            // Any file to attach?
            var attached = '#inbox .inbox-new-file a.file';
            
            if(Common.exists(attached)) {
                body += '\n' + 
                    '\n' + 
                    $(attached).attr('data-attachedtitle') + ' - ' + $(attached).attr('data-attachedhref');
            }
            
            // Set body
            mess.setBody(body);
            
            con.send(mess, Errors.handleReply);
        } catch(e) {
            Console.error('Inbox.sendMessage', e);
        }

    };


    /**
     * Performs the normal message sender checks
     * @public
     * @return {boolean}
     */
    self.checkMessage = function() {

        try {
            // We get some informations
            var mPath = '#inbox ';
            var to = $(mPath + '.inbox-new-to-input').val();
            var body = $(mPath + '.inbox-new-textarea').val();
            var subject = $(mPath + '.inbox-new-subject-input').val();
            
            if(to && body && subject) {
                // New array of XID
                var xid = new Array(to);
                
                // More than one XID
                if(to.indexOf(',') != -1) {
                    xid = to.split(',');
                }
                
                for(var i in xid) {
                    var current = xid[i];
                    
                    // No current value?
                    if(!current || current.match(/^(\s+)$/))
                        continue;
                    
                    // Edit the XID if needed
                    current = current.replace(/ /g, '');
                    current = Common.generateXID(current, 'chat');
                    
                    // We send the message
                    self.sendMessage(current, subject, body);
                    
                    // We clean the inputs
                    self.cleanNewMessage();
                    
                    Console.info('Inbox message sent: ' + current);
                }
                
                // Close the inbox
                self.close();
            }
            
            else {
                $(mPath + 'input[type="text"], ' + mPath + 'textarea').each(function() {
                    var current = this;
                    
                    if(!$(current).val()) {
                        $(document).oneTime(10, function() {
                            $(current).addClass('please-complete').focus();
                        });
                    } else {
                        $(current).removeClass('please-complete');  
                    }
                });
            }
        } catch(e) {
            Console.error('Inbox.checkMessage', e);
        } finally {
            return false;
        }

    };


    /**
     * Shows the inbox messages
     * @public
     * @return {boolean}
     */
    self.showMessage = function() {

        try {
            // Init
            var mPath = '#inbox .';
            
            // We switch the divs
            $(mPath + 'inbox-new').hide();
            $(mPath + 'inbox-results').show();
            
            // We show a new link in the menu
            $(mPath + 'a-show-messages').hide();
            $(mPath + 'a-delete-messages').show();
            $(mPath + 'a-new-message').show();
            
            // We reset some stuffs
            self.cleanNewMessage();
        } catch(e) {
            Console.error('Inbox.showMessage', e);
        } finally {
            return false;
        }

    };


    /**
     * Displays a normal message
     * @public
     * @param {string} from
     * @param {string} subject
     * @param {string} content
     * @param {string} status
     * @param {string} id
     * @param {string} date
     * @return {boolean}
     */
    self.displayMessage = function(from, subject, content, status, id, date) {

        try {
            // Generate some paths
            var inbox = '#inbox .';
            var one_message = inbox + 'one-message.' + id;
            
            // Message yet displayed!
            if(Common.exists(one_message)) {
                return false;
            }
            
            // Get the nearest element
            var stamp = DateUtils.extractStamp(Date.jab2date(date));
            var nearest = Search.sortElementByStamp(stamp, '#inbox .one-message');
            
            // Get the buddy name
            var name = Name.getBuddy(from).htmlEnc();
            
            // We generate the html code
            var nContent = '<div class="one-message message-' + status + ' ' + id + ' ' + hex_md5(from) + '" data-stamp="' + stamp + '">' + 
                        '<div class="message-head">' + 
                            '<div class="avatar-container">' + 
                                '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                            '</div>' + 
                            
                            '<div class="message-jid">' + name + '</div>' + 
                            '<div class="message-subject">' + subject.htmlEnc() + '</div>' + 
                            
                            '<div class="message-truncated">' + Utils.truncate(Utils.noLines(content), 90).htmlEnc() + '</div>' + 
                        '</div>' + 
                    '</div>';
            
            // Display the message
            if(nearest === 0) {
                $(inbox + 'inbox-results .inbox').append(nContent);
            } else {
                $('#inbox .one-message[data-stamp="' + nearest + '"]:first').before(nContent);
            }
            
            // Click events
            $(one_message + ' .message-head').click(function() {
                if(!Common.exists(one_message + ' .message-content'))
                    self.revealMessage(id, from, subject, content, name, date, status);
                else
                    self.hideMessage(id);
                
                return false;
            });
            
            // Get the user avatar
            Avatar.get(from, 'cache', 'true', 'forget');

            return true;
        } catch(e) {
            Console.error('Inbox.displayMessage', e);
        }

    };


    /**
     * Stores an inbox message
     * @public
     * @param {string} from
     * @param {string} subject
     * @param {string} content
     * @param {string} status
     * @param {string} id
     * @param {string} date
     * @return {undefined}
     */
    self.storeMessage = function(from, subject, content, status, id, date) {

        try {
            // Initialize the XML data
            var xml = '<message><id>' + id.htmlEnc().htmlEnc() + '</id><date>' + date.htmlEnc().htmlEnc() + '</date><from>' + from.htmlEnc().htmlEnc() + '</from><subject>' + subject.htmlEnc().htmlEnc() + '</subject><status>' + status.htmlEnc().htmlEnc() + '</status><content>' + content.htmlEnc().htmlEnc() + '</content>';
            
            // End the XML data
            xml += '</message>';
            
            // Store this message!
            DataStore.setDB(Connection.desktop_hash, 'inbox', id, xml);
        } catch(e) {
            Console.error('Inbox.storeMessage', e);
        }

    };


    /**
     * Removes a given normal message
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.deleteMessage = function() {

        try {
            // Remove the message from the inbox
            $('#inbox .one-message.' + id).remove();
            
            // Remove the message from the database
            DataStore.removeDB(Connection.desktop_hash, 'inbox', id);
            
            // Check the unread messages
            self.checkMessages();
            
            // Store the new inbox
            self.store();
        } catch(e) {
            Console.error('Inbox.deleteMessage', e);
        } finally {
            return false;
        }

    };


    /**
     * Removes all the inbox messages
     * @public
     * @return {boolean}
     */
    self.purge = function() {

        try {
            // Remove all the messages from the database
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'inbox' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored message
                if(current.match(db_regex)) {
                    DataStore.removeDB(Connection.desktop_hash, 'inbox', RegExp.$1);
                }
            }
            
            // Prevent the database lag
            $(document).oneTime(100, function() {
                // Store the new inbox
                self.store();
                
                // Remove all the messages from the inbox
                $('#inbox .one-message').remove();
                
                // Reload the inbox
                self.load();
            });
        } catch(e) {
            Console.error('Inbox.purge', e);
        } finally {
            return false;
        }

    };


    /**
     * Checks if there are new messages to be notified
     * @public
     * @return {boolean}
     */
    self.checkMessages = function() {

        try {
            // Selectors
            var inbox_link = '#top-content a.inbox-hidable';
            var no_results = '#inbox .inbox-noresults';
            
            // Marker
            var has_messages = false;
            
            // Read the number of unread messages
            var unread = 0;
            
            // Read the local inbox database
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'inbox' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Database pointer
                var current = DataStore.storageDB.key(i);
                
                // Check inbox messages
                if(current.match(db_regex)) {
                    // Read the current status
                    var status = $(Common.XMLFromString(DataStore.storageDB.getItem(current))).find('status').text();
                    
                    // Found an unread message
                    if(status == 'unread') {
                        unread++;
                    }
                    
                    // Update the marker
                    has_messages = true;
                }
            }
            
            // No message?
            if(!has_messages) {
                $(no_results).show();
            } else {
                $(no_results).hide();
            }
            
            // Reset notifications
            $(inbox_link + ' .notify').remove();
            
            // Any unread message?
            if(unread) {
                // Notify the user
                $(inbox_link).prepend('<div class="notify one-counter" data-counter="' + unread + '">' + unread + '</div>');
                
                // Update the title
                Interface.updateTitle();
                
                return true;
            }
            
            // Anyway, update the title
            Interface.updateTitle();
        } catch(e) {
            Console.error('Inbox.checkMessages', e);
        } finally {
            return false;
        }

    };


    /**
     * Reveal a normal message content
     * @public
     * @param {string} id
     * @param {string} from
     * @param {string} subject
     * @param {string} content
     * @param {string} name
     * @param {string} date
     * @param {string} status
     * @return {undefined}
     */
    self.revealMessage = function(id, from, subject, content, name, date, status) {

        try {
            // Message path
            var all_message = '#inbox .one-message';
            var one_message = all_message + '.' + id;
            var one_content = one_message + ' .message-content';
            
            // We reset all the other messages
            $(all_message + ' .message-content').remove();
            $(all_message).removeClass('message-reading');
            
            // Message content
            var html = 
                '<div class="message-content">' + 
                    '<div class="message-body">' + Filter.message(content, name, true) + '</div>' + 
                    
                    '<div class="message-meta">' + 
                        '<span class="date">' + DateUtils.parse(date) + '</span>' + 
                        
                        '<a href="#" class="reply one-button talk-images">' + Common._e("Reply") + '</a>' + 
                        '<a href="#" class="remove one-button talk-images">' + Common._e("Delete") + '</a>' + 
                        
                        '<div class="clear">' + 
                    '</div>' + 
                '</div>';
            
            // Message content
            html += '</div>';
            
            $(one_message).append(html).addClass('message-reading');
            
            // Click events
            $(one_content + ' a.reply').click(function() {
                return self.replyMessage(id, from, subject, content);
            });
            
            $(one_content + ' a.remove').click(function() {
                return self.deleteMessage(id);
            });
            
            // Unread message
            if(status == 'unread') {
                // Update our database
                var xml = DataStore.getDB(Connection.desktop_hash, 'inbox', id).replace(/<status>unread<\/status>/i,'<status>read</status>');
                DataStore.setDB(Connection.desktop_hash, 'inbox', id, xml);
                
                // Remove the unread class
                $(one_message).removeClass('message-unread');
                
                // Send it to the server!
                self.store();
            }
            
            // Check the unread messages
            self.checkMessages();
        } catch(e) {
            Console.error('Inbox.revealMessage', e);
        }

    };


    /**
     * Hides a normal message content
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.hideMessage = function(id) {

        try {
            // Define the paths
            var inbox = '#inbox .';
            var one_message = inbox + 'one-message.' + id;
            
            // Reset this message
            $(one_message).removeClass('message-reading');
            $(one_message + ' .message-content').remove();
        } catch(e) {
            Console.error('Inbox.hideMessage', e);
        }

    };


    /**
     * Replies to a given normal message
     * @public
     * @param {type} name
     * @return {boolean}
     */
    self.replyMessage = function(id, from, subject, body) {

        try {
            // We switch to the writing div
            self.newMessage();
            
            // Inbox path
            var inbox = '#inbox .';
            
            // Generate the body
            body = '\n' + '____________' + '\n\n' + Utils.truncate(body, 120);
            
            // We apply the generated values to the form
            $(inbox + 'inbox-new-to-input').val(from);
            $(inbox + 'inbox-new-subject-input').val(subject);
            
            $(document).oneTime(10, function() {
                $(inbox + 'inbox-new-textarea').val(body).focus().selectRange(1, 0);
            });
        } catch(e) {
            Console.error('Inbox.replyMessage', e);
        } finally {
            return false;
        }

    };


    /**
     * Loads the inbox messages
     * @public
     * @return {undefined}
     */
    self.load = function() {

        try {
            // Read the local database
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'inbox' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored message
                if(current.match(db_regex)) {
                    // Get the current value
                    var value = $(Common.XMLFromString(DataStore.storageDB.getItem(current)));
                    
                    // Display the current message
                    self.displayMessage(
                                value.find('from').text().revertHtmlEnc(),
                                value.find('subject').text().revertHtmlEnc(),
                                value.find('content').text().revertHtmlEnc(),
                                value.find('status').text().revertHtmlEnc(),
                                value.find('id').text().revertHtmlEnc(),
                                value.find('date').text().revertHtmlEnc()
                               );
                }
            }
            
            // Check new messages
            self.checkMessages();
        } catch(e) {
            Console.error('Inbox.load', e);
        }

    };


    /**
     * Wait event for file attaching
     * @public
     * @return {undefined}
     */
    self.waitAttach = function() {

        try {
            $('#inbox .wait').show();
        } catch(e) {
            Console.error('Inbox.waitAttach', e);
        }

    };


    /**
     * Success event for file attaching
     * @public
     * @param {string} responseXML
     * @return {undefined}
     */
    self.handleAttach = function(responseXML) {

        try {
            // Data selector
            var dData = $(responseXML).find('jappix');
            
            // Process the returned data
            if(dData.find('error').size()) {
                Board.openThisError(4);
                
                Console.error('Error while attaching the file', dData.find('error').text());
            } else {
                // Get the file values
                var fName = dData.find('title').text();
                var fType = dData.find('type').text();
                var fURL = dData.find('href').text();
                
                // Hide the attach link, show the unattach one
                $('#inbox .inbox-new-file input').hide();
                $('#inbox .inbox-new-file').append('<a class="file ' + Common.encodeQuotes(Utils.fileCategory(Common.explodeThis('/', fType, 1))) + ' talk-images" href="' + Common.encodeQuotes(fURL) + '" target="_blank">' + fName.htmlEnc() + '</a><a href="#" class="remove one-button talk-images">' + Common._e("Remove") + '</a>');
                
                // Set values to the file link
                $('#inbox .inbox-new-file a.file').attr('data-attachedtitle', fName)
                                  .attr('data-attachedhref',  fURL);
                
                // Click events
                $('#inbox .inbox-new-file a.remove').click(function() {
                    $('#inbox .inbox-new-file a').remove();
                    $('#inbox .inbox-new-file input').show();
                    
                    return false;
                });
                
                Console.info('File attached.');
            }
            
            // Reset the attach bubble
            $('#inbox .inbox-new-file input[type="file"]').val('');
            $('#inbox .wait').hide();
        } catch(e) {
            Console.error('Inbox.handleAttach', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Define the pats
            var inbox = '#inbox .';
            
            // Define the buddy search vars
            var destination = inbox + 'inbox-new-to';
            var dHovered = destination + ' ul li.hovered:first';
            
            // Send the message when enter pressend
            $(inbox + 'inbox-new input').keyup(function(e) {
                if(e.keyCode == 13) {
                    if(Common.exists(dHovered))
                        Search.addBuddy(destination, $(dHovered).attr('data-xid'));
                    else
                        self.checkMessage();
                }
            });
            
            // Buddy search
            $(inbox + 'inbox-new-to-input').keyup(function(e) {
                if(e.keyCode != 13) {
                    // New buddy search
                    if((e.keyCode != 40) && (e.keyCode != 38)) {
                        Search.createBuddy(destination);
                    }
                    
                    // Navigating with keyboard in the results
                    Search.arrowsBuddy(e, destination);
                }
            })
            
            // Buddy search lost focus
            .blur(function() {
                if(!$(destination + ' ul').attr('mouse-hover')) {
                    Search.resetBuddy(destination);
                }
            })
            
            // Buddy search got focus
            .focus(function() {
                var value = $(this).val();
                
                // Add a comma at the end
                if(value && !value.match(/^(.+)((,)(\s)?)$/)) {
                    $(this).val(value + ', ');
                }
            });
            
            // Click events
            $(inbox + 'a-delete-messages').click(self.purge);
            $(inbox + 'a-new-message').click(self.newMessage);
            $(inbox + 'a-show-messages').click(self.showMessage);
            $(inbox + 'inbox-new-send a').click(self.checkMessage);
            
            $(inbox + 'bottom .finish').click(function() {
                return self.close();
            });
            
            // File upload
            var attach_options = {
                dataType:   'xml',
                beforeSubmit:   self.waitAttach,
                success:        self.handleAttach
            };
            
            // Upload form submit event
            $('#inbox .inbox-new-file').submit(function() {
                if($('#inbox .wait').is(':hidden') && $('#inbox .inbox-new-file input[type="file"]').val()) {
                    $(this).ajaxSubmit(attach_options);
                }
                
                return false;
            });
            
            // Upload input change event
            $('#inbox .inbox-new-file input[type="file"]').change(function() {
                if($('#inbox .wait').is(':hidden') && $(this).val()) {
                    $('#inbox .inbox-new-file').ajaxSubmit(attach_options);
                }
                
                return false;
            });
        } catch(e) {
            Console.error('Inbox.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the microblog JS scripts for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, Maranda

*/

// Bundle
var Microblog = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};
    

    /**
     * Completes arrays of an entry's attached files
     * @public
     * @param {string} selector
     * @param {object} tFName
     * @param {object} tFURL
     * @param {object} tFThumb
     * @param {object} tFSource
     * @param {object} tFLength
     * @param {object} tFEComments
     * @param {object} tFNComments
     * @return {undefined}
     */
    self.attached = function(selector, tFName, tFURL, tFThumb, tFSource, tFType, tFLength, tFEComments, tFNComments) {

        try {
            if($(selector).attr('title'))
                tFName.push($(selector).attr('title'));
            else
                tFName.push('');
            
            if($(selector).attr('href'))
                tFURL.push($(selector).attr('href'));
            else
                tFURL.push('');
            
            if($(selector).find('link[rel="self"][title="thumb"]:first').attr('href'))
                tFThumb.push($(selector).find('link[rel="self"][title="thumb"]:first').attr('href'));
            else
                tFThumb.push('');
            
            if($(selector).attr('source'))
                tFSource.push($(selector).attr('source'));
            else
                tFSource.push('');
            
            if($(selector).attr('type'))
                tFType.push($(selector).attr('type'));
            else
                tFType.push('');
            
            if($(selector).attr('length'))
                tFLength.push($(selector).attr('length'));
            else
                tFLength.push('');
            
            // Comments?
            var comments_href_c = $(selector).find('link[rel="replies"][title="comments_file"]:first').attr('href');
            
            if(comments_href_c && comments_href_c.match(/^xmpp:(.+)\?;node=(.+)/)) {
                tFEComments.push(RegExp.$1);
                tFNComments.push(decodeURIComponent(RegExp.$2));
            }
            
            else {
                tFEComments.push('');
                tFNComments.push('');
            }
        } catch(e) {
            Console.error('Microblog.attached', e);
        }

    };


    /**
     * Displays a given microblog item
     * @public
     * @param {object} packet
     * @param {string} from
     * @param {string} hash
     * @param {string} mode
     * @param {string} way
     * @return {undefined}
     */
    self.display = function(packet, from, hash, mode, way) {

        try {
            // Get some values
            var iParse = $(packet.getNode()).find('items item');
            
            iParse.each(function() {
                // Initialize
                var tContent, tFiltered, tTime, tDate, tStamp, tBody, tName, tID, tHash, tIndividual, tFEClick;
                var tHTMLEscape = false;

                // Arrays
                var tFName = [];
                var tFURL = [];
                var tFThumb = [];
                var tFSource = [];
                var tFType = [];
                var tFLength = [];
                var tFEComments = [];
                var tFNComments = [];
                var aFURL = [];
                var aFCat = [];
                
                // Get the values
                tDate = $(this).find('published').text();
                tBody = $(this).find('body').text();
                tID = $(this).attr('id');
                tName = Name.getBuddy(from);
                tHash = 'update-' + hex_md5(tName + tDate + tID);
                
                // Read attached files with a thumb (place them at first)
                $(this).find('link[rel="enclosure"]:has(link[rel="self"][title="thumb"])').each(function() {
                    self.attached(this, tFName, tFURL, tFThumb, tFSource, tFType, tFLength, tFEComments, tFNComments);
                });
                
                // Read attached files without any thumb
                $(this).find('link[rel="enclosure"]:not(:has(link[rel="self"][title="thumb"]))').each(function() {
                    self.attached(this, tFName, tFURL, tFThumb, tFSource, tFType, tFLength, tFEComments, tFNComments);
                });
                
                // Get the repeat value
                var uRepeat = [$(this).find('author name').text(), Common.explodeThis(':', $(this).find('author uri').text(), 1)];
                var uRepeated = false;
                
                if(!uRepeat[0])
                    uRepeat = [Name.getBuddy(from), uRepeat[1]];
                if(!uRepeat[1])
                    uRepeat = [uRepeat[0], from];
                
                // Repeated?
                if(uRepeat[1] != from)
                    uRepeated = true;
                
                // Get the comments node
                var entityComments, nodeComments;
                
                // Get the comments
                var comments_href = $(this).find('link[title="comments"]:first').attr('href');
                
                if(comments_href && comments_href.match(/^xmpp:(.+)\?;node=(.+)/)) {
                    entityComments = RegExp.$1;
                    nodeComments = decodeURIComponent(RegExp.$2);
                }
                
                // No comments node?
                if(!entityComments || !nodeComments) {
                    entityComments = '';
                    nodeComments = '';
                }
                
                // Get the stamp & time
                if(tDate) {
                    tStamp = DateUtils.extractStamp(Date.jab2date(tDate));
                    tTime = DateUtils.relative(tDate);
                }
                
                else {
                    tStamp = DateUtils.getTimeStamp();
                    tTime = '';
                }
                
                // Get the item geoloc
                var tGeoloc = '';
                var sGeoloc = $(this).find('geoloc:first');
                var gLat = sGeoloc.find('lat').text();
                var gLon = sGeoloc.find('lon').text();
                
                if(gLat && gLon) {
                    tGeoloc += '<a class="geoloc talk-images" href="http://maps.google.com/?q=' + Common.encodeQuotes(gLat) + ',' + Common.encodeQuotes(gLon) + '" target="_blank">';
                    
                    // Human-readable name?
                    var gHuman = PEP.humanPosition(
                                           sGeoloc.find('locality').text(),
                                           sGeoloc.find('region').text(),
                                           sGeoloc.find('country').text()
                                          );
                    
                    if(gHuman)
                        tGeoloc += gHuman.htmlEnc();
                    else
                        tGeoloc += gLat.htmlEnc() + '; ' + gLon.htmlEnc();
                    
                    tGeoloc += '</a>';
                }
                
                // Entry content: HTML, parse!
                if($(this).find('content[type="html"]').size()) {
                    // Filter the xHTML message
                    tContent = Filter.xhtml(this);
                    tHTMLEscape = false;
                }

                // Entry content: Fallback on PLAIN?
                if(!tContent) {
                    tContent = $(this).find('content[type="text"]').text();
                    
                    if(!tContent) {
                        // Legacy?
                        tContent = $(this).find('title:not(source > title)').text();
                        
                        // Last chance?
                        if(!tContent)
                            tContent = tBody;
                    }
                    
                    // Trim the content
                    tContent = $.trim(tContent);
                    tHTMLEscape = true;
                }

                // Any content?
                if(tContent) {
                    // Apply links to message body
                    tFiltered = Filter.message(tContent, tName.htmlEnc(), tHTMLEscape);
                    
                    // Display the received message
                    var html = '<div class="one-update update_' + hash + ' ' + tHash + '" data-stamp="' + Common.encodeQuotes(tStamp) + '" data-id="' + Common.encodeQuotes(tID) + '" data-xid="' + Common.encodeQuotes(from) + '">' + 
                            '<div class="' + hash + '">' + 
                                '<div class="avatar-container">' + 
                                    '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                                '</div>' + 
                            '</div>' + 
                            
                            '<div class="body">' + 
                                '<p>';
                    
                    // Is it a repeat?
                    if(uRepeated)
                        html += '<a href="#" class="repeat talk-images" title="' + Common.encodeQuotes(Common.printf(Common._e("This is a repeat from %s"), uRepeat[0] + ' (' + uRepeat[1] + ')')) + '" onclick="return Chat.checkCreate(\'' + Utils.encodeOnclick(uRepeat[1]) + '\', \'chat\');" data-xid="' + Common.encodeQuotes(uRepeat[1]) + '"></a>';
                    
                    html += '<b title="' + from + '" class="name">' + tName.htmlEnc() + '</b> <span>' + tFiltered + '</span></p>' + 
                        '<p class="infos">' + tTime + tGeoloc + '</p>';
                    
                    // Any file to display?
                    if(tFURL.length)
                        html += '<p class="file">';
                    
                    // Generate an array of the files URL
                    for(var a = 0; a < tFURL.length; a++) {
                        // Not enough data?
                        if(!tFURL[a])
                            continue;
                        
                        // Push the current URL! (YouTube or file)
                        if(tFURL[a].match(/(\w{3,5})(:)(\S+)((\.youtube\.com\/watch(\?v|\?\S+v|\#\!v|\#\!\S+v)\=)|(youtu\.be\/))([^& ]+)((&amp;\S)|(&\S)|\s|$)/gim)) {
                            aFURL.push($.trim(RegExp.$8));
                            aFCat.push('youtube');
                        }
                        
                        else if(IntegrateBox.can(Common.strAfterLast('.', tFURL[a]))) {
                            aFURL.push(tFURL[a]);
                            aFCat.push(Utils.fileCategory(Common.strAfterLast('.', tFURL[a])));
                        }
                    }
                    
                    // Add each file code
                    for(var f = 0; f < tFURL.length; f++) {
                        // Not enough data?
                        if(!tFURL[f])
                            continue;
                        
                        // Get the file type
                        var tFLink = tFURL[f];
                        var tFExt = Common.strAfterLast('.', tFLink);
                        var tFCat = Utils.fileCategory(tFExt);
                        
                        // Youtube video?
                        if(tFLink.match(/(\w{3,5})(:)(\S+)((\.youtube\.com\/watch(\?v|\?\S+v|\#\!v|\#\!\S+v)\=)|(youtu\.be\/))([^& ]+)((&amp;\S)|(&\S)|\s|$)/gim)) {
                            tFLink = $.trim(RegExp.$8);
                            tFCat = 'youtube';
                        }
                        
                        // Supported image/video/sound
                        if(IntegrateBox.can(tFExt) || (tFCat == 'youtube'))
                            tFEClick = 'onclick="return IntegrateBox.apply(\'' + Utils.encodeOnclick(tFLink) + '\', \'' + Utils.encodeOnclick(tFCat) + '\', \'' + Utils.encodeOnclick(aFURL) + '\', \'' + Utils.encodeOnclick(aFCat) + '\', \'' + Utils.encodeOnclick(tFEComments) + '\', \'' + Utils.encodeOnclick(tFNComments) + '\', \'large\');" ';
                        else
                            tFEClick = '';
                        
                        // Any thumbnail?
                        if(tFThumb[f])
                            html += '<a class="thumb" ' + tFEClick + 'href="' + Common.encodeQuotes(tFURL[f]) + '" target="_blank" title="' + Common.encodeQuotes(tFName[f]) + '" data-node="' + Common.encodeQuotes(tFNComments[f]) + '"><img src="' + Common.encodeQuotes(tFThumb[f]) + '" alt="" /></a>';
                        else
                            html += '<a class="' + Common.encodeQuotes(tFCat) + ' link talk-images" ' + tFEClick + 'href="' + Common.encodeQuotes(tFURL[f]) + '" target="_blank" data-node="' + Common.encodeQuotes(tFNComments[f]) + '">' + tFName[f].htmlEnc() + '</a>';
                    }
                    
                    if(tFURL.length)
                        html += '</p>';
                    
                    // It's my own notice, we can remove it!
                    if(from == Common.getXID())
                        html += '<a href="#" onclick="return Microblog.remove(\'' + Utils.encodeOnclick(tID) + '\', \'' + Utils.encodeOnclick(tHash) + '\', \'' + Utils.encodeOnclick(entityComments) + '\', \'' + Utils.encodeOnclick(nodeComments) + '\');" title="' + Common._e("Remove this notice") + '" class="mbtool remove talk-images"></a>';
                    
                    // Notice from another user
                    else {
                        // User profile
                        html += '<a href="#" title="' + Common._e("View profile") + '" class="mbtool profile talk-images" onclick="return UserInfos.open(\'' + Utils.encodeOnclick(from) + '\');"></a>';
                        
                        // If PEP is enabled
                        if(Features.enabledPEP() && tHTMLEscape)
                            html += '<a href="#" title="' + Common._e("Repeat this notice") + '" class="mbtool repost talk-images"></a>';
                    }
                    
                    html += '</div><div class="comments-container" data-node="' + Common.encodeQuotes(nodeComments) + '"></div></div>';
                    
                    // Mixed mode
                    if((mode == 'mixed') && !Common.exists('.mixed .' + tHash)) {
                        // Remove the old element
                        if(way == 'push')
                            $('#channel .content.mixed .one-update.update_' + hash).remove();
                        
                        // Get the nearest element
                        var nearest = Search.sortElementByStamp(tStamp, '#channel .mixed .one-update');
                        
                        // Append the content at the right position (date relative)
                        if(nearest === 0)
                            $('#channel .content.mixed').append(html);
                        else
                            $('#channel .one-update[data-stamp="' + nearest + '"]:first').before(html);
                        
                        // Show the new item
                        if(way == 'push')
                            $('#channel .content.mixed .one-update.' + tHash).fadeIn('fast');
                        else
                            $('#channel .content.mixed .one-update.' + tHash).show();
                        
                        // Remove the old notices to make the DOM lighter
                        var oneUpdate = '#channel .content.mixed .one-update';
                        
                        if($(oneUpdate).size() > 80)
                            $(oneUpdate + ':last').remove();
                        
                        // Click event on avatar/name
                        $('.mixed .' + tHash + ' .avatar-container, .mixed .' + tHash + ' .body b').click(function() {
                            self.get(from, hash);
                        });
                    }
                    
                    // Individual mode
                    tIndividual = '#channel .content.individual.microblog-' + hash;
                    
                    // Can append individual content?
                    var can_individual = true;
                    
                    if($('#channel .top.individual input[name="comments"]').val() && Common.exists(tIndividual + ' .one-update'))
                        can_individual = false;
                    
                    if(can_individual && Common.exists(tIndividual) && !Common.exists('.individual .' + tHash)) {
                        if(mode == 'mixed')
                            $(tIndividual).prepend(html);
                        else
                            $(tIndividual + ' a.more').before(html);
                        
                        // Show the new item
                        if(way == 'push')
                            $('#channel .content.individual .one-update.' + tHash).fadeIn('fast');
                        else
                            $('#channel .content.individual .one-update.' + tHash).show();
                        
                        // Make 'more' link visible
                        $(tIndividual + ' a.more').css('visibility', 'visible');
                        
                        // Click event on name (if not me!)
                        if(from != Common.getXID())
                            $('.individual .' + tHash + ' .avatar-container, .individual .' + tHash + ' .body b').click(function() {
                                Chat.checkCreate(from, 'chat');
                            });
                    }
                    
                    // Apply the click event
                    $('.' + tHash + ' a.repost:not([data-event="true"])').click(function() {
                        return self.publish(tContent, tFName, tFURL, tFType, tFLength, tFThumb, uRepeat, entityComments, nodeComments, tFEComments, tFNComments);
                    })
                    
                    .attr('data-event', 'true');
                    
                    // Apply the hover event
                    if(nodeComments) {
                        $('.' + mode + ' .' + tHash).hover(function() {
                            self.showComments($(this), entityComments, nodeComments, tHash);
                        }, function() {
                            if($(this).find('div.comments a.one-comment.loading').size())
                                $(this).find('div.comments').remove();
                        });
                    }
                }
            });
            
            // Display the avatar of this buddy
            Avatar.get(from, 'cache', 'true', 'forget');
        } catch(e) {
            Console.error('Microblog.display', e);
        }

    };


    /**
     * Removes a given microblog item
     * @public
     * @param {string} id
     * @param {string} hash
     * @param {string} pserver
     * @param {string} cnode
     * @return {boolean}
     */
    self.remove = function(id, hash, pserver, cnode) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#publisher-delete */

        try {
            // Initialize
            var selector = $('.' + hash);
            var get_last = false;
            
            // Get the latest item for the mixed mode
            if(Common.exists('#channel .content.mixed .' + hash))
                get_last = true;
            
            // Remove the item from our DOM
            selector.fadeOut('fast', function() {
                $(this).remove();
            });
            
            // Send the IQ to remove the item (and get eventual error callback)
            // Also attempt to remove the comments node.
            var retract_iq = new JSJaCIQ();
            retract_iq.setType('set');
            retract_iq.appendNode('pubsub', {'xmlns': NS_PUBSUB}).appendChild(retract_iq.buildNode('retract', {'node': NS_URN_MBLOG, 'xmlns': NS_PUBSUB})).appendChild(retract_iq.buildNode('item', {'id': id, 'xmlns': NS_PUBSUB}));
            
            var comm_delete_iq;
            if (pserver !== '' && cnode !== '') {
                comm_delete_iq = new JSJaCIQ();
                comm_delete_iq.setType('set');
                comm_delete_iq.setTo(pserver);
                comm_delete_iq.appendNode('pubsub', {'xmlns': 'http://jabber.org/protocol/pubsub#owner'}).appendChild(comm_delete_iq.buildNode('delete', {'node': cnode, 'xmlns': 'http://jabber.org/protocol/pubsub#owner'}));
            }
            
            if(get_last) {
                if (comm_delete_iq) { con.send(comm_delete_iq); }
                con.send(retract_iq, self.handleRemove);
            } else {
                if (comm_delete_iq) { con.send(comm_delete_iq); }
                con.send(retract_iq, Errors.handleReply);
            }
        } catch(e) {
            Console.error('Microblog.remove', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the microblog item removal
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleRemove = function(iq) {

        try {
            // Handle the error reply
            Errors.handleReply(iq);
            
            // Get the latest item
            self.request(Common.getXID(), '1', false, self.handleUpdateRemove);
        } catch(e) {
            Console.error('Microblog.handleRemove', e);
        }

    };


    /**
     * Handles the microblog update
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleUpdateRemove = function(iq) {

        try {
            // Error?
            if(iq.getType() == 'error')
                return;
            
            // Initialize
            var xid = Common.bareXID(Common.getStanzaFrom(iq));
            var hash = hex_md5(xid);
            
            // Display the item!
            self.display(iq, xid, hash, 'mixed', 'push');
        } catch(e) {
            Console.error('Microblog.handleUpdateRemove', e);
        }

    };


    /**
     * Gets a given microblog comments node
     * @public
     * @param {string} server
     * @param {string} node
     * @param {string} id
     * @return {boolean}
     */
    self.getComments = function(server, node, id) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#subscriber-retrieve-requestall */

        try {
            var iq = new JSJaCIQ();
            iq.setType('get');
            iq.setID('get_' + genID() + '-' + id);
            iq.setTo(server);
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            pubsub.appendChild(iq.buildNode('items', {'node': node, 'xmlns': NS_PUBSUB}));
            
            con.send(iq, self.handleComments);
        } catch(e) {
            Console.error('Microblog.getComments', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles a microblog comments node items
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleComments = function(iq) {

        try {
            // Path
            var id = Common.explodeThis('-', iq.getID(), 1);
            var path = 'div.comments[data-id="' + id + '"] div.comments-content';
            
            // Does not exist?
            if(!Common.exists(path))
                return false;
            
            // Any error?
            if(Errors.handleReply(iq)) {
                $(path).html('<div class="one-comment loading">' + Common._e("Could not get the comments!") + '</div>');
                
                return false;
            }
            
            // Initialize
            var data = iq.getNode();
            var server = Common.bareXID(Common.getStanzaFrom(iq));
            var node = $(data).find('items:first').attr('node');
            var users_xid = [];
            var code = '';
            
            // No node?
            if(!node) {
                node = $(data).find('publish:first').attr('node');
            }
            
            // Get the parent microblog item
            var parent_select = $('#channel .one-update:has(*[data-node="' + node + '"])');
            var parent_data = [parent_select.attr('data-xid'), NS_URN_MBLOG, parent_select.attr('data-id')];
            
            // Get the owner XID
            var owner_xid = parent_select.attr('data-xid');
            var repeat_xid = parent_select.find('a.repeat').attr('data-xid');
            
            // Must we create the complete DOM?
            var complete = true;
            
            if($(path).find('.one-comment.compose').size())
                complete = false;
            
            // Add the comment tool
            if(complete) {
                code += 
                '<div class="one-comment compose">' + 
                    '<span class="icon talk-images"></span><input type="text" placeholder="' + Common._e("Type your comment here...") + '" />' + 
                '</div>';
            }

            // Append the comments
            $(data).find('item').each(function() {
                // Get comment
                var current_id = $(this).attr('id');
                var current_xid = Common.explodeThis(':', $(this).find('author uri').text(), 1);
                var current_name = $(this).find('author name').text();
                var current_date = $(this).find('published').text();
                var current_body = $(this).find('content[type="text"]').text();
                var current_bname = Name.getBuddy(current_xid);
                
                // Legacy?
                if(!current_body)
                    current_body = $(this).find('title:not(source > title)').text();
                
                // Yet displayed? (continue the loop)
                if($(path).find('.one-comment[data-id="' + current_id + '"]').size())
                    return;
                
                // No XID?
                if(!current_xid) {
                    current_xid = '';
                    
                    if(!current_name)
                        current_name = Common._e("unknown");
                }
                
                else if(!current_name || (current_bname != Common.getXIDNick(current_xid)))
                    current_name = current_bname;
                
                // Any date?
                if(current_date)
                    current_date = DateUtils.relative(current_date);
                else
                    current_date = DateUtils.getCompleteTime();
                
                // Click event
                var onclick = 'false';
                
                if(current_xid != Common.getXID())
                    onclick = 'Chat.checkCreate(\'' + Utils.encodeOnclick(current_xid) + '\', \'chat\')';
                
                // If this is my comment, add a marker
                var type = 'him';
                var marker = '';
                var remove = '';
                
                if(current_xid == Common.getXID()) {
                    type = 'me';
                    marker = '<div class="marker"></div>';
                    remove = '<a href="#" class="remove" onclick="return Microblog.removeComment(\'' + Utils.encodeOnclick(server) + '\', \'' + Utils.encodeOnclick(node) + '\', \'' + Utils.encodeOnclick(current_id) + '\');">' + Common._e("Remove") + '</a>';
                }
                
                // New comment?
                var new_class = '';
                
                if(!complete)
                    new_class = ' new';
                
                // Add the comment
                if(current_body) {
                    // Add the XID
                    if(!Utils.existArrayValue(users_xid, current_xid))
                        users_xid.push(current_xid);
                    
                    // Add the HTML code
                    code = '<div class="one-comment ' + hex_md5(current_xid) + ' ' + type + new_class + '" data-id="' + Common.encodeQuotes(current_id) + '">' + 
                            marker + 
                            
                            '<div class="avatar-container" onclick="return ' + onclick + ';">' + 
                                '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                            '</div>' + 
                            
                            '<div class="comment-container">' + 
                                '<a href="#" onclick="return ' + onclick + ';" title="' + Common.encodeQuotes(current_xid) + '" class="name">' + current_name.htmlEnc() + '</a>' + 
                                '<span class="date">' + current_date.htmlEnc() + '</span>' + 
                                remove + 
                            
                                '<p class="body">' + Filter.message(current_body, current_name, true) + '</p>' + 
                            '</div>' + 
                            
                            '<div class="clear"></div>' + 
                        '</div>' + code;
                }
            });
            
            // Add the HTML
            if(complete) {
                $(path).html(code);
                
                // Focus on the compose input
                $(document).oneTime(10, function() {
                    $(path).find('.one-comment.compose input').focus();
                });
            }
            
            else {
                $(path).find('.one-comment.compose').before(code);
                
                // Beautiful effect
                $(path).find('.one-comment.new').slideDown('fast', function() {
                    self.adaptComment(id);
                }).removeClass('new');
            }
            
            // Set the good widths
            self.adaptComment(id);
            
            // Get the avatars
            for(var a in users_xid)
                Avatar.get(users_xid[a], 'cache', 'true', 'forget');
            
            // Add the owner XID
            if(owner_xid && owner_xid.match('@') && !Utils.existArrayValue(users_xid, owner_xid))
                users_xid.push(owner_xid);
            
            // Add the repeated from XID
            if(repeat_xid && repeat_xid.match('@') && !Utils.existArrayValue(users_xid, repeat_xid))
                users_xid.push(repeat_xid);
            
            // Remove my own XID
            Utils.removeArrayValue(users_xid, Common.getXID());
            
            // DOM events
            if(complete) {
                // Update timer
                $(path).everyTime('60s', function() {
                    self.getComments(server, node, id);
                    
                    Console.log('Updating comments node: ' + node + ' on ' + server + '...');
                });
                
                // Input key event
                $(path).find('.one-comment.compose input').placeholder()
                                 .keyup(function(e) {
                                        if((e.keyCode == 13) && $(this).val()) {
                                            // Send the comment!
                                            self.sendComment($(this).val(), server, node, id, users_xid, parent_data);
                                            
                                            // Reset the input value
                                            $(this).val('');
                                            
                                            return false;
                                        }
                                 });
            }
        } catch(e) {
            Console.error('Microblog.handleComments', e);
        }

    };


    /**
     * Shows the microblog comments box
     * @public
     * @param {string} path
     * @param {string} entityComments
     * @param {string} nodeComments
     * @param {string} tHash
     * @return {undefined}
     */
    self.showComments = function(path, entityComments, nodeComments, tHash) {

        try {
            // Do not display it twice!
            if(path.find('div.comments').size())
                return;
            
            // Generate an unique ID
            var idComments = genID();
            
            // Create comments container
            path.find('div.comments-container').append(
                '<div class="comments" data-id="' + Common.encodeQuotes(idComments) + '">' + 
                    '<div class="arrow talk-images"></div>' + 
                    '<div class="comments-content">' + 
                        '<a href="#" class="one-comment loading"><span class="icon talk-images"></span>' + Common._e("Show comments") + '</a>' + 
                    '</div>' + 
                '</div>'
            );
            
            // Click event
            path.find('div.comments a.one-comment').click(function() {
                // Set loading info
                $(this).parent().html('<div class="one-comment loading"><span class="icon talk-images"></span>' + Common._e("Loading comments...") + '</div>');
                
                // Request comments
                self.getComments(entityComments, nodeComments, idComments);
                
                // Remove the comments from the DOM if click away
                if(tHash) {
                    $('#channel').off('click');
                    
                    $('#channel').on('click', function(evt) {
                        if(!$(evt.target).parents('.' + tHash).size()) {
                            $('#channel').off('click');
                            $('#channel .one-update div.comments-content').stopTime();
                            $('#channel .one-update div.comments').remove();
                        }
                    });
                }
                
                return false;
            });
        } catch(e) {
            Console.error('Microblog.showComments', e);
        }

    };


    /**
     * Sends a comment on a given microblog comments node
     * @public
     * @param {string} value
     * @param {string} server
     * @param {string} node
     * @param {string} id
     * @param {object} notifiy_arr
     * @param {string} parent_data
     * @return {boolean}
     */
    self.sendComment = function(value, server, node, id, notifiy_arr, parent_data) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#publisher-publish */

        try {
            // Not enough data?
            if(!value || !server || !node)
                return false;
            
            // Get some values
            var date = DateUtils.getXMPPTime('utc');
            var hash = hex_md5(value + date);
            
            // New IQ
            var iq = new JSJaCIQ();
            iq.setType('set');
            iq.setTo(server);
            iq.setID('set_' + genID() + '-' + id);
            
            // PubSub main elements
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': node, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'id': hash, 'xmlns': NS_PUBSUB}));
            var entry = item.appendChild(iq.buildNode('entry', {'xmlns': NS_ATOM}));
            entry.appendChild(iq.buildNode('title', {'xmlns': NS_ATOM}));
            
            // Author infos
            var author = entry.appendChild(iq.buildNode('author', {'xmlns': NS_ATOM}));
            author.appendChild(iq.buildNode('name', {'xmlns': NS_ATOM}, Name.get()));
            author.appendChild(iq.buildNode('uri', {'xmlns': NS_ATOM}, 'xmpp:' + Common.getXID()));
            
            // Create the comment
            entry.appendChild(iq.buildNode('content', {'type': 'text', 'xmlns': NS_ATOM}, value));
            entry.appendChild(iq.buildNode('published', {'xmlns': NS_ATOM}, date));
            
            con.send(iq);
            
            // Handle this comment!
            iq.setFrom(server);
            self.handleComments(iq);
            
            // Notify users
            if(notifiy_arr && notifiy_arr.length) {
                // XMPP link to the item
                var href = 'xmpp:' + server + '?;node=' + encodeURIComponent(node) + ';item=' + encodeURIComponent(hash);
                
                // Loop!
                for(var n in notifiy_arr) {
                    Notification.send(notifiy_arr[n], 'comment', href, value, parent_data);
                }
            }
        } catch(e) {
            Console.error('Microblog.sendComment', e);
        } finally {
            return false;
        }

    };


    /**
     * Removes a given microblog comment item
     * @public
     * @param {string} server
     * @param {string} node
     * @param {string} id
     * @return {undefined}
     */
    self.removeComment = function(server, node, id) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#publisher-delete */

        try {
            // Remove the item from our DOM
            $('.one-comment[data-id="' + id + '"]').slideUp('fast', function() {
                // Get the parent ID
                var parent_id = $(this).parents('div.comments').attr('data-id');
                
                // Remove it!
                $(this).remove();
                
                // Adapt the width
                self.adaptComment(parent_id);
            });
            
            // Send the IQ to remove the item (and get eventual error callback)
            var iq = new JSJaCIQ();
            iq.setType('set');
            iq.setTo(server);
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var retract = pubsub.appendChild(iq.buildNode('retract', {'node': node, 'xmlns': NS_PUBSUB}));
            retract.appendChild(iq.buildNode('item', {'id': id, 'xmlns': NS_PUBSUB}));
            
            con.send(iq);
        } catch(e) {
            Console.error('Microblog.removeComment', e);
        } finally {
            return false;
        }

    };


    /**
     * Adapts the comment elements width
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.adaptComment = function(id) {

        try {
            var selector = $('div.comments[data-id="' + id + '"] div.comments-content');
            var selector_width = selector.width();
            
            // Change widths
            selector.find('.one-comment.compose input').css('width', selector_width - 60);
            selector.find('.one-comment .comment-container').css('width', selector_width - 55);
        } catch(e) {
            Console.error('Microblog.adaptComment', e);
        }

    };


    /**
     * Handles the microblog of an user
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handle = function(iq) {

        try {
            // Get the from attribute of this IQ
            var from = Common.bareXID(Common.getStanzaFrom(iq));
            
            // Define the selector path
            var selector = '#channel .top.individual input[name=';
            
            // Is this request still alive?
            if(from == $(selector + 'jid]').val()) {
                var hash = hex_md5(from);
                
                // Update the items counter
                var old_count = parseInt($(selector + 'counter]').val());
                $(selector + 'counter]').val(old_count + 20);
                
                // Display the microblog
                self.display(iq, from, hash, 'individual', 'request');
                
                // Hide the waiting icon
                if(Features.enabledPEP())
                    self.wait('sync');
                else
                    self.wait('unsync');
                
                // Hide the 'more items' link?
                if($(iq.getNode()).find('item').size() < old_count)
                    $('#channel .individual a.more').remove();
                
                // Get the comments?
                var comments_node = $('#channel .top.individual input[name="comments"]').val();
                
                if(comments_node && comments_node.match(/^xmpp:(.+)\?;node=(.+);item=(.+)/)) {
                    // Get the values
                    var comments_entity = RegExp.$1;
                    comments_node = decodeURIComponent(RegExp.$2);
                    
                    // Selectors
                    var file_link = $('#channel .individual .one-update p.file a[data-node="' + comments_node + '"]');
                    var entry_link = $('#channel .individual .one-update:has(.comments-container[data-node="' + comments_node + '"])');
                    
                    // Is it a microblog entry (or a lonely entry file)?
                    if(entry_link.size()) {
                        self.showComments(entry_link, comments_entity, comments_node);
                        entry_link.find('a.one-comment').click();
                    }
                    
                    // Is it a file?
                    else if(file_link.size())
                        file_link.click();
                }
            }
            
            Console.info('Microblog got: ' + from);
        } catch(e) {
            Console.error('Microblog.handle', e);
        }

    };


    /**
     * Handles the microblog of an user (from roster)
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleRoster = function(iq) {

        try {
            // Get the from attribute of this IQ
            var from = Common.bareXID(Common.getStanzaFrom(iq));

            // Display the microblog
            self.display(iq, from, hex_md5(from), 'mixed', 'push');
        } catch(e) {
            Console.error('Microblog.handleRoster', e);
        }

    };


    /**
     * Resets the microblog elements
     * @public
     * @return {boolean}
     */
    self.reset = function() {

        try {
            // Reset everything
            $('#channel .individual .one-update div.comments-content').stopTime();
            $('#channel .individual').remove();
            $('#channel .mixed').show();
            
            // Hide the waiting icon
            if(Features.enabledPEP()) {
                self.wait('sync');
            } else {
                self.wait('unsync');
            }
        } catch(e) {
            Console.error('Microblog.reset', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the user's microblog to check it exists
     * @public
     * @return {undefined}
     */
    self.getInit = function() {

        try {
            self.get(Common.getXID(), hex_md5(Common.getXID()), true);
        } catch(e) {
            Console.error('Microblog.getInit', e);
        }

    };


    /**
     * Handles the user's microblog to create it in case of error
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleInit = function(iq) {

        try {
            // Any error?
            if((iq.getType() == 'error') && $(iq.getNode()).find('item-not-found').size()) {
                // The node may not exist, create it!
                Pubsub.setup('', NS_URN_MBLOG, '1', '1000000', '', '', true);
                
                Console.warn('Error while getting microblog, trying to reconfigure the PubSub node!');
            }
        } catch(e) {
            Console.error('Microblog.handleInit', e);
        }

    };


    /**
     * Requests an user's microblog
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.request = function(xid, items, get_item, handler) {

        try {
            // Ask the server the user's microblog 
            var iq = new JSJaCIQ();
            iq.setType('get');
            iq.setTo(xid);
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var ps_items = pubsub.appendChild(iq.buildNode('items', {'node': NS_URN_MBLOG, 'xmlns': NS_PUBSUB}));
            
            // Request a particular item?
            if(get_item)
                ps_items.appendChild(iq.buildNode('item', {'id': get_item, 'xmlns': NS_PUBSUB}));
            else
                ps_items.setAttribute('max_items', items);
            
            if(handler) {
                con.send(iq, handler);
            } else {
                con.send(iq, self.handle);
            }
        } catch(e) {
            Console.error('Microblog.request', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the microblog of an user
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {boolean} check
     * @return {boolean}
     */
    self.get = function(xid, hash, check) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#subscriber-retrieve */

        try {
            Console.info('Get the microblog: ' + xid);
            
            // Fire the wait event
            self.wait('fetch');
            
            // XMPP URI?
            var get_item = '';
            
            if(xid.match(/^xmpp:(.+)\?;node=(.+);item=(.+)/)) {
                xid = RegExp.$1;
                get_item = decodeURIComponent(RegExp.$3);
            }
            
            // No hash?
            if(!hash)
                hash = hex_md5(xid);
            
            // Can display the individual channel?
            if(!check && !Common.exists('#channel .individual')) {
                // Hide the mixed channel
                $('#channel .mixed').hide();
                
                // Get the channel title depending on the XID
                var cTitle;
                var cShortcuts = '';
                
                if(xid == Common.getXID())
                    cTitle = Common._e("Your channel");
                else {
                    cTitle = Common._e("Channel of") + ' ' + Name.getBuddy(xid).htmlEnc();
                    cShortcuts = '<div class="shortcuts">' + 
                                '<a href="#" class="message talk-images" title="' + Common._e("Send him/her a message") + '" onclick="return Inbox.composeMessage(\'' + Utils.encodeOnclick(xid) + '\');"></a>' + 
                                '<a href="#" class="chat talk-images" title="' + Common._e("Start a chat with him/her") + '" onclick="return Chat.checkCreate(\'' + Utils.encodeOnclick(xid) + '\', \'chat\');"></a>' + 
                                '<a href="#" class="command talk-images" title="' + Common._e("Command") + '" onclick="return AdHoc.retrieve(\'' + Utils.encodeOnclick(xid) + '\');"></a>' + 
                                '<a href="#" class="profile talk-images" title="' + Common._e("Show user profile") + '" onclick="return UserInfos.open(\'' + Utils.encodeOnclick(xid) + '\');"></a>' + 
                                 '</div>';
                }
                
                // Create a new individual channel
                $('#channel .content.mixed').after(
                        '<div class="content individual microblog-' + hash + '">' + 
                            '<a href="#" class="more home-images" onclick="if($(\'#channel .footer div.fetch\').is(\':hidden\')) { return Microblog.get(\'' + Utils.encodeOnclick(xid) + '\', \'' + Utils.encodeOnclick(hash) + '\'); } return false;">' + Common._e("More notices...") + '</a>' + 
                        '</div>'
                                 )
                               
                               .before(
                        '<div class="top individual ' + hash + '">' + 
                            '<div class="avatar-container">' + 
                                '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                            '</div>' + 
                            
                            '<div class="update">' + 
                                '<h2>' + cTitle + '</h2>' + 
                                '<a href="#" onclick="return Microblog.reset();">¬´ ' + Common._e("Previous") + '</a>' + 
                            '</div>' + 
                            
                            cShortcuts + 
                            
                            '<input type="hidden" name="jid" value="' + Common.encodeQuotes(xid) + '" />' + 
                            '<input type="hidden" name="counter" value="20" />' + 
                        '</div>'
                                 );
                
                // Microblog navigation
                $('#channel .content.individual').scroll(function() {
                    if($('#channel .footer div.fetch').is(':hidden') && $('#channel .individual a.more:visible').size() && $('#channel .content.individual').scrollTop() >= ($('#channel .content.individual')[0].scrollHeight - $('#channel .content.individual').height() - 200))
                        $('#channel .individual a.more').click();
                });

                // Display the user avatar
                Avatar.get(xid, 'cache', 'true', 'forget');
            }
            
            // Get the number of items to retrieve
            var items = '0';
            
            if(!check)
                items = $('#channel .top.individual input[name="counter"]').val();
            
            // Request
            if(check)
                self.request(xid, items, get_item, self.handleInit);
            else
                self.request(xid, items, get_item, self.handle);
        } catch(e) {
            Console.error('Microblog.get', e);
        } finally {
            return false;
        }

    };


    /**
     * Show a given microblog waiting status
     * @public
     * @param {string} type
     * @return {undefined}
     */
    self.wait = function(type) {

        try {
            // First hide all the infos elements
            $('#channel .footer div').hide();
            
            // Display the good one
            $('#channel .footer div.' + type).show();
            
            // Depending on the type, disable/enable certain tools
            var selector = $('#channel .top input[name="microblog_body"]');
            
            if(type == 'unsync') {
                selector.attr('disabled', true);
            } else if(type == 'sync') {
                $(document).oneTime(10, function() {
                    selector.removeAttr('disabled').focus();
                });
            }
        } catch(e) {
            Console.error('Microblog.wait', e);
        }

    };


    /**
     * Gets the microblog configuration
     * @public
     * @return {undefined}
     */
    self.getConfig = function() {

        try {
            // Lock the microblog options
            $('#persistent, #maxnotices').attr('disabled', true);
            
            // Get the microblog configuration
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB_OWNER});
            pubsub.appendChild(iq.buildNode('configure', {'node': NS_URN_MBLOG, 'xmlns': NS_PUBSUB_OWNER}));
            
            con.send(iq, self.handleGetConfig);
        } catch(e) {
            Console.error('Microblog.getConfig', e);
        }

    };


    /**
     * Handles the microblog configuration
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleGetConfig = function(iq) {

        try {
            // Reset the options stuffs
            Options.wait('microblog');
            
            // Unlock the microblog options
            $('#persistent, #maxnotices').removeAttr('disabled');
            
            // End if not a result
            if(!iq || (iq.getType() != 'result'))
                return;
            
            // Initialize the values
            var selector = $(iq.getNode());
            var persistent = '0';
            var maxnotices = '1000000';
            
            // Get the values
            var xPersistent = selector.find('field[var="pubsub#persist_items"] value:first').text();
            var xMaxnotices = selector.find('field[var="pubsub#max_items"] value:first').text();
            
            // Any value?
            if(xPersistent)
                persistent = xPersistent;
            
            if(xMaxnotices)
                maxnotices = xMaxnotices;
            
            // Change the maxnotices value
            switch(maxnotices) {
                case '1':
                case '100':
                case '1000':
                case '10000':
                case '100000':
                case '1000000':
                    break;
                
                default:
                    maxnotices = '1000000';
                    break;
            }
            
            // Apply persistent value
            if(persistent == '0')
                $('#persistent').attr('checked', false);
            else
                $('#persistent').attr('checked', true);
            
            // Apply maxnotices value
            $('#maxnotices').val(maxnotices);
        } catch(e) {
            Console.error('Microblog.handleGetConfig', e);
        }

    };


    /**
     * Handles the user's microblog
     * @public
     * @param {object} packet
     * @return {undefined}
     */
    self.handleMine = function(packet) {

        try {
            // Reset the entire form
            $('#channel .top input[name="microblog_body"]').removeAttr('disabled').val('');
            $('#channel .top input[name="microblog_body"]').placeholder();
            self.unattach();
            
            // Check for errors
            Errors.handleReply(packet);
        } catch(e) {
            Console.error('Microblog.handleMy', e);
        }

    };


    /**
     * Performs the microblog sender checks
     * @public
     * @param {type} name
     * @return {boolean}
     */
    self.send = function() {

        try {
            // Get the values
            var selector = $('#channel .top input[name="microblog_body"]');
            var body = $.trim(selector.val());
            
            // Sufficient parameters
            if(body) {
                // Disable & blur our input
                selector.attr('disabled', true).blur();
                
                // Files array
                var fName = [];
                var fType = [];
                var fLength = [];
                var fURL = [];
                var fThumb = [];
                
                // Read the files
                $('#attach .one-file').each(function() {
                    // Push the values!
                    fName.push($(this).find('a.link').text());
                    fType.push($(this).attr('data-type'));
                    fLength.push($(this).attr('data-length'));
                    fURL.push($(this).find('a.link').attr('href'));
                    fThumb.push($(this).attr('data-thumb'));
                });
                
                // Containing YouTube videos?
                var yt_matches = body.match(/(\w{3,5})(:)(\S+)((\.youtube\.com\/watch(\?v|\?\S+v|\#\!v|\#\!\S+v)\=)|(youtu\.be\/))([^& ]+)((&amp;\S)|(&\S)|\s|$)/gim);
                
                for(var y in yt_matches) {
                    fName.push('');
                    fType.push('text/html');
                    fLength.push('');
                    fURL.push($.trim(yt_matches[y]));
                    fThumb.push('https://img.youtube.com/vi/' + $.trim(yt_matches[y].replace(/(\w{3,5})(:)(\S+)((\.youtube\.com\/watch(\?v|\?\S+v|\#\!v|\#\!\S+v)\=)|(youtu\.be\/))([^& ]+)((&amp;\S)|(&\S)|\s|$)/gim, '$8')) + '/0.jpg');
                }
                
                // Send the message on the XMPP network
                self.publish(body, fName, fURL, fType, fLength, fThumb);
            }
        } catch(e) {
            Console.error('Microblog.send', e);
        } finally {
            return false;
        }

    };


    /**
     * Publishes a given microblog item
     * @public
     * @param {type} body
     * @param {type} attachedname
     * @param {type} attachedurl
     * @param {type} attachedtype
     * @param {type} attachedlength
     * @param {type} attachedthumb
     * @param {type} repeat
     * @param {type} comments_entity
     * @param {type} comments_node
     * @param {type} comments_entity_file
     * @param {type} comments_node_file
     * @return {boolean}
     */
    self.publish = function(body, attachedname, attachedurl, attachedtype, attachedlength, attachedthumb, repeat, comments_entity, comments_node, comments_entity_file, comments_node_file) {

        /* REF: http://xmpp.org/extensions/xep-0277.html */

        try {
            // Generate some values
            var time = DateUtils.getXMPPTime('utc');
            var id = hex_md5(body + time);
            var nick = Name.get();
            var xid = Common.getXID();
            
            // Define repeat options
            var author_nick = nick;
            var author_xid = xid;
            
            if(repeat && repeat.length) {
                author_nick = repeat[0];
                author_xid = repeat[1];
            }
            
            // Define comments options
            var node_create = false;
            
            if(!comments_entity || !comments_node) {
                node_create = true;
                comments_entity = HOST_PUBSUB;
                comments_node = NS_URN_MBLOG + ':comments/' + id;
            }
            
            if(!comments_entity_file)
                comments_entity_file = [];
            if(!comments_node_file)
                comments_node_file = [];
            
            // Don't create another comments node if only 1 file is attached
            if(attachedurl && (attachedurl.length == 1) && (!comments_entity_file[0] || !comments_node_file[0])) {
                comments_entity_file = [comments_entity];
                comments_node_file = [comments_node];
            }
            
            // New IQ
            var iq = new JSJaCIQ();
            iq.setType('set');
            iq.setTo(xid);
            
            // Create the main XML nodes/childs
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_URN_MBLOG, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'id': id, 'xmlns': NS_PUBSUB}));
            var entry = item.appendChild(iq.buildNode('entry', {'xmlns': NS_ATOM}));
            entry.appendChild(iq.buildNode('title', {'xmlns': NS_ATOM}));
            
            // Create the XML author childs
            var author = entry.appendChild(iq.buildNode('author', {'xmlns': NS_ATOM}));
            author.appendChild(iq.buildNode('name', {'xmlns': NS_ATOM}, author_nick));
            author.appendChild(iq.buildNode('uri', {'xmlns': NS_ATOM}, 'xmpp:' + author_xid));
            
            // Create the XML entry childs
            entry.appendChild(iq.buildNode('content', {'type': 'text', 'xmlns': NS_ATOM}, body));
            entry.appendChild(iq.buildNode('published', {'xmlns': NS_ATOM}, time));
            entry.appendChild(iq.buildNode('updated', {'xmlns': NS_ATOM}, time));
            entry.appendChild(iq.buildNode('link', {
                    'rel': 'alternate',
                    'href': 'xmpp:' + xid + '?;node=' + encodeURIComponent(NS_URN_MBLOG) + ';item=' + encodeURIComponent(id),
                    'xmlns': NS_ATOM
            }));
            
            // Create the attached files nodes
            for(var i = 0; i < attachedurl.length; i++) {
                // Not enough data?
                if(!attachedurl[i])
                    continue;
                
                // Append a new file element
                var file = entry.appendChild(iq.buildNode('link', {'xmlns': NS_ATOM, 'rel': 'enclosure', 'href': attachedurl[i]}));
                
                // Add attributes
                if(attachedname[i])
                    file.setAttribute('title', attachedname[i]);
                if(attachedtype[i])
                    file.setAttribute('type', attachedtype[i]);
                if(attachedlength[i])
                    file.setAttribute('length', attachedlength[i]);
                
                // Any thumbnail?
                if(attachedthumb[i])
                    file.appendChild(iq.buildNode('link', {'xmlns': NS_URN_MBLOG, 'rel': 'self', 'title': 'thumb', 'type': attachedtype[i], 'href': attachedthumb[i]}));
                
                // Any comments node?
                if(!comments_entity_file[i] || !comments_node_file[i]) {
                    // Generate values
                    comments_entity_file[i] = HOST_PUBSUB;
                    comments_node_file[i] = NS_URN_MBLOG + ':comments/' + hex_md5(attachedurl[i] + attachedname[i] + attachedtype[i] + attachedlength[i] + time);
                    
                    // Create the node
                    Pubsub.setup(comments_entity_file[i], comments_node_file[i], '1', '1000000', 'open', 'open', true);
                }
                
                file.appendChild(iq.buildNode('link', {'xmlns': NS_URN_MBLOG, 'rel': 'replies', 'title': 'comments_file', 'href': 'xmpp:' + comments_entity_file[i] + '?;node=' + encodeURIComponent(comments_node_file[i])}));
            }
            
            // Create the comments child
            entry.appendChild(iq.buildNode('link', {'xmlns': NS_ATOM, 'rel': 'replies', 'title': 'comments', 'href': 'xmpp:' + comments_entity + '?;node=' + encodeURIComponent(comments_node)}));
            
            // Create the geoloc child
            var geoloc_xml = DataStore.getDB(Connection.desktop_hash, 'geolocation', 'now');
            
            if(geoloc_xml) {
                // Create two position arrays
                var geo_names  = ['lat', 'lon', 'country', 'countrycode', 'region', 'postalcode', 'locality', 'street', 'building', 'text', 'uri', 'timestamp'];
                var geo_values = PEP.parsePosition(Common.XMLFromString(geoloc_xml));
                
                // New geoloc child
                var geoloc = entry.appendChild(iq.buildNode('geoloc', {'xmlns': NS_GEOLOC}));
                
                // Append the geoloc content
                for(var g = 0; g < geo_names.length; g++) {
                    if(geo_names[g] && geo_values[g])
                        geoloc.appendChild(iq.buildNode(geo_names[g], {'xmlns': NS_GEOLOC}, geo_values[g]));
                }
            }
            
            // Send the IQ
            con.send(iq, self.handleMine);
            
            // Create the XML comments PubSub nodes
            if(node_create) {
                Pubsub.setup(comments_entity, comments_node, '1', '1000000', 'open', 'open', true);
            }
        } catch(e) {
            Console.error('Microblog.publish', e);
        } finally {
            return false;
        }

    };


    /**
     * Attaches a file to a microblog post
     * @public
     * @return {undefined}
     */
    self.attach = function() {

        try {
            // File upload vars
            var attach_options = {
                dataType:      'xml',
                beforeSubmit:   self.waitAttach,
                success:        self.handleAttach
            };
            
            // Upload form submit event
            $('#attach').submit(function() {
                if(!Common.exists('#attach .wait') && $('#attach input[type="file"]').val())
                    $(this).ajaxSubmit(attach_options);
                
                return false;
            });
            
            // Upload input change event
            $('#attach input[type="file"]').change(function() {
                if(!Common.exists('#attach .wait') && $(this).val())
                    $('#attach').ajaxSubmit(attach_options);
                
                return false;
            });
        } catch(e) {
            Console.error('Microblog.attach', e);
        }

    };


    /**
     * Unattaches a microblog file
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.unattach = function(id) {

        try {
            // Individual removal?
            if(id)
                $('#attach .one-file[data-id="' + id + '"]').remove();
            else
                $('#attach .one-file').remove();
            
            // Must enable the popup again?
            if(!Common.exists('#attach .one-file')) {
                // Restore the bubble class
                $('#attach').addClass('bubble');
                
                // Enable the bubble click events
                if(id) {
                    $('#attach').hide();
                    Bubble.show('#attach');
                }
                
                else
                    Bubble.close();
            }
        } catch(e) {
            Console.error('Microblog.unattach', e);
        } finally {
            return false;
        }

    };


    /**
     * Wait event for file attaching
     * @public
     * @return {undefined}
     */
    self.waitAttach = function() {

        try {
            // Append the wait icon
            $('#attach input[type="submit"]').after('<div class="wait wait-medium"></div>');
            
            // Lock the bubble
            $('#attach').removeClass('bubble');
        } catch(e) {
            Console.error('Microblog.waitAttach', e);
        }

    };


    /**
     * Success event for file attaching
     * @public
     * @param {string} responseXML
     * @return {undefined}
     */
    self.handleAttach = function(responseXML) {

        try {
            // Data selector
            var dData = $(responseXML).find('jappix');
            
            // Process the returned data
            if(!dData.find('error').size()) {
                // Do not allow this bubble to be hidden
                $('#attach').removeClass('bubble');
                
                // Get the file values
                var fName = dData.find('title').text();
                var fType = dData.find('type').text();
                var fLength = dData.find('length').text();
                var fURL = dData.find('href').text();
                var fThumb = dData.find('thumb').text();
                
                // Generate a file ID
                var fID = hex_md5(fURL);
                
                // Add this file
                $('#attach .attach-subitem').append(
                    '<div class="one-file" data-type="' + Common.encodeQuotes(fType) + '" data-length="' + Common.encodeQuotes(fLength) + '" data-thumb="' + Common.encodeQuotes(fThumb) + '" data-id="' + fID + '">' + 
                        '<a class="remove talk-images" href="#" title="' + Common.encodeQuotes(Common._e("Unattach the file")) + '"></a>' + 
                        '<a class="link" href="' + Common.encodeQuotes(fURL) + '" target="_blank">' + fName.htmlEnc() + '</a>' + 
                    '</div>'
                );
                
                // Click event
                $('#attach .one-file[data-id="' + fID + '"] a.remove').click(function() {
                    return self.unattach(fID);
                });
                
                Console.info('File attached.');
            }
            
            // Any error?
            else {
                Board.openThisError(4);
                
                // Unlock the bubble?
                if(!Common.exists('#attach .one-file')) {
                    $('#attach').addClass('bubble').hide();
                    
                    // Show the bubble again!
                    Bubble.show('#attach');
                }
                
                Console.error('Error while attaching the file', dData.find('error').text());
            }
            
            // Reset the attach bubble
            $('#attach input[type="file"]').val('');
            $('#attach .wait').remove();
            
            // Focus on the text input
            $(document).oneTime(10, function() {
                $('#channel .top input[name="microblog_body"]').focus();
            });
        } catch(e) {
            Console.error('Microblog.handleAttach', e);
        }

    };


    /**
     * Shows the microblog of an user from his infos
     * @public
     * @param {string} xid
     * @param {string} hash
     * @return {undefined}
     */
    self.fromInfos = function(xid, hash) {

        try {
            // Renitialize the channel
            self.reset();
            
            // Switch to the channel
            Interface.switchChan('channel');
            
            // Get the microblog
            self.get(xid, hash);
        } catch(e) {
            Console.error('Microblog.fromInfos', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Keyboard event
            $('#channel .top input[name="microblog_body"]').keyup(function(e) {
                // Enter pressed: send the microblog notice
                if((e.keyCode == 13) && !Common.exists('#attach .wait'))
                    return self.send();
            })
            
            // Placeholder
            .placeholder();
            
            // Microblog file attacher
            self.attach();
        } catch(e) {
            Console.error('Microblog.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the music JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Music = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the music bubble
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            var path = '.music-content';
    
            // Show the music bubble
            Bubble.show(path);
            
            $(document).oneTime(10, function() {
                $(path + ' input').focus();
            });
        } catch(e) {
            Console.error('Music.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Parses the music search XML
     * @public
     * @param {string} xml
     * @param {string} type
     * @return {undefined}
     */
    self.parse = function(xml, type) {

        try {
            var path = '.music-content ';
            var content = path + '.list';
            var path_type = content + ' .' + type;
            
            // Create the result container
            if(!Common.exists(path_type)) {
                var code = '<div class="' + type + '"></div>';
                
                if(type == 'local')
                    $(content).prepend(code);
                else
                    $(content).append(code);
            }
            
            // Fill the results
            $(xml).find('track').each(function() {
                // Parse the XML
                var id = $(this).find('id').text();
                var title = $(this).find('name').text();
                var artist = $(this).find('artist').text();
                var source = $(this).find('source').text();
                var duration = $(this).find('duration').text();
                var uri = $(this).find('url').text();
                var mime = $(this).find('type').text();
                
                // No ID?
                if(!id)
                    id = hex_md5(uri);
                
                // No MIME?
                if(!mime)
                    mime = 'audio/ogg';
                
                // Local URL?
                if(type == 'local')
                    uri = Utils.generateURL(uri);
                
                // Append the HTML code
                $(path_type).append('<a href="#" class="song" data-id="' + id + '">' + title + '</a>');
                
                // Current playing song?
                var current_song = $(path_type + ' a[data-id="' + id + '"]');
                
                if(Common.exists('.music-audio[data-id="' + id + '"]'))
                    current_song.addClass('playing');
                
                // Click event
                current_song.click(function() {
                    return self.add(id,  title, artist, source, duration, uri, mime, type);
                });
            });
            
            // The search is finished
            if(Common.exists(content + ' .jamendo') && Common.exists(content + ' .local')) {
                // Get the result values
                var jamendo = $(content + ' .jamendo').text();
                var local = $(content + ' .local').text();
                
                // Enable the input
                $(path + 'input').val('').removeAttr('disabled');
                
                // No result
                if(!jamendo && !local)
                    $(path + '.no-results').show();
                
                // We must put a separator between the categories
                if(jamendo && local)
                    $(content + ' .local').addClass('special');
            }
        } catch(e) {
            Console.error('Music.parse', e);
        }

    };


    /**
     * Sends the music search requests
     * @public
     * @return {undefined}
     */
    self.search = function() {

        try {
            var path = '.music-content ';
            
            // We get the input string
            var string = $(path + 'input').val();
            
            // We lock the search input
            $(path + 'input').attr('disabled', true);
            
            // We reset the results
            $(path + '.list div').remove();
            $(path + '.no-results').hide();
            
            // Get the Jamendo results
            $.get('./server/music-search.php', {searchquery: string, location: 'jamendo'}, function(data) {
                self.parse(data, 'jamendo');
            });
            
            // Get the local results
            $.get('./server/music-search.php', {searchquery: string, location: JAPPIX_LOCATION}, function(data) {
                self.parse(data, 'local');
            });
        } catch(e) {
            Console.error('Music.search', e);
        }

    };


    /**
     * Performs an action on the music player
     * @public
     * @param {string} action
     * @return {boolean}
     */
    self.action = function(action) {

        try {
            // Initialize
            var playThis = document.getElementById('top-content').getElementsByTagName('audio')[0];
            
            // Nothing to play, exit
            if(!playThis)
                return false;
            
            var stopButton = $('#top-content a.stop');
            
            // User play a song
            if(action == 'play') {
                stopButton.show();
                playThis.load();
                playThis.play();
                playThis.addEventListener('ended', function() {
                    self.action('stop');
                }, true);  
                
                Console.log('Music is now playing.');
            }
            
            // User stop the song or the song came to its end
            else if(action == 'stop') {
                stopButton.hide();
                playThis.pause();
                $('#top-content .music').removeClass('actived');
                $('.music-content .list a').removeClass('playing');
                $('.music-audio').remove();
                self.publish();
                
                Console.log('Music is now stopped.');
            }
        } catch(e) {
            Console.error('Music.action', e);
        } finally {
            return false;
        }

    };


    /**
     * Publishes the current title over PEP
     * @public
     * @param {string} title
     * @param {string} artist
     * @param {string} source
     * @param {string} duration
     * @param {string} uri
     * @return {undefined}
     */
    self.publish = function(title, artist, source, duration, uri) {

        /* REF: http://xmpp.org/extensions/xep-0118.html */

        try {
            // We share the tune on PEP if enabled
            if(Features.enabledPEP()) {
                var iq = new JSJaCIQ();
                iq.setType('set');
                
                // Create the main PubSub nodes
                var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
                var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_TUNE, 'xmlns': NS_PUBSUB}));
                var item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
                var tune = item.appendChild(iq.buildNode('tune', {'xmlns': NS_TUNE}));
                
                // Enough data?
                if(title || artist || source || uri) {
                    // Data array
                    var nodes = new Array(
                            'title',
                            'artist',
                            'source',
                            'length',
                            'uri'
                            );
                    
                    var values = new Array(
                            title,
                            artist,
                            source,
                            length,
                            uri
                             );
                    
                    // Create the children nodes
                    for(var i in nodes) {
                        if(values[i]) {
                            tune.appendChild(iq.buildNode(nodes[i], {'xmlns': NS_TUNE}, values[i]));
                        }
                    }
                }
                
                con.send(iq);
                
                Console.info('New tune sent: ' + title);
            }
        } catch(e) {
            Console.error('Music.publish', e);
        }

    };


    /**
     * Adds a music title to the results
     * @public
     * @param {string} id
     * @param {string} title
     * @param {string} artist
     * @param {string} source
     * @param {string} duration
     * @param {string} uri
     * @param {string} mime
     * @param {string} type
     * @return {boolean}
     */
    self.add = function(id, title, artist, source, duration, uri, mime, type) {

        try {
            var path = '.music-content ';
            
            // We remove & create a new audio tag
            $('.music-audio').remove();
            $(path + '.player').prepend('<audio class="music-audio" type="' + mime + '" data-id="' + id + '" />');
            
            // We apply the new source to the player
            if(type == 'jamendo')
                $('.music-audio').attr('src', 'http://api.jamendo.com/get2/stream/track/redirect/?id=' + id + '&streamencoding=ogg2');
            else
                $('.music-audio').attr('src', uri);
            
            // We play the target sound
            self.action('play');
            
            // We set the actived class
            $('#top-content .music').addClass('actived');
            
            // We set a current played track indicator
            $(path + '.list a').removeClass('playing');
            $(path + 'a[data-id="' + id + '"]').addClass('playing');
            
            // We publish what we listen
            self.publish(title, artist, source, duration, uri);
        } catch(e) {
            Console.error('Music.add', e);
        } finally {
            return false;
        }

    };


    /**
     * Plugin launcher
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // When music search string submitted
            $('.music-content input').keyup(function(e) {
                // Enter : send
                if(e.keyCode == 13 && $(this).val()) {
                    self.search();
                }
                
                // Escape : quit
                if(e.keyCode == 27) {
                    Bubble.close();
                }
            });
        } catch(e) {
            Console.error('Music.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the notification JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Notification = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Resets the notifications alert if no one remaining
     * @public
     * @return {undefined}
     */
    self.closeEmpty = function() {

        try {
            if(!$('.one-notification').size()) {
                Bubble.close();
            }
        } catch(e) {
            Console.error('Notification.closeEmpty', e);
        }

    };


    /**
     * Checks if there are pending notifications
     * @public
     * @return {undefined}
     */
    self.check = function() {

        try {
            // Define the selectors
            var notif = '#top-content .notifications';
            var nothing = '.notifications-content .nothing';
            var empty = '.notifications-content .empty';
            
            // Get the notifications number
            var number = $('.one-notification').size();
            
            // Remove the red notify bubble
            $(notif + ' .notify').remove();
            
            // Any notification?
            if(number) {
                $(notif).prepend('<div class="notify one-counter" data-counter="' + number + '">' + number + '</div>');
                $(nothing).hide();
                $(empty).show();
            }
            
            // No notification!
            else {
                $(empty).hide();
                $(nothing).show();
                
                // Purge the social inbox node
                self.purge();
            }
            
            // Update the page title
            Interface.updateTitle();
        } catch(e) {
            Console.error('Notification.check', e);
        }

    };


    /**
     * Creates a new notification
     * @public
     * @param {string} type
     * @param {string} from
     * @param {string} data
     * @param {string} body
     * @param {string} id
     * @param {boolean} inverse
     * @return {undefined}
     */
    self.create = function(type, from, data, body, id, inverse) {

        try {
            if(!type || !from)
                return;
            
            // Generate an ID hash
            if(!id) {
                id = hex_md5(type + from);
            }
            
            // Generate the text to be displayed
            var text, action, code;
            var yes_path = 'href="#"';
            
            // User things
            from = Common.bareXID(from);
            var hash = hex_md5(from);
            
            switch(type) {
                case 'subscribe':
                    // Get the name to display
                    var display_name = data[1];
                    
                    if(!display_name)
                        display_name = data[0];
                    
                    text = '<b>' + display_name.htmlEnc() + '</b> ' + Common._e("would like to add you as a friend.") + ' ' + Common._e("Do you accept?");
                    
                    break;
                
                case 'invite_room':
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common._e("would like you to join this chatroom:") + ' <em>' + data[0].htmlEnc() + '</em> ' + Common._e("Do you accept?");
                    
                    break;
                
                case 'request':
                    text = '<b>' + from.htmlEnc() + '</b> ' + Common._e("would like to get authorization.") + ' ' + Common._e("Do you accept?");
                    
                    break;
                
                case 'send':
                    yes_path = 'href="' + Common.encodeQuotes(data[1]) + '" target="_blank"';
                    
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common.printf(Common._e("would like to send you a file: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>') + ' ' + Common._e("Do you accept?");
                    
                    break;
                
                case 'send_pending':
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common.printf(Common._e("has received a file exchange request: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'send_accept':
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common.printf(Common._e("has accepted to receive your file: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'send_reject':
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common.printf(Common._e("has rejected to receive your file: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'send_fail':
                    text = '<b>' + Name.getBuddy(from).htmlEnc() + '</b> ' + Common.printf(Common._e("could not receive your file: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'rosterx':
                    text = Common.printf(Common._e("Do you want to see the friends %s suggests you?").htmlEnc(), '<b>' + Name.getBuddy(from).htmlEnc() + '</b>');
                    
                    break;
                
                case 'comment':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("commented an item you follow: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'like':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("liked your post: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'quote':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("quoted you somewhere: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'wall':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("published on your wall: ‚Äú%s‚Äù.").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'photo':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("tagged you in a photo (%s).").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;
                
                case 'video':
                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common.printf(Common._e("tagged you in a video (%s).").htmlEnc(), '<em>' + Utils.truncate(body, 25).htmlEnc() + '</em>');
                    
                    break;

                case 'me_profile_new_success':
                    yes_path = 'href="' + Common.encodeQuotes(data[1]) + '" target="_blank"';

                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common._e("validated your account. Your public profile will be available in a few moments.").htmlEnc();
                    
                    break;

                case 'me_profile_remove_success':
                    yes_path = 'href="' + Common.encodeQuotes(data[1]) + '" target="_blank"';

                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common._e("has removed your public profile after your request. We will miss you!").htmlEnc();
                    
                    break;

                case 'me_profile_update_success':
                    yes_path = 'href="' + Common.encodeQuotes(data[1]) + '" target="_blank"';

                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common._e("has saved your new public profile settings. They will be applied in a few moments.").htmlEnc();
                    
                    break;

                case 'me_profile_check_error':
                    yes_path = 'href="' + Common.encodeQuotes(data[1]) + '" target="_blank"';

                    text = '<b>' + data[0].htmlEnc() + '</b> ' + Common._e("could not validate your account to create or update your public profile. Check your credentials.").htmlEnc();
                    
                    break;
                
                default:
                    break;
            }
            
            // No text?
            if(!text)
                return;
            
            // Action links?
            switch(type) {
                // Hide/Show actions
                case 'send_pending':
                case 'send_accept':
                case 'send_reject':
                case 'send_fail':
                case 'comment':
                case 'like':
                case 'quote':
                case 'wall':
                case 'photo':
                case 'video':
                    action = '<a href="#" class="no">' + Common._e("Hide") + '</a>';

                    // Any parent link?
                    if((type == 'comment') && data[2])
                        action = '<a href="#" class="yes">' + Common._e("Show") + '</a>' + action;

                    break;

                // Jappix Me actions
                case 'me_profile_new_success':
                case 'me_profile_remove_success':
                case 'me_profile_update_success':
                case 'me_profile_check_error':
                    action = '<a ' + yes_path + ' class="yes">' + Common._e("Open") + '</a><a href="#" class="no">' + Common._e("Hide") + '</a>';

                    break;

                // Default actions
                default:
                    action = '<a ' + yes_path + ' class="yes">' + Common._e("Yes") + '</a><a href="#" class="no">' + Common._e("No") + '</a>';
            }
            
            if(text) {
                // We display the notification
                if(!Common.exists('.notifications-content .' + id)) {
                    // We create the html markup depending of the notification type
                    code = '<div class="one-notification ' + id + ' ' + hash + '" title="' + Common.encodeQuotes(body) + ' - ' + Common._e("This notification is only informative, maybe the data it links to have been removed.") + '" data-type="' + Common.encodeQuotes(type) + '">' + 
                            '<div class="avatar-container">' + 
                                '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                            '</div>' + 
                            
                            '<p class="notification-text">' + text + '</p>' + 
                            '<p class="notification-actions">' + 
                                '<span class="talk-images" />' + 
                                action + 
                            '</p>' + 
                           '</div>';
                    
                    // Add the HTML code
                    if(inverse)
                        $('.notifications-content .nothing').before(code);
                    else
                        $('.notifications-content .empty').after(code);
                    
                    // Play a sound to alert the user
                    Audio.play('notification');
                    
                    // The yes click function
                    $('.' + id + ' a.yes').click(function() {
                        self.action(type, data, 'yes', id);
                        
                        if(($(this).attr('href') == '#') && ($(this).attr('target') != '_blank'))
                            return false;
                    });
                    
                    // The no click function
                    $('.' + id + ' a.no').click(function() {
                        return self.action(type, data, 'no', id);
                    });
                    
                    // Get the user avatar
                    Avatar.get(from, 'cache', 'true', 'forget');
                }
            }
            
            // We tell the user he has a new pending notification
            self.check();
            
            Console.info('New notification: ' + from);
        } catch(e) {
            Console.error('Notification.new', e);
        }

    };


    /**
     * Performs an action on a given notification
     * @public
     * @param {string} type
     * @param {string} data
     * @param {string} value
     * @param {string} id
     * @return {boolean}
     */
    self.action = function(type, data, value, id) {

        try {
            // We launch a function depending of the type
            if((type == 'subscribe') && (value == 'yes'))
                Presence.acceptSubscribe(data[0], data[1]);
            
            else if((type == 'subscribe') && (value == 'no'))
                Presence.sendSubscribe(data[0], 'unsubscribed');
            
            else if((type == 'invite_room') && (value == 'yes'))
                Chat.checkCreate(data[0], 'groupchat');
            
            else if(type == 'request')
                HTTPReply.go(value, data[0]);
            
            if((type == 'send') && (value == 'yes'))
                OOB.reply(data[0], data[3], 'accept', data[2], data[4]);
            
            else if((type == 'send') && (value == 'no'))
                OOB.reply(data[0], data[3], 'reject', data[2], data[4]);
            
            else if((type == 'rosterx') && (value == 'yes'))
                RosterX.open(data[0]);
            
            else if((type == 'comment') || (type == 'like') || (type == 'quote') || (type == 'wall') || (type == 'photo') || (type == 'video')) {
                if(value == 'yes') {
                    // Get the microblog item
                    Microblog.fromInfos(data[2]);
                    
                    // Append the marker
                    $('#channel .top.individual').append('<input type="hidden" name="comments" value="' + Common.encodeQuotes(data[1]) + '" />');
                }
                
                self.remove(data[3]);
            }
            
            // We remove the notification
            $('.notifications-content .' + id).remove();
            
            // We check if there's any other pending notification
            self.closeEmpty();
            self.check();
        } catch(e) {
            Console.error('Notification.action', e);
        } finally {
            return false;
        }

    };


    /**
     * Clear the social notifications
     * @public
     * @return {undefined}
     */
    self.clear = function() {

        try {
            // Remove notifications
            $('.one-notification').remove();
            
            // Refresh
            self.closeEmpty();
            self.check();
        } catch(e) {
            Console.error('Notification.clear', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the pending social notifications
     * @public
     * @return {undefined}
     */
    self.get = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            pubsub.appendChild(iq.buildNode('items', {'node': NS_URN_INBOX, 'xmlns': NS_PUBSUB}));
            
            con.send(iq, self.handle);
            
            Console.log('Getting social notifications...');
        } catch(e) {
            Console.error('Notification.get', e);
        }

    };


    /**
     * Handles the social notifications
     * @public
     * @param {object} stanza
     * @return {undefined}
     */
    self.handle = function(stanza) {

        try {
            // Any error?
            if((stanza.getType() == 'error') && $(stanza.getNode()).find('item-not-found').size()) {
                // The node may not exist, create it!
                Pubsub.setup('', NS_URN_INBOX, '1', '1000000', 'whitelist', 'open', true);
                
                Console.warn('Error while getting social notifications, trying to reconfigure the Pubsub node!');
            }
            
            // Selector
            var items = $(stanza.getNode()).find('item');
            
            // Should we inverse?
            var inverse = true;
            
            if(items.size() == 1)
                inverse = false;
            
            // Parse notifications
            items.each(function() {
                // Parse the current item
                var current_item = $(this).attr('id');
                var current_type = $(this).find('link[rel="via"]:first').attr('title');
                var current_href = $(this).find('link[rel="via"]:first').attr('href');
                var current_parent_href = $(this).find('link[rel="related"]:first').attr('href');
                var current_xid = Common.explodeThis(':', $(this).find('author uri').text(), 1);
                var current_name = $(this).find('author name').text();
                var current_text = $(this).find('content[type="text"]:first').text();
                var current_bname = Name.getBuddy(current_xid);
                var current_id = hex_md5(current_type + current_xid + current_href + current_text);
                
                // Choose the good name!
                if(!current_name || (current_bname != Common.getXIDNick(current_xid)))
                    current_name = current_bname;
                
                // Create it!
                self.create(current_type, current_xid, [current_name, current_href, current_parent_href, current_item], current_text, current_id, inverse);
            });
            
            Console.info(items.size() + ' social notification(s) got!');
        } catch(e) {
            Console.error('Notification.handle', e);
        }

    };


    /**
     * Sends a social notification
     * @public
     * @param {string} xid
     * @param {string} type
     * @param {string} href
     * @param {string} text
     * @param {object} parent
     * @return {undefined}
     */
    self.send = function(xid, type, href, text, parent) {

        try {
            // Notification ID
            var id = hex_md5(xid + text + DateUtils.getTimeStamp());
            
            // IQ
            var iq = new JSJaCIQ();
            iq.setType('set');
            iq.setTo(xid);
            
            // ATOM content
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_URN_INBOX, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'id': id, 'xmlns': NS_PUBSUB}));
            var entry = item.appendChild(iq.buildNode('entry', {'xmlns': NS_ATOM}));
            
            // Notification author (us)
            var author = entry.appendChild(iq.buildNode('author', {'xmlns': NS_ATOM}));
            author.appendChild(iq.buildNode('name', {'xmlns': NS_ATOM}, Name.get()));
            author.appendChild(iq.buildNode('uri', {'xmlns': NS_ATOM}, 'xmpp:' + Common.getXID()));
            
            // Notification content
            entry.appendChild(iq.buildNode('published', {'xmlns': NS_ATOM}, DateUtils.getXMPPTime('utc')));
            entry.appendChild(iq.buildNode('content', {'type': 'text', 'xmlns': NS_ATOM}, text));
            entry.appendChild(iq.buildNode('link', {'rel': 'via', 'title': type, 'href': href, 'xmlns': NS_ATOM}));
            
            // Any parent item?
            if(parent && parent[0] && parent[1] && parent[2]) {
                // Generate the parent XMPP URI
                var parent_href = 'xmpp:' + parent[0] + '?;node=' + encodeURIComponent(parent[1]) + ';item=' + encodeURIComponent(parent[2]);
                
                entry.appendChild(iq.buildNode('link', {'rel': 'related', 'href': parent_href, 'xmlns': NS_ATOM}));
            }
            
            con.send(iq);
            
            Console.log('Sending a social notification to ' + xid + ' (type: ' + type + ')...');
        } catch(e) {
            Console.error('Notification.send', e);
        }

    };


    /**
     * Removes a social notification
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.remove = function(id) {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var retract = pubsub.appendChild(iq.buildNode('retract', {'node': NS_URN_INBOX, 'xmlns': NS_PUBSUB}));
            retract.appendChild(iq.buildNode('item', {'id': id, 'xmlns': NS_PUBSUB}));
            
            con.send(iq);
        } catch(e) {
            Console.error('Notification.remove', e);
        }

    };


    /**
     * Purge the social notifications
     * @public
     * @param {type} name
     * @return {boolean}
     */
    self.purge = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB_OWNER});
            pubsub.appendChild(iq.buildNode('purge', {'node': NS_URN_INBOX, 'xmlns': NS_PUBSUB_OWNER}));
            
            con.send(iq);
        } catch(e) {
            Console.error('Notification.purge', e);
        } finally {
            return false;
        }

    };


    /**
     * Adapt the notifications bubble max-height
     * @public
     * @return {undefined}
     */
    self.adapt = function() {

        try {
            // Process the new height
            var max_height = $('#right-content').height() - 22;
            
            // New height too small
            if(max_height < 250) {
                max_height = 250;
            }
            
            // Apply the new height
            $('.notifications-content .tools-content-subitem').css('max-height', max_height);
        } catch(e) {
            Console.error('Notification.adapt', e);
        }

    };


    /**
     * Plugin instance launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Adapt the notifications height
            self.adapt();
        } catch(e) {
            Console.error('Notification.instance', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            // Adapt the notifications height
            $(window).resize(self.adapt);
        } catch(e) {
            Console.error('Notification.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Notification.launch();
/*

Jappix - An open social platform
These are the http-reply JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var HTTPReply = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Replies to a HTTP request
     * @public
     * @param {string} value
     * @param {object} xml
     * @return {undefined}
     */
    self.go = function(value, xml) {

        try {
            // We parse the xml content
            var from = Common.fullXID(Common.getStanzaFrom(xml));
            var confirm = $(xml.getNode()).find('confirm');
            var xmlns = confirm.attr('xmlns');
            var id = confirm.attr('id');
            var method = confirm.attr('method');
            var url = confirm.attr('url');
            
            // We generate the reply message
            var aMsg = new JSJaCMessage();
            aMsg.setTo(from);
            
            // If "no"
            if(value == 'no') {
                aMsg.setType('error');
                aMsg.appendNode('error', {'code': '401', 'type': 'auth'});
            }
            
            // We set the confirm node
            aMsg.appendNode('confirm', {'xmlns': xmlns, 'url': url, 'id': id, 'method': method});
            
            // We send the message
            con.send(aMsg, Errors.handleReply);
            
            Console.info('Replying HTTP auth request: ' + from);
        } catch(e) {
            Console.error('HTTPReply.go', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the options JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var Options = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the options popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Edit options") + '</div>' + 
            
            '<div class="tab">' + 
                '<a href="#" class="tab-general tab-active" data-key="1">' + Common._e("General") + '</a>' + 
                '<a href="#" class="tab-channel pubsub-hidable pubsub-hidable-cn" data-key="2">' + Common._e("Channel") + '</a>' + 
                '<a href="#" class="tab-account" data-key="3">' + Common._e("Account") + '</a>' + 
            '</div>' + 
            
            '<div class="content">' + 
                '<div id="conf1" class="lap-active one-lap forms">' + 
                    '<fieldset class="privacy">' + 
                        '<legend>' + Common._e("Privacy") + '</legend>' + 
                        
                        '<div class="geolocation">' +
                            '<label for="geolocation" class="pep-hidable">' + Common._e("Geolocation") + '</label>' + 
                            '<input id="geolocation" type="checkbox" class="pep-hidable" />' + 
                        '</div>' +
                        
                        '<div class="archiving">' +
                            '<label for="archiving" class="mam-hidable">' + Common._e("Message archiving") + '</label>' + 
                            '<select id="archiving" class="mam-hidable">' + 
                                '<option value="never">' + Common._e("Disabled") + '</option>' + 
                                '<option value="roster">' + Common._e("Store friend chats") + '</option>' + 
                                '<option value="always">' + Common._e("Store all chats") + '</option>' + 
                            '</select>' + 
                            '<a href="#" class="linked empty-archives mam-purge-hidable">' + Common._e("Remove all archives") + '</a>' + 
                        '</div>' +
                    '</fieldset>' + 
                    
                    '<fieldset class="application">' + 
                        '<legend>' + Common._e("Application") + '</legend>' + 
                        
                        '<div class="sounds">' +
                            '<label for="sounds">' + Common._e("Sounds") + '</label>' + 
                            '<input id="sounds" type="checkbox" />' + 
                        '</div>' +
                        
                        '<div class="showall">' +
                            '<label for="showall">' + Common._e("Show all friends") + '</label>' + 
                            '<input id="showall" type="checkbox" />' + 
                        '</div>' +

                        '<div class="groupchatpresence">' +
                            '<label for="groupchatpresence">' + Common._e("Groupchat presence messages") + '</label>' + 
                            '<input id="groupchatpresence" type="checkbox" />' + 
                        '</div>' +
                        
                        '<div class="noxhtmlimg">' +
                            '<label for="noxhtmlimg">' + Common._e("No chat images auto-load") + '</label>' + 
                            '<input id="noxhtmlimg" type="checkbox" />' + 
                        '</div>' +
                        
                        '<div class="integratemedias">' +
                            '<label for="integratemedias">' + Common._e("Media integration") + '</label>' + 
                            '<input id="integratemedias" type="checkbox" />' + 
                        '</div>' +

                        '<div class="localarchives mam-showable">' +
                            '<label for="localarchives">' + Common._e("Keep local chat archives") + '</label>' + 
                            '<input id="localarchives" type="checkbox" />' + 
                        '</div>' +
                        
                        '<div class="xmpplinks">' +
                            '<label class="xmpplinks-hidable">' + Common._e("XMPP links") + '</label>' + 
                            '<a href="#" class="linked xmpp-links xmpplinks-hidable">' + Common._e("Open XMPP links with Jappix") + '</a>' + 
                        '</div>' +
                    '</fieldset>' + 

                    '<div class="sub-ask sub-ask-mam sub-ask-element">' + 
                        '<div class="sub-ask-top">' + 
                            '<div class="sub-ask-title">' + Common._e("Remove all archives") + '</div>' + 
                            '<a href="#" class="sub-ask-close">X</a>' + 
                        '</div>' + 
                        
                        '<div class="sub-ask-content">' + 
                            '<label>' + Common._e("Password") + '</label>' + 
                            '<input type="password" class="purge-archives check-mam" required="" />' + 
                        '</div>' + 
                        
                        '<a href="#" class="sub-ask-bottom">' + Common._e("Remove") + ' &raquo;</a>' + 
                    '</div>' + 
                '</div>' + 
                
                '<div id="conf2" class="one-lap forms">' + 
                    '<fieldset class="channel">' + 
                        '<legend>' + Common._e("Channel") + '</legend>' + 
                        
                        '<div class="empty-channel">' +
                            '<label>' + Common._e("Empty") + '</label>' + 
                            '<a href="#" class="linked empty-channel">' + Common._e("Empty channel") + '</a>' + 
                        '</div>' +
                        
                        '<div class="persistent">' +
                            '<label>' + Common._e("Persistent") + '</label>' + 
                            '<input id="persistent" type="checkbox" />' + 
                        '</div>' +
                        
                        '<div class="maxnotices">' +
                            '<label>' + Common._e("Maximum notices") + '</label>' + 
                            '<select id="maxnotices">' + 
                                '<option value="1">1</option>' + 
                                '<option value="100">100</option>' + 
                                '<option value="1000">1000</option>' + 
                                '<option value="10000">10000</option>' + 
                                '<option value="100000">100000</option>' + 
                                '<option value="1000000">1000000</option>' + 
                            '</select>' + 
                        '</div>' +

                    '</fieldset>' + 
                    
                    '<div class="sub-ask sub-ask-empty sub-ask-element">' + 
                        '<div class="sub-ask-top">' + 
                            '<div class="sub-ask-title">' + Common._e("Empty channel") + '</div>' + 
                            '<a href="#" class="sub-ask-close">X</a>' + 
                        '</div>' + 
                        
                        '<div class="sub-ask-content">' + 
                            '<label>' + Common._e("Password") + '</label>' + 
                            '<input type="password" class="purge-microblog check-empty" required="" />' + 
                        '</div>' + 
                        
                        '<a href="#" class="sub-ask-bottom">' + Common._e("Empty") + ' &raquo;</a>' + 
                    '</div>' + 
                '</div>' + 
                
                '<div id="conf3" class="one-lap forms">' + 
                    '<fieldset>' + 
                        '<legend>' + Common._e("Account") + '</legend>' + 
                        
                        '<label>' + Common._e("Password") + '</label>' + 
                        '<a href="#" class="linked change-password">' + Common._e("Change password") + '</a>' + 
                        
                        '<label>' + Common._e("Delete") + '</label>' + 
                        '<a href="#" class="linked delete-account">' + Common._e("Delete account") + '</a>' + 
                    '</fieldset>' + 
                        
                    '<div class="sub-ask sub-ask-pass sub-ask-element">' + 
                        '<div class="sub-ask-top">' + 
                            '<div class="sub-ask-title">' + Common._e("Change password") + '</div>' + 
                            '<a href="#" class="sub-ask-close">X</a>' + 
                        '</div>' + 
                        
                        '<div class="sub-ask-content">' + 
                            '<label>' + Common._e("Old") + '</label>' + 
                            '<input type="password" class="password-change old" required="" />' + 
                            
                            '<label>' + Common._e("New (2 times)") + '</label>' + 
                            '<input type="password" class="password-change new1" required="" />' + 
                            '<input type="password" class="password-change new2" required="" />' + 
                        '</div>' + 
                        
                        '<a href="#" class="sub-ask-bottom">' + Common._e("Continue") + ' &raquo;</a>' + 
                    '</div>' + 
                    
                    '<div class="sub-ask sub-ask-delete sub-ask-element">' + 
                        '<div class="sub-ask-top">' + 
                            '<div class="sub-ask-title">' + Common._e("Delete account") + '</div>' + 
                            '<a href="#" class="sub-ask-close">X</a>' + 
                        '</div>' + 
                        
                        '<div class="sub-ask-content">' + 
                            '<label>' + Common._e("Password") + '</label>' + 
                            '<input type="password" class="delete-account check-password" required="" />' + 
                        '</div>' + 
                        
                        '<a href="#" class="sub-ask-bottom">' + Common._e("Delete") + ' &raquo;</a>' + 
                    '</div>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish save">' + Common._e("Save") + '</a>' + 
                '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('options', html);
            
            // Apply the features
            Features.apply('options');
            
            // Associate the events
            self.instance();
        } catch(e) {
            Console.error('Options.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Closes the options popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('options');
        } catch(e) {
            Console.error('Options.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Checks whether the options are loaded or not
     * @public
     * @return {boolean}
     */
    self.loaded = function() {

        is_loaded = false;

        try {
            if($('.options-hidable').is(':visible')) {
                is_loaded = true;
            }
        } catch(e) {
            Console.error('Options.loaded', e);
        } finally {
            return is_loaded;
        }

    };


    /**
     * Switches between the options tabs
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.switchTab = function(id) {

        try {
            $('#options .one-lap').hide();
            $('#options #conf' + id).show();
            $('#options .tab a').removeClass('tab-active');
            $('#options .tab a[data-key="' + id + '"]').addClass('tab-active');
            $('#options .sub-ask .sub-ask-close').click();
        } catch(e) {
            Console.error('Options.switchTab', e);
        } finally {
            return false;
        }

    };


    /**
     * Manages the options wait item
     * @public
     * @param {string} id
     * @return {undefined}
     */
    self.wait = function(id) {

        try {
            var sOptions = $('#options .content');
            
            // Remove the current item class
            sOptions.removeClass(id);
            
            // Hide the waiting items if all was received
            if(!sOptions.hasClass('microblog') && !sOptions.hasClass('mam')) {
                $('#options .wait').hide();
                $('#options .finish:first').removeClass('disabled');
            }
        } catch(e) {
            Console.error('Options.wait', e);
        }

    };


    /**
     * Sends the options to the XMPP server
     * @public
     * @return {undefined}
     */
    self.store = function() {

        try {
            // Get the values
            var sounds = DataStore.getDB(Connection.desktop_hash, 'options', 'sounds');
            var geolocation = DataStore.getDB(Connection.desktop_hash, 'options', 'geolocation');
            var showall = DataStore.getDB(Connection.desktop_hash, 'options', 'roster-showall');
            var noxhtmlimg = DataStore.getDB(Connection.desktop_hash, 'options', 'no-xhtml-images');
            var groupchatpresence = DataStore.getDB(Connection.desktop_hash, 'options', 'groupchatpresence');
            var integratemedias = DataStore.getDB(Connection.desktop_hash, 'options', 'integratemedias');
            var localarchives = DataStore.getDB(Connection.desktop_hash, 'options', 'localarchives');
            var status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
            
            // Create an array to be looped
            var oType = ['sounds', 'geolocation', 'roster-showall', 'no-xhtml-images', 'groupchatpresence', 'integratemedias', 'localarchives', 'presence-status'];
            var oContent = [sounds, geolocation, showall, noxhtmlimg, groupchatpresence, integratemedias, localarchives, status];
            
            // New IQ
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var query = iq.setQuery(NS_PRIVATE);
            var storage = query.appendChild(iq.buildNode('storage', {'xmlns': NS_OPTIONS}));
            
            // Loop the array
            for(var i in oType) {
                storage.appendChild(iq.buildNode('option', {'type': oType[i], 'xmlns': NS_OPTIONS}, oContent[i]));
            }
            
            con.send(iq, self.handleStore);
            
            Console.info('Storing options...');
        } catch(e) {
            Console.error('Options.store', e);
        }

    };


    /**
     * Handles the option storing
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleStore = function(iq) {

        try {
            if(!iq || (iq.getType() != 'result')) {
                Console.warn('Options not stored.');
            } else {
                Console.info('Options stored.');
            }
        } catch(e) {
            Console.error('Options.handleStore', e);
        }

    };


    /**
     * Saves the user options
     * @public
     * @return {boolean}
     */
    self.save = function() {

        try {
            // We apply the sounds
            var sounds = '0';
            
            if($('#sounds').filter(':checked').size()) {
                sounds = '1';
            }
            
            DataStore.setDB(Connection.desktop_hash, 'options', 'sounds', sounds);
            
            // We apply the geolocation
            if($('#geolocation').filter(':checked').size()) {
                DataStore.setDB(Connection.desktop_hash, 'options', 'geolocation', '1');
                
                // We geolocate the user on the go
                PEP.geolocate();
            } else {
                DataStore.setDB(Connection.desktop_hash, 'options', 'geolocation', '0');
                
                // We delete the geolocation informations
                PEP.sendPosition();
                DataStore.removeDB(Connection.desktop_hash, 'geolocation', 'now');
            }
            
            // We apply the roster show all
            if($('#showall').filter(':checked').size()) {
                DataStore.setDB(Connection.desktop_hash, 'options', 'roster-showall', '1');
                Interface.showAllBuddies('options');
            } else {
                DataStore.setDB(Connection.desktop_hash, 'options', 'roster-showall', '0');
                Interface.showOnlineBuddies('options');
            }
            
            // We apply the XHTML-IM images filter
            var noxhtmlimg = '1' ? $('#noxhtmlimg').filter(':checked').size() : '0';
            DataStore.setDB(Connection.desktop_hash, 'options', 'no-xhtml-images', noxhtmlimg);
            
            // We apply the groupchat presence messages configuration
            var groupchatpresence = '1' ? $('#groupchatpresence').filter(':checked').size() : '0';
            DataStore.setDB(Connection.desktop_hash, 'options', 'groupchatpresence', groupchatpresence);

            // We apply the media integration
            var integratemedias = '1' ? $('#integratemedias').filter(':checked').size() : '0';
            DataStore.setDB(Connection.desktop_hash, 'options', 'integratemedias', integratemedias);

            // We apply the local archiving
            var localarchives = '1' ? $('#localarchives').filter(':checked').size() : '0';
            DataStore.setDB(Connection.desktop_hash, 'options', 'localarchives', localarchives);

            // Flush local archives?
            if(localarchives === '0') {
                Message.flushLocalArchive();
            }
            
            // We apply the message archiving
            if(Features.enabledMAM()) {
                MAM.setConfig($('#archiving').val() || 'never');
            }
            
            // We apply the microblog configuration
            var persist = '1' ? $('#persist').filter(':checked').size() : '0';
            var maximum = $('#maxnotices').val();
            
            if(Features.enabledPEP() && (Features.enabledPubSub() || Features.enabledPubSubCN())) {
                Pubsub.setup('', NS_URN_MBLOG, persist, maximum, '', '', false);
            }
            
            // We send the options to the database
            self.store();
            
            // Close the options
            self.close();
        } catch(e) {
            Console.error('Options.save', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the password changing
     * @public
     * @param {string} iq
     * @return {undefined}
     */
    self.handlePwdChange = function(iq) {

        try {
            // Remove the general wait item
            Interface.removeGeneralWait();
            
            // If no errors
            if(!Errors.handleReply(iq)) {
                Connection.clearLastSession();
                Connection.quit();
                Board.openThisInfo(1);
                
                Console.info('Password changed.');
            } else {
                Console.warn('Password not changed.');
            }
        } catch(e) {
            Console.error('Options.handlePwdChange', e);
        }

    };


    /**
     * Sends the new account password
     * @public
     * @return {boolean}
     */
    self.sendNewPassword = function() {

        /* REF: http://xmpp.org/extensions/xep-0077.html#usecases-changepw */

        try {
            var password0 = $('#options .old').val();
            var password1 = $('#options .new1').val();
            var password2 = $('#options .new2').val();
            
            if ((password1 == password2) && (password0 == Utils.getPassword())) {
                // We show the waiting image
                Interface.showGeneralWait();
                
                // We send the IQ
                var iq = new JSJaCIQ();
                
                iq.setTo(Utils.getServer());
                iq.setType('set');
                
                var iqQuery = iq.setQuery(NS_REGISTER);
                
                iqQuery.appendChild(iq.buildNode('username', {'xmlns': NS_REGISTER}, con.username));
                iqQuery.appendChild(iq.buildNode('password', {'xmlns': NS_REGISTER}, password1));
                
                con.send(iq, self.handlePwdChange);
                
                Console.info('Password change sent.');
            } else {
                $('.sub-ask-pass input').each(function() {
                    var select = $(this);
                    
                    if(!select.val())
                        $(document).oneTime(10, function() {
                            select.addClass('please-complete').focus();
                        });
                    else
                        select.removeClass('please-complete');  
                });
                
                if(password0 != Utils.getPassword())
                    $(document).oneTime(10, function() {
                        $('#options .old').addClass('please-complete').focus();
                    });
                if(password1 != password2)
                    $(document).oneTime(10, function() {
                        $('#options .new1, #options .new2').addClass('please-complete').focus();
                    });
            }
        } catch(e) {
            Console.error('Options.sendNewPassword', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the account deletion request
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleAccDeletion = function(iq) {

        try {
            // Remove the general wait item
            Interface.removeGeneralWait();
            
            // If no errors
            if(!Errors.handleReply(iq)) {
                Connection.clearLastSession();
                Talk.destroy();
                Board.openThisInfo(2);
                Connection.logout();
                
                Console.info('Account deleted.');
            } else {
                Console.warn('Account not deleted.');
            }
        } catch(e) {
            Console.error('Options.handleAccDeletion', e);
        }

    };


    /**
     * Purge the user's archives (MAM)
     * @public
     * @return {boolean}
     */
    self.purgeMyArchives = function() {

        try {
            var pwd_input_sel = $('#options .check-mam');
            var password = pwd_input_sel.val();
            
            if(password == Utils.getPassword()) {
                MAM.purgeArchives();

                // Clear archives in UI
                $('.page-engine-chan[data-type="chat"] .tools-clear').click();

                // Hide the tool
                pwd_input_sel.val('');
                $('#options .sub-ask-mam .sub-ask-close').click();
            } else {
                var selector = $('#options .check-mam');
                
                if(password != Utils.getPassword())
                    $(document).oneTime(10, function() {
                        selector.addClass('please-complete').focus();
                    });
                else
                    selector.removeClass('please-complete');
            }
        } catch(e) {
            Console.error('Options.purgeMyArchives', e);
        } finally {
            return false;
        }

    };


    /**
     * Purge the user's microblog items
     * @public
     * @return {boolean}
     */
    self.purgeMyMicroblog = function() {

        /* REF: http://xmpp.org/extensions/xep-0060.html#owner-purge */

        try {
            var pwd_input_sel = $('#options .check-empty');
            var password = pwd_input_sel.val();
            
            if(password == Utils.getPassword()) {
                // Send the IQ to remove the item (and get eventual error callback)
                var iq = new JSJaCIQ();
                iq.setType('set');
                
                var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB_OWNER});
                pubsub.appendChild(iq.buildNode('purge', {'node': NS_URN_MBLOG, 'xmlns': NS_PUBSUB_OWNER}));
                
                con.send(iq, self.handleMicroblogPurge);
                
                // Hide the tool
                pwd_input_sel.val('');
                $('#options .sub-ask-empty .sub-ask-close').click();
                
                Console.info('Microblog purge sent.');
            } else {
                var selector = $('#options .check-empty');
                
                if(password != Utils.getPassword())
                    $(document).oneTime(10, function() {
                        selector.addClass('please-complete').focus();
                    });
                else
                    selector.removeClass('please-complete');
            }
        } catch(e) {
            Console.error('Options.purgeMyMicroblog', e);
        } finally {
            return false;
        }

    };


    /**
     * Handles the microblog purge
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleMicroblogPurge = function(iq) {

        try {
            // If no errors
            if(!Errors.handleReply(iq)) {
                // Remove the microblog items
                $('.one-update.update_' + hex_md5(Common.getXID())).remove();
                
                Console.info('Microblog purged.');
            } else {
                Console.warn('Microblog not purged.');
            }
        } catch(e) {
            Console.error('Options.handleMicroblogPurge', e);
        }

    };


    /**
     * Deletes the user's account
     * @public
     * @return {boolean}
     */
    self.deleteMyAccount = function() {

        /* REF: http://xmpp.org/extensions/xep-0077.html#usecases-cancel */

        try {
            var password = $('#options .check-password').val();
            
            if(password == Utils.getPassword()) {
                // We show the waiting image
                Interface.showGeneralWait();
                
                // We send the IQ
                var iq = new JSJaCIQ();
                iq.setType('set');
                
                var iqQuery = iq.setQuery(NS_REGISTER);
                iqQuery.appendChild(iq.buildNode('remove', {'xmlns': NS_REGISTER}));
                
                con.send(iq, self.handleAccDeletion);
                
                Console.info('Delete account sent.');
            }
            
            else {
                var selector = $('#options .check-password');
                
                if(password != Utils.getPassword())
                    $(document).oneTime(10, function() {
                        selector.addClass('please-complete').focus();
                    });
                else
                    selector.removeClass('please-complete');
            }
        } catch(e) {
            Console.error('Options.deleteMyAccount', e);
        } finally {
            return false;
        }

    };


    /**
     * Loads the user options
     * @public
     * @return {undefined}
     */
    self.load = function() {

        try {
            // Process the good stuffs, depending of the server features
            var enabled_mam = Features.enabledMAM();
            var enabled_pubsub = Features.enabledPubSub();
            var enabled_pubsub_cn = Features.enabledPubSubCN();
            var enabled_pep = Features.enabledPEP();
            var sWait = $('#options .content');
            
            // Show the waiting items if necessary
            if(enabled_mam || (enabled_pep && (enabled_pubsub || enabled_pubsub_cn))) {
                $('#options .wait').show();
                $('#options .finish:first').addClass('disabled');
            }
            
            // We get the archiving configuration
            if(enabled_mam) {
                sWait.addClass('mam');
                MAM.getConfig();
            }
            
            // We get the microblog configuration
            if((enabled_pubsub || enabled_pubsub_cn) && enabled_pep) {
                sWait.addClass('microblog');
                Microblog.getConfig();
            }
            
            // We show the "privacy" form if something is visible into it
            if(enabled_mam || enabled_pep)
                $('#options fieldset.privacy').show();
            
            // We get the values of the forms for the sounds
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'sounds') == '0')
                $('#sounds').attr('checked', false);
            else
                $('#sounds').attr('checked', true);
            
            // We get the values of the forms for the geolocation
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'geolocation') == '1')
                $('#geolocation').attr('checked', true);
            else
                $('#geolocation').attr('checked', false);
            
            // We get the values of the forms for the roster show all
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'roster-showall') == '1')
                $('#showall').attr('checked', true);
            else
                $('#showall').attr('checked', false);
                
            // We get the values of the forms for the XHTML-IM images filter
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'no-xhtml-images') == '1')
                $('#noxhtmlimg').attr('checked', true);
            else
                $('#noxhtmlimg').attr('checked', false);
            
            // We get the values of the forms for the integratemedias
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'integratemedias') == '0')
                $('#integratemedias').attr('checked', false);
            else
                $('#integratemedias').attr('checked', true);

            // We get the values of the forms for the groupchatpresence
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'groupchatpresence') == '0')
                $('#groupchatpresence').attr('checked', false);
            else
                $('#groupchatpresence').attr('checked', true);

            // We get the values of the forms for the localarchives
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'localarchives') == '0')
                $('#localarchives').attr('checked', false);
            else
                $('#localarchives').attr('checked', true);
        } catch(e) {
            Console.error('Options.load', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#options .tab a').click(function() {
                // Yet active?
                if($(this).hasClass('tab-active'))
                    return false;
                
                // Switch to the good tab
                var key = parseInt($(this).attr('data-key'));
                
                return self.switchTab(key);
            });
            
            $('#options .linked').click(function() {
                $('#options .sub-ask').hide();
                $('#options .forms').removeClass('in_background');
            });
            
            $('#options .xmpp-links').click(function() {
                Utils.xmppLinksHandler();
                
                return false;
            });

            $('#options .empty-archives').click(function() {
                var selector = '#options .sub-ask-mam';
                
                $(selector).show();
                $('#options .forms').addClass('in_background');
                
                $(document).oneTime(10, function() {
                    $(selector + ' input').focus();
                });
                
                return false;
            });
            
            $('#options .empty-channel').click(function() {
                var selector = '#options .sub-ask-empty';
                
                $(selector).show();
                $('#options .forms').addClass('in_background');
                
                $(document).oneTime(10, function() {
                    $(selector + ' input').focus();
                });
                
                return false;
            });
            
            $('#options .change-password').click(function() {
                var selector = '#options .sub-ask-pass';
                
                $(selector).show();
                $('#options .forms').addClass('in_background');
                
                $(document).oneTime(10, function() {
                    $(selector + ' input:first').focus();
                });
                
                return false;
            });
            
            $('#options .delete-account').click(function() {
                var selector = '#options .sub-ask-delete';
                
                $(selector).show();
                $('#options .forms').addClass('in_background');
                
                $(document).oneTime(10, function() {
                    $(selector + ' input').focus();
                });
                
                return false;
            });
            
            $('#options .sub-ask-pass .sub-ask-bottom').click(function() {
                return self.sendNewPassword();
            });
            
            $('#options .sub-ask-mam .sub-ask-bottom').click(function() {
                return self.purgeMyArchives();
            });

            $('#options .sub-ask-empty .sub-ask-bottom').click(function() {
                return self.purgeMyMicroblog();
            });
            
            $('#options .sub-ask-delete .sub-ask-bottom').click(function() {
                return self.deleteMyAccount();
            });
            
            $('#options .sub-ask-close').click(function() {
                $('#options .sub-ask').hide();
                $('#options .forms').removeClass('in_background');
                
                return false;
            });
            
            $('#options .bottom .finish').click(function() {
                if($(this).is('.save') && !$(this).hasClass('disabled'))
                    return self.save();
                if($(this).is('.cancel'))
                    return self.close();
                
                return false;
            });
            
            // The keyup events
            $('#options .sub-ask input').keyup(function(e) {
                if(e.keyCode == 13) {
                    // Archives purge
                    if($(this).is('.purge-archives'))
                        return self.purgeMyArchives();

                    // Microblog purge
                    else if($(this).is('.purge-microblog'))
                        return self.purgeMyMicroblog();
                    
                    // Password change
                    else if($(this).is('.password-change'))
                        return self.sendNewPassword();
                    
                    // Account deletion
                    else if($(this).is('.delete-account'))
                        return self.deleteMyAccount();
                }
            });
            
            // Load the options
            self.load();
        } catch(e) {
            Console.error('Options.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the integratebox JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var IntegrateBox = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the integratebox popup
     * @public
     * @return {undefined}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Media viewer") + '</div>' + 
            
            '<div class="content"></div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish close">' + Common._e("Close") + '</a>' + 
                '<a href="#" class="finish next disabled" title="' + Common._e("Next") + '">&gt;</a>' + 
                '<a href="#" class="finish previous disabled" title="' + Common._e("Previous") + '">&lt;</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('integratebox', html);
            
            // Associate the events
            self.instance();
        } catch(e) {
            Console.error('IntegrateBox.open', e);
        }

    };


    /**
     * Closes the integratebox popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('integratebox');
        } catch(e) {
            Console.error('IntegrateBox.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Generates the integratebox HTML code
     * @public
     * @param {string} serv
     * @param {string} url
     * @return {string}
     */
    self.code = function(serv, url) {

        try {
            var code = '';
            
            // Protocol to use
            var protocol = Utils.isHTTPS() ? 'https' : 'http';
            
            // Legacy browser
            var legacy = false;
            
            if((BrowserDetect.browser == 'Explorer') && (BrowserDetect.version < 9)) {
                legacy = true;
            }
            
            // Switch to get the good DOM code
            switch(serv) {
                case 'youtube':
                    if(legacy) {
                        code = '<object width="640" height="385"><param name="movie" value="http://www.youtube.com/v/' + url + '&amp;autoplay=1"></param><embed src="http://www.youtube.com/v/' + Common.encodeQuotes(url) + '&amp;autoplay=1" type="application/x-shockwave-flash" width="640" height="385"></embed></object>';
                    } else {
                        code = '<object width="640" height="385" data="' + Common.encodeQuotes(protocol) + '://www.youtube.com/embed/' + Common.encodeQuotes(url) + '?autoplay=1" type="text/html"><a href="http://www.youtube.com/watch?v=' + Common.encodeQuotes(url) + '" target="_blank">http://www.youtube.com/watch?v=' + Common.encodeQuotes(url) + '</a></object>';
                    }
                    
                    break;
                
                case 'dailymotion':
                    code = '<object width="640" height="385"><param name="movie" value="http://www.dailymotion.com/swf/video/' + url + '&amp;autoplay=1"></param><param name="allowFullScreen" value="false"></param><embed type="application/x-shockwave-flash" src="http://www.dailymotion.com/swf/video/' + Common.encodeQuotes(url) + '&amp;autoplay=1" width="640" height="385" allowfullscreen="true" allowscriptaccess="always"></embed></object>';
                    
                    break;
                
                case 'vimeo':
                    code = '<object width="640" height="385"><param name="allowfullscreen" value="true" /><param name="movie" value="http://vimeo.com/moogaloop.swf?clip_id=' + Common.encodeQuotes(url) + '&amp;server=vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=&amp;fullscreen=1&amp;autoplay=1" /><embed src="http://vimeo.com/moogaloop.swf?clip_id=' + Common.encodeQuotes(url) + '&amp;server=vimeo.com&amp;show_title=1&amp;show_byline=1&amp;show_portrait=0&amp;color=&amp;fullscreen=1&amp;autoplay=1" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" width="640" height="385"></embed></object>';
                    
                    break;
                
                case 'theora':
                case 'video':
                    code = '<video width="640" height="385" src="' + Common.encodeQuotes(url) + '" controls autoplay><a href="' + Common.encodeQuotes(url) + '" target="_blank">' + Common.encodeQuotes(url) + '</a></video>';
                    
                    break;
                
                case 'vorbis':
                case 'audio':
                    code = '<audio src="' + Common.encodeQuotes(url) + '" controls autoplay><a href="' + Common.encodeQuotes(url) + '" target="_blank">' + Common.encodeQuotes(url) + '</a></audio>';
                    
                    break;
                
                case 'image':
                    code = '<a href="' + Common.encodeQuotes(url) + '" target="_blank"><img alt="" src="' + Common.encodeQuotes(url) + '" /></a>';
                
                    break;
            }
            
            return code;
        } catch(e) {
            Console.error('IntegrateBox.code', e);
        }

    };


    /**
     * Applies a given integratebox element
     * @public
     * @param {string} url
     * @param {string} service
     * @param {string} url_list
     * @param {string} services_list
     * @param {string} comments_e_list
     * @param {string} comments_n_list
     * @param {string} width_style
     * @return {boolean}
     */
    self.apply = function(url, service, url_list, services_list, comments_e_list, comments_n_list, width_style) {

        try {
            // Close the integratebox
            self.close();
            
            // Media integration not wanted?
            if(DataStore.getDB(Connection.desktop_hash, 'options', 'integratemedias') == '0')
                return true;
            
            // Apply the HTML code
            var dom_code = self.code(service, url);
            
            // Any code: apply it!
            if(dom_code) {
                // We show the integratebox
                self.open();
                
                // We add the code to the DOM
                $('#integratebox .content').prepend('<div class="one-media">' + dom_code + '</div>');
                
                // Image waiting icon
                if(service == 'image') {
                    var waitItem = $('#integratebox .wait');
                    
                    // Show it while it is loading
                    waitItem.show();
                    
                    // Hide it when it is loaded
                    $('#integratebox img').load(function() {
                        waitItem.hide();
                        
                        // Center the image vertically
                        $(this).oneTime(10, function() {
                            $(this).css('margin-top', (($('#integratebox .content').height() - $(this).height()) / 2));
                        });
                    });
                }
                
                // Large style?
                var comments_id = genID();
                
                if(width_style == 'large') {
                    // Make the popup large
                    $('#integratebox .popup').addClass('large');
                    
                    // Add the right content
                    $('#integratebox .content').after(
                        '<div class="comments" data-id="' + Common.encodeQuotes(comments_id) + '">' + 
                            '<div class="comments-content">' + 
                                '<div class="one-comment loading"><span class="icon talk-images"></span>' + Common._e("Loading comments...") + '</div>' + 
                            '</div>' + 
                        '</div>'
                    );
                }
                
                // Previous and next items?
                var url_array = Utils.stringToArray(url_list);
                var services_array = Utils.stringToArray(services_list);
                var comments_e_array = Utils.stringToArray(comments_e_list);
                var comments_n_array = Utils.stringToArray(comments_n_list);
                var index = Utils.indexArrayValue(url_array, url);
                
                // Any comments?
                if(Common.exists('#integratebox .comments')) {
                    if(comments_e_array[index] && comments_n_array[index]) {
                        Microblog.getComments(comments_e_array[index], comments_n_array[index], comments_id);
                    } else {
                        $('#integratebox .comments .comments-content').html('<div class="one-comment loading"><span class="icon talk-images"></span>' + Common._e("Comments locked!") + '</div>');
                    }
                }
                
                // Get the previous values
                var previous_url = url_array[index - 1];
                var previous_services = services_array[index - 1];
                
                // Get the next values
                var next_url = url_array[index + 1];
                var next_services = services_array[index + 1];
                
                // Enable/disable buttons
                if(previous_url && previous_services) {
                    $('#integratebox .bottom .finish.previous').removeClass('disabled');
                } else {
                    $('#integratebox .bottom .finish.previous').addClass('disabled');
                }
                
                if(next_url && next_services) {
                    $('#integratebox .bottom .finish.next').removeClass('disabled');
                } else {
                    $('#integratebox .bottom .finish.next').addClass('disabled');
                }
                
                // Click events
                $('#integratebox .bottom .finish.previous, #integratebox .bottom .finish.next').click(function() {
                    // Not acceptable?
                    if($(this).is('.disabled')) {
                        return false;
                    }
                    
                    // Apply the event!
                    if($(this).is('.previous')) {
                        self.apply(previous_url, previous_services, url_list, services_list, comments_e_list, comments_n_list, width_style);
                    } else {
                        self.apply(next_url, next_services, url_list, services_list, comments_e_list, comments_n_list, width_style);
                    }
                    
                    return false;
                });
                
                if(width_style == 'large')
                    $('#integratebox .content a:has(img)').click(function() {
                        if(next_url && next_services) {
                            self.apply(next_url, next_services, url_list, services_list, comments_e_list, comments_n_list, width_style);
                        }
                        
                        return false;
                    });
                
                return false;
            }
            
            // Nothing: return true to be able to open the URL in a new tab
            return true;
        } catch(e) {
            Console.error('IntegrateBox.apply', e);
        }

    };


    /**
     * Checks whether the file ext can use integratebox or not
     * @public
     * @param {string} ext
     * @return {boolean}
     */
    self.can = function(ext) {

        can_use = false;

        try {
            // Can use?
            if(ext && ((ext == 'jpg') || (ext == 'jpeg') || (ext == 'png') || (ext == 'gif') || (ext == 'ogg') || (ext == 'oga') || (ext == 'ogv'))) {
                can_use = true;
            }
        } catch(e) {
            Console.error('IntegrateBox.can', e);
        } finally {
            return can_use;
        }

    };


    /**
     * Filters a string to apply the integratebox links
     * @public
     * @param {string} data
     * @return {string}
     */
    self.filter = function(data) {

        try {
            // Encapsulates the string into two <div /> elements
            var xml = $('<div><div>' + data + '</div></div>').contents();
            
            // Loop the <a /> elements
            $(xml).find('a').each(function() {
                // Initialize this element
                var href = $(this).attr('href');
                var to, url, service, event;
                
                // XMPP ID
                if(href.match(/^xmpp:(.+)/i)) {
                    to = RegExp.$1;
                }
                
                // YouTube video box
                else if(href.match(/(\w{3,5})(:)(\S+)((\.youtube\.com\/watch(\?v|\?\S+v|\#\!v|\#\!\S+v)\=)|(youtu\.be\/))([^& ]+)((&amp;\S)|(&\S)|\s|$)/gim)) {
                    url = RegExp.$8;
                    service = 'youtube';
                }
                
                // Dailymotion video box
                else if(href.match(/(\w{3,5})(:)(\S+)\.dailymotion\.com\/video\/([\w\-]+)((\#[\w\-]+)|\s|$)/gim)) {
                    url = RegExp.$4;
                    service = 'dailymotion';
                }
                
                // Vimeo video box
                else if(href.match(/((\w{3,5})(:)(\S+)(vimeo|www\.vimeo)\.com\/([\w\-]+))/gim)) {
                    url = RegExp.$6;
                    service = 'vimeo';
                }
                
                // Theora video box
                else if(href.match(/((\w{3,5})(:)(\S+)(\.)(ogv|ogg))/gim)) {
                    url = RegExp.$1;
                    service = 'theora';
                }
                
                // Vorbis audio box
                else if(href.match(/((\w{3,5})(:)(\S+)(\.oga))/gim)) {
                    url = RegExp.$1;
                    service = 'vorbis';
                }
                
                // Image box
                else if(href.match(/((\w{3,5})(:)(\S+)(\.)(jpg|jpeg|png|gif|tif|bmp))/gim)) {
                    url = RegExp.$1;
                    service = 'image';
                }
                
                // Define the good event
                if(to) {
                    event = 'XMPPLinks.go(\'' + Utils.encodeOnclick(to) + '\')';
                } else if(url && service) {
                    event = 'IntegrateBox.apply(\'' + Utils.encodeOnclick(url) + '\', \'' + Utils.encodeOnclick(service) + '\')';
                }
                
                // Any click event to apply?
                if(event) {
                    // Regenerate the link element (for onclick)
                    var new_a = '<a';
                    var element_a = (this);
                    
                    // Attributes
                    $(element_a.attributes).each(function(index) {
                        // Read the current attribute
                        var current_attr = element_a.attributes[index];
                        
                        // Apply the current attribute
                        new_a += ' ' + Common.encodeQuotes(current_attr.name) + '="' + Common.encodeQuotes(current_attr.value) + '"';
                    });
                    
                    // Add onclick attribute
                    new_a += ' onclick="return ' + event + ';"';
                    
                    // Value
                    new_a += '>' + $(this).html() + '</a>';
                    
                    // Replace it!
                    $(this).replaceWith(new_a);
                }
            });
            
            // Regenerate the HTML code (include string into a div to be readable)
            var string = $(xml).html();
            
            return string;
        } catch(e) {
            Console.error('IntegrateBox.filter', e);
        }

    };


    /**
     * Instance launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click event
            $('#integratebox .bottom .finish.close').click(self.close);
        } catch(e) {
            Console.error('IntegrateBox.instance', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            $(document).keyup(function(e) {
                // Previous item?
                if((Common.exists('#integratebox .bottom .finish.previous:not(.disabled)')) && (e.keyCode == 37)) {
                    $('#integratebox .bottom .finish.previous').click();
                    
                    return false;
                }
                
                // Next item?
                if((Common.exists('#integratebox .bottom .finish.next:not(.disabled)')) && (e.keyCode == 39)) {
                    $('#integratebox .bottom .finish.next').click();
                    
                    return false;
                }
            });
        } catch(e) {
            Console.error('IntegrateBox.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

IntegrateBox.launch();
/*

Jappix - An open social platform
These are the Pubsub JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Pubsub = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Setups a Pubsub node
     * @public
     * @param {string} entity
     * @param {object} node
     * @param {boolean} persist
     * @param {number} maximum
     * @param {string} access
     * @param {string} publish
     * @param {boolean} create
     * @return {undefined}
     */
    self.setup = function(entity, node, persist, maximum, access, publish, create) {

        /* REF: http://xmpp.org/extensions/xep-0060.html#owner-create-and-configure */

        try {
            // Create the PubSub node
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // Any external entity?
            if(entity) {
                iq.setTo(entity);
            }
            
            // Create it?
            var pubsub;

            if(create) {
                pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
                pubsub.appendChild(iq.buildNode('create', {'xmlns': NS_PUBSUB, 'node': node}));
            } else {
                pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB_OWNER});
            }
            
            // Configure it!
            var configure = pubsub.appendChild(iq.buildNode('configure', {'node': node, 'xmlns': NS_PUBSUB}));
            var x = configure.appendChild(iq.buildNode('x', {'xmlns': NS_XDATA, 'type': 'submit'}));
            
            var field1 = x.appendChild(iq.buildNode('field', {'var': 'FORM_TYPE', 'type': 'hidden', 'xmlns': NS_XDATA}));
            field1.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, NS_PUBSUB_NC));
            
            // Persist items?
            if(persist) {
                var field2 = x.appendChild(iq.buildNode('field', {'var': 'pubsub#persist_items', 'xmlns': NS_XDATA}));
                field2.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, persist));
            }
            
            // Maximum items?
            if(maximum) {
                var field3 = x.appendChild(iq.buildNode('field', {'var': 'pubsub#max_items', 'xmlns': NS_XDATA}));
                field3.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, maximum));
            }
            
            // Access rights?
            if(access) {
                var field4 = x.appendChild(iq.buildNode('field', {'var': 'pubsub#access_model', 'xmlns': NS_XDATA}));
                field4.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, access));
            }
            
            // Publish rights?
            if(publish) {
                var field5 = x.appendChild(iq.buildNode('field', {'var': 'pubsub#publish_model', 'xmlns': NS_XDATA}));
                field5.appendChild(iq.buildNode('value', {'xmlns': NS_XDATA}, publish));
            }
            
            con.send(iq);
        } catch(e) {
            Console.error('Pubsub.setup', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the PEP JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var PEP = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Stores the PEP items
     * @public
     * @param {string} xid
     * @param {string} type
     * @param {string} value1
     * @param {string} value2
     * @param {string} value3
     * @param {string} value4
     * @return {undefined}
     */
    self.store = function(xid, type, value1, value2, value3, value4) {

        try {
            // Handle the correct values
            if(!value1)
                value1 = '';
            if(!value2)
                value2 = '';
            if(!value3)
                value3 = '';
            if(!value4)
                value4 = '';
            
            // If one value
            if(value1 || value2 || value3 || value4) {
                // Define the XML variable
                var xml = '<pep type="' + type + '">';
                
                // Generate the correct XML
                if(type == 'tune')
                    xml += '<artist>' + value1.htmlEnc() + '</artist><title>' + value2.htmlEnc() + '</title><album>' + value3.htmlEnc() + '</album><uri>' + value4.htmlEnc() + '</uri>';
                else if(type == 'geoloc')
                    xml += '<lat>' + value1.htmlEnc() + '</lat><lon>' + value2.htmlEnc() + '</lon><human>' + value3.htmlEnc() + '</human>';
                else
                    xml += '<value>' + value1.htmlEnc() + '</value><text>' + value2.htmlEnc() + '</text>';
                
                // End the XML node
                xml += '</pep>';
                
                // Update the input with the new value
                DataStore.setDB(Connection.desktop_hash, 'pep-' + type, xid, xml);
            } else {
                DataStore.removeDB(Connection.desktop_hash, 'pep-' + type, xid);
            }
            
            // Display the PEP event
            self.display(xid, type);
        } catch(e) {
            Console.error('PEP.store', e);
        }

    };


    /**
     * Displays a PEP item
     * @public
     * @param {string} xid
     * @param {string} type
     * @return {undefined}
     */
    self.display = function(xid, type) {

        try {
            // Read the target input for values
            var value = $(Common.XMLFromString(DataStore.getDB(Connection.desktop_hash, 'pep-' + type, xid)));
            var aLink = '';
            
            // If the PEP element exists
            if(type) {
                // Get the user hash
                var hash = hex_md5(xid);
                
                // Initialize
                var fText, fValue;
                var dText = '';

                // Initialize typed valyes
                var tLat, tLon, tHuman, tReal;
                var fArtist, fTitle, fAlbum, fURI;
                var pepValue, pepText;
                
                // Parse the XML for mood and activity
                if((type == 'mood') || (type == 'activity')) {
                    if(value) {
                        pepValue = value.find('value').text();
                        pepText = value.find('text').text();
                        
                        // No value?
                        if(!pepValue)
                            pepValue = 'none';
                        
                        // Apply the good values
                        if(type == 'mood')
                            fValue = self.moodIcon(pepValue);
                        else if(type == 'activity')
                            fValue = self.activityIcon(pepValue);
                        if(!pepText)
                            fText = Common._e("unknown");
                        else
                            fText = pepText;
                    }
                    
                    else {
                        if(type == 'mood')
                            fValue = self.moodIcon('undefined');
                        else if(type == 'activity')
                            fValue = self.activityIcon('exercising');
                        
                        fText = Common._e("unknown");
                    }
                    
                    dText = fText;
                    fText = fText.htmlEnc();
                }
                
                else if(type == 'tune') {
                    fValue = 'tune-note';
                    
                    if(value) {
                        // Parse the tune XML
                        var tArtist = value.find('artist').text();
                        var tTitle = value.find('title').text();
                        var tAlbum = value.find('album').text();
                        var tURI = value.find('uri').text();
                        
                        // Apply the good values
                        if(!tArtist && !tAlbum && !tTitle) {
                            fText = Common._e("unknown");
                            dText = fText;
                        }
                        
                        else {
                            // URI element
                            if(!tURI)
                                fURI = 'http://grooveshark.com/search?q=' + encodeURIComponent(tArtist + ' ' + tTitle + ' ' + tAlbum);
                            else
                                fURI = tURI;
                            
                            // Artist element
                            if(!tArtist)
                                fArtist = Common._e("unknown");
                            else
                                fArtist = tArtist;
                            
                            // Title element
                            if(!tTitle)
                                fTitle = Common._e("unknown");
                            else
                                fTitle = tTitle;
                            
                            // Album element
                            if(!tAlbum)
                                fAlbum = Common._e("unknown");
                            else
                                fAlbum = tAlbum;
                            
                            // Generate the link to the title
                            aLink = ' href="' + fURI + '" target="_blank"';
                            
                            // Generate the text to be displayed
                            dText = fArtist + ' - ' + fTitle + ' (' + fAlbum + ')';
                            fText =  '<a' + aLink + '>' + dText + '</a>';
                        }
                    }
                    
                    else {
                        fText = Common._e("unknown");
                        dText = fText;
                    }
                }
                
                else if(type == 'geoloc') {
                    fValue = 'location-world';
                    
                    if(value) {
                        // Parse the geoloc XML
                        tLat = value.find('lat').text();
                        tLon = value.find('lon').text();
                        tHuman = value.find('human').text();
                        tReal = tHuman;
                        
                        // No human location?
                        if(!tHuman)
                            tHuman = Common._e("See his/her position on the globe");
                        
                        // Generate the text to be displayed
                        if(tLat && tLon) {
                            aLink = ' href="http://maps.google.com/?q=' + Common.encodeQuotes(tLat) + ',' + Common.encodeQuotes(tLon) + '" target="_blank"';
                            fText = '<a' + aLink + '>' + tHuman.htmlEnc() + '</a>';
                            
                            if(tReal)
                                dText = tReal;
                            else
                                dText = tLat + '; ' + tLon;
                        }
                        
                        else {
                            fText = Common._e("unknown");
                            dText = fText;
                        }
                    }
                    
                    else {
                        fText = Common._e("unknown");
                        dText = fText;
                    }
                }
                
                // Apply the text to the buddy infos
                var this_buddy = '#roster .buddy[data-xid="' + escape(xid) + '"]';
                
                if(Common.exists(this_buddy))
                    $(this_buddy + ' .bi-' + type).replaceWith('<p class="bi-' + type + ' talk-images ' + fValue + '" title="' + Common.encodeQuotes(dText) + '">' + fText + '</p>');
                
                // Apply the text to the buddy chat
                if(Common.exists('#' + hash)) {
                    // Selector
                    var bc_pep = $('#' + hash + ' .bc-pep');
                    
                    // We remove the old PEP item
                    bc_pep.find('a.bi-' + type).remove();
                    
                    // If the new PEP item is not null, create a new one
                    if(fText != Common._e("unknown"))
                        bc_pep.prepend(
                            '<a' + aLink + ' class="bi-' + type + ' talk-images ' + fValue + '" title="' + Common.encodeQuotes(dText) + '"></a>'
                        );
                    
                    // Process the new status position
                    Presence.adaptChat(hash);
                }
                
                // If this is the PEP values of the logged in user
                if(xid == Common.getXID()) {
                    // Change the icon/value of the target element
                    if((type == 'mood') || (type == 'activity')) {
                        // Change the input value
                        var dVal = '';
                        var dAttr = pepValue;
                        
                        // Must apply default values?
                        if(pepValue == 'none') {
                            if(type == 'mood')
                                dAttr = 'happy';
                            else
                                dAttr = 'exercising';
                        }
                        
                        // No text?
                        if(dText != Common._e("unknown"))
                            dVal = dText;
                        
                        // Store this user event in our database
                        DataStore.setDB(Connection.desktop_hash, type + '-value', 1, dAttr);
                        DataStore.setDB(Connection.desktop_hash, type + '-text', 1, dVal);
                        
                        // Apply this PEP event
                        $('#my-infos .f-' + type + ' a.picker').attr('data-value', dAttr);
                        $('#my-infos .f-' + type + ' input').val(dVal);
                        $('#my-infos .f-' + type + ' input').placeholder();
                    }
                    
                    else if((type == 'tune') || (type == 'geoloc')) {
                        // Reset the values
                        $('#my-infos .f-others a.' + type).remove();
                        
                        // Not empty?
                        if(dText != Common._e("unknown")) {
                            // Specific stuffs
                            var href, title, icon_class;
                            
                            if(type == 'tune') {
                                href = fURI;
                                title = dText;
                                icon_class = 'tune-note';
                            }
                            
                            else {
                                href = 'http://maps.google.com/?q=' + Common.encodeQuotes(tLat) + ',' + Common.encodeQuotes(tLon);
                                title = Common._e("Where are you?") + ' (' + dText + ')';
                                icon_class = 'location-world';
                            }
                            
                            // Must create the container?
                            if(!Common.exists('#my-infos .f-others'))
                                $('#my-infos .content').append('<div class="element f-others"></div>');
                            
                            // Create the element
                            $('#my-infos .f-others').prepend(
                                '<a class="icon ' + type + '" href="' + Common.encodeQuotes(href) + '" target="_blank" title="' + Common.encodeQuotes(title) +  '">' + 
                                    '<span class="talk-images ' + icon_class + '"></span>' + 
                                '</a>'
                            );
                        }
                        
                        // Empty?
                        else if(!Common.exists('#my-infos .f-others a.icon'))
                            $('#my-infos .f-others').remove();
                        
                        // Process the roster height again
                        Roster.adapt();
                    }
                }
            }
        } catch(e) {
            Console.error('PEP.display', e);
        }

    };


    /**
     * Changes the mood icon
     * @public
     * @param {string} value
     * @return {string}
     */
    self.moodIcon = function(value) {

        try {
            // The main var
            var icon;
            
            // Switch the values
            switch(value) {
                case 'angry':
                case 'cranky':
                case 'hot':
                case 'invincible':
                case 'mean':
                case 'restless':
                case 'serious':
                case 'strong':
                    icon = 'mood-one';
                    break;
                
                case 'contemplative':
                case 'happy':
                case 'playful':
                    icon = 'mood-two';
                    break;
                
                case 'aroused':
                case 'envious':
                case 'excited':
                case 'interested':
                case 'lucky':
                case 'proud':
                case 'relieved':
                case 'satisfied':
                case 'shy':
                    icon = 'mood-three';
                    break;
                
                case 'calm':
                case 'cautious':
                case 'contented':
                case 'creative':
                case 'humbled':
                case 'lonely':
                case 'undefined':
                case 'none':
                    icon = 'mood-four';
                    break;
                
                case 'afraid':
                case 'amazed':
                case 'confused':
                case 'dismayed':
                case 'hungry':
                case 'in_awe':
                case 'indignant':
                case 'jealous':
                case 'lost':
                case 'offended':
                case 'outraged':
                case 'shocked':
                case 'surprised':
                case 'embarrassed':
                case 'impressed':
                    icon = 'mood-five';
                    break;
                
                case 'crazy':
                case 'distracted':
                case 'neutral':
                case 'relaxed':
                case 'thirsty':
                    icon = 'mood-six';
                    break;
                
                case 'amorous':
                case 'curious':
                case 'in_love':
                case 'nervous':
                case 'sarcastic':
                    icon = 'mood-eight';
                    break;
                
                case 'brave':
                case 'confident':
                case 'hopeful':
                case 'grateful':
                case 'spontaneous':
                case 'thankful':
                    icon = 'mood-nine';
                    break;
                
                default:
                    icon = 'mood-seven';
                    break;
            }
            
            // Return the good icon name
            return icon;
        } catch(e) {
            Console.error('PEP.moodIcon', e);
        }

    };


    /**
     * Changes the activity icon
     * @public
     * @param {string} value
     * @return {string}
     */
    self.activityIcon = function(value) {

        try {
            // The main var
            var icon;
            
            // Switch the values
            switch(value) {
                case 'doing_chores':
                    icon = 'activity-doing_chores';
                    break;
                
                case 'drinking':
                    icon = 'activity-drinking';
                    break;
                
                case 'eating':
                    icon = 'activity-eating';
                    break;
                
                case 'grooming':
                    icon = 'activity-grooming';
                    break;
                
                case 'having_appointment':
                    icon = 'activity-having_appointment';
                    break;
                
                case 'inactive':
                    icon = 'activity-inactive';
                    break;
                
                case 'relaxing':
                    icon = 'activity-relaxing';
                    break;
                
                case 'talking':
                    icon = 'activity-talking';
                    break;
                
                case 'traveling':
                    icon = 'activity-traveling';
                    break;
                
                case 'working':
                    icon = 'activity-working';
                    break;
                default:
                    icon = 'activity-exercising';
                    break;
            }
            
            // Return the good icon name
            return icon;
        } catch(e) {
            Console.error('PEP.activityIcon', e);
        }

    };


    /**
     * Sends the user's mood
     * @public
     * @param {string} value
     * @param {string} text
     * @return {undefined}
     */
    self.sendMood = function(value, text) {

        /* REF: http://xmpp.org/extensions/xep-0107.html */

        try {
            // We propagate the mood on the xmpp network
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // We create the XML document
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_MOOD, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
            var mood = item.appendChild(iq.buildNode('mood', {'xmlns': NS_MOOD}));
            
            if(value != 'none') {
                mood.appendChild(iq.buildNode(value, {'xmlns': NS_MOOD}));
                mood.appendChild(iq.buildNode('text', {'xmlns': NS_MOOD}, text));
            }
            
            // And finally we send the mood that is set
            con.send(iq);
            
            Console.info('New mood sent: ' + value + ' (' + text + ')');
        } catch(e) {
            Console.error('PEP.sendMood', e);
        }

    };


    /**
     * Sends the user's activity
     * @public
     * @param {string} main
     * @param {string} sub
     * @param {string} text
     * @return {undefined}
     */
    self.sendActivity = function(main, sub, text) {

        try {
            // We propagate the mood on the xmpp network
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // We create the XML document
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_ACTIVITY, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
            var activity = item.appendChild(iq.buildNode('activity', {'xmlns': NS_ACTIVITY}));
            
            if(main != 'none') {
                var mainType = activity.appendChild(iq.buildNode(main, {'xmlns': NS_ACTIVITY}));
                
                // Child nodes
                if(sub)
                    mainType.appendChild(iq.buildNode(sub, {'xmlns': NS_ACTIVITY}));
                if(text)
                    activity.appendChild(iq.buildNode('text', {'xmlns': NS_ACTIVITY}, text));
            }
            
            // And finally we send the mood that is set
            con.send(iq);
            
            Console.info('New activity sent: ' + main + ' (' + text + ')');
        } catch(e) {
            Console.error('PEP.sendActivity', e);
        }

    };


    /**
     * Sends the user's geographic position
     * @public
     * @param {string} vLat
     * @param {string} vLon
     * @param {string} vAlt
     * @param {string} vCountry
     * @param {string} vCountrycode
     * @param {string} vRegion
     * @param {string} vPostalcode
     * @param {string} vLocality
     * @param {string} vStreet
     * @param {string} vBuilding
     * @param {string} vText
     * @param {string} vURI
     * @return {undefined}
     */
    self.sendPosition = function(vLat, vLon, vAlt, vCountry, vCountrycode, vRegion, vPostalcode, vLocality, vStreet, vBuilding, vText, vURI) {

        /* REF: http://xmpp.org/extensions/xep-0080.html */

        try {
            // We propagate the position on pubsub
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // We create the XML document
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var publish = pubsub.appendChild(iq.buildNode('publish', {'node': NS_GEOLOC, 'xmlns': NS_PUBSUB}));
            var item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
            var geoloc = item.appendChild(iq.buildNode('geoloc', {'xmlns': NS_GEOLOC}));
            
            // Create two position arrays
            var pos_names  = ['lat', 'lon', 'alt', 'country', 'countrycode', 'region', 'postalcode', 'locality', 'street', 'building', 'text', 'uri', 'timestamp'];
            var pos_values = [ vLat,  vLon,  vAlt,  vCountry,  vCountrycode,  vRegion,  vPostalcode,  vLocality,  vStreet,  vBuilding,  vText,  vURI,  DateUtils.getXMPPTime('utc')];
            
            for(var i = 0; i < pos_names.length; i++) {
                if(pos_names[i] && pos_values[i])
                    geoloc.appendChild(iq.buildNode(pos_names[i], {'xmlns': NS_GEOLOC}, pos_values[i]));
            }
            
            // And finally we send the XML
            con.send(iq);
            
            // For logger
            if(vLat && vLon) {
                Console.info('Geolocated.');
            } else {
                Console.warn('Not geolocated.');
            }
        } catch(e) {
            Console.error('PEP.sendPosition', e);
        }

    };


    /**
     * Parses the user's geographic position
     * @public
     * @param {string} data
     * @return {object}
     */
    self.parsePosition = function(data) {

        try {
            var result = $(data).find('result:first');
    
            // Get latitude and longitude
            var lat = result.find('geometry:first location:first lat').text();
            var lng = result.find('geometry:first location:first lng').text();
            
            var array = [
                         lat,
                         lng,
                         result.find('address_component:has(type:contains("country")):first long_name').text(),
                         result.find('address_component:has(type:contains("country")):first short_name').text(),
                         result.find('address_component:has(type:contains("administrative_area_level_1")):first long_name').text(),
                         result.find('address_component:has(type:contains("postal_code")):first long_name').text(),
                         result.find('address_component:has(type:contains("locality")):first long_name').text(),
                         result.find('address_component:has(type:contains("route")):first long_name').text(),
                         result.find('address_component:has(type:contains("street_number")):first long_name').text(),
                         result.find('formatted_address:first').text(),
                         'http://maps.google.com/?q=' + Common.encodeQuotes(lat) + ',' + Common.encodeQuotes(lng)
                        ];
            
            return array;
        } catch(e) {
            Console.error('PEP.parsePosition', e);
        }

    };


    /**
     * Converts a position into an human-readable one
     * @public
     * @param {string} tLocality
     * @param {string} tRegion
     * @param {string} tCountry
     * @return {string}
     */
    self.humanPosition = function(tLocality, tRegion, tCountry) {

        try {
            var tHuman = '';
            
            // Any locality?
            if(tLocality) {
                tHuman += tLocality;
                
                if(tRegion)
                    tHuman += ', ' + tRegion;
                if(tCountry)
                    tHuman += ', ' + tCountry;
            }
            
            // Any region?
            else if(tRegion) {
                tHuman += tRegion;
                
                if(tCountry)
                    tHuman += ', ' + tCountry;
            }
            
            // Any country?
            else if(tCountry)
                tHuman += tCountry;
            
            return tHuman;
        } catch(e) {
            Console.error('PEP.humanPosition', e);
        }

    };


    /**
     * Gets the user's geographic position
     * @public
     * @param {object} position
     * @return {undefined}
     */
    self.getPosition = function(position) {

        try {
            // Convert integers to strings
            var vLat = '' + position.coords.latitude;
            var vLon = '' + position.coords.longitude;
            var vAlt = '' + position.coords.altitude;
            
            // Get full position (from Google Maps API)
            $.get('./server/geolocation.php', {latitude: vLat, longitude: vLon, language: XML_LANG}, function(data) {
                // Parse data!
                var results = self.parsePosition(data);
                
                // Handled!
                self.sendPosition(
                             Utils.isNumber(vLat) ? vLat : null,
                             Utils.isNumber(vLon) ? vLon : null,
                             Utils.isNumber(vAlt) ? vAlt : null,
                             results[2],
                             results[3],
                             results[4],
                             results[5],
                             results[6],
                             results[7],
                             results[8],
                             results[9],
                             results[10]
                            );
                
                // Store data
                DataStore.setDB(Connection.desktop_hash, 'geolocation', 'now', Common.xmlToString(data));
                
                Console.log('Position details got from Google Maps API.');
            });
            
            Console.log('Position got: latitude > ' + vLat + ' / longitude > ' + vLon + ' / altitude > ' + vAlt);
        } catch(e) {
            Console.error('PEP.getPosition', e);
        }

    };


    /**
     * Geolocates the user
     * @public
     * @return {undefined}
     */
    self.geolocate = function() {

        try {
            // Don't fire it until options & features are not retrieved!
            if(!DataStore.getDB(Connection.desktop_hash, 'options', 'geolocation') || (DataStore.getDB(Connection.desktop_hash, 'options', 'geolocation') == '0') || !Features.enabledPEP()) {
                return;
            }
            
            // We publish the user location if allowed
            if(navigator.geolocation) {
                // Wait a bit... (to fix a bug)
                $('#my-infos').stopTime().oneTime('1s', function() {
                    navigator.geolocation.getCurrentPosition(self.getPosition);
                });
                
                Console.info('Geolocating...');
            } else {
                Console.error('Not geolocated: browser does not support it.');
            }
        } catch(e) {
            Console.error('PEP.geolocate', e);
        }

    };


    /**
     * Gets the user's geolocation to check it exists
     * @public
     * @return {undefined}
     */
    self.getInitGeoloc = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
            var ps_items = pubsub.appendChild(iq.buildNode('items', {'node': NS_GEOLOC, 'xmlns': NS_PUBSUB}));
            
            ps_items.setAttribute('max_items', '0');
            
            con.send(iq, self.handleInitGeoloc);
        } catch(e) {
            Console.error('PEP.getInitGeoloc', e);
        }

    };


    /**
     * Handles the user's geolocation to create note in case of error
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleInitGeoloc = function(iq) {

        try {
            // Any error?
            if((iq.getType() == 'error') && $(iq.getNode()).find('item-not-found').size()) {
                // The node may not exist, create it!
                Pubsub.setup('', NS_GEOLOC, '1', '1', '', '', true);
                
                Console.warn('Error while getting geoloc, trying to reconfigure the PubSub node!');
            }
        } catch(e) {
            Console.error('PEP.handleInitGeoloc', e);
        }

    };


    /**
     * Displays all the supported PEP events for a given XID
     * @public
     * @return {undefined}
     */
    self.displayAll = function() {

        try {
            self.display(xid, 'mood');
            self.display(xid, 'activity');
            self.display(xid, 'tune');
            self.display(xid, 'geoloc');
        } catch(e) {
            Console.error('PEP.displayAll', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Apply empty values to the PEP database
            DataStore.setDB(Connection.desktop_hash, 'mood-value', 1, '');
            DataStore.setDB(Connection.desktop_hash, 'mood-text', 1, '');
            DataStore.setDB(Connection.desktop_hash, 'activity-value', 1, '');
            DataStore.setDB(Connection.desktop_hash, 'activity-text', 1, '');
            
            // Click event for user mood
            $('#my-infos .f-mood a.picker').click(function() {
                // Initialize some vars
                var path = '#my-infos .f-mood div.bubble';
                var mood_id = ['crazy', 'excited', 'playful', 'happy', 'shocked', 'hot', 'sad', 'amorous', 'confident'];
                var mood_lang = [Common._e("Crazy"), Common._e("Excited"), Common._e("Playful"), Common._e("Happy"), Common._e("Shocked"), Common._e("Hot"), Common._e("Sad"), Common._e("Amorous"), Common._e("Confident")];
                var mood_val = $('#my-infos .f-mood a.picker').attr('data-value');
                
                // Yet displayed?
                var can_append = true;
                
                if(Common.exists(path))
                    can_append = false;
                
                // Add this bubble!
                Bubble.show(path);
                
                if(!can_append)
                    return false;
                
                // Generate the HTML code
                var html = '<div class="bubble removable">';
                
                for(var i in mood_id) {
                    // Yet in use: no need to display it!
                    if(mood_id[i] == mood_val)
                        continue;
                    
                    html += '<a href="#" class="talk-images" data-value="' + mood_id[i] + '" title="' + mood_lang[i] + '"></a>';
                }
                
                html += '</div>';
                
                // Append the HTML code
                $('#my-infos .f-mood').append(html);
                
                // Click event
                $(path + ' a').click(function() {
                    // Update the mood marker
                    $('#my-infos .f-mood a.picker').attr('data-value', $(this).attr('data-value'));
                    
                    // Close the bubble
                    Bubble.close();
                    
                    // Focus on the status input
                    $(document).oneTime(10, function() {
                        $('#mood-text').focus();
                    });
                    
                    return false;
                });
                
                return false;
            });
            
            // Click event for user activity
            $('#my-infos .f-activity a.picker').click(function() {
                // Initialize some vars
                var path = '#my-infos .f-activity div.bubble';
                var activity_id = ['doing_chores', 'drinking', 'eating', 'exercising', 'grooming', 'having_appointment', 'inactive', 'relaxing', 'talking', 'traveling', 'working'];
                var activity_lang = [Common._e("Chores"), Common._e("Drinking"), Common._e("Eating"), Common._e("Exercising"), Common._e("Grooming"), Common._e("Appointment"), Common._e("Inactive"), Common._e("Relaxing"), Common._e("Talking"), Common._e("Traveling"), Common._e("Working")];
                var activity_val = $('#my-infos .f-activity a.picker').attr('data-value');
                
                // Yet displayed?
                var can_append = true;
                
                if(Common.exists(path))
                    can_append = false;
                
                // Add this bubble!
                Bubble.show(path);
                
                if(!can_append)
                    return false;
                
                // Generate the HTML code
                var html = '<div class="bubble removable">';
                
                for(var i in activity_id) {
                    // Yet in use: no need to display it!
                    if(activity_id[i] == activity_val)
                        continue;
                    
                    html += '<a href="#" class="talk-images" data-value="' + activity_id[i] + '" title="' + activity_lang[i] + '"></a>';
                }
                
                html += '</div>';
                
                // Append the HTML code
                $('#my-infos .f-activity').append(html);
                
                // Click event
                $(path + ' a').click(function() {
                    // Update the activity marker
                    $('#my-infos .f-activity a.picker').attr('data-value', $(this).attr('data-value'));
                    
                    // Close the bubble
                    Bubble.close();
                    
                    // Focus on the status input
                    $(document).oneTime(10, function() {
                        $('#activity-text').focus();
                    });
                    
                    return false;
                });
                
                return false;
            });
            
            // Submit events for PEP inputs
            $('#mood-text, #activity-text').placeholder()
            
            .keyup(function(e) {
                if(e.keyCode == 13) {
                    $(this).blur();
                    
                    return false;
                }
            });
            
            // Input blur handler
            $('#mood-text').blur(function() {
                // Read the parameters
                var value = $('#my-infos .f-mood a.picker').attr('data-value');
                var text = $(this).val();
                
                // Must send the mood?
                if((value != DataStore.getDB(Connection.desktop_hash, 'mood-value', 1)) || (text != DataStore.getDB(Connection.desktop_hash, 'mood-text', 1))) {
                    // Update the local stored values
                    DataStore.setDB(Connection.desktop_hash, 'mood-value', 1, value);
                    DataStore.setDB(Connection.desktop_hash, 'mood-text', 1, text);
                    
                    // Send it!
                    self.sendMood(value, text);
                }
            })
            
            // Input focus handler
            .focus(function() {
                Bubble.close();
            });
            
            // Input blur handler
            $('#activity-text').blur(function() {
                // Read the parameters
                var value = $('#my-infos .f-activity a.picker').attr('data-value');
                var text = $(this).val();
                
                // Must send the activity?
                if((value != DataStore.getDB(Connection.desktop_hash, 'activity-value', 1)) || (text != DataStore.getDB(Connection.desktop_hash, 'activity-text', 1))) {
                    // Update the local stored values
                    DataStore.setDB(Connection.desktop_hash, 'activity-value', 1, value);
                    DataStore.setDB(Connection.desktop_hash, 'activity-text', 1, text);
                    
                    // Send it!
                    self.sendActivity(value, '', text);
                }
            })
            
            // Input focus handler
            .focus(function() {
                Bubble.close();
            });
        } catch(e) {
            Console.error('PEP.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the presence JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Presence = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.first_sent = false;
    self.auto_idle = false;


    /**
     * Sends the user first presence
     * @public
     * @param {string} checksum
     * @return {undefined}
     */
    self.sendFirst = function(checksum) {

        try {
            Console.info('First presence sent.');
            
            // Jappix is now ready: change the title
            Interface.title('talk');
            
            // Anonymous check
            var is_anonymous = Utils.isAnonymous();
            
            // Update our marker
            self.first_sent = true;
            
            // Try to use the last status message
            var status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
            
            if(!status)
                status = '';
            
            // We tell the world that we are online
            if(!is_anonymous)
                self.send('', '', '', status, checksum);
            
            // Any status to apply?
            if(status)
                $('#presence-status').val(status);
            
            // Enable the presence picker
            $('#presence-status').removeAttr('disabled');
            $('#my-infos .f-presence a.picker').removeClass('disabled');
            
            // We set the last activity stamp
            DateUtils.presence_last_activity = DateUtils.getTimeStamp();
            
            // We store our presence
            DataStore.setDB(Connection.desktop_hash, 'presence-show', 1, 'available');
            
            // Not anonymous
            if(!is_anonymous) {
                // We get the stored bookmarks (because of the photo hash and some other stuffs, we must get it later)
                Storage.get(NS_BOOKMARKS);
                
                // We open a new chat if a XMPP link was submitted
                if((parent.location.hash != '#OK') && XMPPLinks.links_var.x) {
                    // A link is submitted in the URL
                    XMPPLinks.go(XMPPLinks.links_var.x);
                    
                    // Set a OK status
                    parent.location.hash = 'OK';
                }
            }
        } catch(e) {
            Console.error('Presence.sendFirst', e);
        }

    };


    /**
     * Handles incoming presence packets
     * @public
     * @param {object} presence
     * @return {undefined}
     */
    self.handle = function(presence) {

        try {
            // We define everything needed here
            var from = Common.fullXID(Common.getStanzaFrom(presence));
            var hash = hex_md5(from);
            var node = presence.getNode();
            var xid = Common.bareXID(from);
            var xidHash = hex_md5(xid);
            var resource = Common.thisResource(from);
            var resources_obj, xml;
            
            // We get the type content
            var type = presence.getType();
            if(!type)
                type = '';
            
            // We get the priority content
            var priority = presence.getPriority() + '';
            if(!priority || (type == 'error'))
                priority = '0';
            
            // We get the show content
            var show = presence.getShow();
            if(!show || (type == 'error'))
                show = '';
            
            // We get the status content
            var status = presence.getStatus();
            if(!status || (type == 'error'))
                status = '';
            
            // We get the photo content
            var photo = $(node).find('x[xmlns="' + NS_VCARD_P + '"]:first photo');
            var checksum = photo.text();
            var hasPhoto = photo.size();
            
            if(hasPhoto && (type != 'error'))
                hasPhoto = 'true';
            else
                hasPhoto = 'false';
            
            // We get the CAPS content
            var caps = $(node).find('c[xmlns="' + NS_CAPS + '"]:first').attr('ver');
            if(!caps || (type == 'error'))
                caps = '';
            
            // This presence comes from another resource of my account with a difference avatar checksum
            if((xid == Common.getXID()) && (hasPhoto == 'true') && (checksum != DataStore.getDB(Connection.desktop_hash, 'checksum', 1)))
                Avatar.get(Common.getXID(), 'force', 'true', 'forget');
            
            // This presence comes from a groupchat
            if(Utils.isPrivate(xid)) {
                var x_muc = $(node).find('x[xmlns="' + NS_MUC_USER + '"]:first');
                var item = x_muc.find('item');
                var affiliation = item.attr('affiliation');
                var role = item.attr('role');
                var reason = item.find('reason').text();
                var iXID = item.attr('jid');
                var iNick = item.attr('nick');
                var nick = resource;
                var messageTime = DateUtils.getCompleteTime();
                var notInitial = true;

                // Read the status code
                var status_code = [];
                
                x_muc.find('status').each(function() {
                    status_code.push(parseInt($(this).attr('code')));
                });
                
                // If this is an initial presence (when user join the room)
                if(Common.exists('#' + xidHash + '[data-initial="true"]')) {
                    notInitial = false;
                }
                
                // If one user is quitting
                if(type && (type == 'unavailable')) {
                    self.displayMUC(from, xidHash, hash, type, show, status, affiliation, role, reason, status_code, iXID, iNick, messageTime, nick, notInitial);
                    
                    DataStore.removeDB(Connection.desktop_hash, 'presence-stanza', from);
                    resources_obj = self.removeResource(xid, resource);
                }
                
                // If one user is joining
                else {
                    // Fixes M-Link first presence bug (missing ID!)
                    if((nick == Name.getMUCNick(xidHash)) && (presence.getID() === null) && !Common.exists('#page-engine #' + xidHash + ' .list .' + hash)) {
                        Groupchat.handleMUC(presence);
                        
                        Console.warn('Passed M-Link MUC first presence handling.');
                    }
                    
                    else {
                        self.displayMUC(from, xidHash, hash, type, show, status, affiliation, role, reason, status_code, iXID, iNick, messageTime, nick, notInitial);
                        
                        xml = '<presence from="' + Common.encodeQuotes(from) + '"><priority>' + priority.htmlEnc() + '</priority><show>' + show.htmlEnc() + '</show><type>' + type.htmlEnc() + '</type><status>' + status.htmlEnc() + '</status><avatar>' + hasPhoto.htmlEnc() + '</avatar><checksum>' + checksum.htmlEnc() + '</checksum><caps>' + caps.htmlEnc() + '</caps></presence>';

                        DataStore.setDB(Connection.desktop_hash, 'presence-stanza', from, xml);
                        resources_obj = self.addResource(xid, resource);
                    }
                }
                
                // Manage the presence
                self.processPriority(from, resource, resources_obj);
                self.funnel(from, hash);
            }
            
            // This presence comes from an user or a gateway
            else {
                // Subscribed/Unsubscribed stanzas
                if((type == 'subscribed') || (type == 'unsubscribed'))
                    return;
                // Subscribe stanza
                else if(type == 'subscribe') {
                    // This is a buddy we can safely authorize, because we added him to our roster
                    if(Common.exists('#roster .buddy[data-xid="' + escape(xid) + '"]'))
                        self.acceptSubscribe(xid);
                    
                    // We do not know this entity, we'd be better ask the user
                    else {
                        // Get the nickname
                        var nickname = $(node).find('nick[xmlns="' + NS_NICK + '"]:first').text();
                        
                        // New notification
                        Notification.create('subscribe', xid, [xid, nickname], status);
                    }
                }
                
                // Unsubscribe stanza
                else if(type == 'unsubscribe') {
                    Roster.send(xid, 'remove');
                }
                
                // Other stanzas
                else {
                    // Unavailable/error presence
                    if(type == 'unavailable') {
                        DataStore.removeDB(Connection.desktop_hash, 'presence-stanza', from);
                        resources_obj = self.removeResource(xid, resource);
                    }
                    
                    // Other presence (available, subscribe...)
                    else {
                        xml = '<presence from="' + Common.encodeQuotes(from) + '"><priority>' + priority.htmlEnc() + '</priority><show>' + show.htmlEnc() + '</show><type>' + type.htmlEnc() + '</type><status>' + status.htmlEnc() + '</status><avatar>' + hasPhoto.htmlEnc() + '</avatar><checksum>' + checksum.htmlEnc() + '</checksum><caps>' + caps.htmlEnc() + '</caps></presence>';

                        DataStore.setDB(Connection.desktop_hash, 'presence-stanza', from, xml);
                        resources_obj = self.addResource(xid, resource);
                    }

                    // We manage the presence
                    self.processPriority(xid, resource, resources_obj);
                    self.funnel(xid, xidHash);
                    
                    // We display the presence in the current chat
                    if(Common.exists('#' + xidHash)) {
                        var dStatus = self.filterStatus(xid, status, false);
                        
                        if(dStatus)
                            dStatus = ' (' + dStatus + ')';
                        
                        // Generate the presence-in-chat code
                        var dName = Name.getBuddy(from).htmlEnc();
                        var dBody = dName + ' (' + from + ') ' + Common._e("is now") + ' ' + self.humanShow(show, type) + dStatus;
                        
                        // Check whether it has been previously displayed
                        var can_display = true;
                        
                        if($('#' + xidHash + ' .one-line.system-message:last').html() == dBody)
                            can_display = false;
                        
                        if(can_display)
                            Message.display('chat', xid, xidHash, dName, dBody, DateUtils.getCompleteTime(), DateUtils.getTimeStamp(), 'system-message', false);
                    }
                }

                // Get disco#infos for this presence (related to Caps)
                Caps.getDiscoInfos(from, caps);
            }
            
            // For logger
            if(!show) {
                if(!type)
                    show = 'available';
                else
                    show = 'unavailable';
            }
            
            Console.log('Presence received: ' + show + ', from ' + from);
        } catch(e) {
            Console.error('Presence.handle', e);
        }

    };


    /**
     * Displays a MUC presence
     * @public
     * @param {string} from
     * @param {string} roomHash
     * @param {string} hash
     * @param {string} type
     * @param {string} show
     * @param {string} status
     * @param {string} affiliation
     * @param {string} role
     * @param {string} reason
     * @param {string} status_code
     * @param {string} iXID
     * @param {string} iNick
     * @param {string} messageTime
     * @param {string} nick
     * @param {boolean} initial
     * @return {undefined}
     */
    self.displayMUC = function(from, roomHash, hash, type, show, status, affiliation, role, reason, status_code, iXID, iNick, messageTime, nick, initial) {

        try {
            // Generate the values
            var room_xid = Common.bareXID(from);
            var thisUser = '#page-engine #' + roomHash + ' .list .' + hash;
            var thisPrivate = $('#' + hash + ' .message-area');
            var nick_html = nick.htmlEnc();
            var real_xid = '';
            var write = nick_html + ' ';
            var notify = false;
            
            // Reset data?
            if(!role)
                role = 'participant';
            if(!affiliation)
                affiliation = 'none';
            
            // Must update the role?
            if(Common.exists(thisUser) && (($(thisUser).attr('data-role') != role) || ($(thisUser).attr('data-affiliation') != affiliation)))
                $(thisUser).remove();
            
            // Any XID submitted?
            if(iXID) {
                real_xid = ' data-realxid="' + iXID + '"';
                iXID = Common.bareXID(iXID);
                write += ' (<a onclick="return Chat.checkCreate(\'' + Utils.encodeOnclick(iXID) + '\', \'chat\');" href="xmpp:' + Utils.encodeOnclick(iXID) + '">' + iXID + '</a>) ';
            }
            
            // User does not exists yet
            if(!Common.exists(thisUser) && (!type || (type == 'available'))) {
                var myself = '';
                
                // Is it me?
                if(nick == Name.getMUCNick(roomHash)) {
                    // Enable the room
                    $('#' + roomHash + ' .message-area').removeAttr('disabled');
                    
                    // Marker
                    myself = ' myself';
                }
                
                // Set the user in the MUC list
                $('#' + roomHash + ' .list .' + role + ' .title').after(
                    '<div class="user ' + hash + myself + '" data-xid="' + Common.encodeQuotes(from) + '" data-nick="' + escape(nick) + '"' + real_xid + ' data-role="' + Common.encodeQuotes(role) + '" data-affiliation="' + Common.encodeQuotes(affiliation) + '">' + 
                        '<div class="user-details">' + 
                            '<div class="name talk-images available">' + nick_html + '</div>' + 
                            
                            '<div class="avatar-container">' + 
                                '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                            '</div>' + 

                            '<div class="clear"></div>' + 
                        '</div>' + 

                        '<div class="user-actions">' + 
                            '<span class="action promote">' + 
                                '<a href="#" class="talk-images" title="' + Common._e("Promote as moderator") + '"></a>' + 
                            '</span>' + 

                            '<span class="action demote">' + 
                                '<a href="#" class="talk-images" title="' + Common._e("Remove moderator status") + '"></a>' + 
                            '</span>' + 

                            '<span class="action add">' + 
                                '<a href="#" class="talk-images" title="' + Common._e("Add to my contacts") + '"></a>' + 
                            '</span>' + 

                            '<span class="action kick">' + 
                                '<a href="#" class="talk-images" title="' + Common._e("Kick from room") + '"></a>' + 
                            '</span>' + 

                            '<div class="clear"></div>' + 
                        '</div>' + 
                    '</div>'
                );
                
                // Click event
                if(nick != Name.getMUCNick(roomHash)) {
                    $(thisUser).hover(function() {
                        if(iXID && Groupchat.affiliationMe(room_xid).code >= 2) {
                            var user_actions_sel = $(this).find('.user-actions');
                            var user_actions_btn_sel = user_actions_sel.find('.action');

                            // Update buttons
                            var i;
                            var hide_btns = [];

                            var user_affiliation = Groupchat.affiliationUser(room_xid, nick);

                            if(user_affiliation.name == 'owner') {
                                hide_btns.push('promote');
                                hide_btns.push('demote');
                                hide_btns.push('kick');
                            } else if(user_affiliation.name === 'admin') {
                                hide_btns.push('promote');
                                hide_btns.push('kick');
                            } else {
                                hide_btns.push('demote');
                            }

                            if(Roster.isFriend(iXID)) {
                                hide_btns.push('add');
                            }

                            // Go Go Go!!
                            for(i in hide_btns) {
                                user_actions_btn_sel.filter('.' + hide_btns[i]).hide();
                            }

                            // Slide down?
                            if(hide_btns.length < user_actions_btn_sel.size()) {
                                user_actions_sel.stop(true).slideDown(250);
                            }
                        }
                    }, function() {
                        var user_actions_sel = $(this).find('.user-actions');

                        if(user_actions_sel.is(':visible')) {
                            user_actions_sel.stop(true).slideUp(200, function() {
                                user_actions_sel.find('.action').show();
                            });
                        }
                    });

                    $(thisUser).find('.user-details').on('click', function() {
                        Chat.checkCreate(from, 'private');
                    });

                    $(thisUser).find('.user-actions .action a').on('click', function() {
                        var this_parent_sel = $(this).parent();

                        if(this_parent_sel.is('.promote')) {
                            Groupchat.promoteModerator(room_xid, iXID);
                        } else if(this_parent_sel.is('.demote')) {
                            Groupchat.demoteModerator(room_xid, iXID);
                        } else if(this_parent_sel.is('.add')) {
                            this_parent_sel.hide();
                            Roster.addThisContact(iXID, nick);
                        } else if(this_parent_sel.is('.kick')) {
                            Groupchat.kickUser(room_xid, (iXID || from), nick);
                        }

                        return false;
                    });
                }
                
                // We tell the user that someone entered the room
                if(!initial && DataStore.getDB(Connection.desktop_hash, 'options', 'groupchatpresence') !== '0') {
                    notify = true;
                    write += Common._e("joined the chat room");
                    
                    // Any status?
                    if(status)
                        write += ' (' + Filter.message(status, nick_html, true) + ')';
                    else
                        write += ' (' + Common._e("no status") + ')';
                }
                
                // Enable the private chat input
                thisPrivate.removeAttr('disabled');
            }
            
            else if((type == 'unavailable') || (type == 'error')) {
                // Is it me?
                if(nick == Name.getMUCNick(roomHash)) {
                    $(thisUser).remove();
                    
                    // Disable the groupchat input
                    $('#' + roomHash + ' .message-area').attr('disabled', true);
                    
                    // Remove all the groupchat users
                    $('#' + roomHash + ' .list .user').remove();
                }
                
                // Someone has been kicked or banned?
                if(Utils.existArrayValue(status_code, 301) || Utils.existArrayValue(status_code, 307)) {
                    $(thisUser).remove();
                    notify = true;
                    
                    // Kicked?
                    if(Utils.existArrayValue(status_code, 307))
                        write += Common._e("has been kicked");
                    
                    // Banned?
                    if(Utils.existArrayValue(status_code, 301))
                        write += Common._e("has been banned");
                    
                    // Any reason?
                    if(reason)
                        write += ' (' + Filter.message(reason, nick_html, true) + ')';
                    else
                        write += ' (' + Common._e("no reason") + ')';
                }
                
                // Nickname change?
                else if(Utils.existArrayValue(status_code, 303) && iNick) {
                    notify = true;
                    write += Common.printf(Common._e("changed his/her nickname to %s"), iNick.htmlEnc());
                    
                    // New values
                    var new_xid = Common.cutResource(from) + '/' + iNick;
                    var new_hash = hex_md5(new_xid);
                    var new_class = 'user ' + new_hash;
                    
                    if($(thisUser).hasClass('myself'))
                        new_class += ' myself';
                    
                    // Die the click event
                    $(thisUser).off('click');
                    
                    // Change to the new nickname
                    $(thisUser).attr('data-nick', escape(iNick))
                               .attr('data-xid', new_xid)
                               .find('.name').text(iNick);
                    
                    // Change the user class
                    $(thisUser).attr('class', new_class);
                    
                    // New click event
                    $('#page-engine #' + roomHash + ' .list .' + new_hash).on('click', function() {
                        Chat.checkCreate(new_xid, 'private');
                    });
                }
                
                // We tell the user that someone left the room
                else if(!initial && DataStore.getDB(Connection.desktop_hash, 'options', 'groupchatpresence') !== '0') {
                    $(thisUser).remove();
                    notify = true;
                    write += Common._e("left the chat room");
                    
                    // Any status?
                    if(status)
                        write += ' (' + Filter.message(status, nick_html, true) + ')';
                    else
                        write += ' (' + Common._e("no status") + ')';
                }
                
                // Disable the private chat input
                thisPrivate.attr('disabled', true);
            }
            
            // Must notify something
            if(notify)
                Message.display('groupchat', from, roomHash, nick_html, write, messageTime, DateUtils.getTimeStamp(), 'system-message', false);
            
            // Set the good status show icon
            switch(show) {
                case 'chat':
                case 'away':
                case 'xa':
                case 'dnd':
                    break;
                
                default:
                    show = 'available';
                    break;
            }
            
            $(thisUser + ' .name').attr('class', 'name talk-images ' + show);
            
            // Set the good status text
            var uTitle = nick;
            
            // Any XID to add?
            if(iXID)
                uTitle += ' (' + iXID + ')';
            
            // Any status to add?
            if(status)
                uTitle += ' - ' + status;
            
            $(thisUser).attr('title', uTitle);
            
            // Show or hide the role category, depending of its content
            $('#' + roomHash + ' .list .role').each(function() {
                if($(this).find('.user').size())
                    $(this).show();
                else
                    $(this).hide();
            });
        } catch(e) {
            Console.error('Presence.displayMUC', e);
        }

    };


    /**
     * Filters a given status
     * @public
     * @param {string} xid
     * @param {string} status
     * @param {boolean} cut
     * @return {string}
     */
    self.filterStatus = function(xid, status, cut) {

        try {
            var dStatus = '';
            
            if(!status) {
                status = '';
            }
            
            else {
                if(cut) {
                    dStatus = Utils.truncate(status, 50);
                } else {
                    dStatus = status;
                }
                
                dStatus = Filter.message(dStatus, Name.getBuddy(xid).htmlEnc(), true);
            }
            
            return dStatus;
        } catch(e) {
            Console.error('Presence.filterStatus', e);
        }

    };


    /**
     * Displays a user's presence
     * @public
     * @param {string} value
     * @param {string} type
     * @param {string} show
     * @param {string} status
     * @param {string} hash
     * @param {string} xid
     * @param {string} avatar
     * @param {string} checksum
     * @param {string} caps
     * @return {undefined}
     */
    self.display = function(value, type, show, status, hash, xid, avatar, checksum, caps) {

        try {
            // Display the presence in the roster
            var path = '#roster .' + hash;
            var buddy = $('#roster .content .' + hash);
            var dStatus = self.filterStatus(xid, status, false);
            var tStatus = Common.encodeQuotes(status);
            var biStatus;
            
            // The buddy presence behind his name
            $(path + ' .name .buddy-presence').replaceWith('<p class="buddy-presence talk-images ' + type + '">' + value + '</p>');
            
            // The buddy presence in the buddy infos
            if(dStatus)
                biStatus = dStatus;
            else
                biStatus = value;
            
            $(path + ' .bi-status').replaceWith('<p class="bi-status talk-images ' + type + '" title="' + tStatus + '">' + biStatus + '</p>');
            
            // When the buddy disconnect himself, we hide him
            if((type == 'unavailable') || (type == 'error')) {
                // Set a special class to the buddy
                buddy.addClass('hidden-buddy');
                
                // No filtering is launched?
                if(!Search.search_filtered)
                    buddy.hide();
                
                // All the buddies are shown?
                if(Roster.blist_all)
                    buddy.show();
                
                // Chat stuffs
                if(Common.exists('#' + hash)) {
                    // Remove the chatstate stuffs
                    ChatState.reset(hash);
                    $('#' + hash + ' .chatstate').remove();
                    $('#' + hash + ' .message-area').removeAttr('data-chatstates');
                    
                    // Get the buddy avatar (only if a chat is opened)
                    Avatar.get(xid, 'cache', 'true', 'forget');
                }
            }
            
            // If the buddy is online
            else {
                // When the buddy is online, we show it
                buddy.removeClass('hidden-buddy');
                
                // No filtering is launched?
                if(!Search.search_filtered)
                    buddy.show();
                
                // Get the online buddy avatar if not a gateway
                Avatar.get(xid, 'cache', avatar, checksum);
            }
            
            // Display the presence in the chat
            if(Common.exists('#' + hash)) {
                // We generate a well formed status message
                if(dStatus) {
                    // No need to write the same status two times
                    if(dStatus == value)
                        dStatus = '';
                    else
                        dStatus = ' (' + dStatus + ')';
                }
                
                // We show the presence value
                $('#' + hash + ' .bc-infos').replaceWith('<p class="bc-infos" title="' + tStatus + '"><span class="' + type + ' show talk-images">' + value + '</span>' + dStatus + '</p>');
                
                // Process the new status position
                self.adaptChat(hash);
            }
            
            // Display the presence in the switcher
            if(Common.exists('#page-switch .' + hash)) {
                $('#page-switch .' + hash + ' .icon').removeClass('available unavailable error away busy').addClass(type);
            }
            
            // Update roster groups
            if(!Search.search_filtered) {
                Roster.updateGroups();
            } else {
                Search.funnelFilterBuddy();
            }

            // Get the disco#infos for this user
            var highest = self.highestPriority(xid);
            
            if(highest) {
                Caps.getDiscoInfos(highest, caps);
            } else {
                Caps.displayDiscoInfos(xid, '');
            }
        } catch(e) {
            Console.error('Presence.display', e);
        }

    };


    /**
     * Process the chat presence position
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.adaptChat = function(hash) {

        try {
            // Get values
            var pep_numb = $('#' + hash + ' .bc-pep').find('a').size();
            
            // Process the left/right position
            var presence_h = 12;
            
            if(pep_numb)
                presence_h = (pep_numb * 20) + 18;
            
            // Apply the left/right position
            var presence_h_tag = ($('html').attr('dir') == 'rtl') ? 'left' : 'right';
            $('#' + hash + ' p.bc-infos').css(presence_h_tag, presence_h);
        } catch(e) {
            Console.error('Presence.adaptChat', e);
        }

    };


    /**
     * Convert the presence "show" element into a human-readable output
     * @public
     * @param {string} show
     * @param {string} type
     * @return {undefined}
     */
    self.humanShow = function(show, type) {

        try {
            if(type == 'unavailable')
                show = Common._e("Unavailable");
            
            else if(type == 'error')
                show = Common._e("Error");
            
            else {
                switch(show) {
                    case 'chat':
                        show = Common._e("Talkative");
                        break;
                    
                    case 'away':
                        show = Common._e("Away");
                        break;
                    
                    case 'xa':
                        show = Common._e("Not available");
                        break;
                    
                    case 'dnd':
                        show = Common._e("Busy");
                        break;
                    
                    default:
                        show = Common._e("Available");
                        break;
                }
            }
            
            return show;
        } catch(e) {
            Console.error('Presence.humanShow', e);
        }

    };


    /**
     * Makes the presence data go in the right way
     * @public
     * @param {string} type
     * @param {string} show
     * @param {string} status
     * @param {string} hash
     * @param {string} xid
     * @param {string} avatar
     * @param {string} checksum
     * @param {string} caps
     * @return {undefined}
     */
    self.IA = function(type, show, status, hash, xid, avatar, checksum, caps) {

        try {
            // Is there a status defined?
            if(!status)
                status = self.humanShow(show, type);
            
            // Then we can handle the events
            if(type == 'error')
                self.display(Common._e("Error"), 'error', show, status, hash, xid, avatar, checksum, caps);
            
            else if(type == 'unavailable')
                self.display(Common._e("Unavailable"), 'unavailable', show, status, hash, xid, avatar, checksum, caps);
            
            else {
                switch(show) {
                    case 'chat':
                        self.display(Common._e("Talkative"), 'available', show, status, hash, xid, avatar, checksum, caps);
                        break;
                    
                    case 'away':
                        self.display(Common._e("Away"), 'away', show, status, hash, xid, avatar, checksum, caps);
                        break;
                    
                    case 'xa':
                        self.display(Common._e("Not available"), 'busy', show, status, hash, xid, avatar, checksum, caps);
                        break;
                    
                    case 'dnd':
                        self.display(Common._e("Busy"), 'busy', show, status, hash, xid, avatar, checksum, caps);
                        break;
                    
                    default:
                        self.display(Common._e("Available"), 'available', show, status, hash, xid, avatar, checksum, caps);
                        break;
                }
            }
        } catch(e) {
            Console.error('Presence.IA', e);
        }

    };


    /**
     * Flush the presence data for a given user
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.flush = function(xid) {

        try {
            var flushed_marker = false;
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'presence' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored presence
                if(current.match(db_regex)) {
                    // Get the current XID
                    var now_full = RegExp.$1;
                    var now_bare = Common.bareXID(now_full);
                    
                    // If the current XID equals the asked XID
                    if(now_bare == xid) {
                        if(DataStore.removeDB(Connection.desktop_hash, 'presence-stanza', now_full)) {
                            Console.info('Presence data flushed for: ' + now_full);

                            flushed_marker = true;
                            i--;
                        }
                    }
                }
            }

            return flushed_marker;
        } catch(e) {
            Console.error('Presence.flush', e);
        }

    };


    /**
     * Process the highest resource priority for an user
     * @public
     * @param {string} xid
     * @param {string} resource
     * @param {object} resources_obj
     * @return {undefined}
     */
    self.processPriority = function(xid, resource, resources_obj) {

        try {
            if(!xid) {
                Console.warn('No XID value');
                return;
            }

            // Initialize vars
            var cur_resource, cur_from, cur_pr,
                cur_xml, cur_priority,
                from_highest;

            from_highest = null;
            max_priority = null;

            // Groupchat presence? (no priority here)
            if(xid.indexOf('/') !== -1) {
                from_highest = xid;

                Console.log('Processed presence for groupchat user: ' + xid);
            } else {
                if(!self.highestPriority(xid)) {
                    from_highest = xid + '/' + resource;

                    Console.log('Processed initial presence for regular user: ' + xid + ' (highest priority for: ' + (from_highest || 'none') + ')');
                } else {
                    for(cur_resource in resources_obj) {
                        // Read presence data
                        cur_from = xid + '/' + cur_resource;
                        cur_pr   = DataStore.getDB(Connection.desktop_hash, 'presence-stanza', cur_from);

                        if(cur_pr) {
                            // Parse presence data
                            cur_xml      = Common.XMLFromString(cur_pr);
                            cur_priority = $(cur_xml).find('priority').text();
                            cur_priority = !isNaN(cur_priority) ? parseInt(cur_priority) : 0;
                            
                            // Higher priority?
                            if((cur_priority >= max_priority) || (max_priority === null)) {
                                max_priority = cur_priority;
                                from_highest = cur_from;
                            }
                        }
                    }

                    Console.log('Processed presence for regular user: ' + xid + ' (highest priority for: ' + (from_highest || 'none') + ')');
                }
            }

            if(from_highest)
                DataStore.setDB(Connection.desktop_hash, 'presence-priority', xid, from_highest);
            else
                DataStore.removeDB(Connection.desktop_hash, 'presence-priority', xid);
        } catch(e) {
            Console.error('Presence.processPriority', e);
        }

    };


    /**
     * Returns the highest presence priority XID for an user
     * @public
     * @param {string} xid
     * @return {string}
     */
    self.highestPriority = function(xid) {

        try {
            return DataStore.getDB(Connection.desktop_hash, 'presence-priority', xid) || '';
        } catch(e) {
            Console.error('Presence.highestPriority', e);
        }

    };


    /**
     * Gets the presence stanza for given full XID
     * @public
     * @param {string} xid_full
     * @return {object}
     */
    self.readStanza = function(xid_full) {

        try {
            var pr = DataStore.getDB(Connection.desktop_hash, 'presence-stanza', xid_full);

            if(!pr) {
                pr = '<presence><type>unavailable</type></presence>';
            }

            return Common.XMLFromString(pr);
        } catch(e) {
            Console.error('Presence.readStanza', e);
        }

    };


    /**
     * Gets the resource from a XID which has the highest priority
     * @public
     * @param {string} xid
     * @return {object}
     */
    self.highestPriorityStanza = function(xid) {

        try {
            return self.readStanza(
                self.highestPriority(xid)
            );
        } catch(e) {
            Console.error('Presence.highestPriorityStanza', e);
        }

    };


    /**
     * Lists presence resources for an user
     * @public
     * @param {string} xid
     * @return {object}
     */
    self.resources = function(xid) {

        try {
            var resources_obj = {};
            var resources_db  = DataStore.getDB(Connection.desktop_hash, 'presence-resources', xid);

            if(resources_db) {
                resources_obj = $.evalJSON(resources_db);
            }

            return resources_obj;
        } catch(e) {
            Console.error('Presence.resources', e);
        }

    };


    /**
     * Adds a given presence resource for an user
     * @public
     * @param {string} xid
     * @param {string} resource
     * @return {object}
     */
    self.addResource = function(xid, resource) {

        var resources_obj = null;

        try {
            resources_obj = self.resources(xid);

            resources_obj[resource] = 1;
            DataStore.setDB(Connection.desktop_hash, 'presence-resources', xid, $.toJSON(resources_obj));
        } catch(e) {
            Console.error('Presence.addResource', e);
        } finally {
            return resources_obj;
        }

    };


    /**
     * Removes a given presence resource for an user
     * @public
     * @param {string} xid
     * @param {string} resource
     * @return {object}
     */
    self.removeResource = function(xid, resource) {

        var resources_obj = null;

        try {
            resources_obj = self.resources(xid);

            delete resources_obj[resource];
            DataStore.setDB(Connection.desktop_hash, 'presence-resources', xid, $.toJSON(resources_obj));
        } catch(e) {
            Console.error('Presence.removeResource', e);
        } finally {
            return resources_obj;
        }

    };


    /**
     * Makes something easy to process for the presence IA
     * @public
     * @param {string} xid
     * @param {string} hash
     * @return {undefined}
     */
    self.funnel = function(xid, hash) {

        try {
            // Get the highest priority presence value
            var xml = $(self.highestPriorityStanza(xid));
            var type = xml.find('type').text();
            var show = xml.find('show').text();
            var status = xml.find('status').text();
            var avatar = xml.find('avatar').text();
            var checksum = xml.find('checksum').text();
            var caps = xml.find('caps').text();

            // Display the presence with that stored value
            if(!type && !show)
                self.IA('', 'available', status, hash, xid, avatar, checksum, caps);
            else
                self.IA(type, show, status, hash, xid, avatar, checksum, caps);
        } catch(e) {
            Console.error('Presence.funnel', e);
        }

    };


    /**
     * Sends a defined presence packet
     * @public
     * @param {string} to
     * @param {string} type
     * @param {string} show
     * @param {string} status
     * @param {string} checksum
     * @param {number} limit_history
     * @param {string} password
     * @param {function} handle
     * @return {undefined}
     */
    self.send = function(to, type, show, status, checksum, limit_history, password, handle) {

        try {
            // Get some stuffs
            var priority = DataStore.getDB(Connection.desktop_hash, 'priority', 1);
            
            if(!priority)
                priority = '1';
            if(!checksum)
                checksum = DataStore.getDB(Connection.desktop_hash, 'checksum', 1);
            if(show == 'available')
                show = '';
            if(type == 'available')
                type = '';
            
            // New presence
            var presence = new JSJaCPresence();
            
            // Avoid "null" or "none" if nothing stored
            if(!checksum || (checksum == 'none'))
                checksum = '';
            
            // Presence headers
            if(to)
                presence.setTo(to);
            if(type)
                presence.setType(type);
            if(show)
                presence.setShow(show);
            if(status)
                presence.setStatus(status);
            
            presence.setPriority(priority);
            
            // CAPS (entity capabilities)
            presence.appendNode('c', {'xmlns': NS_CAPS, 'hash': 'sha-1', 'node': 'http://jappix.org/', 'ver': Caps.mine()});
            
            // Nickname
            var nickname = Name.get();
            
            if(nickname && !limit_history)
                presence.appendNode('nick', {'xmlns': NS_NICK}, nickname);
            
            // vcard-temp:x:update node
            var x = presence.appendNode('x', {'xmlns': NS_VCARD_P});
            x.appendChild(presence.buildNode('photo', {'xmlns': NS_VCARD_P}, checksum));
            
            // MUC X data
            if(limit_history || password) {
                var xMUC = presence.appendNode('x', {'xmlns': NS_MUC});
                
                // Max messages age (for MUC)
                if(limit_history)
                    xMUC.appendChild(presence.buildNode('history', {'maxstanzas': 20, 'seconds': 86400, 'xmlns': NS_MUC}));
                
                // Room password
                if(password)
                    xMUC.appendChild(presence.buildNode('password', {'xmlns': NS_MUC}, password));
            }
            
            // If away, send a last activity time
            if((show == 'away') || (show == 'xa')) {
                /* REF: http://xmpp.org/extensions/xep-0256.html */
                
                presence.appendNode(presence.buildNode('query', {
                    'xmlns': NS_LAST,
                    'seconds': DateUtils.getPresenceLast()
                }));
            }
            
            // Else, set a new last activity stamp
            else
                DateUtils.presence_last_activity = DateUtils.getTimeStamp();
            
            // Send the presence packet
            if(handle)
                con.send(presence, handle);
            else
                con.send(presence);
            
            if(!type)
                type = 'available';
            
            Console.info('Presence sent: ' + type);
        } catch(e) {
            Console.error('Presence.send', e);
        }

    };


    /**
     * Performs all the actions to get the presence data
     * @public
     * @param {string} checksum
     * @param {boolean} autoidle
     * @return {undefined}
     */
    self.sendActions = function(checksum, autoidle) {

        try {
            // We get the values of the inputs
            var show = self.getUserShow();
            var status = self.getUserStatus();
            
            // Send the presence
            if(!Utils.isAnonymous())
                self.send('', '', show, status, checksum);
            
            // We set the good icon
            self.icon(show);
            
            // We store our presence
            if(!autoidle)
                DataStore.setDB(Connection.desktop_hash, 'presence-show', 1, show);
            
            // We send the presence to our active MUC
            $('.page-engine-chan[data-type="groupchat"]').each(function() {
                var tmp_nick = $(this).attr('data-nick');
                
                if(!tmp_nick)
                    return;
                
                var room = unescape($(this).attr('data-xid'));
                var nick = unescape(tmp_nick);
                
                // Must re-initialize?
                if(RESUME)
                    Groupchat.getMUC(room, nick);
                
                // Not disabled?
                else if(!$(this).find('.message-area').attr('disabled'))
                    self.send(room + '/' + nick, '', show, status, '', true);
            });
        } catch(e) {
            Console.error('Presence.quickSend', e);
        }

    };


    /**
     * Changes the presence icon
     * @public
     * @param {string} value
     * @return {undefined}
     */
    self.icon = function(value) {

        try {
            $('#my-infos .f-presence a.picker').attr('data-value', value);
        } catch(e) {
            Console.error('Presence.icon', e);
        }

    };


    /**
     * Sends a subscribe stanza
     * @public
     * @param {string} to
     * @param {string} type
     * @return {undefined}
     */
    self.sendSubscribe = function(to, type) {

        try {
            var status = '';
            
            // Subscribe request?
            if(type == 'subscribe')
                status = Common.printf(Common._e("Hi, I am %s, I would like to add you as my friend."), Name.get());
            
            self.send(to, type, '', status);
        } catch(e) {
            Console.error('Presence.sendSubscribe', e);
        }

    };


    /**
     * Accepts the subscription from another entity
     * @public
     * @param {string} xid
     * @param {string} name
     * @return {undefined}
     */
    self.acceptSubscribe = function(xid, name) {

        try {
            // We update our chat
            $('#' + hex_md5(xid) + ' .tools-add').hide();
            
            // We send a subsribed presence (to confirm)
            self.sendSubscribe(xid, 'subscribed');
            
            // We send a subscription request (subscribe both sides)
            self.sendSubscribe(xid, 'subscribe');
            
            // Specify the buddy name (if any)
            if(name) {
                Roster.send(xid, '', name);
            }
        } catch(e) {
            Console.error('Presence.acceptSubscribe', e);
        }

    };


    /**
     * Sends automatic away presence
     * @public
     * @return {undefined}
     */
    self.autoIdle = function() {

        try {
            // Not connected?
            if(!Common.isConnected())
                return;
            
            // Stop if an xa presence was set manually
            var last_presence = self.getUserShow();
            
            if(!self.auto_idle && ((last_presence == 'away') || (last_presence == 'xa')))
                return;
            
            var idle_presence;
            var activity_limit;
            
            // Can we extend to auto extended away mode (20 minutes)?
            if(self.auto_idle && (last_presence == 'away')) {
                idle_presence = 'xa';
                activity_limit = 1200;
            }
            
            // We must set the user to auto-away (10 minutes)
            else {
                idle_presence = 'away';
                activity_limit = 600;
            }
            
            // The user is really inactive and has set another presence than extended away
            if(((!self.auto_idle && (last_presence != 'away')) || (self.auto_idle && (last_presence == 'away'))) && (DateUtils.getLastActivity() >= activity_limit)) {
                // Then tell we use an auto presence
                self.auto_idle = true;
                
                // Get the old status message
                var status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
                
                if(!status)
                    status = '';
                
                // Change the presence input
                $('#my-infos .f-presence a.picker').attr('data-value', idle_presence);
                $('#presence-status').val(status);
                
                // Then send the xa presence
                self.sendActions('', true);
                
                Console.info('Auto-idle presence sent: ' + idle_presence);
            }
        } catch(e) {
            Console.error('Presence.autoIdle', e);
        }

    };


    /**
     * Restores the old presence on a document bind
     * @public
     * @return {undefined}
     */
    self.eventIdle = function() {

        try {
            // If we were idle, restore our old presence
            if(self.auto_idle) {
                // Get the values
                var show = DataStore.getDB(Connection.desktop_hash, 'presence-show', 1);
                var status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
                
                // Change the presence input
                $('#my-infos .f-presence a.picker').attr('data-value', show);
                $('#presence-status').val(status);
                $('#presence-status').placeholder();
                
                // Then restore the old presence
                self.sendActions('', true);
                
                if(!show)
                    show = 'available';
                
                Console.info('Presence restored: ' + show);
            }
            
            // Apply some values
            self.auto_idle = false;
            DateUtils.last_activity = DateUtils.getTimeStamp();
        } catch(e) {
            Console.error('Presence.eventIdle', e);
        }

    };


    /**
     * Lives the auto idle functions
     * @public
     * @return {undefined}
     */
    self.liveIdle = function() {

        try {
            // Apply the autoIdle function every minute
            self.auto_idle = false;
            $('#my-infos .f-presence').everyTime('30s', self.autoIdle);
            
            // On body bind (click & key event)
            $('body').on('mousedown', self.eventIdle)
                     .on('mousemove', self.eventIdle)
                     .on('keydown', self.eventIdle);
        } catch(e) {
            Console.error('Presence.liveIdle', e);
        }

    };


    /**
     * Kills the auto idle functions
     * @public
     * @return {undefined}
     */
    self.dieIdle = function() {

        try {
            // Remove the event detector
            $('body').off('mousedown', self.eventIdle)
                     .off('mousemove', self.eventIdle)
                     .off('keydown', self.eventIdle);
        } catch(e) {
            Console.error('Presence.dieIdle', e);
        }

    };


    /**
     * Gets the user presence show
     * @public
     * @return {string}
     */
    self.getUserShow = function() {

        try {
            return $('#my-infos .f-presence a.picker').attr('data-value');
        } catch(e) {
            Console.error('Presence.getUserShow', e);
        }

    };


    /**
     * Gets the user presence status
     * @public
     * @return {string}
     */
    self.getUserStatus = function() {

        try {
            return $('#presence-status').val();
        } catch(e) {
            Console.error('Presence.getUserStatus', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click event for user presence show
            $('#my-infos .f-presence a.picker').click(function() {
                // Disabled?
                if($(this).hasClass('disabled'))
                    return false;
                
                // Initialize some vars
                var path = '#my-infos .f-presence div.bubble';
                var show_id = ['xa', 'away', 'available'];
                var show_lang = [Common._e("Not available"), Common._e("Away"), Common._e("Available")];
                var show_val = self.getUserShow();
                
                // Yet displayed?
                var can_append = true;
                
                if(Common.exists(path))
                    can_append = false;
                
                // Add this bubble!
                Bubble.show(path);
                
                if(!can_append)
                    return false;
                
                // Generate the HTML code
                var html = '<div class="bubble removable">';
                
                for(var i in show_id) {
                    // Yet in use: no need to display it!
                    if(show_id[i] == show_val)
                        continue;
                    
                    html += '<a href="#" class="talk-images" data-value="' + show_id[i] + '" title="' + show_lang[i] + '"></a>';
                }
                
                html += '</div>';
                
                // Append the HTML code
                $('#my-infos .f-presence').append(html);
                
                // Click event
                $(path + ' a').click(function() {
                    // Update the presence show marker
                    $('#my-infos .f-presence a.picker').attr('data-value', $(this).attr('data-value'));
                    
                    // Close the bubble
                    Bubble.close();
                    
                    // Focus on the status input
                    $(document).oneTime(10, function() {
                        $('#presence-status').focus();
                    });
                    
                    return false;
                });
                
                return false;
            });
            
            // Submit events for user presence status
            $('#presence-status').placeholder()
            
            .keyup(function(e) {
                if(e.keyCode == 13) {
                    $(this).blur();
                    
                    return false;
                }
            })
            
            .blur(function() {
                // Read the parameters
                var show = self.getUserShow();
                var status = self.getUserStatus();
                
                // Read the old parameters
                var old_show = DataStore.getDB(Connection.desktop_hash, 'presence-show', 1);
                var old_status = DataStore.getDB(Connection.desktop_hash, 'options', 'presence-status');
                
                // Must send the presence?
                if((show != old_show) || (status != old_status)) {
                    // Update the local stored status
                    DataStore.setDB(Connection.desktop_hash, 'options', 'presence-status', status);
                    
                    // Update the server stored status
                    if(status != old_status)
                        Options.store();
                    
                    // Send the presence
                    self.sendActions();
                }
            })
            
            // Input focus handler
            .focus(function() {
                Bubble.close();
            });
        } catch(e) {
            Console.error('Presence.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the roster JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Roster = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.blist_all = false;


    /**
     * Gets the roster items
     * @public
     * @return {undefined}
     */
    self.get = function() {

        try {
            var iq = new JSJaCIQ();
            
            iq.setType('get');
            iq.setQuery(NS_ROSTER);
            
            con.send(iq, self.handle);
        } catch(e) {
            Console.error('Roster.get', e);
        }

    };


    /**
     * Handles the roster items
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handle = function(iq) {

        try {
            // Parse the roster xml
            $(iq.getQuery()).find('item').each(function() {
                // Get user data
                var _this = $(this);
                var user_xid = _this.attr('jid');
                var user_subscription = _this.attr('subscription');

                // Parse roster data & display user
                self.parse($(this), 'load');

                // Request user microblog (populates channel)
                if(user_xid && ((user_subscription == 'both') || (user_subscription == 'to'))) {
                    // Openfire has an issue, forget about it!
                    if(Features.getServerName() != 'openfire') {
                        Microblog.request(user_xid, 1, null, Microblog.handleRoster);
                    }
                }
            });
            
            // Update our avatar (if changed), and send our presence
            Avatar.get(Common.getXID(), 'force', 'true', 'forget');
            
            Console.log('Roster received.');
        } catch(e) {
            Console.error('Roster.handle', e);
        }

    };


    /**
     * Parses the group XML and display the roster
     * @public
     * @param {string} current
     * @param {string} mode
     * @return {undefined}
     */
    self.parse = function(current, mode) {

        try {
            // Get the values
            xid = current.attr('jid');
            dName = current.attr('name');
            subscription = current.attr('subscription');
            xidHash = hex_md5(xid);
            
            // Create an array containing the groups
            var groups = [];
            
            current.find('group').each(function() {
                var group_text = $(this).text();
                
                if(group_text)
                    groups.push(group_text);
            });
            
            // No group?
            if(!groups.length)
                groups.push(Common._e("Unclassified"));
            
            // If no name is defined, we get the default nick of the buddy
            if(!dName)
                dName = Common.getXIDNick(xid);
            
            self.display(xid, xidHash, dName, subscription, groups, mode);
        } catch(e) {
            Console.error('Roster.parse', e);
        }

    };


    /**
     * Updates the roster groups
     * @public
     * @return {undefined}
     */
    self.updateGroups = function() {

        try {
            $('#roster .one-group').each(function() {
                // Current values
                var check = $(this).find('.buddy').size();
                var hidden = $(this).find('.buddy:not(.hidden-buddy:hidden)').size();
                
                // Special case: the filtering tool
                if(Search.search_filtered)
                    hidden = $(this).find('.buddy:visible').size();
                
                // If the group is empty
                if(!check)
                    $(this).remove();
                
                // If the group contains no online buddy (and is not just hidden)
                if(!hidden && $(this).find('a.group').hasClass('minus'))
                    $(this).hide();
                else
                    $(this).show();
            });
        } catch(e) {
            Console.error('Roster.updateGroups', e);
        }

    };


    /**
     * Displays a defined roster item
     * @public
     * @param {string} dXID
     * @param {string} dXIDHash
     * @param {string} dName
     * @param {string} dSubscription
     * @param {string} dGroup
     * @param {string} dMode
     * @return {undefined}
     */
    self.display = function(dXID, dXIDHash, dName, dSubscription, dGroup, dMode) {

        try {
            // First remove the buddy
            $('#roster .' + dXIDHash).remove();
            
            // Define some things around the groups
            var is_gateway = Common.isGateway(dXID);
            var gateway = '';
            
            if(is_gateway) {
                gateway = ' gateway';
                dGroup = new Array(Common._e("Gateways"));
            }
            
            // Remove request
            if(dSubscription == 'remove') {
                // Flush presence
                Presence.flush(dXID);
                Presence.funnel(dXID, dXIDHash);

                // Empty social channel
                $('#channel .mixed .one-update.update_' + dXIDHash).remove();
            }
            
            // Other request
            else {
                // Is this buddy blocked?
                var privacy_class = '';
                var privacy_state = Privacy.status('block', dXID);
                
                if(privacy_state == 'deny')
                    privacy_class = ' blocked';
                
                // For each group this buddy has
                $.each(dGroup, function(i, cGroup) {
                    if(cGroup) {
                        // Process some vars
                        var groupHash = 'group' + hex_md5(cGroup);
                        var groupContent = '#roster .' + groupHash;
                        var groupBuddies = groupContent + ' .group-buddies';
                        
                        // Is this group blocked?
                        if((Privacy.status('block', cGroup) == 'deny') && (privacy_state != 'allow'))
                            privacy_class = ' blocked';
                        
                        // Group not yet displayed
                        if(!Common.exists(groupContent)) {
                            // Define some things
                            var groupCont = '#roster .content';
                            var groupToggle = groupCont + ' .' + groupHash + ' a.group';
                            
                            // Create the HTML markup of the group
                            $(groupCont).prepend(
                                '<div class="' + groupHash + ' one-group" data-group="' + escape(cGroup) + '">' + 
                                    '<a href="#" class="group talk-images minus">' + cGroup.htmlEnc() + '</a>' + 
                                    '<div class="group-buddies"></div>' + 
                                '</div>'
                            );
                            
                            // Create the click event which will hide and show the content
                            $(groupToggle).click(function() {
                                var group = $(groupBuddies);
                                var group_toggle = $(groupContent + ' a.group');
                                
                                // We must hide the buddies
                                if(group_toggle.hasClass('minus')) {
                                    group.hide();
                                    group_toggle.removeClass('minus').addClass('plus');
                                    
                                    // Remove the group opened buddy-info
                                    Bubble.close();
                                }
                                
                                // We must show the buddies
                                else {
                                    group_toggle.removeClass('plus').addClass('minus');
                                    group.show();
                                }
                                
                                return false;
                            });
                        }
                        
                        // Initialize the HTML code
                        var name_code = '<p class="buddy-name">' + dName.htmlEnc() + '</p>';
                        var presence_code = '<p class="buddy-presence talk-images unavailable">' + Common._e("Unavailable") + '</p>';
                        
                        var html = '<div class="hidden-buddy buddy ibubble ' + dXIDHash + gateway + privacy_class + '" data-xid="' + escape(dXID) + '">' + 
                                '<div class="buddy-click">';
                        
                        // Display avatar if not gateway
                        if(!is_gateway) {
                            html += '<div class="avatar-container">' + 
                                    '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                                '</div>';
                        }
                        
                        html += '<div class="name">';
                        
                        // Special gateway code
                        if(is_gateway)
                            html += presence_code +
                                name_code;
                        
                        else
                            html += name_code + 
                                presence_code;
                        
                        html += '</div></div></div>';
                        
                        // Create the DOM element for this buddy
                        $(groupBuddies).append(html);
                        
                        // Apply the hover event
                        self.applyBuddyHover(dXID, dXIDHash, dName, dSubscription, dGroup, groupHash);
                    }
                });
                
                // Click event on this buddy
                $('#roster .' + dXIDHash + ' .buddy-click').click(function() {
                    return Chat.checkCreate(dXID, 'chat');
                });
                
                // We get the user presence if necessary
                if(dMode == 'presence') {
                    Presence.funnel(dXID, dXIDHash);
                }
                
                // If the buddy must be shown
                if(self.blist_all) {
                    $('#roster .' + dXIDHash).show();
                }
            }
            
            // We update our groups
            if(!Search.search_filtered) {
                self.updateGroups();
            } else {
                Search.funnelFilterBuddy();
            }
        } catch(e) {
            Console.error('Roster.display', e);
        }

    };


    /**
     * Applies the buddy editing input events
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.applyBuddyInput = function(xid) {

        try {
            // Initialize
            var path = '#roster .buddy[data-xid="' + escape(xid) + '"]';
            var rename = path + ' .bm-rename input';
            var group = path + ' .bm-group input';
            var manage_infos = path + ' .manage-infos';
            var bm_choose = manage_infos + ' div.bm-choose';
            
            // Keyup events
            $(rename).keyup(function(e) {
                if(e.keyCode == 13) {
                    // Send the item
                    self.send(xid, '', $.trim($(rename).val()), self.thisBuddyGroups(xid));
                    
                    // Remove the buddy editor
                    Bubble.close();
                    
                    return false;
                }
            });
            
            $(group).keyup(function(e) {
                if(e.keyCode == 13) {
                    // Empty input?
                    if(!$.trim($(this).val())) {
                        // Send the item
                        self.send(xid, '', $.trim($(rename).val()), self.thisBuddyGroups(xid));
                        
                        // Remove the buddy editor
                        Bubble.close();
                        
                        return false;
                    }
                    
                    // Get the values
                    var this_value = $.trim($(this).val());
                    var escaped_value = escape(this_value);
                    
                    // Check if the group yet exists
                    var group_exists = false;
                    
                    $(bm_choose + ' label span').each(function() {
                        if($(this).text() == this_value)
                            group_exists = true;
                    });
                    
                    // Create a new checked checkbox
                    if(!group_exists)
                        $(bm_choose).prepend('<label><input type="checkbox" data-group="' + escaped_value + '" /><span>' + this_value.htmlEnc() + '</span></label>');
                    
                    // Check the checkbox
                    $(bm_choose + ' input[data-group="' + escaped_value + '"]').attr('checked', true);
                    
                    // Reset the value of this input
                    $(this).val('');
                    
                    return false;
                }
            });
            
            // Click events
            $(manage_infos + ' p.bm-authorize a.to').click(function() {
                Bubble.close();
                Presence.sendSubscribe(xid, 'subscribed');
                
                return false;
            });
            
            $(manage_infos + ' p.bm-authorize a.from').click(function() {
                Bubble.close();
                Presence.sendSubscribe(xid, 'subscribe');
                
                return false;
            });
            
            $(manage_infos + ' p.bm-authorize a.unblock').click(function() {
                Bubble.close();
                
                // Update privacy settings
                Privacy.push('block', ['jid'], [xid], ['allow'], [false], [true], [true], [true], '', 'roster');
                $(path).removeClass('blocked');
                
                // Enable the "block" list
                Privacy.change('block', 'active');
                Privacy.change('block', 'default');
                
                // Send an available presence
                Presence.send(xid, 'available', Presence.getUserShow(), getUserStatus());
                
                return false;
            });
            
            $(manage_infos + ' p.bm-remove a.remove').click(function() {
                Bubble.close();
                
                // First unregister if gateway
                if(Common.isGateway(xid))
                    self.unregisterGateway(xid);
                
                // Then send roster removal query
                self.send(xid, 'remove');
                
                return false;
            });
            
            $(manage_infos + ' p.bm-remove a.prohibit').click(function() {
                Bubble.close();
                Presence.sendSubscribe(xid, 'unsubscribed');
                
                return false;
            });
            
            $(manage_infos + ' p.bm-remove a.block').click(function() {
                Bubble.close();
                
                // Update privacy settings
                Privacy.push('block', ['jid'], [xid], ['deny'], [false], [true], [true], [true], '', 'roster');
                $(path).addClass('blocked');
                
                // Enable the "block" list
                Privacy.change('block', 'active');
                Privacy.change('block', 'default');
                
                // Send an unavailable presence
                Presence.send(xid, 'unavailable');
                
                // Remove the user presence
                var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'presence' + ('_(.+)'));

                for(var i = 0; i < DataStore.storageDB.length; i++) {
                    // Get the pointer values
                    var current = DataStore.storageDB.key(i);
                    
                    // If the pointer is on a stored presence
                    if(current.match(db_regex)) {
                        if(Common.bareXID(RegExp.$1) == xid)
                            DataStore.storageDB.removeItem(current);
                    }
                }
                
                // Manage his new presence
                Presence.funnel(xid, hex_md5(xid));
                
                return false;
            });
            
            $(manage_infos + ' a.save').click(function() {
                // Send the item
                self.send(xid, '', $.trim($(rename).val()), self.thisBuddyGroups(xid));
                
                // Remove the buddy editor
                Bubble.close();
                
                return false;
            });
        } catch(e) {
            Console.error('Roster.applyBuddyInput', e);
        }

    };


    /**
     * Applies the buddy editing hover events
     * @public
     * @param {string} xid
     * @param {string} hash
     * @param {string} nick
     * @param {string} subscription
     * @param {object} groups
     * @param {string} group_hash
     * @return {undefined}
     */
    self.applyBuddyHover = function(xid, hash, nick, subscription, groups, group_hash) {

        try {
            // Generate the values
            var bPath = '#roster .' + group_hash + ' .buddy[data-xid="' + escape(xid) + '"]';
            var iPath = bPath + ' .buddy-infos';
            
            // Apply the hover event
            $(bPath).hover(function() {
                // Another bubble exist
                if(Common.exists('#roster .buddy-infos'))
                    return false;
                
                $(bPath).oneTime(200, function() {
                    // Another bubble exist
                    if(Common.exists('#roster .buddy-infos'))
                        return false;
                    
                    // Add this bubble!
                    Bubble.show(iPath);
                    
                    // Create the buddy infos DOM element
                    $(bPath).append(
                        '<div class="buddy-infos bubble removable">' + 
                            '<div class="buddy-infos-subarrow talk-images"></div>' + 

                            '<div class="buddy-infos-subitem">' + 
                                '<div class="pep-infos">' + 
                                    '<p class="bi-status talk-images unavailable">' + Common._e("unknown") + '</p>' + 
                                    '<p class="bi-mood talk-images mood-four">' + Common._e("unknown") + '</p>' + 
                                    '<p class="bi-activity talk-images activity-exercising">' + Common._e("unknown") + '</p>' + 
                                    '<p class="bi-tune talk-images tune-note">' + Common._e("unknown") + '</p>' + 
                                    '<p class="bi-geoloc talk-images location-world">' + Common._e("unknown") + '</p>' + 
                                    '<p class="bi-jingle talk-images call-jingle"><a href="#" class="audio">' + Common._e("Audio Call") + '</a><span class="separator"> / </span><a href="#" class="video">' + Common._e("Video Call") + '</a>' + 
                                    '<p class="bi-view talk-images view-individual"><a href="#" class="profile">' + Common._e("Profile") + '</a> / <a href="#" class="channel">' + Common._e("Channel") + '</a> / <a href="#" class="commands">' + Common._e("Commands") + '</a></p>' + 
                                    '<p class="bi-edit talk-images edit-buddy"><a href="#">' + Common._e("Edit") + '</a></p>' + 
                                '</div>' + 
                            '</div>' + 
                        '</div>'
                    );
                    
                    // Sets the good position
                    self.buddyInfosPosition(xid, group_hash);
                    
                    // Get the presence
                    Presence.funnel(xid, hash);
                    
                    // Get the PEP infos
                    PEP.displayAll(xid);
                    
                    // Click events
                    $(bPath + ' .bi-view a').click(function() {
                        // Renitialize the buddy infos
                        Bubble.close();
                        
                        // Profile
                        if($(this).is('.profile'))
                            UserInfos.open(xid);
                        
                        // Channel
                        else if($(this).is('.channel'))
                            Microblog.fromInfos(xid, hash);
                        
                        // Command
                        else if($(this).is('.commands'))
                            AdHoc.retrieve(xid);
                        
                        return false;
                    });

                    // Jingle events
                    $(bPath + ' .bi-jingle a').click(function() {
                        // Renitialize the buddy infos
                        Bubble.close();
                        
                        // Audio call?
                        if($(this).is('.audio'))
                            Jingle.start(xid, 'audio');
                        
                        // Video call?
                        else if($(this).is('.video'))
                            Jingle.start(xid, 'video');
                        
                        return false;
                    });
                    
                    $(bPath + ' .bi-edit a').click(function() {
                        self.buddyEdit(xid, nick, subscription, groups);
                        
                        return false;
                    });
                });
            }, function() {
                if(!Common.exists(iPath + ' .manage-infos'))
                    Bubble.close();
                
                $(bPath).stopTime();
            });
        } catch(e) {
            Console.error('Roster.applyBuddyHover', e);
        }

    };


    /**
     * Sets the good buddy-infos position
     * @public
     * @param {string} xid
     * @param {string} group_hash
     * @return {undefined}
     */
    self.buddyInfosPosition = function(xid, group_hash) {

        try {
            // Paths
            var group = '#roster .' + group_hash;
            var buddy = group + ' .buddy[data-xid="' + escape(xid) + '"]';
            var buddy_infos = buddy + ' .buddy-infos';
            
            // Get the offset to define
            var offset = 3;
            
            if(Common.isGateway(xid))
                offset = -8;
            
            // Process the position
            var v_position = $(buddy).position().top + offset;
            var h_position = $(buddy).width() - 10;
            
            // Apply the top position
            $(buddy_infos).css('top', v_position);

            // Apply the left/right position
            if($('html').attr('dir') == 'rtl')
                $(buddy_infos).css('right', h_position);
            else
                $(buddy_infos).css('left', h_position);
        } catch(e) {
            Console.error('Roster.buddyInfosPosition', e);
        }

    };


    /**
     * Generates an array of the current groups of a buddy
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.thisBuddyGroups = function(xid) {

        try {
            var path = '#roster .buddy[data-xid="' + escape(xid) + '"] ';
            var array = [];
            
            // Each checked checkboxes
            $(path + 'div.bm-choose input[type="checkbox"]').filter(':checked').each(function() {
                array.push(unescape($(this).attr('data-group')));
            });
            
            // Entered input value (and not yet in the array)
            var value = $.trim($(path + 'p.bm-group input').val());
            
            if(value && !Utils.existArrayValue(array, value))
                array.push(value);
            
            return array;
        } catch(e) {
            Console.error('Roster.thisBuddyGroups', e);
        }

    };


    /**
     * Adds a given contact to our roster
     * @public
     * @param {string} xid
     * @param {string} name
     * @return {undefined}
     */
    self.addThisContact = function(xid, name) {

        try {
            Console.info('Add this contact: ' + xid + ', as ' + name);
            
            // Cut the resource of this XID
            xid = Common.bareXID(xid);
            
            // If the form is complete
            if(xid) {
                // We send the subscription
                Presence.sendSubscribe(xid, 'subscribe');
                self.send(xid, '', name);
                
                // We hide the bubble
                Bubble.close();
            }
        } catch(e) {
            Console.error('Roster.addThisContact', e);
        }

    };


    /**
     * Gets an array of all the groups in the roster
     * @public
     * @param {type} name
     * @return {undefined}
     */
    self.getAllGroups = function() {

        try {
            var groups = [];
            
            $('#roster .one-group').each(function() {
                var current = unescape($(this).attr('data-group'));
                
                if((current != Common._e("Unclassified")) && (current != Common._e("Gateways")))
                    groups.push(current);
            });
            
            return groups.sort();
        } catch(e) {
            Console.error('Roster.getAllGroups', e);
        }

    };


    /**
     * Edits buddy informations
     * @public
     * @param {string} xid
     * @param {string} nick
     * @param {string} subscription
     * @param {object} groups
     * @return {undefined}
     */
    self.buddyEdit = function(xid, nick, subscription, groups) {

        try {
            Console.info('Buddy edit: ' + xid);
            
            // Initialize
            var path = '#roster .buddy[data-xid="' + escape(xid) + '"] .';
            var html = '<div class="manage-infos">';
            
            // Get the privacy state
            var privacy_state = Privacy.status('block', xid);
            var privacy_active = DataStore.getDB(Connection.desktop_hash, 'privacy-marker', 'available');
            
            // Get the group privacy state
            for(var g in groups) {
                if((Privacy.status('block', groups[g]) == 'deny') && (privacy_state != 'allow'))
                    privacy_state = 'deny';
            }
            
            // The subscription with this buddy is not full
            if((subscription != 'both') || ((privacy_state == 'deny') && privacy_active)) {
                var authorize_links = '';
                html += '<p class="bm-authorize talk-images">';
                
                // Link to allow to see our status
                if((subscription == 'to') || (subscription == 'none'))
                    authorize_links += '<a href="#" class="to">' + Common._e("Authorize") + '</a>';
                
                // Link to ask to see his/her status
                if((subscription == 'from') || (subscription == 'none')) {
                    if(authorize_links)
                        authorize_links += ' / ';
                    
                    authorize_links += '<a href="#" class="from">' + Common._e("Ask for authorization") + '</a>';
                }
                
                // Link to unblock this buddy
                if((privacy_state == 'deny') && privacy_active) {
                    if(authorize_links)
                        authorize_links += ' / ';
                    
                    html += '<a href="#" class="unblock">' + Common._e("Unblock") + '</a>';
                }
                
                html += authorize_links + '</p>';
            }
            
            // Complete the HTML code
            var remove_links = '';
            html += '<p class="bm-remove talk-images">';
            remove_links = '<a href="#" class="remove">' + Common._e("Remove") + '</a>';
            
            // This buddy is allowed to see our presence, we can show a "prohibit" link
            if((subscription == 'both') || (subscription == 'from'))
                remove_links += ' / <a href="#" class="prohibit">' + Common._e("Prohibit") + '</a>';
            
            // Complete the HTML code
            if((privacy_state != 'deny') && privacy_active) {
                if(remove_links)
                    remove_links += ' / ';
                
                remove_links += '<a href="#" class="block">' + Common._e("Block") + '</a>';
            }
            
            // Complete the HTML code
            html += remove_links + 
                '</p>' + 
                '<p class="bm-rename talk-images"><label>' + Common._e("Rename") + '</label> <input type="text" value="' + Common.encodeQuotes(nick) + '" /></p>';
            
            // Only show group tool if not a gateway
            if(!Common.isGateway(xid))
                html += '<p class="bm-group talk-images"><label>' + Common._e("Groups") + '</label> <input type="text" /></p>' + 
                    '<div class="bm-choose">' + 
                        '<div></div>' + 
                    '</div>';
            
            // Close the DOM element
            html += '<a href="#" class="save">' + Common._e("Save") + '</a>' + 
                '</div>';
            
            // We update the DOM elements
            $(path + 'pep-infos').replaceWith(html);
            
            // Gets all the existing groups
            var all_groups = self.getAllGroups();
            var all_groups_dom = '';
            
            for(var a in all_groups) {
                // Current group
                var all_groups_current = all_groups[a];
                
                // Is the current group checked?
                var checked = '';
                
                if(Utils.existArrayValue(groups, all_groups_current))
                    checked = ' checked="true"';
                
                // Add the current group HTML
                all_groups_dom += '<label><input type="checkbox" data-group="' + escape(all_groups_current) + '"' + checked + ' /><span>' + all_groups_current.htmlEnc() + '</span></label>';
            }
            
            // Prepend this in the DOM
            var bm_choose = path + 'manage-infos div.bm-choose';
            
            $(bm_choose).prepend(all_groups_dom);
            
            // Apply the editing input events
            self.applyBuddyInput(xid);
        } catch(e) {
            Console.error('Roster.buddyEdit', e);
        }

    };


    /**
     * Unregisters from a given gateway
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.unregisterGateway = function(xid) {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            iq.setTo(xid);
            
            var query = iq.setQuery(NS_REGISTER);
            query.appendChild(iq.buildNode('remove', {'xmlns': NS_REGISTER}));
            
            con.send(iq);
        } catch(e) {
            Console.error('Roster.unregisterGateway', e);
        }

    };


    /**
     * Updates the roster items
     * @public
     * @param {string} xid
     * @param {string} subscription
     * @param {string} name
     * @param {string} group
     * @return {undefined}
     */
    self.send = function(xid, subscription, name, group) {

        try {
            // We send the new buddy name
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var iqQuery = iq.setQuery(NS_ROSTER);
            var item = iqQuery.appendChild(iq.buildNode('item', {'xmlns': NS_ROSTER, 'jid': xid}));
            
            // Any subscription?
            if(subscription)
                item.setAttribute('subscription', subscription);
            
            // Any name?
            if(name)
                item.setAttribute('name', name);
            
            // Any group?
            if(group && group.length) {
                for(var i in group)
                    item.appendChild(iq.buildNode('group', {'xmlns': NS_ROSTER}, group[i]));
            }
            
            con.send(iq);
            
            Console.info('Roster item sent: ' + xid);
        } catch(e) {
            Console.error('Roster.send', e);
        }

    };


    /**
     * Adapts the roster height, depending of the window size
     * @public
     * @return {undefined}
     */
    self.adapt = function() {

        try {
            // Process the new height
            var new_height = $('#left-content').height() - $('#my-infos').height() - 97;
            
            // New height too small
            if(new_height < 211)
                new_height = 211;
            
            // Apply the new height
            $('#roster .content').css('height', new_height);
        } catch(e) {
            Console.error('Roster.adapt', e);
        }

    };


    /**
     * Gets all the buddies in our roster
     * @public
     * @return {object}
     */
    self.getAllBuddies = function() {

        try {
            var buddies = [];
    
            $('#roster .buddy').each(function() {
                var xid = unescape($(this).attr('data-xid'));
                
                if(xid) {
                    buddies.push(xid);
                }
            });
            
            return buddies;
        } catch(e) {
            Console.error('Roster.getAllBuddies', e);
        }

    };


    /**
     * Returns whether given XID is in buddy list or not
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.isFriend = function(xid) {

        try {
            return Common.exists('#roster .buddy[data-xid="' + escape(xid) + '"]');
        } catch(e) {
            Console.error('Roster.isFriend', e);
        }

    };


    /**
     * Gets the user gateways
     * @public
     * @return {object}
     */
    self.getGateways = function() {

        try {
            // New array
            var gateways = [];
            var buddies = self.getAllBuddies();
            
            // Get the gateways
            for(var c in buddies) {
                if(Common.isGateway(buddies[c])) {
                    gateways.push(buddies[c]);
                }
            }
            
            return gateways;
        } catch(e) {
            Console.error('Roster.getGateways', e);
        }

    };


    /**
     * Instanciate the roster
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Filtering tool
            var iFilter = $('#roster .filter input');
            var aFilter = $('#roster .filter a');
            
            iFilter.placeholder()
            
            .blur(function() {
                // Nothing is entered, put the placeholder instead
                if(!$.trim($(this).val()))
                    aFilter.hide();
                else
                    aFilter.show();
            })
            
            .keyup(function(e) {
                Search.funnelFilterBuddy(e.keyCode);
            });
            
            aFilter.click(function() {
                // Reset the input
                $(this).hide();
                iFilter.val('');
                iFilter.placeholder();
                
                // Security: show all the groups, empty or not
                $('#roster .one-group').show();
                
                // Reset the filtering tool
                Search.resetFilterBuddy();
                
                return false;
            });
            
            // When the user click on the add button, show the contact adding tool
            $('#roster .foot .add').click(function() {
                // Yet displayed?
                if(Common.exists('#buddy-conf-add'))
                    return Bubble.close();
                
                // Add the bubble
                Bubble.show('#buddy-conf-add');
                
                // Append the content
                $('#roster .roster-add').append(
                    '<div id="buddy-conf-add" class="buddy-conf-item bubble removable">' + 
                        '<div class="buddy-conf-subarrow talk-images"></div>' + 
                        
                        '<div class="buddy-conf-subitem">' + 
                            '<p class="buddy-conf-p">' + Common._e("Add a friend") +  '</p>' + 
                            
                            '<label><span>' + Common._e("Address") +  '</span><input type="text" class="buddy-conf-input add-contact-jid" required="" /></label>' + 
                            '<label><span>' + Common._e("Name") +  '</span><input type="text" class="buddy-conf-input add-contact-name" /></label>' +  
                            '<label>' + 
                                '<span>' + Common._e("Gateway") +  '</span>' + 
                                '<select class="buddy-conf-select add-contact-gateway">' + 
                                    '<option value="none" selected="">' + Common._e("None") +  '</option>' + 
                                '</select>' + 
                            '</label>' +  
                            '<span class="add-contact-name-get">' + Common._e("Getting the name...") + '</span>' + 
                            
                            '<p class="buddy-conf-text">' + 
                                '<a href="#" class="buddy-conf-add-search">' + Common._e("Search a friend") +  '</a>' + 
                            '</p>' + 
                        '</div>' + 
                    '</div>'
                );
                
                // Add the gateways
                var gateways = self.getGateways();
                
                // Any gateway?
                if(gateways.length) {
                    // Append the gateways
                    for(var i in gateways) {
                        $('.add-contact-gateway').append('<option value="' + escape(gateways[i]) + '">' + gateways[i].htmlEnc() +  '</option>');
                    }
                    
                    // Show the gateway selector
                    $('.add-contact-gateway').parent().show();
                } else {
                    $('.add-contact-gateway').parent().hide();
                }
                
                // Blur event on the add contact input
                $('.add-contact-jid').blur(function() {
                    // Read the value
                    var value = $.trim($(this).val());
                    
                    // Try to catch the buddy name
                    if(value && !$.trim($('.add-contact-name').val()) && ($('.add-contact-gateway').val() == 'none')) {
                        // User XID
                        var xid = Common.generateXID(value, 'chat');
                        
                        // Notice for the user
                        $('.add-contact-name-get').attr('data-for', escape(xid)).show();
                        
                        // Request the user vCard
                        Name.getAddUser(xid);
                    }
                });
                
                // When a key is pressed...
                $('#buddy-conf-add input, #buddy-conf-add select').keyup(function(e) {
                    // Enter : continue
                    if(e.keyCode == 13) {
                        // Get the values
                        var xid = $.trim($('.add-contact-jid').val());
                        var name = $.trim($('.add-contact-name').val());
                        var gateway = unescape($('.add-contact-gateway').val());
                        
                        // Generate the XID to add
                        if((gateway != 'none') && xid)
                            xid = xid.replace(/@/g, '%') + '@' + gateway;
                        else
                            xid = Common.generateXID(xid, 'chat');
                        
                        // Submit the form
                        if(xid && Common.getXIDNick(xid) && (xid != Common.getXID()))
                            self.addThisContact(xid, name);
                        else
                            $(document).oneTime(10, function() {
                                $('.add-contact-jid').addClass('please-complete').focus();
                            });
                        
                        return false;
                    }
                    
                    // Escape : quit
                    if(e.keyCode == 27)
                        Bubble.close();
                });
                
                // Click event on search link
                $('.buddy-conf-add-search').click(function() {
                    Bubble.close();
                    return Directory.open();
                });
                
                // Focus on the input
                $(document).oneTime(10, function() {
                    $('.add-contact-jid').focus();
                });
                
                return false;
            });
            
            // When the user click on the join button, show the chat joining tool
            $('#roster .foot .join').click(function() {
                // Yet displayed?
                if(Common.exists('#buddy-conf-join'))
                    return Bubble.close();
                
                // Add the bubble
                Bubble.show('#buddy-conf-join');
                
                // Append the content
                $('#roster .roster-join').append(
                    '<div id="buddy-conf-join" class="buddy-conf-item bubble removable">' + 
                        '<div class="buddy-conf-subarrow talk-images"></div>' + 
                        
                        '<div class="buddy-conf-subitem search">' + 
                            '<p class="buddy-conf-p" style="margin-bottom: 0;">' + Common._e("Join a chat") +  '</p>' + 
                            
                            '<input type="text" class="buddy-conf-input join-jid" required="" />' + 
                            '<select class="buddy-conf-select buddy-conf-join-select join-type">' + 
                                '<option value="chat" selected="">' + Common._e("Chat") +  '</option>' + 
                                '<option value="groupchat">' + Common._e("Groupchat") +  '</option>' + 
                            '</select>' + 
                        '</div>' + 
                    '</div>'
                );
                
                // Input vars
                var destination = '#buddy-conf-join .search';
                var dHovered = destination + ' ul li.hovered:first';
                
                // When a key is pressed...
                $('#buddy-conf-join input, #buddy-conf-join select').keyup(function(e) {
                    // Enter: continue
                    if(e.keyCode == 13) {
                        // Select something from the search
                        if(Common.exists(dHovered)) {
                            Search.addBuddy(destination, $(dHovered).attr('data-xid'));
                        }
                        
                        // Join something
                        else {
                            var xid = $.trim($('.join-jid').val());
                            var type = $('.buddy-conf-join-select').val();
                            
                            if(xid && type) {
                                // Generate a correct XID
                                xid = Common.generateXID(xid, type);
                                
                                // Not me
                                if(xid != Common.getXID()) {
                                    // Update some things
                                    $('.join-jid').removeClass('please-complete');
                                    Bubble.close();
                                    
                                    // Create a new chat
                                    Chat.checkCreate(xid, type);
                                }
                                
                                else {
                                    $('.join-jid').addClass('please-complete');
                                }
                            }
                            
                            else {
                                $('.join-jid').addClass('please-complete');
                            }
                        }
                        
                        return false;
                    }
                    
                    // Escape: quit
                    else if(e.keyCode == 27)
                        Bubble.close();
                    
                    // Buddy search?
                    else if($('.buddy-conf-join-select').val() == 'chat') {
                        // New buddy search
                        if((e.keyCode != 40) && (e.keyCode != 38))
                            Search.createBuddy(destination);
                        
                        // Navigating with keyboard in the results
                        Search.arrowsBuddy(e, destination);
                    }
                });
                
                // Buddy search lost focus
                $('#buddy-conf-join input').blur(function() {
                    if(!$(destination + ' ul').attr('mouse-hover'))
                        Search.resetBuddy(destination);
                });
                
                // Re-focus on the text input
                $('#buddy-conf-join select').change(function() {
                    $(document).oneTime(10, function() {
                        $('#buddy-conf-join input').focus();
                    });
                });
                
                // We focus on the input
                $(document).oneTime(10, function() {
                    $('#buddy-conf-join .join-jid').focus();
                });
                
                return false;
            });
            
            // When the user click on the groupchat button, show the groupchat menu
            $('#roster .foot .groupchat').click(function() {
                // Yet displayed?
                if(Common.exists('#buddy-conf-groupchat'))
                    return Bubble.close();
                
                // Add the bubble
                Bubble.show('#buddy-conf-groupchat');
                
                // Append the content
                $('#roster .roster-groupchat').append(
                    '<div id="buddy-conf-groupchat" class="buddy-conf-item bubble removable">' + 
                        '<div class="buddy-conf-subarrow talk-images"></div>' + 
                        
                        '<div class="buddy-conf-subitem">' + 
                            '<p class="buddy-conf-p">' + Common._e("Your groupchats") +  '</p>' + 
                            
                            '<select name="groupchat-join" class="buddy-conf-select buddy-conf-groupchat-select"></select>' + 
                            
                            '<p class="buddy-conf-text">' + 
                                '- <a href="#" class="buddy-conf-groupchat-edit">' + Common._e("Manage your favorite groupchats") +  '</a>' + 
                            '</p>' + 
                        '</div>' + 
                    '</div>'
                );
                
                // When the user wants to edit his groupchat favorites
                $('.buddy-conf-groupchat-edit').click(function() {
                    Favorites.open();
                    Bubble.close();
                    
                    return false;
                });
                
                // Change event
                $('.buddy-conf-groupchat-select').change(function() {
                    var groupchat = $.trim($(this).val());
                    
                    if(groupchat != 'none') {
                        // We hide the bubble
                        Bubble.close();
                        
                        // Create the chat
                        Chat.checkCreate(groupchat, 'groupchat');
                        
                        // We reset the select value
                        $(this).val('none');
                    }
                });
                
                // Load the favorites
                Favorites.load();
                
                return false;
            });
            
            // When the user click on the more button, show the more menu
            $('#roster .foot .more').click(function() {
                // Yet displayed?
                if(Common.exists('#buddy-conf-more'))
                    return Bubble.close();
                
                // Add the bubble
                Bubble.show('#buddy-conf-more');
                
                // Append the content
                $('#roster .roster-more').append(
                    '<div id="buddy-conf-more" class="buddy-conf-item bubble removable">' + 
                        '<div class="buddy-conf-subarrow talk-images"></div>' + 
                        
                        '<div class="buddy-conf-subitem">' + 
                            '<p class="buddy-conf-p">' + Common._e("More stuff") +  '</p>' + 
                            
                            '<p class="buddy-conf-text">' + 
                                '- <a href="#" class="buddy-conf-more-display-unavailable">' + Common._e("Show all friends") +  '</a>' + 
                                '<a href="#" class="buddy-conf-more-display-available">' + Common._e("Only show connected friends") +  '</a>' + 
                            '</p>' + 
                            
                            '<p class="buddy-conf-text privacy-hidable">' + 
                                '- <a href="#" class="buddy-conf-more-privacy">' + Common._e("Privacy") +  '</a>' + 
                            '</p>' + 
                            
                            '<p class="buddy-conf-text">' + 
                                '- <a href="#" class="buddy-conf-more-service-disco">' + Common._e("Service discovery") +  '</a>' + 
                            '</p>' + 
                            
                            '<p class="buddy-conf-text commands-hidable"">' + 
                                '- <a href="#" class="buddy-conf-more-commands">' + Common._e("Commands") +  '</a>' + 
                            '</p>' + 
                        '</div>' + 
                    '</div>'
                );
                
                // Close bubble when link clicked
                $('#buddy-conf-more a').click(function() {
                    Bubble.close();
                });
                
                // When the user wants to display all his buddies
                $('.buddy-conf-more-display-unavailable').click(function() {
                    Interface.showAllBuddies('roster');
                    
                    return false;
                });
                
                // When the user wants to display only online buddies
                $('.buddy-conf-more-display-available').click(function() {
                    Interface.showOnlineBuddies('roster');
                    
                    return false;
                });
                
                // When the user click on the privacy link
                $('.buddy-conf-more-privacy').click(Privacy.open);
                
                // When the user click on the service discovery link
                $('.buddy-conf-more-service-disco').click(Discovery.open);
                
                // When the user click on the command link
                $('.buddy-conf-more-commands').click(function() {
                    AdHoc.server(con.domain);
                    
                    return false;
                });
                
                // Manage the displayed links
                if(self.blist_all) {
                    $('.buddy-conf-more-display-unavailable').hide();
                    $('.buddy-conf-more-display-available').show();
                }
                
                if(Features.enabledCommands())
                    $('.buddy-conf-more-commands').parent().show();
                
                if(DataStore.getDB(Connection.desktop_hash, 'privacy-marker', 'available'))
                    $('.buddy-conf-more-privacy').parent().show();
                
                return false;
            });
            
            // When the user scrolls the buddy list
            $('#roster .content').scroll(function() {
                // Close the opened buddy infos bubble
                Bubble.close();
            });
        } catch(e) {
            Console.error('Roster.instance', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            // Window resize event handler
            $(window).resize(self.adapt);
        } catch(e) {
            Console.error('Roster.launch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

Roster.launch();
/*

Jappix - An open social platform
These are the Jingle helpers & launchers

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Jingle = (function() {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self._jingle_current = null;
    self._start_stamp = 0;
    self._call_ender = null;
    self._bypass_termination_notify = false;


    /**
     * Provides an adapter to the JSJaCJingle console implementation which is different
     * @private
     * @return {object}
     */
    self._consoleAdapter = (function() {

        /**
         * Alias of this
         * @private
         */
        var _console = {};


        /**
         * Console logging interface (adapted)
         * @public
         * @param {string} message
         * @param {number} loglevel
         * @return {undefined}
         */
        _console.log = function(message, loglevel) {

            try {
                if(!message) {
                    throw 'No message passed to console adapter!';
                }

                switch(loglevel) {
                    case 0:
                        Console.warn(message); break;
                    case 1:
                        Console.error(message); break;
                    case 2:
                        Console.info(message); break;
                    case 4:
                        Console.debug(message); break;
                    default:
                        Console.log(message);
                }
            } catch(e) {
                Console.error('Jingle._consoleAdapter.log', e);
            }

        };


        /**
         * Return sub-class scope
         */
        return _console;

    })();


    /**
     * Opens the Jingle interface (depending on the state)
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            var jingle_tool_sel = $('#top-content .tools.jingle');

            if(jingle_tool_sel.is('.active')) {
                Console.info('Opened Jingle notification drawer');
            } else if(jingle_tool_sel.is('.streaming.video')) {
                // Videobox?
                self.showInterface();

                Console.info('Opened Jingle videobox');
            } else {
                Console.warn('Could not open any Jingle tool (race condition on state)');
            }
        } catch(e) {
            Console.error('Jingle.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Returns the Jingle session arguments (used to configure it)
     * @private
     * @param connection
     * @param xid
     * @param hash
     * @param local_view
     * @param remote_view
     * @return {object}
     */
    self._args = function(connection, xid, hash, media, local_view, remote_view) {

        args = {};

        try {
            // Network configuration
            var stun = {};
            var turn = {};

            if(HOST_STUN) {
                stun[HOST_STUN] = {};
            }

            if(HOST_TURN) {
                turn[HOST_TURN] = {
                    'username': HOST_TURN_USERNAME,
                    'credential': HOST_TURN_PASSWORD
                };
            }

            // Jingle arguments
            args = {
                // Configuration (required)
                connection: connection,
                to: xid,
                media: media,
                local_view: local_view,
                remote_view: remote_view,
                stun: stun,
                turn: turn,
                //resolution: 'hd', -> this can cause some lags
                debug: self._consoleAdapter,

                // Custom handlers (optional)
                session_initiate_pending: function(jingle) {
                    self.notify(
                        Common.bareXID(jingle.get_to()),
                        'initiating',
                        jingle.get_media()
                    );

                    Console.log('Jingle._args', 'session_initiate_pending');
                },

                session_initiate_success: function(jingle, stanza) {
                    // Already in a call?
                    if(self.in_call() && !self.is_same_sid(jingle)) {
                        jingle.terminate(JSJAC_JINGLE_REASON_BUSY);

                        Console.warn('session_initiate_success', 'Dropped incoming call (already in a call)');
                    } else {
                        // Incoming call?
                        if(jingle.is_responder()) {
                            self.notify(
                                Common.bareXID(jingle.get_to()),
                                ('call_' + jingle.get_media()),
                                jingle.get_media()
                            );

                            // Play ringtone
                            // Hard-fix: avoids the JSJaC packets group timer (that will delay success reply)
                            setTimeout(function() {
                                Audio.play('incoming-call', true);
                                jingle.info(JSJAC_JINGLE_SESSION_INFO_RINGING);
                            }, 250);
                        } else {
                            self.notify(
                                Common.bareXID(jingle.get_to()),
                                'waiting',
                                jingle.get_media()
                            );

                            // Play wait ringtone
                            Audio.play('outgoing-call', true);
                        }
                    }
                    
                    Console.log('Jingle._args', 'session_initiate_success');
                },

                session_initiate_error: function(jingle, stanza) {
                    self._reset();

                    self.notify(
                        Common.bareXID(jingle.get_to()),
                        'error',
                        jingle.get_media()
                    );

                    Console.log('Jingle._args', 'session_initiate_error');
                },

                session_initiate_request: function(jingle, stanza) {
                    Console.log('Jingle._args', 'session_initiate_request');
                },

                session_accept_pending: function(jingle) {
                    self.notify(
                        Common.bareXID(jingle.get_to()),
                        'waiting',
                        jingle.get_media()
                    );

                    Console.log('Jingle._args', 'session_accept_pending');
                },

                session_accept_success: function(jingle, stanza) {
                    self.unnotify();

                    // Start call! Go Go Go!
                    self._startSession(jingle.get_media());
                    self.showInterface();
                    self._startCounter();

                    Console.log('Jingle._args', 'session_accept_success');
                },

                session_accept_error: function(jingle, stanza) {
                    self._reset();

                    self.notify(
                        Common.bareXID(jingle.get_to()),
                        'declined',
                        jingle.get_media()
                    );

                    Console.log('Jingle._args', 'session_accept_error');
                },

                session_accept_request: function(jingle, stanza) {
                    Console.log('Jingle._args', 'session_accept_request');
                },

                session_info_success: function(jingle, stanza) {
                    Console.log('Jingle._args', 'session_info_success');
                },

                session_info_error: function(jingle, stanza) {
                    Console.log('Jingle._args', 'session_info_error');
                },

                session_info_request: function(jingle, stanza) {
                    var info_name = jingle.util_stanza_session_info(stanza);

                    switch(info_name) {
                        // Ringing?
                        case JSJAC_JINGLE_SESSION_INFO_RINGING:
                            self.notify(
                                Common.bareXID(jingle.get_to()),
                                'ringing',
                                jingle.get_media()
                            );
                            break;
                    }

                    Console.log('Jingle._args', 'session_info_request');
                },

                session_terminate_pending: function(jingle) {
                    self._reset();

                    self.notify(
                        Common.bareXID(jingle.get_to()),
                        'ending',
                        jingle.get_media()
                    );

                    Console.log('Jingle._args', 'session_terminate_pending');
                },

                session_terminate_success: function(jingle, stanza) {
                    // Ensure we this is the same call session ID (SID)
                    if(self._jingle_current.get_sid() == jingle.get_sid()) {
                        if(self._bypass_termination_notify !== true) {
                            self._reset();

                            self.notify(
                                Common.bareXID(jingle.get_to()),
                                (self._call_ender === 'remote' ? 'remote_ended' : 'local_ended'),
                                jingle.get_media()
                            );
                        }

                        Console.debug('Stopped current Jingle call');
                    } else {
                        Console.warn('session_terminate_success', 'Dropped stanza with unmatching SID');
                    }

                    Console.log('Jingle._args', 'session_terminate_success');
                },

                session_terminate_error: function(jingle, stanza) {
                     // Ensure we this is the same call session ID (SID)
                    if(self._jingle_current.get_sid() == jingle.get_sid()) {
                        if(self._bypass_termination_notify !== true) {
                            self._reset();

                            self.notify(
                                Common.bareXID(jingle.get_to()),
                                'error',
                                jingle.get_media()
                            );
                        }

                        Console.warn('Stopped current Jingle call, but with brute force!');
                    } else {
                        Console.warn('session_terminate_error', 'Dropped stanza with unmatching SID');
                    }

                    Console.log('Jingle._args', 'session_terminate_error');
                },

                session_terminate_request: function(jingle, stanza) {
                    var notify_type;
                    var reason = jingle.util_stanza_terminate_reason(stanza);

                    // The remote wants to end call
                    self._call_ender = 'remote';

                    // Notify depending on the termination reason
                    switch(reason) {
                        case JSJAC_JINGLE_REASON_CANCEL:
                            notify_type = 'remote_canceled'; break;
                        case JSJAC_JINGLE_REASON_BUSY:
                            notify_type = 'busy'; break;
                        case JSJAC_JINGLE_REASON_DECLINE:
                            notify_type = 'declined'; break;
                        default:
                            notify_type = 'ending'; break;
                    }

                    self._reset();

                    // Anything to notify?
                    if(notify_type !== undefined) {
                        if(notify_type !== 'ending') {
                            self._bypass_termination_notify = true;
                        }

                        self.notify(
                            Common.bareXID(jingle.get_to()),
                            notify_type,
                            jingle.get_media()
                        );
                    }

                    Console.log('Jingle._args', 'session_terminate_request');
                }
            };
        } catch(e) {
            Console.error('Jingle._args', e);
        } finally {
            return args;
        }

    };


    /**
     * Launch a new Jingle session with given buddy
     * @private
     * @param xid
     * @param mode
     * @param is_callee
     * @param stanza
     * @return {boolean}
     */
    self._new = function(xid, mode, is_callee, stanza) {

        var status = false;

        try {
            if(!xid) {
                throw 'No XID to be called given!';
            }

            var bare_xid    = Common.bareXID(xid);
            var full_xid    = xid;
            var bare_hash   = hex_md5(bare_xid);

            // Caller mode?
            if(!is_callee && !Common.isFullXID(full_xid)) {
                var jingle_ns = (mode == 'audio') ? NS_JINGLE_APPS_RTP_AUDIO : NS_JINGLE_APPS_RTP_VIDEO;
                full_xid = Caps.getFeatureResource(bare_xid, jingle_ns);

                if(!full_xid) {
                    throw 'Could not get user full XID to be called!';
                }
            }

            // Create interface for video containers
            $('body').addClass('in_jingle_call');
            var jingle_sel = self.createInterface(bare_xid, mode);

            // Filter media
            var media = null;

            switch(mode) {
                case 'audio':
                    media = JSJAC_JINGLE_MEDIA_AUDIO; break;
                case 'video':
                    media = JSJAC_JINGLE_MEDIA_VIDEO; break;
            }

            // Start the Jingle negotiation
            var args = self._args(
                                   con,
                                   full_xid,
                                   bare_hash,
                                   media,
                                   jingle_sel.find('.local_video video')[0],
                                   jingle_sel.find('.remote_video video')[0]
                                 );

            self._jingle_current = new JSJaCJingle(args);
            self._call_ender = null;
            self._bypass_termination_notify = false;

            if(is_callee) {
                self._jingle_current.handle(stanza);

                Console.debug('Receive call form: ' + full_xid);
            } else {
                self._jingle_current.initiate();

                Console.debug('Emit call to: ' + full_xid);
            }

            status = true;
        } catch(e) {
            Console.error('Jingle._new', e);
        } finally {
            return status;
        }

    };


    /**
     * Processes the Jingle elements size
     * @private
     * @param {object} screen
     * @param {object} video
     * @return {object}
     */
    self._processSize = function(screen, video) {

        try {
            if(!(typeof screen === 'object' && typeof video === 'object')) {
                throw 'Invalid object passed, aborting!';
            }

            // Get the intrinsic size of the video
            var video_w = video.videoWidth;
            var video_h = video.videoHeight;

            // Get the screen size of the video
            var screen_w = screen.width();
            var screen_h = screen.height();

            // Process resize ratios (2 cases)
            var r_1 = screen_h / video_h;
            var r_2 = screen_w / video_w;

            // Process resized video sizes
            var video_w_1 = video_w * r_1;
            var video_h_1 = video_h * r_1;

            var video_w_2 = video_w * r_2;
            var video_h_2 = video_h * r_2;

            // DOM view modifiers
            var dom_width  = 'auto';
            var dom_height = 'auto';
            var dom_left   = 0;
            var dom_top    = 0;

            // Landscape/Portrait/Equal container?
            if(video_w > video_h || (video_h == video_w && screen_w < screen_h)) {
                // Not sufficient?
                if(video_w_1 < screen_w) {
                    dom_width = screen_w + 'px';
                    dom_top   = -1 * (video_h_2 - screen_h) / 2;
                } else {
                    dom_height = screen_h + 'px';
                    dom_left   = -1 * (video_w_1 - screen_w) / 2;
                }
            } else if(video_h > video_w || (video_h == video_w && screen_w > screen_h)) {
                // Not sufficient?
                if(video_h_1 < screen_h) {
                    dom_height = screen_h + 'px';
                    dom_left   = -1 * (video_w_1 - screen_w) / 2;
                } else {
                    dom_width = screen_w + 'px';
                    dom_top   = -1 * (video_h_2 - screen_h) / 2;
                }
            } else if(screen_w == screen_h) {
                dom_width  = screen_w + 'px';
                dom_height = screen_h + 'px';
            }

            return {
                width  : dom_width,
                height : dom_height,
                left   : dom_left,
                top    : dom_top
            };
        } catch(e) {
            Console.error('Jingle._processSize', e);
        }

    };


    /**
     * Adapts the local Jingle view
     * @private
     * @return {undefined}
     */
    self._adaptLocal = function() {

        try {
            var local_sel = $('#jingle .local_video');
            var local_video_sel = local_sel.find('video');

            // Process new sizes
            var sizes = self._processSize(
                local_sel,
                local_video_sel[0]
            );

            // Apply new sizes
            local_video_sel.css({
                'height': sizes.height,
                'width': sizes.width,
                'margin-top': sizes.top,
                'margin-left': sizes.left
            });
        } catch(e) {
            Console.error('Jingle._adaptLocal', e);
        }

    };


    /**
     * Adapts the remote Jingle view
     * @private
     * @return {undefined}
     */
    self._adaptRemote = function() {

        try {
            var videobox_sel = $('#jingle .videobox');
            var remote_sel = videobox_sel.find('.remote_video');
            var remote_video_sel = remote_sel.find('video');

            // Process new sizes
            var sizes = self._processSize(
                remote_sel,
                remote_video_sel[0]
            );

            // Apply new sizes
            remote_video_sel.css({
                'height': sizes.height,
                'width': sizes.width,
                'margin-top': sizes.top,
                'margin-left': sizes.left
            });
        } catch(e) {
            Console.error('Jingle._adaptRemote', e);
        }

    };


    /**
     * Adapts the Jingle view to the window size
     * @private
     * @return {undefined}
     */
    self._adapt = function() {

        try {
            if(self.in_call() && Common.exists('#jingle')) {
                self._adaptLocal();
                self._adaptRemote();
            }
        } catch(e) {
            Console.error('Jingle._adapt', e);
        }

    };


    /**
     * Initializes Jingle router
     * @public
     * @return {undefined}
     */
    self.init = function() {

        try {
            JSJaCJingle_listen({
                connection: con,
                debug: self._consoleAdapter,
                // TODO: seems like it fucks up the calls!
                //fallback: './server/jingle.php',
                
                initiate: function(stanza) {
                    try {
                        // Already in a call?
                        if(self.in_call()) {
                            // Try to restore SID there
                            var stanza_id = stanza.getID();
                            var sid = null;

                            if(stanza_id) {
                                var stanza_id_split = stanza_id.split('_');
                                sid = stanza_id_split[1];
                            }

                            // Build a temporary Jingle session
                            var jingle_close = new JSJaCJingle({
                                to: stanza.getFrom(),
                                debug: JSJAC_JINGLE_STORE_DEBUG
                            });

                            if(sid) {
                                jingle_close._set_sid(sid);
                            }

                            jingle_close.terminate(JSJAC_JINGLE_REASON_BUSY);

                            Console.warn('session_initiate_success', 'Dropped incoming call because already in a call.');

                            return;
                        }

                        var xid  = Common.fullXID(Common.getStanzaFrom(stanza));

                        Console.info('Incoming call from: ' + xid);

                        // Session values
                        self.receive(xid, stanza);
                    } catch(e) {
                        Console.error('Jingle.init[initiate]', e);
                    }
                }
            });
        } catch(e) {
            Console.error('Jingle.init', e);
        }

    };


    /**
     * Receive a Jingle call
     * @public
     * @param {string} xid
     * @param {object} stanza
     * @return {boolean}
     */
    self.receive = function(xid, stanza) {

        try {
            if(!self.in_call()) {
                self._new(xid, null, true, stanza);
            }
        } catch(e) {
            Console.error('Jingle.receive', e);
        } finally {
            return false;
        }

    };


    /**
     * Start a Jingle call
     * @public
     * @param {string} xid
     * @param {string} mode
     * @return {boolean}
     */
    self.start = function(xid, mode) {

        try {
            if(!self.in_call()) {
                self._new(xid, mode);
            }
        } catch(e) {
            Console.error('Jingle.start', e);
        } finally {
            return false;
        }

    };


     /**
     * Reset current Jingle call
     * @public
     * @return {boolean}
     */
    self._reset = function() {

        try {
            // Trash interface
            self._stopCounter();
            self._stopSession();
            self.destroyInterface();
            $('body').removeClass('in_jingle_call');

            // Hack: stop audio in case it is still ringing
            Audio.stop('incoming-call');
            Audio.stop('outgoing-call');
        } catch(e) {
            Console.error('Jingle._reset', e);
        } finally {
            return false;
        }

    };


    /**
     * Stops current Jingle call
     * @public
     * @return {boolean}
     */
    self.stop = function() {

        try {
            // Reset interface
            self._reset();

            // Stop Jingle session
            if(self._jingle_current !== null) {
                self._call_ender = 'local';
                self._jingle_current.terminate();

                Console.debug('Stopping current Jingle call...');
            } else {
                Console.warn('No Jingle call to be terminated!');
            }
        } catch(e) {
            Console.error('Jingle.stop', e);
        } finally {
            return false;
        }

    };


    /**
     * Mutes current Jingle call
     * @public
     * @return {undefined}
     */
    self.mute = function() {

        try {
            if(self._jingle_current) {
                var jingle_controls = $('#jingle .videobox .topbar .controls a');

                // Toggle interface buttons
                jingle_controls.filter('.mute').hide();
                jingle_controls.filter('.unmute').show();

                // Actually mute audio stream
                if(self._jingle_current.get_mute(JSJAC_JINGLE_MEDIA_AUDIO) === false) {
                    self._jingle_current.mute(JSJAC_JINGLE_MEDIA_AUDIO);
                }
            }
        } catch(e) {
            Console.error('Jingle.mute', e);
        }

    };


    /**
     * Unmutes current Jingle call
     * @public
     * @return {undefined}
     */
    self.unmute = function() {

        try {
            if(self._jingle_current) {
                var jingle_controls = $('#jingle .videobox .topbar .controls a');

                jingle_controls.filter('.unmute').hide();
                jingle_controls.filter('.mute').show();

                if(self._jingle_current.get_mute(JSJAC_JINGLE_MEDIA_AUDIO) === true) {
                    self._jingle_current.unmute(JSJAC_JINGLE_MEDIA_AUDIO);
                }
            }
        } catch(e) {
            Console.error('Jingle.mute', e);
        }

    };


    /**
     * Checks whether user is in call or not
     * @public
     * @return {boolean}
     */
    self.in_call = function() {

        in_call = false;

        try {
            if(self._jingle_current && 
              (self._jingle_current.get_status() === JSJAC_JINGLE_STATUS_INITIATING  || 
               self._jingle_current.get_status() === JSJAC_JINGLE_STATUS_INITIATED   || 
               self._jingle_current.get_status() === JSJAC_JINGLE_STATUS_ACCEPTING   || 
               self._jingle_current.get_status() === JSJAC_JINGLE_STATUS_ACCEPTED    ||
               self._jingle_current.get_status() === JSJAC_JINGLE_STATUS_TERMINATING)) {
                in_call = true;
            }
        } catch(e) {
            Console.error('Jingle.in_call', e);
        } finally {
            return in_call;
        }

    };


    /**
     * Checks if the given call SID is the same as the current call's one
     * @public
     * @param {object}
     * @return {boolean}
     */
    self.is_same_sid = function(jingle) {

        is_same = false;

        try {
            if(jingle && self._jingle_current  && 
               jingle.get_sid() === self._jingle_current.get_sid()) {
                is_same = true;
            }
        } catch(e) {
            Console.error('Jingle.is_same_sid', e);
        } finally {
            return is_same;
        }

    };


    /**
     * Returns if current Jingle call is audio
     * @public
     * @return {boolean}
     */
    self.is_audio = function() {

        audio = false;

        try {
            if(self._jingle_current && self._jingle_current.get_media() === JSJAC_JINGLE_MEDIA_AUDIO) {
                audio = true;
            }
        } catch(e) {
            Console.error('Jingle.is_audio', e);
        } finally {
            return audio;
        }

    };


    /**
     * Returns if current Jingle call is video
     * @public
     * @return {boolean}
     */
    self.is_video = function() {

        video = false;

        try {
            if(self._jingle_current && self._jingle_current.get_media() === JSJAC_JINGLE_MEDIA_VIDEO) {
                video = true;
            }
        } catch(e) {
            Console.error('Jingle.is_video', e);
        } finally {
            return video;
        }

    };


    /**
     * Get the notification map
     * @private
     * @return {object}
     */
    self._notify_map = function() {

        try {
            return {
                'call_audio': {
                    'text': Common._e("Is calling you"),

                    'buttons': {
                        'accept': {
                            'text': Common._e("Accept"),
                            'color': 'green',
                            'cb': function(xid, mode) {
                                self._jingle_current.accept();
                                Audio.stop('incoming-call');
                            }
                        },

                        'decline': {
                            'text': Common._e("Decline"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_DECLINE);
                                Audio.stop('incoming-call');
                            }
                        }
                    }
                },

                'call_video': {
                    'text': Common._e("Is calling you"),

                    'buttons': {
                        'accept': {
                            'text': Common._e("Accept"),
                            'color': 'green',
                            'cb': function(xid, mode) {
                                self._jingle_current.accept();
                                Audio.stop('incoming-call');
                            }
                        },

                        'decline': {
                            'text': Common._e("Decline"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_DECLINE);
                                Audio.stop('incoming-call');
                            }
                        }
                    }
                },

                'initiating': {
                    'text': Common._e("Initiating call"),

                    'buttons': {
                        'cancel': {
                            'text': Common._e("Cancel"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_CANCEL);
                            }
                        }
                    }
                },

                'waiting': {
                    'text': Common._e("Waiting..."),

                    'buttons': {
                        'cancel': {
                            'text': Common._e("Cancel"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_CANCEL);
                            }
                        }
                    }
                },

                'ringing': {
                    'text': Common._e("Ringing..."),

                    'buttons': {
                        'cancel': {
                            'text': Common._e("Cancel"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_CANCEL);
                            }
                        }
                    }
                },

                'declined': {
                    'text': Common._e("Declined the call"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'busy': {
                    'text': Common._e("Is already in a call"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'connecting': {
                    'text': Common._e("Connecting to call..."),

                    'buttons': {
                        'cancel': {
                            'text': Common._e("Cancel"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._jingle_current.terminate(JSJAC_JINGLE_REASON_CANCEL);
                            }
                        }
                    }
                },

                'error': {
                    'text': Common._e("Call error"),

                    'buttons': {
                        'retry': {
                            'text': Common._e("Retry"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self.start(xid, mode);
                            }
                        },

                        'cancel': {
                            'text': Common._e("Cancel"),
                            'color': 'red',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'ending': {
                    'text': Common._e("Ending call...")
                },

                'local_ended': {
                    'text': Common._e("Call ended"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'remote_ended': {
                    'text': Common._e("Ended the call"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'local_canceled': {
                    'text': Common._e("Call canceled"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                },

                'remote_canceled': {
                    'text': Common._e("Canceled the call"),

                    'buttons': {
                        'okay': {
                            'text': Common._e("Okay"),
                            'color': 'blue',
                            'cb': function(xid, mode) {
                                self._reset();
                            }
                        }
                    }
                }
            };
        } catch(e) {
            Console.error('Jingle._notify_map', e);

            return {};
        }

    };


    /**
     * Notify for something related to Jingle
     * @public
     * @param {string} xid
     * @param {string} type
     * @param {string} mode
     * @return {boolean}
     */
    self.notify = function(xid, type, mode) {

        try {
            var map = self._notify_map();

            if(!(type in map)) {
                throw 'Notification type not recognized!';
            }

            var jingle_tools_all_sel = $('#top-content .tools-all:has(.tools.jingle)');
            var jingle_tool_sel = jingle_tools_all_sel.find('.tools.jingle');
            var jingle_content_sel = jingle_tools_all_sel.find('.jingle-content');
            var jingle_subitem_sel = jingle_content_sel.find('.tools-content-subitem');

            var buttons_html = '';
            var i = 0;

            if(typeof map[type].buttons === 'object') {
                $.each(map[type].buttons, function(button, attrs) {
                    buttons_html += '<a class="reply-button ' + button + ' ' + attrs.color + ' ' + (!(i++) ? 'first' : '') + '" data-action="' + button + '">' + attrs.text + '</a>';
                });
            }

            // Append notification to DOM
            jingle_subitem_sel.html(
                '<div class="jingle-notify notify-' + type + ' ' + hex_md5(xid) + '" data-type="' + type + '" data-xid="' + Common.encodeQuotes(xid) + '">' + 
                    '<div class="avatar-pane">' + 
                        '<div class="avatar-container">' + 
                            '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                        '</div>' + 

                        '<span class="icon jingle-images"></span>' + 
                    '</div>' + 

                    '<div class="notification-content">' + 
                        '<span class="fullname">' + Name.getBuddy(xid).htmlEnc() + '</span>' + 
                        '<span class="text">' + map[type].text + '</span>' + 

                        '<div class="reply-buttons">' + buttons_html + '</div>' + 
                    '</div>' + 
                '</div>'
            );

            // Apply user avatar
            Avatar.get(xid, 'cache', 'true', 'forget');

            // Apply button events
            if(typeof map[type].buttons === 'object') {
                $.each(map[type].buttons, function(button, attrs) {
                    jingle_tools_all_sel.find('a.reply-button[data-action="' + button + '"]').click(function() {
                        try {
                            // Remove notification
                            self.unnotify(xid);

                            // Execute callback, if any
                            if(typeof attrs.cb === 'function') {
                                attrs.cb(xid, mode);
                            }

                            Console.info('Closed Jingle notification drawer');
                        } catch(e) {
                            Console.error('Jingle.notify[async]', e);
                        } finally {
                            return false;
                        }
                    });
                });
            }

            // Enable notification box!
            jingle_tool_sel.addClass('active');

            // Open notification box!
            jingle_content_sel.show();
        } catch(e) {
            Console.error('Jingle.notify', e);
        } finally {
            return false;
        }

    };


    /**
     * Remove notification
     * @public
     * @return {boolean}
     */
    self.unnotify = function() {

        try {
            // Selectors
            var jingle_tools_all_sel = $('#top-content .tools-all:has(.tools.jingle)');
            var jingle_tool_sel = jingle_tools_all_sel.find('.tools.jingle');
            var jingle_content_sel = jingle_tools_all_sel.find('.jingle-content');
            var jingle_subitem_sel = jingle_content_sel.find('.tools-content-subitem');

            // Close & disable notification box
            jingle_content_sel.hide();
            jingle_subitem_sel.empty();
            jingle_tool_sel.removeClass('active');

            // Stop all sounds
            Audio.stop('incoming-call');
            Audio.stop('outgoing-call');
        } catch(e) {
            Console.error('Jingle.unnotify', e);
        } finally {
            return false;
        }

    };


    /**
     * Set the Jingle session as started
     * @private
     * @param {string} mode
     * @return {boolean}
     */
    self._startSession = function(mode) {

        try {
            if(!(mode in JSJAC_JINGLE_MEDIAS)) {
                throw 'Unknown mode: ' + (mode || 'none');
            }

            var jingle_tool_sel = $('#top-content .tools.jingle');

            jingle_tool_sel.removeClass('audio video active');
            jingle_tool_sel.addClass('streaming').addClass(mode);

            Console.info('Jingle session successfully started, mode: ' + (mode || 'none'));
        } catch(e) {
            Console.error('Jingle._startSession', e);
        } finally {
            return false;
        }

    };


    /**
     * Set the Jingle session as stopped
     * @private
     * @param {string} mode
     * @return {boolean}
     */
    self._stopSession = function() {

        try {
            $('#top-content .tools.jingle').removeClass('audio video active streaming');

            Console.info('Jingle session successfully stopped');
        } catch(e) {
            Console.error('Jingle._stopSession', e);
        } finally {
            return false;
        }

    };


    /**
     * Start call elpsed time counter
     * @private
     * @return {boolean}
     */
    self._startCounter = function() {

        try {
            // Initialize counter
            self._stopCounter();
            self._start_stamp = DateUtils.getTimeStamp();
            self._fireClock();
            
            // Fire it every second
            $('#top-content .tools.jingle .counter').everyTime('1s', self._fireClock);

            Console.info('Jingle counter started');
        } catch(e) {
            Console.error('Jingle._startCounter', e);
        } finally {
            return false;
        }

    };


    /**
     * Stop call elpsed time counter
     * @private
     * @return {boolean}
     */
    self._stopCounter = function() {

        try {
            // Reset stamp storage
            self._start_stamp = 0;

            // Reset counter
            var counter_sel = $('#top-content .tools.jingle .counter');
            var default_count = counter_sel.attr('data-default');
            
            counter_sel.stopTime();
            $('#top-content .tools.jingle .counter, #jingle .videobox .topbar .elapsed').text(default_count);

            Console.info('Jingle counter stopped');
        } catch(e) {
            Console.error('Jingle._stopCounter', e);
        } finally {
            return false;
        }

    };


    /**
     * Fires the counter clock (once more)
     * @private
     * @return {undefined}
     */
    self._fireClock = function() {

        try {
            // Process updated time
            var count = DateUtils.difference(DateUtils.getTimeStamp(), self._start_stamp);
            
            if(count.getHours()) {
                count = count.toString('H:mm:ss');
            } else {
                count = count.toString('mm:ss');
            }
            
            // Display updated counter
            $('#top-content .tools.jingle .counter, #jingle .videobox .topbar .elapsed').text(count);
        } catch(e) {
            Console.error('Jingle._fireClock', e);
        }

    };


    /**
     * Create the Jingle interface
     * @public
     * @return {object}
     */
    self.createInterface = function(xid, mode) {

        try {
            // Jingle interface already exists?
            if(Common.exists('#jingle')) {
                throw 'Jingle interface already exist!';
            }

            // Create DOM
            $('body').append(
                '<div id="jingle" class="lock removable ' + hex_md5(xid) + '" data-xid="' + Common.encodeQuotes(xid) + '" data-mode="' + Common.encodeQuotes(mode) + '">' + 
                    '<div class="videobox">' + 
                        '<div class="topbar">' + 
                            '<div class="card">' + 
                                '<div class="avatar-container">' + 
                                    '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                                '</div>' + 

                                '<div class="identity">' + 
                                    '<span class="name">' + Name.getBuddy(xid).htmlEnc() + '</span>' + 
                                    '<span class="xid">' + xid.htmlEnc() + '</span>' + 
                                '</div>' + 
                            '</div>' + 

                            '<div class="controls">' + 
                                '<a href="#" class="stop control-button" data-type="stop"><span class="icon jingle-images"></span>' + Common._e("Stop") + '</a>' + 
                                '<a href="#" class="mute control-button" data-type="mute"><span class="icon jingle-images"></span>' + Common._e("Mute") + '</a>' + 
                                '<a href="#" class="unmute control-button" data-type="unmute"><span class="icon jingle-images"></span>' + Common._e("Unmute") + '</a>' + 
                            '</div>' + 

                            '<div class="elapsed">00:00:00</div>' + 

                            '<div class="actions">' + 
                                '<a href="#" class="close action-button jingle-images" data-type="close"></a>' + 
                            '</div>' + 
                        '</div>' + 

                        '<div class="local_video">' + 
                            '<video src="" alt="" poster="' + './images/placeholders/jingle_video_local.png' + '"></video>' + 
                        '</div>' + 

                        '<div class="remote_video">' + 
                            '<video src="" alt=""></video>' + 
                        '</div>' + 

                        '<div class="branding jingle-images"></div>' + 
                    '</div>' + 
                '</div>'
            );

            // Apply events
            self._eventsInterface();

            // Apply user avatar
            Avatar.get(xid, 'cache', 'true', 'forget');
        } catch(e) {
            Console.error('Jingle.createInterface', e);
        } finally {
            return $('#jingle');
        }

    };


    /**
     * Destroy the Jingle interface
     * @public
     * @return {undefined}
     */
    self.destroyInterface = function() {

        try {
            var jingle_sel = $('#jingle');

            jingle_sel.stopTime();
            jingle_sel.find('*').stopTime();

            jingle_sel.remove();
        } catch(e) {
            Console.error('Jingle.destroyInterface', e);
        }

    };


    /**
     * Show the Jingle interface
     * @public
     * @return {boolean}
     */
    self.showInterface = function() {

        try {
            if(self.in_call() && self.is_video()) {
                $('#jingle:hidden').show();

                // Launch back some events
                $('#jingle .videobox').mousemove();
            }
        } catch(e) {
            Console.error('Jingle.showInterface', e);
        } finally {
            return false;
        }

    };


    /**
     * Hide the Jingle interface
     * @public
     * @return {boolean}
     */
    self.hideInterface = function() {

        try {
            $('#jingle:visible').hide();

            // Reset some events
            $('#jingle .videobox .topbar').stopTime().hide();
        } catch(e) {
            Console.error('Jingle.hideInterface', e);
        } finally {
            return false;
        }

    };


    /**
     * Attaches interface events
     * @private
     * @return {undefined}
     */
    self._eventsInterface = function() {

        try {
            var jingle_sel = $('#jingle');

            jingle_sel.everyTime(50, function() {
                self._adapt();
            });

            // Close interface on click on semi-transparent background
            jingle_sel.click(function(evt) {
                try {
                    // Click on lock background?
                    if($(evt.target).is('.lock')) {
                        return self.hideInterface();
                    }
                } catch(e) {
                    Console.error('Jingle._eventsInterface[async]', e);
                }
            });

            // Click on a control or action button
            jingle_sel.find('.topbar').find('.controls a, .actions a').click(function() {
                try {
                    switch($(this).data('type')) {
                        case 'close':
                            self.hideInterface(); break;
                        case 'stop':
                            self.stop(); break;
                        case 'mute':
                            self.mute(); break;
                        case 'unmute':
                            self.unmute(); break;
                    }
                } catch(e) {
                    Console.error('Jingle._eventsInterface[async]', e);
                } finally {
                    return false;
                }
            });

            // Auto Hide/Show interface topbar
            jingle_sel.find('.videobox').mousemove(function() {
                try {
                    var topbar_sel = $(this).find('.topbar');

                    if(topbar_sel.is(':hidden')) {
                        topbar_sel.stop(true).fadeIn(250);
                    }

                    topbar_sel.stopTime();
                    topbar_sel.oneTime('5s', function() {
                        topbar_sel.stop(true).fadeOut(250);
                    });
                } catch(e) {
                    Console.error('Jingle._eventsInterface[async]', e);
                }
            });
        } catch(e) {
            Console.error('Popup._eventsInterface', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.launch = function() {

        try {
            $(window).resize(self._adapt());
        } catch(e) {
            Console.error('Jingle.launch', e);
        }
    
    };


    /**
     * Return class scope
     */
    return self;

})();

Jingle.launch();
/*

Jappix - An open social platform
These are the storage JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Storage = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


      /**
     * Gets the storage items of the user
     * @public
     * @param {string} type
     * @return {undefined}
     */
    self.get = function(type) {

        /* REF: http://xmpp.org/extensions/xep-0049.html */

        try {
            var iq = new JSJaCIQ();
            iq.setType('get');
            
            var iqQuery = iq.setQuery(NS_PRIVATE);
            iqQuery.appendChild(iq.buildNode('storage', {'xmlns': type}));
            
            con.send(iq, self.handle);
        } catch(e) {
            Console.error('Storage.get', e);
        }

    };


    /**
     * Handles the storage items
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handle = function(iq) {

        try {
            var handleXML = iq.getQuery();
            var handleFrom = Common.fullXID(Common.getStanzaFrom(iq));
            
            // Define some vars
            var options = $(handleXML).find('storage[xmlns="' + NS_OPTIONS + '"]');
            var inbox = $(handleXML).find('storage[xmlns="' + NS_INBOX + '"]');
            var bookmarks = $(handleXML).find('storage[xmlns="' + NS_BOOKMARKS + '"]');
            var rosternotes = $(handleXML).find('storage[xmlns="' + NS_ROSTERNOTES + '"]');
            
            // No options and node not yet configured
            if(options.size() && !options.find('option').size() && (iq.getType() != 'error')) {
                Welcome.open();
            }
            
            // Parse the options xml
            options.find('option').each(function() {
                // We retrieve the informations
                var type = $(this).attr('type');
                var value = $(this).text();
                
                // We display the storage
                DataStore.setDB(Connection.desktop_hash, 'options', type, value);
                
                // If this is the buddy list show status
                if((type == 'roster-showall') && (value == '1'))
                    Interface.showAllBuddies('storage');
            });
            
            // Parse the inbox xml
            inbox.find('message').each(function() {
                Inbox.storeMessage(
                          $(this).attr('from'),
                          $(this).attr('subject'),
                          $(this).text(),
                          $(this).attr('status'),
                          $(this).attr('id'),
                          $(this).attr('date'),
                          [
                           $(this).attr('file_title'),
                           $(this).attr('file_href'),
                           $(this).attr('file_type'),
                           $(this).attr('file_length')
                          ]
                         );
            });
            
            // Parse the bookmarks xml
            bookmarks.find('conference').each(function() {
                // We retrieve the informations
                var xid = $(this).attr('jid');
                var name = $(this).attr('name');
                var autojoin = $(this).attr('autojoin');
                var password = $(this).find('password').text();
                var nick = $(this).find('nick').text();
                
                // Filter autojoin (compatibility)
                autojoin = ((autojoin == 'true') || (autojoin == '1')) ? 'true' : 'false';

                // We display the storage
                Favorites.display(xid, name, nick, autojoin, password);
                
                // Join the chat if autojoin is enabled
                if(autojoin == 'true')
                    Chat.checkCreate(xid, 'groupchat', nick, password, name);
            });
            
            // Parse the roster notes xml
            rosternotes.find('note').each(function() {
                DataStore.setDB(Connection.desktop_hash, 'rosternotes', $(this).attr('jid'), $(this).text());
            });
            
            // Options received
            if(options.size()) {
                Console.log('Options received.');
                
                // Now, get the inbox
                self.get(NS_INBOX);
                
                // Geolocate the user
                PEP.geolocate();
                
                $('.options-hidable').show();
            }
            
            // Inbox received
            else if(inbox.size()) {
                Console.log('Inbox received.');
                
                // Send the first presence!
                Presence.sendFirst(DataStore.getDB(Connection.desktop_hash, 'checksum', 1));
                
                // Check we have new messages (play a sound if any unread messages)
                if(Inbox.checkMessages()) {
                    Audio.play('notification');
                }
                
                $('.inbox-hidable').show();
            }
            
            // Bookmarks received
            else if(bookmarks.size()) {
                // Join the groupchats the admin defined (if any)
                Groupchat.joinConf();
                
                Console.log('Bookmarks received.');
            }
            
            // Roster notes received (for logger)
            else if(rosternotes.size()) {
                Console.log('Roster notes received.');
            }
        } catch(e) {
            Console.error('Storage.handle', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
// License: MIT

/*
 *  Console.js
 *
 *  An interface to native console methods
 *  Avoids issues when browser does not have native support for console
 *
 *  @license OS
 *  @author Val√©rian Saliou <valerian@valeriansaliou.name>
 *  @url https://github.com/valeriansaliou/console.js
 */

var Console = (function () {

  var self = this;


  /* Variables */
  self._available = typeof(window.console) != 'undefined';
  self._has = self._available && JappixSystem.isDeveloper();
  self._console = self._available ? console : {};


  /* Adapters */
  self._adapter = function (level) {
    if (!self._has) {
      return function() {};
    }

    var adapter = null;
    try {
      switch (level) {
        case 0:
          adapter = console.warn; break;
        case 1:
          adapter = console.error; break;
        case 2:
          adapter = console.info; break;
        case 3:
          adapter = console.log; break;
        case 4:
          adapter = console.debug; break;
      }
    } catch (e) {
      adapter = function() {};
    }

    return adapter.bind(self._console);
  };


  /* Methods */
  self.warn = self._adapter(0);
  self.error = self._adapter(1);
  self.info = self._adapter(2);
  self.log = self._adapter(3);
  self.debug = self._adapter(4);


  /* Return class scope */
  return self;

})();

var JappixConsole = Console;
/*

Jappix - An open social platform
These are the common JS script for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Authors: Val√©rian Saliou, olivierm, regilero, Maranda

*/

// Bundle
var Common = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Checks if an element exists in the DOM
     * @public
     * @param {string} path
     * @return {boolean}
     */
    self.exists = function(path) {

        var exists = false;

        try {
            if(jQuery(path).size() > 0) {
                exists = true;
            }
        } catch(e) {
            Console.error('Common.exists', e);
        } finally {
            return exists;
        }

    };


    /**
     * Checks if Jappix is connected
     * @public
     * @return {boolean}
     */
    self.isConnected = function() {

        connected = false;

        try {
            if((typeof con != 'undefined') && con && con.connected()) {
                connected = true;
            }
        } catch(e) {
            Console.error('Common.isConnected', e);
        } finally {
            return connected;
        }

    };


    /**
     * Checks if Jappix is connected
     * @public
     * @return {boolean}
     */
    self.hasWebSocket = function() {

        has_websocket = false;

        try {
            if(HOST_WEBSOCKET && typeof window.WebSocket != 'undefined') {
                has_websocket = true;
            }
        } catch(e) {
            Console.error('Common.hasWebSocket', e);
        } finally {
            return has_websocket;
        }

    };


    /**
     * Checks if Jappix has focus
     * @public
     * @return {boolean}
     */
    self.isFocused = function() {

        has_focus = true;

        try {
            if(!document.hasFocus()) {
                has_focus = false;
            }
        } catch(e) {
            Console.error('Common.isFocused', e);
        } finally {
            return has_focus;
        }

    };


    /**
     * Generates the good XID
     * @public
     * @param {string} xid
     * @param {string} type
     * @return {string}
     */
    self.generateXID = function(xid, type) {

        try {
            // XID needs to be transformed
            // .. and made lowercase (uncertain though this is the right place...)
            xid = xid.toLowerCase();

            if(xid && (xid.indexOf('@') == -1)) {
                // Groupchat
                if(type == 'groupchat')
                    return xid + '@' + HOST_MUC;
                
                // One-to-one chat
                if(xid.indexOf('.') == -1)
                    return xid + '@' + HOST_MAIN;
                
                // It might be a gateway?
                return xid;
            }
            
            // Nothing special (yet bare XID)
            return xid;
        } catch(e) {
            Console.error('Common.generateXID', e);
        }

    };


    /**
     * Gets the asked translated string
     * @public
     * @param {string} string
     * @return {string}
     */
    self._e = function(string) {

        try {
            return string;
        } catch(e) {
            Console.error('Common._e', e);
        }

    };


    /**
     * Replaces '%s' to a given value for a translated string
     * @public
     * @param {string} string
     * @param {string} value
     * @return {string}
     */
    self.printf = function(string, value) {

        try {
            return string.replace('%s', value);
        } catch(e) {
            Console.error('Common.printf', e);
        }

    };


    /**
     * Returns the string after the last given char
     * @public
     * @param {string} given_char
     * @param {string} str
     * @return {string}
     */
    self.strAfterLast = function(given_char, str) {

        try {
            if(!given_char || !str)
                return '';
            
            var char_index = str.lastIndexOf(given_char);
            var str_return = str;
            
            if(char_index >= 0)
                str_return = str.substr(char_index + 1);
            
            return str_return;
        } catch(e) {
            Console.error('Common.strAfterLast', e);
        }

    };


    /**
     * Properly explodes a string with a given character
     * @public
     * @param {string} toEx
     * @param {string} toStr
     * @param {number} i
     * @return {string}
     */
    self.explodeThis = function(toEx, toStr, i) {

        try {
            // Get the index of our char to explode
            var index = toStr.indexOf(toEx);
            
            // We split if necessary the string
            if(index !== -1) {
                if(i === 0)
                    toStr = toStr.substr(0, index);
                else
                    toStr = toStr.substr(index + 1);
            }
            
            // We return the value
            return toStr;
        } catch(e) {
            Console.error('Common.explodeThis', e);
        }

    };


    /**
     * Cuts the resource of a XID
     * @public
     * @param {string} aXID
     * @return {string}
     */
    self.cutResource = function(aXID) {

        try {
            return self.explodeThis('/', aXID, 0);
        } catch(e) {
            Console.error('Common.cutResource', e);
        }

    };


    /**
     * Gets the resource of a XID
     * @public
     * @param {string} aXID
     * @return {string}
     */
    self.thisResource = function(aXID) {

        resource = '';

        try {
            // Any resource?
            if(self.isFullXID(aXID)) {
                resource = self.explodeThis('/', aXID, 1);
            }
        } catch(e) {
            Console.error('Common.thisResource', e);
        } finally {
            return resource;
        }

    };


    /**
     * Returns whether this XID is full or not
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.isFullXID = function(xid) {

        try {
            return xid.indexOf('/') !== -1;
        } catch(e) {
            Console.error('Common.isFullXID', e);

            return false;
        }

    };


    /**
     * nodepreps an XMPP node
     * @public
     * @param {string} node
     * @return {string}
     */
    self.nodeprep = function(node) {

        // Spec: http://tools.ietf.org/html/rfc6122#appendix-A

        try {
            if(!node)
                return node;

            // Remove prohibited chars
            var prohibited_chars = ['"', '&', '\'', '/', ':', '<', '>', '@'];

            for(var j in prohibited_chars) {
                node = node.replace(prohibited_chars[j], '');
            }

            // Lower case
            node = node.toLowerCase();

            return node;
        } catch(e) {
            Console.error('Common.nodeprep', e);
        }

    };


    /**
     * Encodes quotes in a string
     * @public
     * @param {string} str
     * @return {string}
     */
    self.encodeQuotes = function(str) {

        try {
            return (str + '').htmlEnc();
        } catch(e) {
            Console.error('Common.encodeQuotes', e);
        }

    };


    /**
     * Gets the bare XID from a XID
     * @public
     * @param {string} xid
     * @return {string}
     */
    self.bareXID = function(xid) {

        try {
            // Cut the resource
            xid = self.cutResource(xid);
            
            // Launch nodeprep
            if(xid.indexOf('@') != -1) {
                xid = self.nodeprep(self.getXIDNick(xid)) + '@' + self.getXIDHost(xid);
            }
            
            return xid;
        } catch(e) {
            Console.error('Common.bareXID', e);
        }

    };


    /**
     * Gets the full XID from a XID
     * @public
     * @param {string} xid
     * @return {string}
     */
    self.fullXID = function(xid) {

        try {
            // Normalizes the XID
            var full = self.bareXID(xid);
            var resource = self.thisResource(xid);
            
            // Any resource?
            if(resource)
                full += '/' + resource;
            
            return full;
        } catch(e) {
            Console.error('Common.fullXID', e);
        }

    };


    /**
     * Gets the nick from a XID
     * @public
     * @param {string} aXID
     * @return {string}
     */
    self.getXIDNick = function(aXID) {

        try {
            // Gateway nick?
            if(aXID.match(/\\40/))
                return self.explodeThis('\\40', aXID, 0);
            
            return self.explodeThis('@', aXID, 0);
        } catch(e) {
            Console.error('Common.getXIDNick', e);
        }

    };


    /**
     * Gets the host from a XID
     * @public
     * @param {string} aXID
     * @return {string}
     */
    self.getXIDHost = function(aXID) {

        try {
            return self.explodeThis('@', aXID, 1);
        } catch(e) {
            Console.error('Common.getXIDHost', e);
        }

    };


    /**
     * Checks if we are RTL (Right-To-Left)
     * @public
     * @return {boolean}
     */
    self.isRTL = function() {

        try {
            return (self._e("default:LTR") == 'default:RTL');
        } catch(e) {
            Console.error('Common.isRTL', e);
        }

    };


    /**
     * Checks if anonymous mode is allowed
     * @public
     * @return {boolean}
     */
    self.allowedAnonymous = function() {

        try {
            return (ANONYMOUS == 'on');
        } catch(e) {
            Console.error('Common.allowedAnonymous', e);
        }

    };


    /**
     * Checks if host is locked
     * @public
     * @return {boolean}
     */
    self.lockHost = function() {

        try {
            return (LOCK_HOST == 'on');
        } catch(e) {
            Console.error('Common.lockHost', e);
        }

    };


    /**
     * Gets the full XID of the user
     * @public
     * @return {string}
     */
    self.getXID = function() {

        try {
            // Return the XID of the user
            if(con.username && con.domain) {
                return con.username + '@' + con.domain;
            }
            
            return '';
        } catch(e) {
            Console.error('Common.getXID', e);
        }

    };


    /**
     * Generates the colors for a given user XID
     * @public
     * @param {type} xid
     * @return {string}
     */
    self.generateColor = function(xid) {

        try {
            var colors = new Array(
                'ac0000',
                'a66200',
                '007703',
                '00705f',
                '00236b',
                '4e005c'
            );
            
            var number = 0;
            
            for(var i = 0; i < xid.length; i++) {
                number += xid.charCodeAt(i);
            }
            
            var color = '#' + colors[number % (colors.length)];
            
            return color;
        } catch(e) {
            Console.error('Common.generateColor', e);
        }

    };


    /**
     * Checks if the XID is a gateway
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.isGateway = function(xid) {

        is_gateway = true;

        try {
            if(xid.indexOf('@') != -1) {
                is_gateway = false;
            }
        } catch(e) {
            Console.error('Common.isGateway', e);
        } finally {
            return is_gateway;
        }

    };


    /**
     * Gets the from attribute of a stanza (overrides some servers like Prosody missing from attributes)
     * @public
     * @param {object} stanza
     * @return {string}
     */
    self.getStanzaFrom = function(stanza) {

        try {
            var from = stanza.getFrom();
            
            // No from, we assume this is our XID
            if(!from) {
                from = self.getXID();
            }
            
            return from;
        } catch(e) {
            Console.error('Common.getStanzaFrom', e);
        }

    };


    /**
     * Returns whether the stanza has been really sent from our own server or entity
     * @public
     * @param {object} stanza
     * @return {string}
     */
    self.isSafeStanza = function(stanza) {

        var is_safe = false;

        try {
            var from = self.getStanzaFrom(stanza);

            is_safe = (!from || from == con.domain || from == self.getXID()) && true;
        } catch(e) {
            Console.error('Common.isSafeStanza', e);
        } finally {
            return is_safe;
        }

    };


    /**
     * Adds a zero to a date when needed
     * @public
     * @param {number} i
     * @return {string}
     */
    self.padZero = function(i) {

        try {
            // Negative number (without first 0)
            if(i > -10 && i < 0)
                return '-0' + (i * -1);
            
            // Positive number (without first 0)
            if(i < 10 && i >= 0)
                return '0' + i;
            
            // All is okay
            return i;
        } catch(e) {
            Console.error('Common.padZero', e);
        }

    };


    /**
     * Escapes a string (or an array of string) for a regex usage. In case of an
     * array, escapes are not done "in place", keeping the query unmodified
     * @public
     * @param {object} query
     * @return {object}
     */
    self.escapeRegex = function(query) {

        if (query instanceof Array) {
            var result = new Array(query.length);
            for(i=0; i<query.length; i++) {
                try {
                    result[i] = Common.escapeRegex(query[i]);
                } catch(e) {
                    Console.error('Common.escapeRegex', e);
                    result[i] = null;
                }
            }
            return result;
        } else {
            try {
                return query.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
            } catch(e) {
                Console.error('Common.escapeRegex', e);
            }
        }

    };


    /**
     * Returns a random array value
     * @public
     * @param {object} arr
     * @return {object}
     */
    self.randomArrayValue = function(arr) {

        try {
            return arr[Math.floor(Math.random() * arr.length)];
        } catch(e) {
            Console.error('Common.randomArrayValue', e);
        }

    };


    /**
     * Returns whether the browser is mobile or not
     * @public
     * @return {boolean}
     */
    self.isMobile = function() {

        is_mobile = false;

        try {
            is_mobile = /Android|iPhone|iPod|iPad|Windows Phone|BlackBerry|Bada|Maemo|Meego|webOS/i.test(navigator.userAgent);
        } catch(e) {
            Console.error('Common.isMobile', e);
        } finally {
            return is_mobile;
        }

    };


    /**
     * Converts a XML document to a string
     * @public
     * @param {object} xmlData
     * @return {string}
     */
    self.xmlToString = function(xmlData) {

        xml_str = null;

        try {
            // For Mozilla, Firefox, Opera, etc.
            if(window.XMLSerializer) {
                xml_str = (new XMLSerializer()).serializeToString(xmlData);
            }
            
            // For Internet Explorer
            if(window.ActiveXObject) {
                xml_str = xmlData.xml;
            }
        } catch(e) {
            Console.error('Common.xmlToString', e);
        } finally {
            return xml_str;
        }

    };


    /**
     * Converts a string to a XML document
     * @public
     * @param {string} sXML
     * @return {object}
     */
    self.XMLFromString = function(sXML) {

        try {
            // No data?
            if(!sXML) {
                return '';
            }
            
            // Add the XML tag
            if(!sXML.match(/^<\?xml/i)) {
                sXML = '<?xml version="1.0"?>' + sXML;
            }
            
            // Parse it!
            if(window.DOMParser) {
                return (new DOMParser()).parseFromString(sXML, 'text/xml');
            }
            
            if(window.ActiveXObject) {
                var oXML = new ActiveXObject('Microsoft.XMLDOM');
                oXML.loadXML(sXML);
                
                return oXML;
            }
        } catch(e) {
            Console.error('Common.XMLFromString', e);

            return '';
        }

    };


    /**
     * Watches for input value change (delays callback)
     * @public
     * @param {function} cb
     * @return {function}
     */
    self.typewatch = function(cb) {

        try {
            var timer = 0;
            
            return function(callback, ms) {
                clearTimeout(timer);
                timer = setTimeout(callback, ms);
            };
        } catch(e) {
            Console.error('Common.typewatch', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixCommon = Common;
/*

Jappix - An open social platform
These are the utilities JS script for Jappix

-------------------------------------------------

License: AGPL
Authors: Val√©rian Saliou, olivierm

*/

// Bundle
var Utils = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Returns whether using HTTPS or not
     * @public
     * @return {boolean}
     */
    self.isHTTPS = function() {

        is_https = false;

        try {
            if(window.location.href && (window.location.href).match(/^https/i)) {
                is_https = true;
            }
        } catch(e) {
            Console.error('Utils.isHTTPS', e);
        } finally {
            return is_https;
        }

    };


    /**
     * Generates the good storage URL
     * @public
     * @param {string} url
     * @return {string}
     */
    self.generateURL = function(url) {

        try {
            // HTTPS not allowed
            if((HTTPS_STORAGE != 'on') && url.match(/^https(.+)/))
                url = 'http' + RegExp.$1;
            
            return url;
        } catch(e) {
            Console.error('Utils.generateURL', e);
        }

    };


    /**
     * Disables an input if needed
     * @public
     * @param {string} value
     * @param {string} condition
     * @return {string}
     */
    self.disableInput = function(value, condition) {

        try {
            if(value == condition) {
                return ' disabled=""';
            }
            
            return '';
        } catch(e) {
            Console.error('Utils.disableInput', e);
        }

    };


    /**
     * Truncates a string
     * @public
     * @param {string} string
     * @param {number} limit
     * @return {string}
     */
    self.truncate = function(string, limit) {

        try {
            // Must truncate the string
            if(string.length > limit) {
                string = string.substr(0, limit) + '...';
            }
            
            return string;
        } catch(e) {
            Console.error('Utils.truncate', e);
        }

    };


    /**
     * Removes the new lines
     * @public
     * @param {string} string
     * @return {string}
     */
    self.noLines = function(string) {

        try {
            return string.replace(/\n/g, ' ');
        } catch(e) {
            Console.error('Utils.noLines', e);
        }

    };


    /**
     * Encodes a string for onclick attribute
     * @public
     * @param {string} str
     * @return {undefined}
     */
    self.encodeOnclick = function(str) {

        try {
            return (Common.encodeQuotes(str)).replace(/'/g, '\\$&');
        } catch(e) {
            Console.error('Utils.encodeOnclick', e);
        }

    };


    /**
     * Checks whether the passed parameter is a number or not
     * @public
     * @param {number} n
     * @return {boolean}
     */
    self.isNumber = function(n) {

        try {
            return !isNaN(parseFloat(n)) && isFinite(n);
        } catch(e) {
            Console.error('Utils.isNumber', e);
        }

    };


    /**
     * Checks if we are in the anonymous mode
     * @public
     * @return {boolean}
     */
    self.isAnonymous = function() {

        var is_anonymous = false;

        try {
            if(Common.allowedAnonymous() && XMPPLinks.links_var.r) {
                is_anonymous = true;
            }
        } catch(e) {
            Console.error('Utils.isAnonymous', e);
        } finally {
            return is_anonymous;
        }

    };


    /**
     * Checks if this is a private chat user
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.isPrivate = function(xid) {

        var is_private = false;

        try {
            if(Common.exists('[data-xid="' + escape(xid) + '"][data-type="groupchat"]')) {
                is_private = true;
            }
        } catch(e) {
            Console.error('Utils.isPrivate', e);
        } finally {
            return is_private;
        }

    };


    /**
     * Checks if the user browser is obsolete
     * @public
     * @return {boolean}
     */
    self.isObsolete = function() {

        try {
            // Get browser name & version
            var browser_name = BrowserDetect.browser;
            var browser_version = BrowserDetect.version;
            
            // No DOM storage
            if(!DataStore.hasDB() || !DataStore.hasPersistent())
                return true;
            
            // Obsolete IE
            if((browser_name == 'Explorer') && (browser_version < 8))
                return true;
            
            // Obsolete Chrome
            if((browser_name == 'Chrome') && (browser_version < 7))
                return true;
            
            // Obsolete Safari
            if((browser_name == 'Safari') && (browser_version < 4))
                return true;
            
            // Obsolete Firefox
            if((browser_name == 'Firefox') && (browser_version < 3.5))
                return true;
            
            // Obsolete Opera
            if((browser_name == 'Opera') && (browser_version < 9))
                return true;
            
            return false;
        } catch(e) {
            Console.error('Utils.isObsolete', e);

            return false;
        }

    };


    /**
     * Gets a MUC user XID
     * @public
     * @param {string} room
     * @param {string} nick
     * @return {string}
     */
    self.getMUCUserXID = function(room, nick) {

        try {
            return $('div.chat[data-xid="' + escape(room) + '"] div[data-nick="' + escape(nick) + '"]').attr('data-xid');
        } catch(e) {
            Console.error('Utils.getMUCUserXID', e);
        }

    };


    /**
     * Gets a MUC user read XID
     * @public
     * @param {string} room
     * @param {string} nick
     * @return {string}
     */
    self.getMUCUserRealXID = function(room, nick) {

        try {
            return $('div.chat[data-xid="' + escape(room) + '"] div[data-nick="' + escape(nick) + '"]').attr('data-realxid');
        } catch(e) {
            Console.error('Utils.getMUCUserRealXID', e);
        }

    };


    /**
     * Gets the server of the user
     * @public
     * @return {string}
     */
    self.getServer = function() {

        try {
            // Return the domain of the user
            return con.domain;
        } catch(e) {
            Console.error('Utils.getServer', e);
        }

    };


    /**
     * Gets the password of the user
     * @public
     * @return {string}
     */
    self.getPassword = function() {

        try {
            // Return the password of the user
            return con.pass;
        } catch(e) {
            Console.error('Utils.getPassword', e);
        }

    };


    /**
     * Quotes the nick of an user. If a message is given, the nick is inserted at its end.
     * @public
     * @param {string} hash
     * @param {string} nick
     * @param {string} message
     * @return {undefined}
     */
    self.quoteMyNick = function(hash, nick, message) {

        try {
            $(document).oneTime(10, function() {
                if (message === undefined || message.length === 0) {
                    $('#page-engine #' + hash + ' .message-area').val(nick + ', ').focus();
                } else {
                    $('#page-engine #' + hash + ' .message-area').val(message + nick).focus();
                }
            });
        } catch(e) {
            Console.error('Utils.quoteMyNick', e);
        }
    
    };


    /**
     * Return the file category
     * @public
     * @param {string} ext
     * @return {string}
     */
    self.fileCategory = function(ext) {

        try {
            var cat;
            
            switch(ext) {
                // Images
                case 'jpg':
                case 'jpeg':
                case 'png':
                case 'bmp':
                case 'gif':
                case 'tif':
                case 'svg':
                case 'ico':
                case 'psp':
                case 'psd':
                case 'psb':
                case 'xcf':
                    cat = 'image';
                    
                    break;
                
                // Videos
                case 'ogv':
                case 'ogg':
                case 'mkv':
                case 'avi':
                case 'mov':
                case 'mp4':
                case 'm4v':
                case 'wmv':
                case 'asf':
                case 'mpg':
                case 'mpeg':
                case 'ogm':
                case 'rmvb':
                case 'rmv':
                case 'qt':
                case 'flv':
                case 'ram':
                case '3gp':
                case 'avc':
                    cat = 'video';
                    
                    break;
                
                // Sounds
                case 'oga':
                case 'mka':
                case 'flac':
                case 'mp3':
                case 'wav':
                case 'm4a':
                case 'wma':
                case 'rmab':
                case 'rma':
                case 'bwf':
                case 'aiff':
                case 'caf':
                case 'cda':
                case 'atrac':
                case 'vqf':
                case 'au':
                case 'aac':
                case 'm3u':
                case 'mid':
                case 'mp2':
                case 'snd':
                case 'voc':
                    cat = 'audio';
                    
                    break;
                
                // Documents
                case 'pdf':
                case 'odt':
                case 'ott':
                case 'sxw':
                case 'stw':
                case 'ots':
                case 'sxc':
                case 'stc':
                case 'sxi':
                case 'sti':
                case 'pot':
                case 'odp':
                case 'ods':
                case 'doc':
                case 'docx':
                case 'docm':
                case 'xls':
                case 'xlsx':
                case 'xlsm':
                case 'xlt':
                case 'ppt':
                case 'pptx':
                case 'pptm':
                case 'pps':
                case 'odg':
                case 'otp':
                case 'sxd':
                case 'std':
                case 'std':
                case 'rtf':
                case 'txt':
                case 'htm':
                case 'html':
                case 'shtml':
                case 'dhtml':
                case 'mshtml':
                    cat = 'document';
                    
                    break;
                
                // Packages
                case 'tgz':
                case 'gz':
                case 'tar':
                case 'ar':
                case 'cbz':
                case 'jar':
                case 'tar.7z':
                case 'tar.bz2':
                case 'tar.gz':
                case 'tar.lzma':
                case 'tar.xz':
                case 'zip':
                case 'xz':
                case 'rar':
                case 'bz':
                case 'deb':
                case 'rpm':
                case '7z':
                case 'ace':
                case 'cab':
                case 'arj':
                case 'msi':
                    cat = 'package';
                    
                    break;
                
                // Others
                default:
                    cat = 'other';
                    
                    break;
            }
            
            return cat;
        } catch(e) {
            Console.error('Utils.fileCategory', e);
        }

    };


    /**
     * Registers Jappix as the default XMPP links handler
     * @public
     * @return {boolean}
     */
    self.xmppLinksHandler = function() {

        try {
            navigator.registerProtocolHandler('xmpp', JAPPIX_LOCATION + '?x=%s', SERVICE_NAME);
            
            return true;
        } catch(e) {
            Console.error('Utils.xmppLinksHandler', e);

            return false;
        }

    };


    /**
     * Checks if a value exists in array
     * @public
     * @param {object} array
     * @param {string} value
     * @return {boolean}
     */
    self.existArrayValue = function(array, value) {

        val_exists = false;

        try {
            // Loop in the array
            for(var i in array) {
                if(array[i] == value) {
                    val_exists = true;
                    break;
                }
            }
        } catch(e) {
            Console.error('Utils.existArrayValue', e);
        } finally {
            return val_exists;
        }

    };


    /**
     * Removes a value from an array
     * @public
     * @param {object} array
     * @param {string} value
     * @return {boolean}
     */
    self.removeArrayValue = function(array, value) {

        was_removed = false;

        try {
            for(var i in array) {
                // It matches, remove it!
                if(array[i] == value) {
                    array.splice(i, 1);

                    was_removed = true;
                }
            }
        } catch(e) {
            Console.error('Utils.removeArrayValue', e);
        } finally {
            return was_removed;
        }

    };


    /**
     * Converts a string to an array
     * @public
     * @param {string} string
     * @return {object}
     */
    self.stringToArray = function(string) {

        try {
            var array = [];
            
            // Any string to convert?
            if(string) {
                // More than one item
                if(string.match(/,/gi)) {
                    var string_split = string.split(',');
                    
                    for(var i in string_split) {
                        if(string_split[i])
                            array.push(string_split[i]);
                        else
                            array.push('');
                    }
                }
                
                // Only one item
                else
                    array.push(string);
            }
            
            return array;
        } catch(e) {
            Console.error('Utils.stringToArray', e);
        }

    };


    /**
     * Get the index of an array value
     * @public
     * @param {object} array
     * @param {string} value
     * @return {number}
     */
    self.indexArrayValue = function(array, value) {

        try {
            // Nothing?
            if(!array || !array.length)
                return 0;
            
            // Read the index of the value
            var index = 0;
            
            for(var i = 0; i < array.length; i++) {
                if(array[i] == value) {
                    index = i;
                    
                    break;
                }
            }
            
            return index;
        } catch(e) {
            Console.error('Utils.indexArrayValue', e);
        }

    };


    /**
     * Capitalizes the first letter of a string
     * @public
     * @param {string} string
     * @return {string}
     */
    self.capitaliseFirstLetter = function(string) {

        try {
            return string.charAt(0).toUpperCase() + string.slice(1);
        } catch(e) {
            Console.error('Utils.capitaliseFirstLetter', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixUtils = Utils;
/*

Jappix - An open social platform
These are the date related JS scripts for Jappix

-------------------------------------------------

License: dual-licensed under AGPL and MPLv2
Author: Val√©rian Saliou

*/

// Bundle
var DateUtils = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.last_activity = 0;
    self.presence_last_activity = 0;


    /**
     * Gets a stamp from a date
     * @public
     * @param {Date} date
     * @return {number}
     */
    self.extractStamp = function(date) {

        try {
            return Math.round(date.getTime() / 1000);
        } catch(e) {
            Console.error('DateUtils.extractStamp', e);
        }

    };


    /**
     * Gets the time from a date
     * @public
     * @param {Date} date
     * @return {string}
     */
    self.extractTime = function(date) {

        try {
            return date.toLocaleTimeString();
        } catch(e) {
            Console.error('DateUtils.extractTime', e);
        }

    };


    /**
     * Gets the actual date stamp
     * @public
     * @return {number}
     */
    self.getTimeStamp = function() {

        try {
            return self.extractStamp(new Date());
        } catch(e) {
            Console.error('DateUtils.getTimeStamp', e);
        }

    };


    /**
     * Gets the last user activity in seconds
     * @public
     * @return {number}
     */
    self.getLastActivity = function() {

        try {
            // Last activity not yet initialized?
            if(self.last_activity === 0)
                return 0;
            
            return self.getTimeStamp() - self.last_activity;
        } catch(e) {
            Console.error('DateUtils.getLastActivity', e);
        }

    };


    /**
     * Gets the last user available presence in seconds
     * @public
     * @return {number}
     */
    self.getPresenceLast = function() {

        try {
            // Last presence stamp not yet initialized?
            if(self.presence_last_activity === 0)
                return 0;
            
            return self.getTimeStamp() - self.presence_last_activity;
        } catch(e) {
            Console.error('DateUtils.getPresenceLast', e);
        }

    };


    /**
     * Generates the time for XMPP
     * @public
     * @param {string} location
     * @return {string}
     */
    self.getXMPPTime = function(location) {

        /* FROM : http://trac.jwchat.org/jsjac/browser/branches/jsjac_1.0/jsextras.js?rev=221 */

        try {
            // Initialize
            var jInit = new Date();
            var year, month, day, hours, minutes, seconds;
            
            // Gets the UTC date
            if(location == 'utc') {
                year = jInit.getUTCFullYear();
                month = jInit.getUTCMonth();
                day = jInit.getUTCDate();
                hours = jInit.getUTCHours();
                minutes = jInit.getUTCMinutes();
                seconds = jInit.getUTCSeconds();
            }
            
            // Gets the local date
            else {
                year = jInit.getFullYear();
                month = jInit.getMonth();
                day = jInit.getDate();
                hours = jInit.getHours();
                minutes = jInit.getMinutes();
                seconds = jInit.getSeconds();
            }
            
            // Generates the date string
            var jDate = year + '-';
            jDate += Common.padZero(month + 1) + '-';
            jDate += Common.padZero(day) + 'T';
            jDate += Common.padZero(hours) + ':';
            jDate += Common.padZero(minutes) + ':';
            jDate += Common.padZero(seconds) + 'Z';
            
            // Returns the date string
            return jDate;
        } catch(e) {
            Console.error('DateUtils.getXMPPTime', e);
        }

    };


    /**
     * Generates then human time
     * @public
     * @return {string}
     */
    self.getCompleteTime = function() {

        try {
            var init = new Date();
            var time = Common.padZero(init.getHours()) + ':';
            time += Common.padZero(init.getMinutes()) + ':';
            time += Common.padZero(init.getSeconds());
            
            return time;
        } catch(e) {
            Console.error('DateUtils.getCompleteTime', e);
        }

    };


    /**
     * Gets the TZO of a date
     * @public
     * @return {string}
     */
    self.getTZO = function() {

        try {
            // Get the date
            var date = new Date();
            var offset = date.getTimezoneOffset();
            
            // Default vars
            var sign = '';
            var hours = 0;
            var minutes = 0;
            
            // Process a neutral offset
            if(offset < 0) {
                offset = offset * -1;
                sign = '+';
            }
            
            // Get the values
            var n_date = new Date(offset * 60 * 1000);
            hours = n_date.getHours() - 1;
            minutes = n_date.getMinutes();
            
            // Process the TZO
            tzo = sign + Common.padZero(hours) + ':' + Common.padZero(minutes);
            
            // Return the processed value
            return tzo;
        } catch(e) {
            Console.error('DateUtils.getTZO', e);
        }

    };


    /**
     * Returns a date representing the difference of time between 2 timestamps
     * @public
     * @param {string} now_stamp
     * @param {string} past_stamp
     * @return {Date}
     */
    self.difference = function(now_stamp, past_stamp) {

        try {
            return (new Date()).clearTime().addSeconds(
                past_stamp > 0 ? now_stamp - past_stamp : 0
            );
        } catch(e) {
            Console.error('DateUtils.difference', e);
        }

    };


    /**
     * Parses a XMPP date (yyyy-mm-dd, hh-mm-ss) into an human-readable one
     * @public
     * @param {string} to_parse
     * @return {string}
     */
    self.parse = function(to_parse) {

        try {
            var date = Date.jab2date(to_parse);
            var parsed = date.toLocaleDateString() + ' (' + date.toLocaleTimeString() + ')';
            
            return parsed;
        } catch(e) {
            Console.error('DateUtils.parse', e);
        }

    };


    /**
     * Parses a XMPP date (yyyy-mm-dd) into an human-readable one
     * @public
     * @param {string} to_parse
     * @return {string}
     */
    self.parseDay = function(to_parse) {

        try {
            var date = Date.jab2date(to_parse);
            var parsed = date.toLocaleDateString();
            
            return parsed;
        } catch(e) {
            Console.error('DateUtils.parseDay', e);
        }

    };


    /**
     * Parses a XMPP date (hh-mm-ss) into an human-readable one
     * @public
     * @param {string} to_parse
     * @return {string}
     */
    self.parseTime = function(to_parse) {

        try {
            var date = Date.jab2date(to_parse);
            var parsed = date.toLocaleTimeString();
            
            return parsed;
        } catch(e) {
            Console.error('DateUtils.parseTime', e);
        }

    };


    /**
     * Parses a XMPP date stamp into a relative one
     * @public
     * @param {string} to_parse
     * @return {string}
     */
    self.relative = function(to_parse) {

        try {
            // Get the current date
            var current_date = Date.jab2date(self.getXMPPTime('utc'));
            var current_day = current_date.getDate();
            var current_stamp = current_date.getTime();
            
            // Parse the given date
            var old_date = Date.jab2date(to_parse);
            var old_day = old_date.getDate();
            var old_stamp = old_date.getTime();
            var old_time = old_date.toLocaleTimeString();
            
            // Get the day number between the two dates
            var days = Math.round((current_stamp - old_stamp) / 86400000);
            
            // Invalid date?
            if(isNaN(old_stamp) || isNaN(days))
                return self.getCompleteTime();
            
            // Is it today?
            if(current_day == old_day)
                return old_time;
            
            // It is yesterday?
            if(days <= 1)
                return Common._e("Yesterday") + ' - ' + old_time;
            
            // Is it less than a week ago?
            if(days <= 7)
                return Common.printf(Common._e("%s days ago"), days) + ' - ' + old_time;
            
            // Another longer period
            return old_date.toLocaleDateString() + ' - ' + old_time;
        } catch(e) {
            Console.error('DateUtils.relative', e);
        }

    };


    /**
     * Reads a message delay
     * @public
     * @param {string} node
     * @return {string}
     */
    self.readMessageDelay = function(node) {

        try {
            // Initialize
            var delay, d_delay;
            
            // Read the delay
            d_delay = jQuery(node).find('delay[xmlns="' + NS_URN_DELAY + '"]:first').attr('stamp');
            
            // New delay (valid XEP)
            if(d_delay)
                delay = d_delay;
            
            // Old delay (obsolete XEP!)
            else {
                // Try to read the old-school delay
                var x_delay = jQuery(node).find('x[xmlns="' + NS_DELAY + '"]:first').attr('stamp');
                
                if(x_delay)
                    delay = x_delay.replace(/^(\w{4})(\w{2})(\w{2})T(\w{2}):(\w{2}):(\w{2})Z?(\S+)?/, '$1-$2-$3T$4:$5:$6Z$7');
            }
            
            return delay;
        } catch(e) {
            Console.error('DateUtils.readMessageDelay', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

var JappixDateUtils = DateUtils;
/*

Jappix - An open social platform
These are the CAPS JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var Caps = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Reads a stored Caps
     * @public
     * @param {string} caps
     * @return {object}
     */
    self.read = function(caps) {

        try {
            return Common.XMLFromString(
                DataStore.getPersistent('global', 'caps', caps)
            );
        } catch(e) {
            Console.error('Caps.read', e);
        }

    };


    /**
     * Returns an array of the Jappix disco#infos
     * @public
     * @return {object}
     */
    self.myDiscoInfos = function() {

        try {
            var disco_base = [
                NS_MUC,
                NS_MUC_USER,
                NS_MUC_ADMIN,
                NS_MUC_OWNER,
                NS_MUC_CONFIG,
                NS_DISCO_INFO,
                NS_DISCO_ITEMS,
                NS_PUBSUB_RI,
                NS_BOSH,
                NS_CAPS,
                NS_MOOD,
                NS_ACTIVITY,
                NS_TUNE,
                NS_GEOLOC,
                NS_NICK,
                NS_URN_MBLOG,
                NS_URN_INBOX,
                NS_MOOD + NS_NOTIFY,
                NS_ACTIVITY + NS_NOTIFY,
                NS_TUNE + NS_NOTIFY,
                NS_GEOLOC + NS_NOTIFY,
                NS_URN_MBLOG + NS_NOTIFY,
                NS_URN_INBOX + NS_NOTIFY,
                NS_URN_DELAY,
                NS_ROSTER,
                NS_ROSTERX,
                NS_HTTP_AUTH,
                NS_CHATSTATES,
                NS_XHTML_IM,
                NS_URN_MAM,
                NS_IPV6,
                NS_LAST,
                NS_PRIVATE,
                NS_REGISTER,
                NS_SEARCH,
                NS_COMMANDS,
                NS_VERSION,
                NS_XDATA,
                NS_VCARD,
                NS_IETF_VCARD4,
                NS_URN_ADATA,
                NS_URN_AMETA,
                NS_URN_TIME,
                NS_URN_PING,
                NS_URN_RECEIPTS,
                NS_PRIVACY,
                NS_IQOOB,
                NS_XOOB,
                NS_URN_CARBONS
            ];

            var disco_jingle = JSJaCJingle_disco();
            var disco_all = disco_base.concat(disco_jingle);
            
            return disco_all;
        } catch(e) {
            Console.error('Caps.myDiscoInfos', e);
        }

    };


    /**
     * Gets the disco#infos of an entity
     * @public
     * @param {string} to
     * @param {string} caps
     * @return {boolean}
     */
    self.getDiscoInfos = function(to, caps) {

        try {
            // No CAPS
            if(!caps) {
                Console.warn('No CAPS: ' + to);
                
                self.displayDiscoInfos(to, '');
                
                return false;
            }
            
            // Get the stored disco infos
            var xml = self.read(caps);
            
            // Yet stored
            if(xml) {
                Console.info('CAPS from cache: ' + to);
                
                self.displayDiscoInfos(to, xml);
                
                return true;
            }
            
            Console.info('CAPS from the network: ' + to);
            
            // Not stored: get the disco#infos
            var iq = new JSJaCIQ();
            
            iq.setTo(to);
            iq.setType('get');
            iq.setQuery(NS_DISCO_INFO);
            
            con.send(iq, self.handleDiscoInfos);
            
            return true;
        } catch(e) {
            Console.error('Caps.getDiscoInfos', e);
        }

    };


    /**
     * Handles the disco#infos of an entity
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleDiscoInfos = function(iq) {

        try {
            if(!iq || (iq.getType() == 'error'))
                return;
            
            // IQ received, get some values
            var from = Common.fullXID(Common.getStanzaFrom(iq));
            var query = iq.getQuery();
            
            // Generate the CAPS-processing values
            var identities = [];
            var features = [];
            var data_forms = [];
            
            // Identity values
            $(query).find('identity').each(function() {
                var pCategory = $(this).attr('category');
                var pType = $(this).attr('type');
                var pLang = $(this).attr('xml:lang');
                var pName = $(this).attr('name');
                
                if(!pCategory)
                    pCategory = '';
                if(!pType)
                    pType = '';
                if(!pLang)
                    pLang = '';
                if(!pName)
                    pName = '';
                
                identities.push(pCategory + '/' + pType + '/' + pLang + '/' + pName);
            });
            
            // Feature values
            $(query).find('feature').each(function() {
                var pVar = $(this).attr('var');
                
                // Add the current value to the array
                if(pVar)
                    features.push(pVar);
            });
            
            // Data-form values
            $(query).find('x[xmlns="' + NS_XDATA + '"]').each(function() {
                // Initialize some stuffs
                var pString = '';
                var sortVar = [];
                
                // Add the form type field
                $(this).find('field[var="FORM_TYPE"] value').each(function() {
                    var cText = $(this).text();
                    
                    if(cText)
                        pString += cText + '<';
                });
                
                // Add the var attributes into an array
                $(this).find('field:not([var="FORM_TYPE"])').each(function() {
                    var cVar = $(this).attr('var');
                    
                    if(cVar)
                        sortVar.push(cVar);
                });
                
                // Sort the var attributes
                sortVar = sortVar.sort();
                
                // Loop this sorted var attributes
                $.each(sortVar, function(i) {
                    // Initialize the value sorting
                    var sortVal = [];
                    
                    // Append it to the string
                    pString += sortVar[i] + '<';
                    
                    // Add each value to the array
                    $(this).find('field[var=' + sortVar[i] + '] value').each(function() {
                        sortVal.push($(this).text());
                    });
                    
                    // Sort the values
                    sortVal = sortVal.sort();
                    
                    // Append the values to the string
                    for(var j in sortVal) {
                        pString += sortVal[j] + '<';
                    }
                });
                
                // Any string?
                if(pString) {
                    // Remove the undesired double '<' from the string
                    if(pString.match(/(.+)(<)+$/))
                        pString = pString.substring(0, pString.length - 1);
                    
                    // Add the current string to the array
                    data_forms.push(pString);
                }
            });
            
            // Process the CAPS
            var caps = self.process(identities, features, data_forms);
            
            // Get the XML string
            var xml = Common.xmlToString(query);
            
            // Store the disco infos
            DataStore.setPersistent('global', 'caps', caps, xml);
            
            // This is our server
            if(from == Utils.getServer()) {
                // Handle the features
                Features.handle(xml);
                
                Console.info('Got our server CAPS');
            } else {
                // Display the disco infos
                self.displayDiscoInfos(from, xml);
                
                Console.info('Got CAPS: ' + from);
            }
        } catch(e) {
            Console.error('Caps.handleDiscoInfos', e);
        }

    };


    /**
     * Displays the disco#infos everywhere needed for an entity
     * @public
     * @param {string} from
     * @param {string} xml
     * @return {undefined}
     */
    self.displayDiscoInfos = function(from, xml) {

        try {
            // Generate the chat path
            var xid = Common.bareXID(from);
            
            // This comes from a private groupchat chat?
            if(Utils.isPrivate(xid))
                xid = from;
            
            hash = hex_md5(xid);

            // Display the supported features
            var features = {};

            $(xml).find('feature').each(function() {
                var current = $(this).attr('var');

                if(current) {
                    features[current] = 1;
                }
            });
            
            // Paths
            var path = $('#' + hash);
            var roster_path = $('#roster .buddy.' + hash);
            var roster_jingle_path = roster_path.find('.buddy-infos .call-jingle');

            var message_area = path.find('.message-area');
            var style = path.find('.chat-tools-style');
            var jingle_audio = path.find('.tools-jingle-audio');
            var roster_jingle_audio = roster_jingle_path.find('a.audio');
            var jingle_video = path.find('.tools-jingle-video');
            var roster_jingle_video = roster_jingle_path.find('a.video');
            var roster_jingle_separator = roster_jingle_path.find('span.separator');
            var file = path.find('.chat-tools-file');
            
            // Apply xHTML-IM
            if(NS_XHTML_IM in features) {
                style.show();
            } else {
                // Remove the tooltip elements
                style.hide();
                style.find('.bubble-style').remove();
                
                // Reset the markers
                message_area.removeAttr('style')
                        .removeAttr('data-font')
                        .removeAttr('data-fontsize')
                        .removeAttr('data-color')
                        .removeAttr('data-bold')
                        .removeAttr('data-italic')
                        .removeAttr('data-underline');
            }

            // Apply Jingle
            var jingle_local_supported = JSJAC_JINGLE_AVAILABLE;
            var jingle_audio_xid = self.getFeatureResource(xid, NS_JINGLE_APPS_RTP_AUDIO);
            var jingle_video_xid = self.getFeatureResource(xid, NS_JINGLE_APPS_RTP_VIDEO);

            if(jingle_audio_xid && jingle_local_supported) {
                jingle_audio.show();
                roster_jingle_audio.show();
            } else {
                jingle_audio.hide();
                roster_jingle_audio.hide();
            }

            if(jingle_video_xid && jingle_local_supported) {
                jingle_video.show();
                roster_jingle_video.show();
            } else {
                jingle_video.hide();
                roster_jingle_video.hide();
            }

            if(jingle_audio_xid && jingle_video_xid && jingle_local_supported) {
                roster_jingle_separator.show();
            } else {
                roster_jingle_separator.hide();
            }

            if((jingle_audio_xid || jingle_video_xid) && jingle_local_supported) {
                roster_jingle_path.show();
            } else {
                roster_jingle_path.hide();
            }
            
            // Apply Out of Band Data
            var iq_oob_xid = self.getFeatureResource(xid, NS_IQOOB);

            if(iq_oob_xid || NS_XOOB in features) {
                file.show();
                
                // Set a marker
                file.attr(
                    'data-oob',
                    iq_oob_xid ? 'iq' : 'x'
                );
            } else {
                // Remove the tooltip elements
                file.hide();
                file.find('.bubble-style').remove();
                
                // Reset the marker
                file.removeAttr('data-oob');
            }
            
            // Apply receipts
            if(NS_URN_RECEIPTS in features) {
                message_area.attr('data-receipts', 'true');
            } else {
                message_area.removeAttr('data-receipts');
            }
        } catch(e) {
            Console.error('Caps.displayDiscoInfos', e);
        }

    };


    /**
     * Generates the CAPS hash
     * @public
     * @param {object} cIdentities
     * @param {object} cFeatures
     * @param {object} cDataForms
     * @return {string}
     */
    self.process = function(cIdentities, cFeatures, cDataForms) {

        try {
            // Initialize
            var cString = '';
            
            // Sort the arrays
            cIdentities = cIdentities.sort();
            cFeatures = cFeatures.sort();
            cDataForms = cDataForms.sort();
            
            // Process the sorted identity string
            for(var a in cIdentities) {
                cString += cIdentities[a] + '<';
            }
            
            // Process the sorted feature string
            for(var b in cFeatures) {
                cString += cFeatures[b] + '<';
            }
            
            // Process the sorted data-form string
            for(var c in cDataForms) {
                cString += cDataForms[c] + '<';
            }
            
            // Process the SHA-1 hash
            var cHash = b64_sha1(cString);
            
            return cHash;
        } catch(e) {
            Console.error('Caps.process', e);
        }

    };


    /**
     * Generates the Jappix CAPS hash
     * @public
     * @return {string}
     */
    self.mine = function() {

        try {
            return self.process(
                ['client/web//Jappix'],
                self.myDiscoInfos(),
                []
            );
        } catch(e) {
            Console.error('Caps.mine', e);
        }

    };


    /**
     * Returns the user resource supporting given feature w/ highest priority
     * @public
     * @param {string} xid
     * @param {string} feature_ns
     * @return {string}
     */
    self.getFeatureResource = function(xid, feature_ns) {

        var selected_xid = null;

        try {
            if(!feature_ns) {
                throw 'No feature namespace given!';
            }

            var max_priority = null;
            var cur_xid_full, cur_presence_sel, cur_caps, cur_features, cur_priority;

            for(var cur_resource in Presence.resources(xid)) {
                cur_xid_full = xid + '/' + cur_resource;
                cur_presence_sel = $(Presence.readStanza(cur_xid_full));

                cur_priority = parseInt((cur_presence_sel.find('priority').text() || 0), 10);
                cur_caps = cur_presence_sel.find('caps').text();

                if(cur_caps) {
                    cur_features = self.read(cur_caps);

                    if(cur_features && $(cur_features).find('feature[var="' + feature_ns + '"]').size()  &&
                       (cur_priority >= max_priority || max_priority === null)) {
                        max_priority = cur_priority;
                        selected_xid = cur_xid_full;
                    }
                }
            }
        } catch(e) {
            Console.error('Caps.getFeatureResource', e);
        } finally {
            return selected_xid;
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the vCard JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou, Maranda

*/

// Bundle
var vCard = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the vCard popup
     * @public
     * @return {boolean}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html =
            '<div class="top">' + Common._e("Your profile") + '</div>' + 
            
            '<div class="tab">' + 
                '<a href="#" class="tab-active" data-key="1">' + Common._e("Identity") + '</a>' + 
                '<a href="#" data-key="2">' + Common._e("Profile image") + '</a>' + 
                '<a href="#" data-key="3">' + Common._e("Others") + '</a>' + 
            '</div>' + 
            
            '<div class="content">' + 
                '<div id="lap1" class="lap-active one-lap forms">' + 
                    '<fieldset>' + 
                        '<legend>' + Common._e("Personal") + '</legend>' + 
                        
                        '<label for="USER-FN">' + Common._e("Complete name") + '</label>' + 
                        '<input type="text" id="USER-FN" data-vcard4="fn-text" class="vcard-item" placeholder="John Locke" />' + 
                        
                        '<label for="USER-NICKNAME">' + Common._e("Nickname") + '</label>' + 
                        '<input type="text" id="USER-NICKNAME" data-vcard4="nickname-text" class="vcard-item" placeholder="Jo" />' + 
                        
                        '<label for="USER-N-GIVEN">' + Common._e("First name") + '</label>' + 
                        '<input type="text" id="USER-N-GIVEN" data-vcard4="n-given" class="vcard-item" placeholder="John" />' + 
                        
                        '<label for="USER-N-FAMILY">' + Common._e("Last name") + '</label>' + 
                        '<input type="text" id="USER-N-FAMILY" data-vcard4="n-surname" class="vcard-item" placeholder="Locke" />' + 
                        
                        '<label for="USER-BDAY">' + Common._e("Date of birth") + '</label>' + 
                        '<input type="text" id="USER-BDAY" data-vcard4="bday-date" class="vcard-item" pattern="^[0-9]{2}-[0-9]{2}-[0-9]{4}$" placeholder="16-02-1974" />' + 
                    '</fieldset>' + 
                    
                    '<fieldset>' + 
                        '<legend>' + Common._e("Contact") + '</legend>' + 
                        
                        '<label for="USER-EMAIL-USERID">' + Common._e("E-mail") + '</label>' + 
                        '<input type="text" id="USER-EMAIL-USERID" data-vcard4="email-text" class="vcard-item" placeholder="john@locke.fam" />' + 
                        
                        '<label for="USER-TEL-NUMBER">' + Common._e("Phone") + '</label>' + 
                        '<input type="text" id="USER-TEL-NUMBER" data-vcard4="tel-uri" class="vcard-item" placeholder="John" placeholder="+1-292-321-0812" />' + 
                        
                        '<label for="USER-URL">' + Common._e("Website") + '</label>' + 
                        '<input type="text" id="USER-URL" data-vcard4="url-uri" class="vcard-item" placeholder="john.locke.fam" />' + 
                    '</fieldset>' + 
                '</div>' + 
                
                '<div id="lap2" class="one-lap forms">' + 
                    '<fieldset>' + 
                        '<legend>' + Common._e("New") + '</legend>' + 
                        
                        '<input type="hidden" id="USER-PHOTO-TYPE" class="vcard-item" />' + 
                        '<input type="hidden" id="USER-PHOTO-BINVAL" class="vcard-item" />' + 
                        
                        '<form id="vcard-avatar" action="./server/avatar-upload.php" method="post" enctype="multipart/form-data">' + 
                            Interface.generateFileShare() + 
                        '</form>' + 
                    '</fieldset>' + 
                    
                    '<fieldset>' + 
                        '<legend>' + Common._e("Current") + '</legend>' + 
                        
                        '<div class="avatar-container"></div>' + 
                        
                        '<a href="#" class="one-button avatar-delete talk-images">' + Common._e("Delete") + '</a>' + 
                        '<div class="no-avatar">' + Common._e("What a pity! You have no profile image defined in your identity card!") + '</div>' + 
                    '</fieldset>' + 
                    
                    '<div class="avatar-wait avatar-info">' + Common._e("Please wait while your avatar is uploaded...") + '</div>' + 
                    '<div class="avatar-ok avatar-info">' + Common._e("Here it is! A new beautiful profile image!") + '</div>' + 
                    '<div class="avatar-error avatar-info">' + Common._e("The image file is not supported or has a bad size.") + '</div>' + 
                '</div>' + 
                
                '<div id="lap3" class="one-lap forms">' + 
                    '<fieldset>' + 
                        '<legend>' + Common._e("Address") + '</legend>' + 
                        
                        '<label for="USER-ADR-STREET">' + Common._e("Street") + '</label>' + 
                        '<input type="text" id="USER-ADR-STREET" data-vcard4="adr-street" class="vcard-item" placeholder="Manhattan" />' + 
                        
                        '<label for="USER-ADR-LOCALITY">' + Common._e("City") + '</label>' + 
                        '<input type="text" id="USER-ADR-LOCALITY" data-vcard4="adr-locality" class="vcard-item" placeholder="New-York" />' + 
                        
                        '<label for="USER-ADR-PCODE">' + Common._e("Postal code") + '</label>' + 
                        '<input type="text" id="USER-ADR-PCODE" data-vcard4="adr-code" class="vcard-item" placeholder="10002" />' + 
                        
                        '<label for="USER-ADR-CTRY">' + Common._e("Country") + '</label>' + 
                        '<input type="text" id="USER-ADR-CTRY" data-vcard4="adr-country" class="vcard-item" placeholder="USA" />' + 
                    '</fieldset>' + 
                    
                    '<fieldset>' + 
                        '<legend>' + Common._e("Biography") + '</legend>' + 
                        
                        '<textarea id="USER-DESC" data-vcard4="note-text" rows="8" cols="60" class="vcard-item"></textarea>' + 
                    '</fieldset>' + 
                '</div>' + 
                
                '<div class="infos">' + 
                    '<p class="infos-title">' + Common._e("Important notice") + '</p>' + 
                    
                    '<p>' + Common._e("Be careful with the information you store into your profile, because it might be accessible by everyone (even someone you don't want to).") + '</p>' + 
                    '<p>' + Common._e("Not everything is private on XMPP; this is one of those things, your public profile (vCard).") + '</p>' + 
                    '<p>' + Common.printf(Common._e("It is strongly recommended to upload a profile image (%s maximum), like a picture of yourself, because that makes you easily recognizable by your friends."), JAPPIX_MAX_UPLOAD) + '</p>' + 
                    '<p><b><a href="https://me.jappix.com/new" target="_blank">' + Common._e("Enable my public profile") + ' ¬ª</a></b></p>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish save disabled">' + Common._e("Save") + '</a>' + 
                '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('vcard', html);
            
            // Associate the events
            self.instance();
            
            // We get the VCard informations
            self.get(Common.getXID(), 'user');
        } catch(e) {
            Console.error('vCard.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Closes the vCard popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('vcard');
            
            // Create the welcome end popup?
            if(Welcome.is_done) {
                // Open popup
                Me.open();
                
                // Unavoidable popup
                $('#me').addClass('unavoidable');
            }
        } catch(e) {
            Console.error('vCard.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Switches the vCard popup tabs
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.switchTab = function(id) {

        try {
            $('#vcard .one-lap').removeClass('lap-active');
            $('#vcard #lap' + id).addClass('lap-active');
            $('#vcard .tab a').removeClass('tab-active');
            $('#vcard .tab a[data-key="' + id + '"]').addClass('tab-active');
        } catch(e) {
            Console.error('vCard.switchTab', e);
        } finally {
            return false;
        }

    };


    /**
     * Waits for the avatar upload reply
     * @public
     * @return {undefined}
     */
    self.waitAvatarUpload = function() {

        try {
            // Reset the avatar info
            $('#vcard .avatar-info').hide().stopTime();
            
            // Show the wait info
            $('#vcard .avatar-wait').show();
        } catch(e) {
            Console.error('vCard.waitAvatarUpload', e);
        }

    };


    /**
     * Handles the avatar upload reply
     * @public
     * @param {object} responseXML
     * @return {undefined}
     */
    self.handleAvatarUpload = function(responseXML) {

        try {
            // Data selector
            var dData = $(responseXML).find('jappix');
            
            // Not current upload session?
            if(parseInt(dData.attr('id')) != parseInt($('#vcard-avatar input[name="id"]').val())) {
                return;
            }
            
            // Reset the avatar info
            $('#vcard .avatar-info').hide().stopTime();
            
            // Process the returned data
            if(!dData.find('error').size()) {
                // Read the values
                var aType = dData.find('type').text();
                var aBinval = dData.find('binval').text();
                
                // We remove everything that isn't useful right here
                $('#vcard .no-avatar').hide();
                $('#vcard .avatar').remove();
                
                // We display the delete button
                $('#vcard .avatar-delete').show();
                
                // We tell the user it's okay
                $('#vcard .avatar-ok').show();
                
                // Timer
                $('#vcard .avatar-info').oneTime('10s', function() {
                    $(this).hide();
                });
                
                // We put the base64 values in a hidden input to be sent
                $('#USER-PHOTO-TYPE').val(aType);
                $('#USER-PHOTO-BINVAL').val(aBinval);
                
                // We display the avatar !
                $('#vcard .avatar-container').replaceWith('<div class="avatar-container"><img class="avatar" src="data:' + aType + ';base64,' + aBinval + '" alt="" /></div>');
            }
            
            // Any error?
            else {
                $('#vcard .avatar-error').show();
                
                // Timer
                $('#vcard .avatar-info').oneTime('10s', function() {
                    $(this).hide();
                });
                
                Console.error('Error while uploading the avatar', dData.find('error').text());
            }
        } catch(e) {
            Console.error('vCard.handleAvatarUpload', e);
        }

    };


    /**
     * Deletes the encoded avatar of an user
     * @public
     * @return {boolean}
     */
    self.deleteAvatar = function() {

        try {
            // We remove the avatar displayed elements
            $('#vcard .avatar-info').stopTime();
            $('#vcard .avatar-info, #vcard .avatar-wait, #vcard .avatar-error, #vcard .avatar-ok, #vcard .avatar-delete').hide();
            $('#vcard .avatar').remove();
            
            // We reset the input value
            $('#USER-PHOTO-TYPE, #USER-PHOTO-BINVAL').val('');
            
            // We show the avatar-uploading request
            $('#vcard .no-avatar').show();
        } catch(e) {
            Console.error('vCard.deleteAvatar', e);
        } finally {
            return false;
        }

    };


    /**
     * Creates a special vCard input
     * @public
     * @param {string} id
     * @param {string} type
     * @return {undefined}
     */
    self.createInput = function(id, type) {

        try {
            // Generate the new ID
            id = 'USER-' + id;
            
            // Can append the content
            if((type == 'user') && !Common.exists('#vcard #' + id)) {
                $('#vcard .content').append('<input id="' + id + '" class="vcard-item" type="hidden" />');
            }
        } catch(e) {
            Console.error('vCard.createInput', e);
        }

    };


    /**
     * Gets the vCard of a XID
     * @public
     * @param {string} to
     * @param {string} type
     * @return {undefined}
     */
    self.get = function(to, type) {

        try {
            // Generate a special ID
            var id = genID();
            
            // New IQ
            var iq = new JSJaCIQ();
            iq.setID(id);
            iq.setType('get');
            iq.appendNode('vCard', {'xmlns': NS_VCARD});
            
            // Send the IQ to the good user
            if(type == 'user') {
                // Show the wait icon
                $('#vcard .wait').show();
                
                // Apply the session ID
                $('#vcard').attr('data-vcard', id);
                
                // Send the IQ
                con.send(iq, self.handleUser);
            }
            
            else {
                // Show the wait icon
                $('#userinfos .wait').show();
                
                // Apply the session ID
                $('#userinfos').attr('data-vcard', id);
                
                // Send the IQ
                iq.setTo(to);
                con.send(iq, self.handleBuddy);
            }
        } catch(e) {
            Console.error('vCard.get', e);
        }

    };


    /**
     * Handles the current connected user's vCard
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleUser = function(iq) {

        try {
            self.handle(iq, 'user');
        } catch(e) {
            Console.error('vCard.handleUser', e);
        }

    };


    /**
     * Handles an external buddy vCard
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleBuddy = function(iq) {

        try {
            self.handle(iq, 'buddy');
        } catch(e) {
            Console.error('vCard.handleBuddy', e);
        }

    };


    /**
     * Handles a vCard stanza
     * @public
     * @param {object} iq
     * @param {string} type
     * @return {undefined}
     */
    self.handle = function(iq, type) {

        try {
            // Extract the data
            var iqID = iq.getID();
            var iqFrom = Common.fullXID(Common.getStanzaFrom(iq));
            var iqNode = iq.getNode();

            // Define some paths
            var path_vcard = '#vcard[data-vcard="' + iqID + '"]';
            var path_userInfos = '#userinfos[data-vcard="' + iqID + '"]';
            
            // End if the session does not exist
            if(((type == 'user') && !Common.exists(path_vcard)) || ((type == 'buddy') && !Common.exists(path_userInfos))) {
                return;
            }

            // We retrieve main values
            var values_yet = [];
            
            $(iqNode).find('vCard').children().each(function() {
                // Read the current parent node name
                var tokenname = (this).nodeName.toUpperCase();
                
                // Node with a parent
                if($(this).children().size()) {
                    $(this).children().each(function() {
                        // Get the node values
                        var currentID = tokenname + '-' + (this).nodeName.toUpperCase();
                        var currentText = $(this).text();
                        
                        // Not yet added?
                        if(!Utils.existArrayValue(values_yet, currentID)) {
                            // Create an input if it does not exist
                            self.createInput(values_yet, type);
                            
                            // Userinfos viewer popup
                            if((type == 'buddy') && currentText) {
                                if(currentID == 'EMAIL-USERID')
                                    $(path_userInfos + ' #BUDDY-' + currentID).html('<a href="mailto:' + currentText.htmlEnc() + '" target="_blank">' + currentText.htmlEnc() + '</a>');
                                else
                                    $(path_userInfos + ' #BUDDY-' + currentID).text(currentText.htmlEnc());
                            }
                            
                            // Profile editor popup
                            else if(type == 'user') {
                                $(path_vcard + ' #USER-' + currentID).val(currentText);
                            }
                            
                            // Avoid duplicating the value
                            values_yet.push(currentID);
                        }
                    });
                }
                
                // Node without any parent
                else {
                    // Get the node values
                    var currentText = $(this).text();
                    
                    // Not yet added?
                    if(!Utils.existArrayValue(values_yet, tokenname)) {
                        // Create an input if it does not exist
                        self.createInput(tokenname, type);
                        
                        // Userinfos viewer popup
                        if((type == 'buddy') && currentText) {
                            // URL modification
                            if(tokenname == 'URL') {
                                // No http:// or https:// prefix, we should add it
                                if(!currentText.match(/^https?:\/\/(.+)/))
                                    currentText = 'http://' + currentText;
                                
                                currentText = '<a href="' + currentText + '" target="_blank">' + currentText.htmlEnc() + '</a>';
                            }
                            
                            // Description modification
                            else if(tokenname == 'DESC') {
                                currentText = Filter.message(currentText, Name.getBuddy(iqFrom).htmlEnc(), true);
                            }
                            
                            // Other stuffs
                            else {
                                currentText = currentText.htmlEnc();
                            }
                            
                            $(path_userInfos + ' #BUDDY-' + tokenname).html(currentText);
                        }
                        
                        // Profile editor popup
                        else if(type == 'user')
                            $(path_vcard + ' #USER-' + tokenname).val(currentText);
                        
                        // Avoid duplicating the value
                        values_yet.push(tokenname);
                    }
                }
            });

            // Update the stored avatar
            if(type == 'buddy') {
                // Get the avatar XML
                var xml = DataStore.getPersistent('global', 'avatar', iqFrom);
                
                // If there were no stored avatar previously
                if($(Common.XMLFromString(xml)).find('type').text() == 'none') {
                    xml = xml.replace(/<forced>false<\/forced>/gi, '<forced>true</forced>');
                    DataStore.setPersistent(Common.getXID(), 'avatar', iqFrom, xml);
                }
                
                // Handle the user avatar
                Avatar.handle(iq);
            }

            // The avatar values targets
            var aBinval, aType, aContainer;
            
            if(type == 'user') {
                aBinval = $('#USER-PHOTO-BINVAL').val();
                aType = $('#USER-PHOTO-TYPE').val();
                aContainer = path_vcard + ' .avatar-container';
            }
            
            else {
                aBinval = $(iqNode).find('BINVAL:first').text();
                aType = $(iqNode).find('TYPE:first').text();
                aContainer = path_userInfos + ' .avatar-container';
            }

            // We display the avatar if retrieved
            if(aBinval) {
                // No type?
                if(!aType) {
                    aType = 'image/png';
                }
                
                if(type == 'user') {
                    // We move all the things that we don't need in that case
                    $(path_vcard + ' .no-avatar').hide();
                    $(path_vcard + ' .avatar-delete').show();
                    $(path_vcard + ' .avatar').remove();
                }
                
                // We display the avatar we have just received
                $(aContainer).replaceWith('<div class="avatar-container"><img class="avatar" src="data:' + aType + ';base64,' + aBinval + '" alt="" /></div>');
            }
            
            else if(type == 'buddy') {
                $(aContainer).replaceWith('<div class="avatar-container"><img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" /></div>');
            }

            // Do someting depending of the type
            if(type == 'user') {
                $(path_vcard + ' .wait').hide();
                $(path_vcard + ' .finish:first').removeClass('disabled');
            } else {
                UserInfos.vCard();
            }
            
            Console.log('vCard received: ' + iqFrom);
        } catch(e) {
            Console.error('vCard.handle', e);
        }

    };


    /**
     * Sends the vCard of the user
     * @public
     * @return {boolean}
     */
    self.send = function() {

        try {
            // Send both vcard-temp + vCard4
            self._sendLegacy();
            self._sendForward();
            
            // Send the user nickname & avatar over PEP
            if(Features.enabledPEP()) {
                self._sendPubsub();
            }
            
            // Close the vCard stuffs
            self.close();
            
            // Get our new avatar
            Avatar.get(Common.getXID(), 'force', 'true', 'forget');
            
            Console.log('vCard sent.');
        } catch(e) {
            Console.error('vCard.send', e);
        } finally {
            return false;
        }

    };


    /**
     * Generate XML tree
     * @private
     * @return {boolean}
     */
    self._generateTree = function(namespace, stanza, node) {

        try {
            var selector = $('#vcard .vcard-item');
            var get_id_fn = function(this_sel) {
                var id = this_sel.attr('id');
                return id ? id.replace(/^USER-(.+)/, '$1') : null;
            };

            if(namespace === NS_IETF_VCARD4) {
                selector = selector.filter('[data-vcard4]');
                get_id_fn = function(this_sel) {
                    return this_sel.attr('data-vcard4') || null;
                };
            }

            // We send the identity part of the form
            selector.each(function() {
                var this_sel = $(this);

                var item_id = get_id_fn(this_sel);
                var item_value = this_sel.val();

                if(item_value && item_id) {
                    if(item_id.indexOf('-') !== -1) {
                        var tagname = Common.explodeThis('-', item_id, 0);
                        var cur_node;

                        if(node.getElementsByTagName(tagname).length > 0)
                            cur_node = node.getElementsByTagName(tagname).item(0);
                        else
                            cur_node = node.appendChild(stanza.buildNode(tagname, {'xmlns': namespace}));
                        
                        cur_node.appendChild(
                            stanza.buildNode(
                                Common.explodeThis('-', item_id, 1),
                                {'xmlns': namespace},
                                item_value
                            )
                        );
                    } else {
                        node.appendChild(stanza.buildNode(item_id, {'xmlns': namespace}, item_value));
                    }
                }
            });

            return true;
        } catch(e) {
            Console.error('vCard._generateTree', e);

            return false;
        }

    };


    /**
     * Configure given Pubsub node
     * @private
     * @param {string} namespace
     * @return {undefined}
     */
    self._configureNode = function(namespace) {

        try {
            Pubsub.setup(null, namespace, '1', '1', 'open', 'whitelist');
        } catch(e) {
            Console.error('vCard._configureNode', e);
        }

    };


    /**
     * Send legacy vCard
     * @private
     * @return {undefined}
     */
    self._sendLegacy = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var vCard = iq.appendNode('vCard', {
                'xmlns': NS_VCARD
            });

            self._generateTree(NS_VCARD, iq, vCard);
            
            con.send(iq);
        } catch(e) {
            Console.error('vCard._sendLegacy', e);
        }

    };


    /**
     * Send forward version vCard (vCard 4)
     * @private
     * @return {undefined}
     */
    self._sendForward = function() {

        try {
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            // Build Pubsub headers
            var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});

            var publish = pubsub.appendChild(iq.buildNode('publish', {
                'node': NS_XMPP_VCARD4,
                'xmlns': NS_PUBSUB
            }));

            var item = publish.appendChild(iq.buildNode('item', {
                'xmlns': NS_PUBSUB,
                'id': 'current'
            }));

            // Generate vCard4 tree
            var vcard = item.appendChild(iq.buildNode('vcard', {
                'xmlns': NS_IETF_VCARD4
            }));
            
            self._generateTree(NS_IETF_VCARD4, iq, vcard);
            
            con.send(iq);

            // Make it publicly-viewable
            self._configureNode(NS_XMPP_VCARD4);
        } catch(e) {
            Console.error('vCard._sendForward', e);
        }

    };


    /**
     * Send other Pubsub items
     * @private
     * @return {undefined}
     */
    self._sendPubsub = function() {

        try {
            // Generate some values
            var photo_bin = $('#USER-PHOTO-BINVAL').val();
            var photo_data = Base64.decode(photo_bin) || '';
            
            // Data to be sent
            var send_data = {};
            send_data[NS_NICK] = $('#USER-NICKNAME').val();
            send_data[NS_URN_ADATA] = photo_bin;
            send_data[NS_URN_AMETA] = {
                'type': $('#USER-PHOTO-TYPE').val(),
                'id': (hex_sha1(photo_data) || ''),
                'bytes': (photo_data.length || '')
            };
            
            // Generate the XML
            $.each(send_data, function(namespace, data) {
                var iq = new JSJaCIQ();
                iq.setType('set');
                
                var pubsub = iq.appendNode('pubsub', {'xmlns': NS_PUBSUB});
                var publish = pubsub.appendChild(iq.buildNode('publish', {'node': namespace, 'xmlns': NS_PUBSUB}));

                if(data) {
                    var item;

                    if(namespace === NS_NICK) {
                        item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
                        
                        // Nickname element
                        item.appendChild(iq.buildNode('nick', {'xmlns': NS_NICK}, data));
                    } else if(namespace === NS_URN_ADATA || namespace === NS_URN_AMETA) {
                        item = publish.appendChild(iq.buildNode('item', {'xmlns': NS_PUBSUB}));
                        
                        // Apply the SHA-1 hash
                        if(send_data[NS_URN_AMETA].id) {
                            item.setAttribute('id', send_data[NS_URN_AMETA].id);
                        }
                        
                        // Append XML nodes depending on namespace
                        if(namespace === NS_URN_ADATA) {
                            item.appendChild(iq.buildNode('data', {'xmlns': NS_URN_ADATA}, data));
                        } else if(namespace === NS_URN_AMETA) {
                            var metadata = item.appendChild(iq.buildNode('metadata', {'xmlns': NS_URN_AMETA}));
                            
                            if(data) {
                                var meta_info = metadata.appendChild(iq.buildNode('info', {'xmlns': NS_URN_AMETA}));
                                
                                if(data.type)
                                    meta_info.setAttribute('type', data.type);
                                if(data.id)
                                    meta_info.setAttribute('id', data.id);
                                if(data.bytes)
                                    meta_info.setAttribute('bytes', data.bytes);
                            }
                        }
                    }
                }

                con.send(iq);

                // Make node publicly-viewable
                self._configureNode(namespace);
            });
        } catch(e) {
            Console.error('vCard._sendPubsub', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Focus on the first input
            $(document).oneTime(10, function() {
                $('#vcard input:first').focus();
            });
            
            // Keyboard events
            $('#vcard input[type="text"]').keyup(function(e) {
                // Enter pressed: send the vCard
                if((e.keyCode == 13) && !$('#vcard .finish.save').hasClass('disabled'))
                    return self.send();
            });
            
            // Click events
            $('#vcard .tab a').click(function() {
                // Yet active?
                if($(this).hasClass('tab-active'))
                    return false;
                
                // Switch to the good tab
                var key = parseInt($(this).attr('data-key'));
                
                return self.switchTab(key);
            });
            
            $('#vcard .avatar-delete').click(function() {
                return self.deleteAvatar();
            });
            
            $('#vcard .bottom .finish').click(function() {
                if($(this).is('.cancel'))
                    return self.close();
                if($(this).is('.save') && !$(this).hasClass('disabled'))
                    return self.send();
                
                return false;
            });
            
            // Avatar upload vars
            var avatar_options = {
                dataType:       'xml',
                beforeSubmit:   self.waitAvatarUpload,
                success:        self.handleAvatarUpload
            };
            
            // Avatar upload form submit event
            $('#vcard-avatar').submit(function() {
                if($('#vcard .wait').is(':hidden') && $('#vcard .avatar-info.avatar-wait').is(':hidden') && $('#vcard-avatar input[type="file"]').val())
                    $(this).ajaxSubmit(avatar_options);
                
                return false;
            });
            
            // Avatar upload input change event
            $('#vcard-avatar input[type="file"]').change(function() {
                if($('#vcard .wait').is(':hidden') && $('#vcard .avatar-info.avatar-wait').is(':hidden') && $(this).val())
                    $('#vcard-avatar').ajaxSubmit(avatar_options);
                
                return false;
            });
            
            // Placeholders
            $('#vcard-avatar input[type="text"]').placeholder();
        } catch(e) {
            Console.error('vCard.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the user-infos JS scripts for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var UserInfos = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Opens the user-infos popup
     * @public
     * @param {string} xid
     * @return {boolean}
     */
    self.open = function(xid) {

        try {
            // Can show shortcuts?
            var shortcuts = '';
            
            if(xid != Common.getXID()) {
                shortcuts = '<div class="shortcuts">' + 
                            '<a href="#" class="message talk-images" title="' + Common._e("Send him/her a message") + '" onclick="UserInfos.close(); return Inbox.composeMessage(\'' + Utils.encodeOnclick(xid) + '\');"></a>' + 
                            '<a href="#" class="chat talk-images" title="' + Common._e("Start a chat with him/her") + '" onclick="UserInfos.close(); return Chat.checkCreate(\'' + Utils.encodeOnclick(xid) + '\', \'chat\');"></a>' + 
                            '<a href="#" class="command talk-images" title="' + Common._e("Command") + '" onclick="UserInfos.close(); return AdHoc.retrieve(\'' + Utils.encodeOnclick(xid) + '\');"></a>' + 
                             '</div>';
            }
            
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("User profile") + '</div>' + 
            
            '<div class="tab">' + 
                '<a href="#" class="tab-active" data-key="1">' + Common._e("General") + '</a>' + 
                '<a href="#" data-key="2">' + Common._e("Advanced") + '</a>' + 
                '<a href="#" data-key="3">' + Common._e("Comments") + '</a>' + 
            '</div>' + 
            
            '<div class="content">' + 
                '<div class="lap-active one-lap info1">' + 
                    '<div class="main-infos">' + 
                        '<div class="avatar-container">' + 
                            '<img class="avatar" src="' + './images/others/default-avatar.png' + '" alt="" />' + 
                        '</div>' + 
                        
                        '<h1 id="BUDDY-FN" class="reset-info">' + Common._e("unknown") + '</h1>' + 
                        '<h2 class="buddy-xid" class="reset-info">' + Common._e("unknown") + '</h2>' + 
                        '<h3 class="buddy-last" class="reset-info">' + Common._e("unknown") + '</h3>' + 
                        
                        shortcuts + 
                    '</div>' + 
                    
                    '<div class="block-infos">' + 
                        '<div class="one-line"><b class="line-label">' + Common._e("Date of birth") + '</b><span id="BUDDY-BDAY" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("E-mail") + '</b><span id="BUDDY-EMAIL-USERID" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("Phone") + '</b><span id="BUDDY-TEL-NUMBER" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("Website") + '</b><span id="BUDDY-URL" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                    '</div>' + 
                    
                    '<div class="block-infos">' + 
                        '<div class="one-line"><b class="line-label">' + Common._e("Client") + '</b><span id="BUDDY-CLIENT" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("System") + '</b><span id="BUDDY-SYSTEM" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("Local time") + '</b><span id="BUDDY-TIME" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                    '</div>' + 
                '</div>' + 
                
                '<div class="one-lap info2">' + 
                    '<div class="block-infos">' + 
                        '<div class="one-line"><b class="line-label">' + Common._e("Street") + '</b><span id="BUDDY-ADR-STREET" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("City") + '</b><span id="BUDDY-ADR-LOCALITY" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("Postal code") + '</b><span id="BUDDY-ADR-PCODE" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                        
                        '<div class="one-line"><b class="line-label">' + Common._e("Country") + '</b><span id="BUDDY-ADR-CTRY" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                    '</div>' + 
                    
                    '<div class="block-infos">' + 
                        '<div class="one-line"><b class="line-label">' + Common._e("Biography") + '</b><span id="BUDDY-DESC" class="reset-info">' + Common._e("unknown") + '</span></div>' + 
                    '</div>' + 
                '</div>' + 
                
                '<div class="one-lap info3">' + 
                    '<textarea class="rosternotes" rows="8" cols="60"></textarea>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('userinfos', html);
            
            // Associate the events
            UserInfos.instance();
            
            // We retrieve the user's vcard
            self.retrieve(xid);
        } catch(e) {
            Console.error('UserInfos.open', e);
        } finally {
            return false;
        }

    };


    /**
     * Closes the user-infos popup
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Send the buddy comments
            self.sendBuddyComments();
            
            // Destroy the popup
            Popup.destroy('userinfos');
        } catch(e) {
            Console.error('UserInfos.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the user-infos
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.retrieve = function(xid) {

        try {
            // We setup the waiting indicator
            markers = 'vcard last';
            
            // We put the user's XID
            $('#userinfos .buddy-xid').text(xid);
            
            // We get the vCard
            vCard.get(xid, 'buddy');
            
            // Get the highest resource for this XID
            var cXID = Presence.highestPriority(xid);
            var pXID = xid;
            
            // If the user is logged in
            if(cXID) {
                // Change the XID
                pXID = cXID;
                
                // We request the user's system infos
                self.query(cXID, 'version');
                
                // We request the user's local time
                self.query(cXID, 'time');
                
                // Add these to the markers
                markers += ' version time';
            }
            
            // We request the user's last activity
            self.query(pXID, 'last');
            
            // Add the markers
            $('#userinfos .content').addClass(markers);
            
            // We request all the user's comments
            self.displayBuddyComments(xid);
        } catch(e) {
            Console.error('UserInfos.retrieve', e);
        }

    };


    /**
     * Builds the asked user-infos query
     * @public
     * @param {string} xid
     * @param {string} mode
     * @return {undefined}
     */
    self.query = function(xid, mode) {

        try {
            // Generate a session ID
            var id = genID();
            $('#userinfos').attr('data-' + mode, id);
            
            // New IQ
            var iq = new JSJaCIQ();
            
            iq.setID(id);
            iq.setType('get');
            iq.setTo(xid);
            
            // Last activity query
            if(mode == 'last') {
                iq.setQuery(NS_LAST);
                con.send(iq, self.lastActivityUserInfos);
            }
            
            // Time query
            else if(mode == 'time') {
                iq.appendNode('time', {'xmlns': NS_URN_TIME});
                con.send(iq, self.localTime);
            }
            
            // Version query
            else if(mode == 'version') {
                iq.setQuery(NS_VERSION);
                con.send(iq, self.version);
            }
        } catch(e) {
            Console.error('UserInfos.query', e);
        }

    };


    /**
     * Checks if the waiting item can be hidden
     * @public
     * @return {undefined}
     */
    self.vCard = function() {

        try {
            $('#userinfos .content').removeClass('vcard');
            self.wait();
        } catch(e) {
            Console.error('UserInfos.vCard', e);
        }

    };


    /**
     * Displays the buddy comments
     * @public
     * @param {string} xid
     * @return {undefined}
     */
    self.displayBuddyComments = function(xid) {

        try {
            var value = DataStore.getDB(Connection.desktop_hash, 'rosternotes', xid);
            
            if(value) {
                $('#userinfos .rosternotes').val(value);
            }
        } catch(e) {
            Console.error('UserInfos.displayBuddyComments', e);
        }

    };


    /**
     * Displays the user's last activity result
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.lastActivity = function(iq) {

        try {
            // Extract the request ID
            var id = iq.getID();
            var path = '#userinfos[data-last="' + id + '"]';
            
            // End if session does not exist
            if(!Common.exists(path))
                return;
            
            if(iq && (iq.getType() == 'result')) {
                // Get the values
                var from = Common.fullXID(Common.getStanzaFrom(iq));
                var seconds = $(iq.getNode()).find('query').attr('seconds');
                
                // Any seconds?
                if(seconds !== undefined) {
                    // Initialize the parsing
                    var last;
                    seconds = parseInt(seconds);
                    
                    // Active user
                    if(seconds <= 60)
                        last = Common._e("User currently active");
                    
                    // Inactive user
                    else {
                        // Parse the date
                        var date_now = new Date();
                        var time_now = date_now.getTime();
                        var date_last = new Date(date_now - (seconds * 1000));
                        var date = date_last.toLocaleString();
                        
                        // Offline user
                        if(from.indexOf('/') == -1)
                            last = Common.printf(Common._e("Last seen: %s"), date);
                        
                        // Online user
                        else
                            last = Common.printf(Common._e("Inactive since: %s"), date);
                    }
                    
                    // Append this text
                    $('#userinfos .buddy-last').text(last);
                }
                
                Console.log('Last activity received: ' + from);
            }
            
            $('#userinfos .content').removeClass('last');
            self.wait();
        } catch(e) {
            Console.error('UserInfos.lastActivity', e);
        }

    };


    /**
     * Displays the user's software version result
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.version = function(iq) {

        try {
            // Extract the request ID
            var id = iq.getID();
            var path = '#userinfos[data-version="' + id + '"]';
            
            // End if session does not exist
            if(!Common.exists(path))
                return;
            
            // Extract the reply data
            if(iq && (iq.getType() == 'result')) {
                // Get the values
                var xml = iq.getQuery();
                var name = $(xml).find('name').text();
                var version = $(xml).find('version').text();
                var os = $(xml).find('os').text();
                
                // Put the values together
                if(name && version)
                    name = name + ' ' + version;
                
                // Display the values
                if(name)
                    $(path + ' #BUDDY-CLIENT').text(name);
                if(os)
                    $(path + ' #BUDDY-SYSTEM').text(os);
                
                Console.log('Software version received: ' + Common.fullXID(Common.getStanzaFrom(iq)));
            }
            
            $('#userinfos .content').removeClass('version');
            self.wait();
        } catch(e) {
            Console.error('UserInfos.version', e);
        }

    };


    /**
     * Displays the user's local time result
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.localTime = function(iq) {

        try {
            // Extract the request ID
            var id = iq.getID();
            var path = '#userinfos[data-time="' + id + '"]';
            
            // End if session does not exist
            if(!Common.exists(path))
                return;
            
            if(iq && (iq.getType() == 'result')) {
                // Get the values
                var xml = iq.getNode();
                var tzo = $(xml).find('tzo').text();
                var utc = $(xml).find('utc').text();
                
                // Any UTC?
                if(utc) {
                    // Add the TZO if there's no one
                    if(tzo && utc.match(/^(.+)Z$/))
                        utc = RegExp.$1 + tzo;
                    
                    // Get the local date string
                    var local_string = Date.hrTime(utc);
                    
                    // Then display it
                    $(path + ' #BUDDY-TIME').text(local_string);
                }
                
                Console.log('Local time received: ' + Common.fullXID(Common.getStanzaFrom(iq)));
            }
            
            $('#userinfos .content').removeClass('time');
            self.wait();
        } catch(e) {
            Console.error('UserInfos.localTime', e);
        }

    };


    /**
     * Hides the waiting image if needed
     * @public
     * @return {undefined}
     */
    self.wait = function() {

        try {
            var selector = $('#userinfos .content');
            
            if(!selector.hasClass('vcard') && !selector.hasClass('last') && !selector.hasClass('version') && !selector.hasClass('time'))
                $('#userinfos .wait').hide();
        } catch(e) {
            Console.error('UserInfos.wait', e);
        }

    };


    /**
     * Sends the buddy comments
     * @public
     * @return {boolean}
     */
    self.sendBuddyComments = function() {

        try {
            // Update the current value
            var value = $('#userinfos .rosternotes').val();
            var xid = $('#userinfos .buddy-xid').text();
            
            // Necessary to update?
            var old_value = DataStore.getDB(Connection.desktop_hash, 'rosternotes', xid);
            
            if((old_value == value) || (!old_value && !value))
                return false;
            
            // Update the database
            DataStore.setDB(Connection.desktop_hash, 'rosternotes', xid, value);
            
            // Send the new buddy storage values
            var iq = new JSJaCIQ();
            iq.setType('set');
            var query = iq.setQuery(NS_PRIVATE);
            var storage = query.appendChild(iq.buildNode('storage', {'xmlns': NS_ROSTERNOTES}));
            
            // We regenerate the XML
            var db_regex = new RegExp(('^' + Connection.desktop_hash + '_') + 'rosternotes' + ('_(.+)'));

            for(var i = 0; i < DataStore.storageDB.length; i++) {
                // Get the pointer values
                var current = DataStore.storageDB.key(i);
                
                // If the pointer is on a stored rosternote
                if(current.match(db_regex)) {
                    var cur_xid = RegExp.$1;
                    var cur_value = DataStore.storageDB.getItem(current);
                    
                    if(cur_xid && cur_value)
                        storage.appendChild(iq.buildNode('note', {'jid': cur_xid, 'xmlns': NS_ROSTERNOTES}, cur_value));
                }
            }
            
            con.send(iq);
            
            return false;
        } catch(e) {
            Console.error('UserInfos.sendBuddyComments', e);
        }

    };


    /**
     * Switches the user-infos tabs
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.switchTab = function(id) {

        try {
            $('#userinfos .content .one-lap').hide();
            $('#userinfos .content .info' + id).show();
            $('#userinfos .tab a').removeClass('tab-active');
            $('#userinfos .tab a[data-key="' + id + '"]').addClass('tab-active');
        } catch(e) {
            Console.error('UserInfos.switchTab', e);
        } finally {
            return false;
        }

    };


    /**
     * Gets the user's informations when creating a new chat
     * @public
     * @param {string} hash
     * @param {string} xid
     * @param {string} nick
     * @param {string} type
     * @return {undefined}
     */
    self.get = function(hash, xid, nick, type) {

        try {
            // This is a normal chat
            if(type != 'private') {
                // Display the buddy name
                if(nick) {
                    $('#' + hash + ' .top .name .bc-name').text(nick);
                    $('#page-switch .' + hash + ' .name').text(nick);
                }
                
                // Get the buddy PEP informations
                PEP.displayAll(xid);
            }
            
            // Display the buddy presence
            Presence.funnel(xid, hash);
        } catch(e) {
            Console.error('UserInfos.get', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#userinfos .tab a').click(function() {
                // Yet active?
                if($(this).hasClass('tab-active'))
                    return false;
                
                // Switch to the good tab
                var key = parseInt($(this).attr('data-key'));
                
                return self.switchTab(key);
            });
            
            $('#userinfos .bottom .finish').click(function() {
                return self.close();
            });
        } catch(e) {
            Console.error('UserInfos.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the seach tools JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Search = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.search_filtered = false;


    /**
     * Searches in the user's buddy list
     * @public
     * @param {string} query
     * @return {object}
     */
    self.processBuddy = function(query) {

        try {
            // No query submitted?
            if(!query) {
                return;
            }
            
            // Wildcard (*) submitted
            if(query == '*') {
                query = '';
            }
            
            // Replace forbidden characters in regex
            query = Common.escapeRegex(query);
            
            // Create an empty array
            var results = [];
            
            // Search regex
            var regex = new RegExp('((^)|( ))' + query, 'gi');
            
            // Search in the roster
            var buddies = Roster.getAllBuddies();
            
            for(var i in buddies) {
                var xid = buddies[i];
                var nick = Name.getBuddy(xid);
                
                // Buddy match our search, and not yet in the array
                if(nick.match(regex) && !Utils.existArrayValue(results, xid)) {
                    results.push(xid);
                }
            }
            
            // Return the results array
            return results;
        } catch(e) {
            Console.error('Search.processBuddy', e);
        }

    };


    /**
     * Resets the buddy search tool
     * @public
     * @param {string} destination
     * @return {undefined}
     */
    self.resetBuddy = function(destination) {

        try {
            $(destination + ' ul').remove();
            $(destination + ' input').removeClass('suggested');
        } catch(e) {
            Console.error('Search.resetBuddy', e);
        }

    };


    /**
     * Add the clicked XID to the input
     * @public
     * @param {string} destination
     * @param {string} xid
     * @return {boolean}
     */
    self.addBuddy = function(destination, xid) {

        try {
            // Remove the search tool
            self.resetBuddy(destination);
            
            // Define a selector
            var input = $(destination + ' input');
            var value = input.val();
            
            // Get the old value (if there's another value)
            var old = '';
            
            if(value.match(/(^(.+)(,)(\s)?)(\w+)$/))
                old = RegExp.$1;
            
            // Add the XID to the "to" input and focus on it
            $(document).oneTime(10, function() {
                input.val(old + xid).focus();
            });
        } catch(e) {
            Console.error('Search.addBuddy', e);
        } finally {
            return false;
        }

    };


    /**
     * Creates the appropriate markup for the search results
     * @public
     * @param {string} destination
     * @return {undefined}
     */
    self.createBuddy = function(destination) {

        try {
            // Reset the search engine
            self.resetBuddy(destination);
            
            // Get the entered value
            var value = $(destination + ' input').val();
            
            // Separation with a comma?
            if(value.match(/^(.+)((,)(\s)?)(\w+)$/))
                value = RegExp.$5;
            
            // Get the result array
            var entered = self.processBuddy(value);
            
            // Display each result (if any)
            if(entered && entered.length) {
                // Set a special class to the search input
                $(destination + ' input').addClass('suggested');
                
                // Append each found buddy in the container 
                var regex = new RegExp('((^)|( ))' + value, 'gi');
                
                // Initialize the code generation
                var code = '<ul>';
                
                for(var b in entered) {
                    // Get some values from the XID
                    var current = Name.getBuddy(entered[b]).htmlEnc();
                    current = current.replace(regex, '<b>$&</b>');
                    
                    // Add the current element to the global code
                    code += '<li onclick="return Search.addBuddy(\'' + Utils.encodeOnclick(destination) + '\', \'' + Utils.encodeOnclick(entered[b]) + '\');" data-xid="' + Common.encodeQuotes(entered[b]) + '">' + current + '</li>';
                }
                
                // Finish the code generation
                code += '</ul>';
                
                // Creates the code in the DOM
                $(destination).append(code);
                
                // Put the hover on the first element
                $(destination + ' ul li:first').addClass('hovered');
                
                // Hover event, to not to remove this onblur and loose the click event
                $(destination + ' ul li').hover(function() {
                    $(destination + ' ul li').removeClass('hovered');
                    $(this).addClass('hovered');
                    
                    // Add a marker for the blur event
                    $(destination + ' ul').attr('mouse-hover', 'true');
                }, function() {
                    $(this).removeClass('hovered');
                    
                    // Remove the mouse over marker
                    $(destination + ' ul').removeAttr('mouse-hover');
                });
            }
        } catch(e) {
            Console.error('Search.createBuddy', e);
        }

    };


    /**
     * Handles the keyboard arrows press when searching
     * @public
     * @param {object} evt
     * @param {string} destination
     * @return {boolean}
     */
    self.arrowsBuddy = function(evt, destination) {

        try {
            // Down arrow: 40
            // Up arrown: 38
            
            // Initialize
            var code = evt.keyCode;
            
            // Not the key we want here
            if((code != 40) && (code != 38))
                return;
            
            // Remove the eventual mouse hover marker
            $(destination + ' ul').removeAttr('mouse-hover');
            
            // Create the path & get its size
            var path = destination + ' ul li';
            var pSize = $(path).size();
            
            // Define the i value
            var i = 0;
            
            // Switching yet launched
            if(Common.exists(path + '.hovered')) {
                var index = $(path).attr('data-hovered');
                
                if(index)
                    i = parseInt(index);
                
                if(code == 40)
                    i++;
                else
                    i--;
            }
            
            else if(code == 38)
                i = pSize - 1;
            
            // We must not override the maximum i limit
            if(i >= pSize)
                i = 0;
            
            // We must not have negative i
            else if(i < 0)
                i = pSize - 1;
            
            // Modify the list
            $(path + '.hovered').removeClass('hovered');
            $(path).eq(i).addClass('hovered');
            
            // Store the i index
            $(path).attr('data-hovered', i);
        } catch(e) {
            Console.error('Search.arrowsBuddy', e);
        } finally {
            return false;
        }

    };


    /**
     * Filters the buddies in the roster
     * @public
     * @param {object} vFilter
     * @return {undefined}
     */
    self.goFilterBuddy = function(vFilter) {

        try {
            // Put a marker
            self.search_filtered = true;
            
            // Show the buddies that match the search string
            var rFilter = self.processBuddy(vFilter);
            
            // Hide all the buddies
            $('#roster .buddy').hide();
            
            // Only show the buddies which match the search
            if(!Roster.blist_all) {
                for(var i in rFilter)
                    $('#roster .buddy[data-xid="' + escape(rFilter[i]) + '"]:not(.hidden-buddy)').show();
            } else {
                for(var j in rFilter)
                    $('#roster .buddy[data-xid="' + escape(rFilter[j]) + '"]').show();
            }
        } catch(e) {
            Console.error('Search.goFilterBuddy', e);
        }

    };


    /**
     * Resets the buddy filtering in the roster
     * @public
     * @return {undefined}
     */
    self.resetFilterBuddy = function() {

        try {
            // Remove the marker
            self.search_filtered = false;
            
            // Show all the buddies
            $('#roster .buddy').show();
            
            // Only show available buddies
            if(!Roster.blist_all)
                $('#roster .buddy.hidden-buddy').hide();
            
            // Update the groups
            Roster.updateGroups();
        } catch(e) {
            Console.error('Search.resetFilterBuddy', e);
        }

    };


    /**
     * Funnels the buddy filtering
     * @public
     * @param {number} keycode
     * @return {undefined}
     */
    self.funnelFilterBuddy = function(keycode) {

        try {
            // Get the input value
            var input = $('#roster .filter input');
            var cancel = $('#roster .filter a');
            var value = input.val();
            
            // Security: reset all the groups, empty or not, deployed or not
            $('#roster .one-group, #roster .group-buddies').show();
            $('#roster .group span').text('-');
            
            // Nothing is entered, or escape pressed
            if(!value || (keycode == 27)) {
                if(keycode == 27)
                    input.val('');
                
                self.resetFilterBuddy();
                cancel.hide();
            }
            
            // Process the filtering
            else {
                cancel.show();
                self.goFilterBuddy(value);
            }
            
            // Update the groups
            Roster.updateGroups();
        } catch(e) {
            Console.error('Search.funnelFilterBuddy', e);
        }

    };


    /**
     * Searches for the nearest element (with a lower stamp than the current one)
     * @public
     * @param {number} stamp
     * @param {string} element
     * @return {number}
     */
    self.sortElementByStamp = function(stamp, element) {

        try {
            var array = [];
            var i = 0;
            var nearest = 0;
            
            // Add the stamp values to the array
            $(element).each(function() {
                var current_stamp = parseInt($(this).attr('data-stamp'));
                
                // Push it!
                array.push(current_stamp);
            });
            
            // Sort the array
            array.sort();
            
            // Get the nearest stamp value
            while(stamp > array[i]) {
                nearest = array[i];
                
                i++;
            }
            
            return nearest;
        } catch(e) {
            Console.error('Search.sortElementByStamp', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the autocompletion tools JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Autocompletion = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Sort an autocompletion result array with insensitivity to the case,
     * using the 1st elements (a[0] and b[0]) to process comparison
     * @public
     * @param {array} a
     * @param {array} b
     * @return {undefined}
     */
    self.caseInsensitiveSort = function(a, b) {

        try {
            // Put the two strings into lower case
            var sA = a[0].toLowerCase();
            var sB = b[0].toLowerCase();
            
            // Process the sort
            if(sA > sB)
                return 1;
            if(sA < sB)
                return -1;
        } catch(e) {
            Console.error('Autocompletion.caseInsensitiveSort', e);
        }

    };


    /**
     * Split a query into its subqueries ready to be used in autocompletion
     * The function return an array containing two others : the first with subqueries
     * and the second with remaining parts
     * For example, if query is "A B C", the subqueries are ["C", "B C", "A B C"] and
     * the remaining parts are ["A B ", "A ", ""]
     * @param {string} query
     * @return {Array}
     */
    self.getSubQueries = function(query) {

        var subqueries = [];
        var remnants = [];

        var queryLastCharPos = query.length - 1;
        var spaceCounter = 0;
        for (var i=queryLastCharPos; i>=0; i--) {
            // Search from the end of the query
            var iChar = query.charAt(i);
            if (spaceCounter === 0 && iChar.search(/\s/) === 0) {
                // the first "local" space was found
                // add the subquery and its remnant to results
                subqueries.push(query.slice(i+1));
                remnants.push(query.slice(0, i+1));
                spaceCounter++;
            } else {
                spaceCounter = 0;
            }
        }
        if (spaceCounter === 0) {
            // If the first char of the query is not a space, add the full query to results
            subqueries.push(query);
            remnants.push("");
        }

        return [subqueries, remnants];
    };


    /**
     * Creates an array with the autocompletion results. An autocompletion result
     * is an array containing the result himself and the rank of the query which
     * matched this answer
     * @public
     * @param {Array} query
     * @param {string} id
     * @return {Array}
     */
    self.process = function(query, id) {

        var results = [];

        try {
            // Replace forbidden characters in regex
            query = Common.escapeRegex(query);
            // Build an array of regex to use
            var queryRegExp = [];
            for (i = 0; i<query.length; i++) {
                if (query[i] !== null) {
                    queryRegExp.push(new RegExp('(^)' + query[i], 'gi'));
                }
            }
            // Search in the roster
            $('#' + id + ' .user').each(function() {
                var nick = $(this).find('.name').text();
                for (i = 0; i<queryRegExp.length; i++) {
                    var regex = queryRegExp[i];
                    if(nick.match(regex)) {
                        results.push([nick, i]);
                    }
                }
            });
            // Sort the array
            results = results.sort(self.caseInsensitiveSort);
        } catch(e) {
            Console.error('Autocompletion.process', e);
        } finally {
            return results;
        }

    };


    /**
     * Resets the autocompletion tools
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.reset = function(hash) {

        try {
            $('#' + hash + ' .message-area').removeAttr('data-autocompletion-pointer').removeAttr('data-autocompletion-query');
        } catch(e) {
            Console.error('Autocompletion.reset', e);
        }

    };


    /**
     * Autocompletes the chat input nick
     * @public
     * @param {string} hash
     * @return {undefined}
     */
    self.create = function(hash) {

       try {
            // Initialize
            var vSelector = $('#' + hash + ' .message-area');
            var value = vSelector.val();

            if(!value) {
                self.reset(hash);
            }

            var query = vSelector.attr('data-autocompletion-query');
            
            if(query === undefined) {
                // The autocompletion has not been yet launched
                query = self.getSubQueries(value);
                vSelector.attr('data-autocompletion-query', JSON.stringify(query));
            } else {
                // The autocompletion has already stored a query
                query = JSON.parse(query);
            }
            
            // Get the pointer
            var pointer = vSelector.attr('data-autocompletion-pointer');
            var i = 0;
            
            if(pointer)
                i = parseInt(pointer);
            
            // We get the nickname
            var nickResult = self.process(query[0], hash)[i];
            var nick;
            if (nickResult !== undefined) {
                nick = nickResult[0];
            }
            
            // Shit, this is my nick!
            if((nick !== undefined) && (nick.toLowerCase() == Name.getMUCNick(hash).toLowerCase())) {
                // Increment
                i++;
                
                // Get the next nick
                nickResult = self.process(query[0], hash)[i];
                if (nickResult !== undefined) {
                    nick = nickResult[0];
                }
            }
            
            // We quote the nick
            if((nickResult !== undefined) && (nick !== undefined)) {
                // Increment
                i++;
                var message = query[1][nickResult[1]];
                Utils.quoteMyNick(hash, nick, message);
                
                // Put a pointer
                vSelector.attr('data-autocompletion-pointer', i);
            }
        } catch(e) {
            Console.error('Autocompletion.create', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();

/*

Jappix - An open social platform
These are the welcome tool functions for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Welcome = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Variables */
    self.is_done = false;

    
    /**
     * Opens the welcome tools
     * @public
     * @return {undefined}
     */
    self.open = function() {

        try {
            // Share message
            var share_msg = Common.printf(Common._e("Using Jappix, an open social platform. I am %s!"), Common.getXID());
            
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Welcome!") + '</div>' + 
            
            '<div class="tab">' + 
                '<a href="#" class="tab-active" data-step="1">' + Common._e("Options") + '</a>' + 
                '<a href="#" class="tab-missing" data-step="2">' + Common._e("Friends") + '</a>' + 
                '<a href="#" class="tab-missing" data-step="3">' + Common._e("Share") + '</a>' + 
            '</div>' + 
            
            '<div class="content">' + 
                '<div class="lap-active one-lap welcome1">' + 
                    '<div class="infos">' + 
                        '<p class="infos-title">' + Common._e("Welcome on Jappix, your own social cloud!") + '</p>' + 
                        '<p>' + Common._e("Before you start using it, you will have to change some settings, search for friends and complete your profile.") + '</p>' + 
                    '</div>' + 
                    
                    '<a href="#" class="box enabled" title="' + Common._e("Click to disable") + '">' + 
                        '<span class="option">' + Common._e("Sounds") + '</span>' + 
                        '<span class="description">' + Common._e("Enable notification sounds") + '</span>' + 
                        '<span class="image sound talk-images"></span>' + 
                        '<span class="tick talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a href="#" class="box enabled pep-hidable" title="' + Common._e("Click to disable") + '">' + 
                        '<span class="option">' + Common._e("Geolocation") + '</span>' + 
                        '<span class="description">' + Common._e("Share your position on the globe") + '</span>' + 
                        '<span class="image geolocation talk-images"></span>' + 
                        '<span class="tick talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a href="#" class="box xmpplinks-hidable" title="' + Common._e("Click to enable") + '">' + 
                        '<span class="option">' + Common._e("XMPP links") + '</span>' + 
                        '<span class="description">' + Common._e("Open XMPP links with Jappix") + '</span>' + 
                        '<span class="image xmpp talk-images"></span>' + 
                        '<span class="tick talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a href="#" class="box mam-hidable pref" title="' + Common._e("Click to enable") + '">' + 
                        '<span class="option">' + Common._e("Message archiving") + '</span>' + 
                        '<span class="description">' + Common._e("Store a history of your chats") + '</span>' + 
                        '<span class="image mam talk-images"></span>' + 
                        '<span class="tick talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a href="#" class="box" title="' + Common._e("Click to enable") + '">' + 
                        '<span class="option">' + Common._e("Offline friends") + '</span>' + 
                        '<span class="description">' + Common._e("Don\'t hide offline friends") + '</span>' + 
                        '<span class="image offline talk-images"></span>' + 
                        '<span class="tick talk-images"></span>' + 
                    '</a>' + 
                '</div>' + 
                
                '<div class="one-lap welcome2">' + 
                    '<div class="infos">' + 
                        '<p class="infos-title">' + Common._e("Friends") + '</p>' + 
                        '<p>' + Common._e("Use this tool to find your friends on the server you are using right now, or add them later.") + '</p>' + 
                    '</div>' + 
                    
                    '<div class="results welcome-results"></div>' + 
                '</div>' + 
                
                '<div class="one-lap welcome3">' + 
                    '<div class="infos">' + 
                        '<p class="infos-title">' + Common._e("Share") + '</p>' + 
                        '<p>' + Common._e("Good job! Now, you can share Jappix with your friends!") + '</p>' + 
                        '<p>' + Common._e("When you will press the save button, the profile editor will be opened. Happy socializing!") + '</p>' + 
                    '</div>' + 
                    
                    '<a class="box share first" href="http://www.facebook.com/sharer/sharer.php?u=' + Common.encodeQuotes(Utils.generateURL(JAPPIX_LOCATION)) + '" target="_blank">' + 
                        '<span class="logo facebook welcome-images"></span>' + 
                        '<span class="name">Facebook</span>' + 
                        '<span class="description">' + Common.printf(Common._e("Share Jappix on %s"), 'Facebook') + '</span>' + 
                        '<span class="go talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a class="box share" href="http://twitter.com/intent/tweet?text=' + Common.encodeQuotes(share_msg) + '&amp;url=' + Common.encodeQuotes(Utils.generateURL(JAPPIX_LOCATION)) + '" target="_blank">' + 
                        '<span class="logo twitter welcome-images"></span>' + 
                        '<span class="name">Twitter</span>' + 
                        '<span class="description">' + Common.printf(Common._e("Share Jappix on %s"), 'Twitter') + '</span>' + 
                        '<span class="go talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a class="box share" href="https://plus.google.com/share?url=' + Common.encodeQuotes(Utils.generateURL(JAPPIX_LOCATION)) + '" target="_blank">' + 
                        '<span class="logo plus welcome-images"></span>' + 
                        '<span class="name">Google+</span>' + 
                        '<span class="description">' + Common.printf(Common._e("Share Jappix on %s"), 'Google+') + '</span>' + 
                        '<span class="go talk-images"></span>' + 
                    '</a>' + 
                    
                    '<a class="box share" href="https://waaave.com/spot/jappix/" target="_blank">' + 
                        '<span class="logo waaave welcome-images"></span>' + 
                        '<span class="name">Waaave</span>' + 
                        '<span class="description">' + Common.printf(Common._e("Follow Jappix topic on %s"), 'Waaave') + '</span>' + 
                        '<span class="go talk-images"></span>' + 
                    '</a>' + 
                '</div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<div class="wait wait-medium"></div>' + 
                
                '<a href="#" class="finish next">' + Common._e("Next") + ' ¬ª</a>' + 
                '<a href="#" class="finish save">' + Common._e("Save") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('welcome', html);
            
            // Unavoidable popup
            $('#welcome').addClass('unavoidable');
            
            // Apply the features
            Features.apply('welcome');
            
            // Associate the events
            self.instance();
            
            Console.log('Welcome assistant opened.');
        } catch(e) {
            Console.error('Welcome.open', e);
        }

    };


    /**
     * Closes the welcome tools
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('welcome');
        } catch(e) {
            Console.error('Welcome.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Switches the welcome tabs
     * @public
     * @param {string} id
     * @return {boolean}
     */
    self.switchTab = function(id) {

        try {
            // Path to
            var welcome = '#welcome ';
            var content = welcome + '.content .';
            var tab = welcome + '.tab ';
            var wait = $(welcome + '.wait');
            
            $(content + 'one-lap').hide();
            $(content + 'welcome' + id).show();
            $(tab + 'a').removeClass('tab-active');
            $(tab + 'a[data-step="' + id + '"]').addClass('tab-active').removeClass('tab-missing');
            
            // Update the "save" button if all is okay
            if(!Common.exists(tab + '.tab-missing')) {
                var finish = welcome + '.finish.';
                $(finish + 'save').show();
                $(finish + 'next').hide();
            }
            
            // If this is ID 2: vJUD search
            if(id == 2) {
                wait.show();
                DataForm.go(HOST_VJUD, 'search', '', '', 'welcome');
            } else {
                wait.hide();
            }
        } catch(e) {
            Console.error('Welcome.switchTab', e);
        } finally {
            return false;
        }

    };


    /**
     * Sends the welcome options
     * @public
     * @param {object} array
     * @return {undefined}
     */
    self.send = function(array) {

        try {
            // Sends the options
            var iq = new JSJaCIQ();
            iq.setType('set');
            
            var query = iq.setQuery(NS_PRIVATE);
            var storage = query.appendChild(iq.buildNode('storage', {'xmlns': NS_OPTIONS}));
            
            // Value array
            var tags = ['sounds', 'geolocation', '', '', 'roster-showall'];
            
            // Build the XML with the array
            for(var i in array) {
                var value = array[i];
                var tag = tags[i];
                
                if((i != 2) && (i != 3) && tag && value) {
                    storage.appendChild(iq.buildNode('option', {'type': tag, 'xmlns': NS_OPTIONS}, value));
                    DataStore.setDB(Connection.desktop_hash, 'options', tag, value);
                }
            }
            
            con.send(iq);
            
            // If geolocation is enabled
            if(array[1] == '1') {
                PEP.geolocate();
            }
        } catch(e) {
            Console.error('Welcome.send', e);
        }

    };


    /**
     * Saves the welcome options
     * @public
     * @return {boolean}
     */
    self.save = function() {

        try {
            // Get the new options
            var array = [];
            
            $('#welcome a.box').each(function() {
                var current = '0';
                
                if($(this).hasClass('enabled'))
                    current = '1';
                
                array.push(current);
            });
            
            // If XMPP links is enabled
            if(array[2] == '1')
                Utils.xmppLinksHandler();
            
            // If offline buddies showing is enabled
            if(array[4] == '1')
                Interface.showAllBuddies('welcome');
            
            // If archiving is supported by the server
            if(Features.enabledMAM()) {
                // If archiving is enabled
                if(array[3] == '1') {
                    MAM.setConfig('roster');
                }
            }
            
            // Send the new options
            self.send(array);
            
            // Close the welcome tool
            self.close();
            
            // Open the profile editor
            vCard.open();
            
            // Unavoidable popup
            $('#vcard').addClass('unavoidable');
            
            self.is_done = true;
        } catch(e) {
            Console.error('Welcome.save', e);
        } finally {
            return false;
        }

    };


    /**
     * Goes to the next welcome step
     * @public
     * @return {boolean}
     */
    self.next = function() {

        try {
            // Check the next step to go to
            var next = 1;
            var missing = '#welcome .tab a.tab-missing';
            
            if(Common.exists(missing))
                next = parseInt($(missing + ':first').attr('data-step'));
            
            // Switch to the next step
            self.switchTab(next);
        } catch(e) {
            Console.error('Welcome.next', e);
        } finally {
            return false;
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#welcome .tab a').click(function() {
                // Switch to the good tab
                var key = parseInt($(this).attr('data-step'));
                
                return self.switchTab(key);
            });
            
            $('#welcome a.box:not(.share)').click(function() {
                if($(this).hasClass('enabled'))
                    $(this).removeClass('enabled').attr('title', Common._e("Click to enable"));
                else
                    $(this).addClass('enabled').attr('title', Common._e("Click to disable"));
                
                return false;
            });
            
            $('#welcome .bottom .finish').click(function() {
                if($(this).is('.next'))
                    return self.next();
                if($(this).is('.save'))
                    return self.save();
                
                return false;
            });
        } catch(e) {
            Console.error('Welcome.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the Jappix Me tool functions for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Me = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};
    

    /**
     * Opens the Me tools
     * @public
     * @return {undefined}
     */
    self.open = function() {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Public profile") + '</div>' + 
            
            '<div class="content">' + 
                '<a class="me-images logo" href="https://me.jappix.com/" target="_blank"></a>' + 
                
                '<div class="infos">' + 
                    '<p class="infos-title">' + Common._e("Your profile anywhere on the Web.") + '</p>' + 
                    '<p>' + Common.printf(Common._e("%s is a Jappix.com service which makes your XMPP profile public. It is easier to share it. No XMPP account is required to view your social channel, your current position and your contact details."), '<a href="https://me.jappix.com/" target="_blank">Jappix Me</a>') + '</p>' + 
                    '<p>' + Common._e("Furthermore, every picture you post in your social channel is added to a beautiful picture timeline. You can now view the pictures you shared year by year.") + '</p>' + 
                    '<p>' + Common._e("You can also use your XMPP avatar as a single avatar for every website, blog and forum you use. When you change it on XMPP, the new avatar appears everywhere. What a genius improvement!") + '</p>' + 
                '</div>' + 
                
                '<a class="go one-button" href="https://me.jappix.com/new" target="_blank">' + Common._e("Yay, let's create your public profile!") + '</a>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<a href="#" class="finish">' + Common._e("Close") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('me', html);
            
            // Associate the events
            self.instance();
            
            Console.log('Public profile tool opened.');
        } catch(e) {
            Console.error('Me.open', e);
        }

    };


    /**
     * Closes the Me tools
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('me');
            
            // We finished
            Welcome.is_done = false;
        } catch(e) {
            Console.error('Me.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#me .content a.go').click(function() {
                self.close();
            });
            
            $('#me .bottom .finish').click(self.close);
        } catch(e) {
            Console.error('Me.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the Roster Item Exchange JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var RosterX = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};
    

    /**
     * Opens the rosterx tools
     * @public
     * @param {string} data
     * @return {undefined}
     */
    self.open = function(data) {

        try {
            // Popup HTML content
            var html = 
            '<div class="top">' + Common._e("Suggested friends") + '</div>' + 
            
            '<div class="content">' + 
                '<div class="rosterx-head">' + 
                    '<a href="#" class="uncheck">' + Common._e("Uncheck all") + '</a>' + 
                    '<a href="#" class="check">' + Common._e("Check all") + '</a>' + 
                '</div>' + 
                
                '<div class="results"></div>' + 
            '</div>' + 
            
            '<div class="bottom">' + 
                '<a href="#" class="finish save">' + Common._e("Save") + '</a>' + 
                '<a href="#" class="finish cancel">' + Common._e("Cancel") + '</a>' + 
            '</div>';
            
            // Create the popup
            Popup.create('rosterx', html);
            
            // Associate the events
            self.instance();
            
            // Parse the data
            self.parse(data);
            
            Console.log('Roster Item Exchange popup opened.');
        } catch(e) {
            Console.error('RosterX.open', e);
        }

    };


    /**
     * Closes the rosterx tools
     * @public
     * @return {boolean}
     */
    self.close = function() {

        try {
            // Destroy the popup
            Popup.destroy('rosterx');
        } catch(e) {
            Console.error('RosterX.close', e);
        } finally {
            return false;
        }

    };


    /**
     * Parses a rosterx query
     * @public
     * @param {string} data
     * @return {undefined}
     */
    self.parse = function(data) {

        try {
            // Main selector
            var x = $(data).find('x[xmlns="' + NS_ROSTERX + '"]:first');
            
            // Parse data
            x.find('item').each(function() {
                // Generate group XML
                var group = '';
                
                $(this).find('group').each(function() {
                    group += '<group>' + $(this).text().htmlEnc() + '</group>';
                });
                
                if(group)
                    group = '<groups>' + group + '</groups>';
                
                // Display it!
                self.display($(this).attr('jid'), $(this).attr('name'), group, $(this).attr('action'));
            });
            
            // Click to check/uncheck
            $('#rosterx .oneresult').click(function(evt) {
                // No need to apply when click on input
                if($(evt.target).is('input[type="checkbox"]'))
                    return;
                
                // Input selector
                var checkbox = $(this).find('input[type="checkbox"]');
                
                // Check or uncheck?
                if(checkbox.filter(':checked').size())
                    checkbox.removeAttr('checked');
                else
                    checkbox.attr('checked', true);
            });
        } catch(e) {
            Console.error('RosterX.parse', e);
        }

    };


    /**
     * Displays a rosterx item
     * @public
     * @param {string} xid
     * @param {string} nick
     * @param {string} group
     * @param {string} action
     * @return {boolean}
     */
    self.display = function(xid, nick, group, action) {

        try {
            // End if no XID
            if(!xid)
                return false;
            
            // Set up a default action if no one
            if(!action || (action != 'modify') || (action != 'delete'))
                action = 'add';
            
            // Override "undefined" for nickname
            if(!nick)
                nick = '';
            
            // Display it
            $('#rosterx .results').append(
                '<div class="oneresult">' + 
                    '<input type="checkbox" checked="" data-name="' + Common.encodeQuotes(nick) + '" data-xid="' + Common.encodeQuotes(xid) + '" data-action="' + Common.encodeQuotes(action) + '" data-group="' + Common.encodeQuotes(group) + '" />' + 
                    '<span class="name">' + nick.htmlEnc() + '</span>' + 
                    '<span class="xid">' + xid.htmlEnc() + '</span>' + 
                    '<span class="action ' + action + ' talk-images"></span>' + 
                '</div>'
            );

            return true;
        } catch(e) {
            Console.error('RosterX.display', e);
        }

    };


    /**
     * Saves the rosterx settings
     * @public
     * @return {undefined}
     */
    self.save = function() {

        try {
            // Send the requests
            $('#rosterx .results input[type="checkbox"]').filter(':checked').each(function() {
                // Read the attributes
                var nick = $(this).attr('data-name');
                var xid = $(this).attr('data-xid');
                var action = $(this).attr('data-action');
                var group = $(this).attr('data-group');
                
                // Parse groups XML
                var group_arr = [];
                
                if(group) {
                    $(group).find('group').each(function() {
                        group_arr.push($(this).text().revertHtmlEnc());
                    });
                }
                
                // Process the asked action
                var roster_item = $('#roster .' + hex_md5(xid));
                
                switch(action) {
                    // Buddy add
                    case 'add':
                        if(!Common.exists(roster_item)) {
                            Presence.sendSubscribe(xid, 'subscribe');
                            Roster.send(xid, '', nick, group_arr);
                        }
                        
                        break;
                    
                    // Buddy edit
                    case 'modify':
                        if(Common.exists(roster_item))
                            Roster.send(xid, '', nick, group_arr);
                        
                        break;
                    
                    // Buddy delete
                    case 'delete':
                        if(Common.exists(roster_item))
                            Roster.send(xid, 'remove');
                        
                        break;
                }
            });
            
            // Close the popup
            self.close();
        } catch(e) {
            Console.error('RosterX.save', e);
        }

    };


    /**
     * Plugin launcher
     * @public
     * @return {undefined}
     */
    self.instance = function() {

        try {
            // Click events
            $('#rosterx .bottom .finish').click(function() {
                if($(this).is('.save'))
                    return self.save();
                if($(this).is('.cancel'))
                    return self.close();
            });
            
            $('#rosterx .rosterx-head a').click(function() {
                if($(this).is('.check'))
                    $('#rosterx .results input[type="checkbox"]').attr('checked', true);
                else if($(this).is('.uncheck'))
                    $('#rosterx .results input[type="checkbox"]').removeAttr('checked');
                
                return false;
            });
        } catch(e) {
            Console.error('RosterX.instance', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
Implementation of XEP-0313: Message Archive Management

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var MAM = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /* Constants */
    self.REQ_MAX = 50;
    self.SCROLL_THRESHOLD = 200;

    self.PREF_DEFAULTS = {
        'always' : 1,
        'never'  : 1,
        'roster' : 1
    };


    /* Variables */
    self.map_reqs = {};
    self.map_pending = {};
    self.map_states = {};
    self.msg_queue = {};


    /**
     * Gets the MAM configuration
     * @public
     * @return {undefined}
     */
    self.getConfig = function() {

        try {
            // Lock the archiving options
            $('#archiving').attr('disabled', true);
            
            // Get the archiving configuration
            var iq = new JSJaCIQ();
            iq.setType('get');

            iq.appendNode('prefs', { 'xmlns': NS_URN_MAM });

            con.send(iq, self.handleConfig);
        } catch(e) {
            Console.error('MAM.getConfig', e);
        }

    };


    /**
     * Handles the MAM configuration
     * @public
     * @param {object} iq
     * @return {undefined}
     */
    self.handleConfig = function(iq) {

        try {
            if(iq.getType() != 'error') {
                // Read packet
                var cur_default = $(iq.getNode()).find('prefs[xmlns="' + NS_URN_MAM + '"]').attr('default') || 'never';

                if(!(cur_default in self.PREF_DEFAULTS)) {
                    cur_default = 'never';
                }

                // Apply value to options
                $('#archiving').val(cur_default);
            }

            // Unlock the archiving option
            $('#archiving').removeAttr('disabled');

            // All done.
            Options.wait('mam');
        } catch(e) {
            Console.error('MAM.handleConfig', e);
        }

    };


    /**
     * Sets the MAM configuration
     * @public
     * @param {string} pref_default
     * @return {undefined}
     */
    self.setConfig = function(pref_default) {

        try {
            // Check parameters
            if(!(pref_default in self.PREF_DEFAULTS)) {
                pref_default = 'never';
            }

            // Send new configuration
            var iq = new JSJaCIQ();
            iq.setType('set');

            iq.appendNode('prefs', { 'xmlns': NS_URN_MAM, 'default': pref_default });

            con.send(iq);
        } catch(e) {
            Console.error('MAM.setConfig', e);
        }

    };


    /**
     * Removes all (or given) MAM archives
     * @public
     * @param {object} args
     * @return {undefined}
     */
    self.purgeArchives = function(args) {

        try {
            if(typeof args != 'object') {
                args = {};
            }

            var iq = new JSJaCIQ();
            iq.setType('set');

            var purge = iq.appendNode('purge', { 'xmlns': NS_METRONOME_MAM_PURGE });

            for(var c in args) {
                if(args[c])  purge.appendChild(iq.buildNode(c, {'xmlns': NS_METRONOME_MAM_PURGE}, args[c]));
            }
            
            con.send(iq, function(iq) {
                if(iq.getType() == 'result') {
                    Console.info('Archives purged (MAM).');
                } else {
                    Console.error('Error purging archives (MAM).');
                }
            });
        } catch(e) {
            Console.error('MAM.purgeArchives', e);
        }

    };


    /**
     * Gets the MAM configuration
     * @public
     * @param {object} args
     * @param {object} rsm_args
     * @param {function} callback
     * @return {undefined}
     */
    self.getArchives = function(args, rsm_args, callback) {

        try {
            if(typeof args != 'object') {
                args = {};
            }

            var req_id = genID();

            if(args['with']) {
                self.map_pending[args['with']] = 1;
                self.map_reqs[req_id] = args['with'];
            }

            var iq = new JSJaCIQ();
            iq.setType('get');
            iq.setID(req_id);

            var query = iq.setQuery(NS_URN_MAM);

            for(var c in args) {
                if(args[c] !== null)  query.appendChild(iq.buildNode(c, {'xmlns': NS_URN_MAM}, args[c]));
            }

            if(rsm_args && typeof rsm_args == 'object') {
                var rsm_set = query.appendChild(iq.buildNode('set', {'xmlns': NS_RSM}));

                for(var r in rsm_args) {
                    if(rsm_args[r] !== null)  rsm_set.appendChild(iq.buildNode(r, {'xmlns': NS_RSM}, rsm_args[r]));
                }
            }

            con.send(iq, function(res_iq) {
                self.handleArchives(res_iq, callback);
            });
        } catch(e) {
            Console.error('MAM.getArchives', e);
        }

    };


    /**
     * Handles the MAM configuration
     * @public
     * @param {object} iq
     * @param {function} callback
     * @return {undefined}
     */
    self.handleArchives = function(iq, callback) {

        try {
            var res_id = iq.getID();
            var res_with;

            if(res_id && res_id in self.map_reqs) {
                res_with = self.map_reqs[res_id];
            }

            if(iq.getType() != 'error') {
                if(res_with) {
                    var res_sel = $(iq.getQuery());
                    var res_rsm_sel = res_sel.find('set[xmlns="' + NS_RSM + '"]');

                    // Store that data
                    self.map_states[res_with] = {
                        'date': {
                            'start': res_sel.find('start').eq(0).text(),
                            'end': res_sel.find('end').eq(0).text()
                        },

                        'rsm': {
                            'first': res_rsm_sel.find('first').eq(0).text(),
                            'last': res_rsm_sel.find('last').eq(0).text(),
                            'count': parseInt(res_rsm_sel.find('count').eq(0).text() || 0)
                        }
                    };

                    // Generate stamps for easy operations
                    var start_stamp = DateUtils.extractStamp(Date.jab2date(self.map_states[res_with].date.start));
                    var start_end = DateUtils.extractStamp(Date.jab2date(self.map_states[res_with].date.end));

                    // Create MAM messages target
                    var target_html = '<div class="mam-chunk" data-start="' + Common.encodeQuotes(start_stamp) + '" data-end="' + Common.encodeQuotes(start_end) + '"></div>';
                    
                    var target_content_sel = $('#' + hex_md5(res_with) + ' .content');
                    var target_wait_sel = target_content_sel.find('.wait-mam');

                    if(target_wait_sel.size()) {
                        target_wait_sel.after(target_html);
                    } else {
                        target_content_sel.prepend(target_html);
                    }

                    // Any enqueued message to display?
                    if(typeof self.msg_queue[res_with] == 'object') {
                        for(var i in self.msg_queue[res_with]) {
                            (self.msg_queue[res_with][i])();
                        }

                        delete self.msg_queue[res_with];
                    }

                    // Remove XID from pending list
                    if(res_with in self.map_pending) {
                        delete self.map_pending[res_with];
                    }

                    Console.info('Got archives from: ' + res_with);
                } else {
                    Console.warn('Could not associate archive response with a known JID.');
                }
            } else {
                Console.error('Error handing archives (MAM).');
            }

            // Execute callback?
            if(typeof callback == 'function') {
                callback(iq);
            }
        } catch(e) {
            Console.error('MAM.handleArchives', e);
        }

    };


    /**
     * Handles a MAM-forwarded message stanza
     * @public
     * @param {object} fwd_stanza
     * @param {object} c_delay
     * @return {undefined}
     */
    self.handleMessage = function(fwd_stanza, c_delay) {

        try {
            // Build message node
            var c_message = fwd_stanza.find('message');

            if(c_message[0]) {
                // Re-build a proper JSJaC message stanza
                var message = JSJaCPacket.wrapNode(c_message[0]);

                // Check message type
                var type = message.getType() || 'chat';

                if(type == 'chat') {
                    // Read message data
                    var xid = Common.bareXID(Common.getStanzaFrom(message));
                    var id = message.getID();
                    var from_xid = xid;
                    var b_name = Name.getBuddy(xid);
                    var mode = (xid == Common.getXID()) ? 'me': 'him';

                    // Refactor chat XID (in case we were the sender of the archived message)
                    if(mode == 'me') {
                        xid = Common.bareXID(message.getTo());
                    }

                    var hash = hex_md5(xid);
                    var body = message.getBody();

                    // Read delay (required since we deal w/ a past message!)
                    var time, stamp;
                    var delay = c_delay.attr('stamp');

                    if(delay) {
                        time = DateUtils.relative(delay);
                        stamp = DateUtils.extractStamp(Date.jab2date(delay));
                    }
                    
                    // Last-minute checks before display
                    if(time && stamp && body) {
                        var mam_chunk_path = '#' + hash + ' .mam-chunk';

                        // No chat auto-scroll?
                        var no_scroll = Common.exists(mam_chunk_path);

                        // Select the custom target
                        var c_target_sel = function() {
                            return $(mam_chunk_path).filter(function() {
                                return $(this).attr('data-start') <= stamp && $(this).attr('data-end') >= stamp;
                            }).filter(':first');
                        };

                        // Display the message in that target
                        var c_msg_display = function() {
                            Message.display(type, from_xid, hash, b_name.htmlEnc(), body, time, stamp, 'old-message', true, null, mode, null, c_target_sel(), no_scroll);
                        };

                        // Hack: do not display the message in case we would duplicate it w/ current session messages
                        //       only used when initiating a new chat, avoids collisions
                        if(!(xid in self.map_states) && $('#' + hash).find('.one-line.user-message:last').text() == body) {
                            return;
                        }

                        if(c_target_sel().size()) {
                            // Display the message in that target
                            c_msg_display();
                        } else {
                            // Delay display (we may not have received the MAM reply ATM)
                            if(typeof self.msg_queue[xid] != 'object') {
                                self.msg_queue[xid] = [];
                            }

                            self.msg_queue[xid].push(c_msg_display);
                        }
                    }
                }
            }
        } catch(e) {
            Console.error('MAM.handleMessage', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
/*

Jappix - An open social platform
These are the Message Carbons JS script for Jappix

-------------------------------------------------

License: AGPL
Author: Val√©rian Saliou

*/

// Bundle
var Carbons = (function () {

    /**
     * Alias of this
     * @private
     */
    var self = {};


    /**
     * Configures Message Carbons options
     * @public
     * @param {string} type
     * @return {undefined}
     */
    self._configure = function(type) {

        try {
            if(!(type in {'enable': 1, 'disable': 1})) {
                Console.error('Carbons._configure', 'Invalid type (must be either "enable" or "disable")'); return;
            }

            var iq = new JSJaCIQ();
            iq.setType('set');
            
            iq.appendNode(type, {'xmlns': NS_URN_CARBONS});
            
            con.send(iq, function(iq) {
                self._handleConfigure(iq, type);
            });
        } catch(e) {
            Console.error('Carbons._configure', e);
        }

    };


    /**
     * Configures Message Carbons options
     * @public
     * @param {object} iq
     * @param {string} type
     * @return {undefined}
     */
    self._handleConfigure = function(iq, type) {

        try {
            if(iq.getType() === 'result') {
                Console.log('Message Carbons successfully configured (type: ' + type + ')');
            } else {
                Console.error('Message Carbons could not be configured (type: ' + type + ')');
            }
        } catch(e) {
            Console.error('Carbons._handleConfigure', e);
        }

    };


    /**
     * Enables Message Carbons for this session
     * @public
     * @return {undefined}
     */
    self.enable = function() {

        try {
            self._configure('enable');
        } catch(e) {
            Console.error('Carbons.enable', e);
        }

    };


    /**
     * Disables Message Carbons for this session
     * @public
     * @return {undefined}
     */
    self.disable = function() {

        try {
            self._configure('disable');
        } catch(e) {
            Console.error('Carbons.disable', e);
        }

    };


    /**
     * Returns whether the server has Carbons support or not
     * @public
     * @return {boolean}
     */
    self.has = function() {

        try {
            return Features.enabledCarbons();
        } catch(e) {
            Console.error('Carbons.has', e);
        }

    };


    /**
     * Returns the forwarded message stanza
     * @public
     * @param {object} message
     * @return {object}
     */
    self._getForwarded = function(message) {

        try {
            var forwarded_message = $(message.getNode()).find('forwarded[xmlns="' + NS_URN_FORWARD + '"]:first message:first');

            if(forwarded_message[0]) {
                return JSJaCPacket.wrapNode(forwarded_message[0]);
            }

            return null;
        } catch(e) {
            Console.error('Carbons._getForwarded', e);
        }

    };


    /**
     * Handles a forwarded sent message
     * @public
     * @param {object} message
     * @return {undefined}
     */
    self.handleSent = function(message) {

        try {
            var forwarded_message = self._getForwarded(message);

            if(forwarded_message !== null) {
                var to = Common.bareXID(forwarded_message.getTo());
                var hash = hex_md5(to);
                var type = forwarded_message.getType();

                // Display sent message
                if(type === 'chat' || !type) {
                    // Chat opened? (no need to display sent messages if chat does not exist there...)
                    if(Chat.exists(hash)) {
                        // Get more data
                        var id = forwarded_message.getID();
                        var body = $.trim(forwarded_message.getBody());
                        var my_xid = Common.getXID();

                        // Generate the message body
                        var html_escape = (Message.generate(forwarded_message, body, hash) !== 'XHTML');
                        if(!html_escape) {
                            body = Filter.xhtml(forwarded_message.getNode());
                        }

                        if(body) {
                            // Display the message (finally!)
                            Message.display(
                                'chat',
                                my_xid,
                                hash,
                                Name.getBuddy(my_xid).htmlEnc(),
                                body,
                                DateUtils.getCompleteTime(),
                                DateUtils.getTimeStamp(),
                                'user-message',
                                html_escape,
                                '',
                                'me',
                                id
                            );

                            Console.debug('Got a sent message from another resource to: ' + (to || 'none'));
                        } else {
                            Console.debug('Got a sent message from another resource to: ' + (to || 'none') + ', was ignored because body empty');
                        }
                    } else {
                        Console.debug('Got a sent message from another resource to: ' + (to || 'none') + ', was ignored because chat not open');
                    }
                } else {
                    Console.warning('Got a sent message from another resource to: ' + (to || 'none') + ', was ignored because of type: ' + type);
                }
            }
        } catch(e) {
            Console.error('Carbons.handleSent', e);
        }

    };


    /**
     * Handles a forwarded received message
     * @public
     * @param {object} message
     * @return {undefined}
     */
    self.handleReceived = function(message) {

        try {
            var forwarded_message = self._getForwarded(message);

            if(forwarded_message !== null) {
                Console.debug('Got a received message from another resource from: ' + (forwarded_message.getFrom() || 'none'));

                Message.handle(forwarded_message);
            }
        } catch(e) {
            Console.error('Carbons.handleReceived', e);
        }

    };


    /**
     * Return class scope
     */
    return self;

})();
